hunk,flag,logs,old_hunk_loc,new_hunk_loc
"[""#endif"", ""#endif"", ""    default:"", ""      cp->ExitException = kwsysProcess_Exception_Other;"", ""      sprintf(cp->ExitExceptionString, \""Signal %d\"", sig);"", ""      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;"", ""      sprintf(cp->ProcessResults[idx].ExitExceptionString, \""Signal %d\"", sig);"", ""      break;"", ""  }"", ""}"", ""#undef KWSYSPE_CASE"", """", ""/*--------------------------------------------------------------------------*/"", ""/* When the child process encounters an error before its program is"", ""   invoked, this is called to report the error to the parent and"", ""   exit.  */""]","[0, 0, 0, -1, -2, 1, 2, 0, 0, 0, 0, 0, -1, 0, 0, 0]","[[4, ""23b3d46e96f88ff66bdd064e484c0ba9ffa10ebc"", ""Merge topic 'update-kwsys'\n\n16ebd9f6 Merge branch 'upstream-KWSys' into update-kwsys\n7be70ca6 KWSys 2017-05-16 (fe1f22ce)\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !856"", ""Source/kwsys/ProcessUNIX.c"", ""-"", ""sprintf(cp->ExitExceptionString, \""Signal %d\"", sig);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_0_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_0_new.cpp""], [6, ""23b3d46e96f88ff66bdd064e484c0ba9ffa10ebc"", ""Merge topic 'update-kwsys'\n\n16ebd9f6 Merge branch 'upstream-KWSys' into update-kwsys\n7be70ca6 KWSys 2017-05-16 (fe1f22ce)\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !856"", ""Source/kwsys/ProcessUNIX.c"", ""+"", ""sprintf(cp->ProcessResults[idx].ExitExceptionString, \""Signal %d\"", sig);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_0_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_0_new.cpp""]]",2243,2273
"["""", ""    case STATUS_NO_MEMORY:"", ""    default:"", ""      cp->ExitException = kwsysProcess_Exception_Other;"", ""      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,"", ""                \""Exit code 0x%x\\n\"", code);"", ""      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;"", ""      _snprintf(cp->ProcessResults[idx].ExitExceptionString,"", ""                KWSYSPE_PIPE_BUFFER_SIZE, \""Exit code 0x%x\\n\"", code);"", ""      break;"", ""  }"", ""}""]","[0, 0, 0, -1, -2, -1, 1, 2, 1, 0, 0, 0]","[[4, ""23b3d46e96f88ff66bdd064e484c0ba9ffa10ebc"", ""Merge topic 'update-kwsys'\n\n16ebd9f6 Merge branch 'upstream-KWSys' into update-kwsys\n7be70ca6 KWSys 2017-05-16 (fe1f22ce)\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !856"", ""Source/kwsys/ProcessWin32.c"", ""-"", ""_snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_1_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_1_new.cpp""], [7, ""23b3d46e96f88ff66bdd064e484c0ba9ffa10ebc"", ""Merge topic 'update-kwsys'\n\n16ebd9f6 Merge branch 'upstream-KWSys' into update-kwsys\n7be70ca6 KWSys 2017-05-16 (fe1f22ce)\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !856"", ""Source/kwsys/ProcessWin32.c"", ""+"", ""_snprintf(cp->ProcessResults[idx].ExitExceptionString,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_1_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_1_new.cpp""]]",2120,2142
"[""#endif"", ""#endif"", ""    default:"", ""      cp->ExitException = kwsysProcess_Exception_Other;"", ""      sprintf(cp->ExitExceptionString, \""Signal %d\"", sig);"", ""      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;"", ""      sprintf(cp->ProcessResults[idx].ExitExceptionString, \""Signal %d\"", sig);"", ""      break;"", ""  }"", ""}"", ""#undef KWSYSPE_CASE"", """", ""/*--------------------------------------------------------------------------*/"", ""/* When the child process encounters an error before its program is"", ""   invoked, this is called to report the error to the parent and"", ""   exit.  */""]","[0, 0, 0, -1, -2, 1, 2, 0, 0, 0, 0, 0, -1, 0, 0, 0]","[[4, ""16ebd9f6152fedd1804f13c91ed14e8963e53d3f"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2017-05-16 (fe1f22ce)"", ""Source/kwsys/ProcessUNIX.c"", ""-"", ""sprintf(cp->ExitExceptionString, \""Signal %d\"", sig);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_2_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_2_new.cpp""], [6, ""16ebd9f6152fedd1804f13c91ed14e8963e53d3f"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2017-05-16 (fe1f22ce)"", ""Source/kwsys/ProcessUNIX.c"", ""+"", ""sprintf(cp->ProcessResults[idx].ExitExceptionString, \""Signal %d\"", sig);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_2_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_2_new.cpp""]]",2243,2273
"["""", ""    case STATUS_NO_MEMORY:"", ""    default:"", ""      cp->ExitException = kwsysProcess_Exception_Other;"", ""      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,"", ""                \""Exit code 0x%x\\n\"", code);"", ""      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;"", ""      _snprintf(cp->ProcessResults[idx].ExitExceptionString,"", ""                KWSYSPE_PIPE_BUFFER_SIZE, \""Exit code 0x%x\\n\"", code);"", ""      break;"", ""  }"", ""}""]","[0, 0, 0, -1, -2, -1, 1, 2, 1, 0, 0, 0]","[[4, ""16ebd9f6152fedd1804f13c91ed14e8963e53d3f"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2017-05-16 (fe1f22ce)"", ""Source/kwsys/ProcessWin32.c"", ""-"", ""_snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_3_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_3_new.cpp""], [7, ""16ebd9f6152fedd1804f13c91ed14e8963e53d3f"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2017-05-16 (fe1f22ce)"", ""Source/kwsys/ProcessWin32.c"", ""+"", ""_snprintf(cp->ProcessResults[idx].ExitExceptionString,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_3_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_3_new.cpp""]]",2120,2142
"[""#endif"", ""#endif"", ""    default:"", ""      cp->ExitException = kwsysProcess_Exception_Other;"", ""      sprintf(cp->ExitExceptionString, \""Signal %d\"", sig);"", ""      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;"", ""      sprintf(cp->ProcessResults[idx].ExitExceptionString, \""Signal %d\"", sig);"", ""      break;"", ""  }"", ""}"", ""#undef KWSYSPE_CASE"", """", ""/*--------------------------------------------------------------------------*/"", ""/* When the child process encounters an error before its program is"", ""   invoked, this is called to report the error to the parent and"", ""   exit.  */""]","[0, 0, 0, -1, -2, 1, 2, 0, 0, 0, 0, 0, -1, 0, 0, 0]","[[4, ""7be70ca6cc888df532d2f1560e74d13642730ee5"", ""KWSys 2017-05-16 (fe1f22ce)\n\nCode extracted from:\n\n    https://gitlab.kitware.com/utils/kwsys.git\n\nat commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).\n\nUpstream Shortlog\n-----------------\n\nAdam Weisi (3):\n      8a799e36 Process: Improve definition ordering in header file\n      7d56ef24 Process: Save results from all children internally\n      b7eba998 Process: Add APIs to get results of individual processes\n\nBen Boeckel (2):\n      cea71543 style: remove separator comments\n      874dc559 style: help clang-format near macros"", ""ProcessUNIX.c"", ""-"", ""sprintf(cp->ExitExceptionString, \""Signal %d\"", sig);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_4_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_4_new.cpp""], [6, ""7be70ca6cc888df532d2f1560e74d13642730ee5"", ""KWSys 2017-05-16 (fe1f22ce)\n\nCode extracted from:\n\n    https://gitlab.kitware.com/utils/kwsys.git\n\nat commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).\n\nUpstream Shortlog\n-----------------\n\nAdam Weisi (3):\n      8a799e36 Process: Improve definition ordering in header file\n      7d56ef24 Process: Save results from all children internally\n      b7eba998 Process: Add APIs to get results of individual processes\n\nBen Boeckel (2):\n      cea71543 style: remove separator comments\n      874dc559 style: help clang-format near macros"", ""ProcessUNIX.c"", ""+"", ""sprintf(cp->ProcessResults[idx].ExitExceptionString, \""Signal %d\"", sig);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_4_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_4_new.cpp""]]",2243,2273
"["""", ""    case STATUS_NO_MEMORY:"", ""    default:"", ""      cp->ExitException = kwsysProcess_Exception_Other;"", ""      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,"", ""                \""Exit code 0x%x\\n\"", code);"", ""      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;"", ""      _snprintf(cp->ProcessResults[idx].ExitExceptionString,"", ""                KWSYSPE_PIPE_BUFFER_SIZE, \""Exit code 0x%x\\n\"", code);"", ""      break;"", ""  }"", ""}""]","[0, 0, 0, -1, -2, -1, 1, 2, 1, 0, 0, 0]","[[4, ""7be70ca6cc888df532d2f1560e74d13642730ee5"", ""KWSys 2017-05-16 (fe1f22ce)\n\nCode extracted from:\n\n    https://gitlab.kitware.com/utils/kwsys.git\n\nat commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).\n\nUpstream Shortlog\n-----------------\n\nAdam Weisi (3):\n      8a799e36 Process: Improve definition ordering in header file\n      7d56ef24 Process: Save results from all children internally\n      b7eba998 Process: Add APIs to get results of individual processes\n\nBen Boeckel (2):\n      cea71543 style: remove separator comments\n      874dc559 style: help clang-format near macros"", ""ProcessWin32.c"", ""-"", ""_snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_5_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_5_new.cpp""], [7, ""7be70ca6cc888df532d2f1560e74d13642730ee5"", ""KWSys 2017-05-16 (fe1f22ce)\n\nCode extracted from:\n\n    https://gitlab.kitware.com/utils/kwsys.git\n\nat commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).\n\nUpstream Shortlog\n-----------------\n\nAdam Weisi (3):\n      8a799e36 Process: Improve definition ordering in header file\n      7d56ef24 Process: Save results from all children internally\n      b7eba998 Process: Add APIs to get results of individual processes\n\nBen Boeckel (2):\n      cea71543 style: remove separator comments\n      874dc559 style: help clang-format near macros"", ""ProcessWin32.c"", ""+"", ""_snprintf(cp->ProcessResults[idx].ExitExceptionString,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_5_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_5_new.cpp""]]",2120,2142
"[""  else"", ""    hostname = conn->host.name;"", """", ""  return aprintf(\""%s:%d\"", hostname, conn->port);"", ""  DEBUGASSERT(len > 32);"", """", ""  /* put the number first so that the hostname gets cut off if too long */"", ""  snprintf(buf, len, \""%ld%s\"", conn->port, hostname);"", ""}"", """", ""/* Look up the bundle with all the connections to the same host this""]","[0, 0, 0, -2, 1, 1, 1, 2, 0, 0, 0]","[[3, ""8843120ded39b90423afd48ebfde4c059d9495ed"", ""Merge topic 'update-curl'\n\n95d3ebcc curl: Set TLS/SSL build options the way we need for CMake\n11ba72c6 curl: Skip building docs within CMake\n29997590 Merge branch 'upstream-curl' into update-curl\nfd7d521c curl 2017-04-19 (d957e218)\n5af9c8e2 curl: Update script to get curl 7.54.0\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !828"", ""Utilities/cmcurl/lib/conncache.c"", ""-"", ""return aprintf(\""%s:%d\"", hostname, conn->port);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_6_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_6_new.cpp""], [7, ""8843120ded39b90423afd48ebfde4c059d9495ed"", ""Merge topic 'update-curl'\n\n95d3ebcc curl: Set TLS/SSL build options the way we need for CMake\n11ba72c6 curl: Skip building docs within CMake\n29997590 Merge branch 'upstream-curl' into update-curl\nfd7d521c curl 2017-04-19 (d957e218)\n5af9c8e2 curl: Update script to get curl 7.54.0\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !828"", ""Utilities/cmcurl/lib/conncache.c"", ""+"", ""snprintf(buf, len, \""%ld%s\"", conn->port, hostname);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_6_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_6_new.cpp""]]",141,136
"[""    time_t filetime;"", ""    struct tm buffer;"", ""    const struct tm *tm = &buffer;"", ""    snprintf(buf, sizeof(data->state.buffer),"", ""    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),"", ""             \""Content-Length: %\"" CURL_FORMAT_CURL_OFF_T \""\\r\\n\"", expected_size);"", ""    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);"", ""    if(result)""]","[0, 0, 0, -2, 2, 0, 0, 0]","[[3, ""8843120ded39b90423afd48ebfde4c059d9495ed"", ""Merge topic 'update-curl'\n\n95d3ebcc curl: Set TLS/SSL build options the way we need for CMake\n11ba72c6 curl: Skip building docs within CMake\n29997590 Merge branch 'upstream-curl' into update-curl\nfd7d521c curl 2017-04-19 (d957e218)\n5af9c8e2 curl: Update script to get curl 7.54.0\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !828"", ""Utilities/cmcurl/lib/file.c"", ""-"", ""snprintf(buf, sizeof(data->state.buffer),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_7_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_7_new.cpp""], [4, ""8843120ded39b90423afd48ebfde4c059d9495ed"", ""Merge topic 'update-curl'\n\n95d3ebcc curl: Set TLS/SSL build options the way we need for CMake\n11ba72c6 curl: Skip building docs within CMake\n29997590 Merge branch 'upstream-curl' into update-curl\nfd7d521c curl 2017-04-19 (d957e218)\n5af9c8e2 curl: Update script to get curl 7.54.0\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !828"", ""Utilities/cmcurl/lib/file.c"", ""+"", ""snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_7_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_7_new.cpp""]]",476,475
"[""        /* we have a time, reformat it */"", ""        time_t secs=time(NULL);"", ""        /* using the good old yacc/bison yuck */"", ""        snprintf(buf, sizeof(conn->data->state.buffer),"", ""        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),"", ""                 \""%04d%02d%02d %02d:%02d:%02d GMT\"","", ""                 year, month, day, hour, minute, second);"", ""        /* now, convert this into a time() value: */""]","[0, 0, 0, -2, 2, 0, 0, 0]","[[3, ""8843120ded39b90423afd48ebfde4c059d9495ed"", ""Merge topic 'update-curl'\n\n95d3ebcc curl: Set TLS/SSL build options the way we need for CMake\n11ba72c6 curl: Skip building docs within CMake\n29997590 Merge branch 'upstream-curl' into update-curl\nfd7d521c curl 2017-04-19 (d957e218)\n5af9c8e2 curl: Update script to get curl 7.54.0\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !828"", ""Utilities/cmcurl/lib/ftp.c"", ""-"", ""snprintf(buf, sizeof(conn->data->state.buffer),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_8_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_8_new.cpp""], [4, ""8843120ded39b90423afd48ebfde4c059d9495ed"", ""Merge topic 'update-curl'\n\n95d3ebcc curl: Set TLS/SSL build options the way we need for CMake\n11ba72c6 curl: Skip building docs within CMake\n29997590 Merge branch 'upstream-curl' into update-curl\nfd7d521c curl 2017-04-19 (d957e218)\n5af9c8e2 curl: Update script to get curl 7.54.0\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !828"", ""Utilities/cmcurl/lib/ftp.c"", ""+"", ""snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_8_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_8_new.cpp""]]",2107,2107
"[""  if(instate == FTP_SIZE) {"", ""#ifdef CURL_FTP_HTTPSTYLE_HEAD"", ""    if(-1 != filesize) {"", ""      snprintf(buf, sizeof(data->state.buffer),"", ""      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),"", ""               \""Content-Length: %\"" CURL_FORMAT_CURL_OFF_T \""\\r\\n\"", filesize);"", ""      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);"", ""      if(result)""]","[0, 0, 0, -2, 2, 0, 0, 0]","[[3, ""8843120ded39b90423afd48ebfde4c059d9495ed"", ""Merge topic 'update-curl'\n\n95d3ebcc curl: Set TLS/SSL build options the way we need for CMake\n11ba72c6 curl: Skip building docs within CMake\n29997590 Merge branch 'upstream-curl' into update-curl\nfd7d521c curl 2017-04-19 (d957e218)\n5af9c8e2 curl: Update script to get curl 7.54.0\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !828"", ""Utilities/cmcurl/lib/ftp.c"", ""-"", ""snprintf(buf, sizeof(data->state.buffer),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_8_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_8_new.cpp""], [4, ""8843120ded39b90423afd48ebfde4c059d9495ed"", ""Merge topic 'update-curl'\n\n95d3ebcc curl: Set TLS/SSL build options the way we need for CMake\n11ba72c6 curl: Skip building docs within CMake\n29997590 Merge branch 'upstream-curl' into update-curl\nfd7d521c curl 2017-04-19 (d957e218)\n5af9c8e2 curl: Update script to get curl 7.54.0\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !828"", ""Utilities/cmcurl/lib/ftp.c"", ""+"", ""snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_8_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_8_new.cpp""]]",2318,2318
"[""    pwd = conn->passwd;"", ""  }"", """", ""  snprintf(data->state.buffer, sizeof(data->state.buffer), \""%s:%s\"", user, pwd);"", ""  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),"", ""           \""%s:%s\"", user, pwd);"", """", ""  result = Curl_base64_encode(data,"", ""                              data->state.buffer, strlen(data->state.buffer),""]","[0, 0, 0, -2, 2, 1, 0, 0, 0]","[[3, ""8843120ded39b90423afd48ebfde4c059d9495ed"", ""Merge topic 'update-curl'\n\n95d3ebcc curl: Set TLS/SSL build options the way we need for CMake\n11ba72c6 curl: Skip building docs within CMake\n29997590 Merge branch 'upstream-curl' into update-curl\nfd7d521c curl 2017-04-19 (d957e218)\n5af9c8e2 curl: Update script to get curl 7.54.0\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !828"", ""Utilities/cmcurl/lib/http.c"", ""-"", ""snprintf(data->state.buffer, sizeof(data->state.buffer), \""%s:%s\"", user, pwd);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_9_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_9_new.cpp""], [4, ""8843120ded39b90423afd48ebfde4c059d9495ed"", ""Merge topic 'update-curl'\n\n95d3ebcc curl: Set TLS/SSL build options the way we need for CMake\n11ba72c6 curl: Skip building docs within CMake\n29997590 Merge branch 'upstream-curl' into update-curl\nfd7d521c curl 2017-04-19 (d957e218)\n5af9c8e2 curl: Update script to get curl 7.54.0\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !828"", ""Utilities/cmcurl/lib/http.c"", ""+"", ""snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_9_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_9_new.cpp""]]",297,297
"["""", ""  /* We do some initial setup here, all those fields that can't be just 0 */"", """", ""  data->state.buffer = malloc(BUFSIZE + 1);"", ""  if(!data->state.buffer) {"", ""    DEBUGF(fprintf(stderr, \""Error: malloc of buffer failed\\n\""));"", ""    result = CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  data->state.headerbuff = malloc(HEADERSIZE);"", ""  if(!data->state.headerbuff) {"", ""    DEBUGF(fprintf(stderr, \""Error: malloc of headerbuff failed\\n\""));""]","[0, 0, 0, 1, 1, 2, 1, 1, 1, 0, 0, 0]","[[5, ""8843120ded39b90423afd48ebfde4c059d9495ed"", ""Merge topic 'update-curl'\n\n95d3ebcc curl: Set TLS/SSL build options the way we need for CMake\n11ba72c6 curl: Skip building docs within CMake\n29997590 Merge branch 'upstream-curl' into update-curl\nfd7d521c curl 2017-04-19 (d957e218)\n5af9c8e2 curl: Update script to get curl 7.54.0\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !828"", ""Utilities/cmcurl/lib/url.c"", ""+"", ""DEBUGF(fprintf(stderr, \""Error: malloc of buffer failed\\n\""));"", 0, ""/data/download/CMake/CMake/Kitware_CMake_10_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_10_new.cpp""]]",641,644
"[""     */"", ""    data->set.buffer_size = va_arg(param, long);"", """", ""    if((data->set.buffer_size> (BUFSIZE -1)) ||"", ""       (data->set.buffer_size < 1))"", ""      data->set.buffer_size = 0; /* huge internal default */"", ""    if(data->set.buffer_size > MAX_BUFSIZE)"", ""      data->set.buffer_size = MAX_BUFSIZE; /* huge internal default */"", ""    else if(data->set.buffer_size < 1)"", ""      data->set.buffer_size = BUFSIZE;"", """", ""    /* Resize only if larger than default buffer size. */"", ""    if(data->set.buffer_size > BUFSIZE) {"", ""      data->state.buffer = realloc(data->state.buffer,"", ""                                   data->set.buffer_size + 1);"", ""      if(!data->state.buffer) {"", ""        DEBUGF(fprintf(stderr, \""Error: realloc of buffer failed\\n\""));"", ""        result = CURLE_OUT_OF_MEMORY;"", ""      }"", ""    }"", """", ""    break;"", """"]","[0, 0, 0, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, 0, 0]","[[16, ""8843120ded39b90423afd48ebfde4c059d9495ed"", ""Merge topic 'update-curl'\n\n95d3ebcc curl: Set TLS/SSL build options the way we need for CMake\n11ba72c6 curl: Skip building docs within CMake\n29997590 Merge branch 'upstream-curl' into update-curl\nfd7d521c curl 2017-04-19 (d957e218)\n5af9c8e2 curl: Update script to get curl 7.54.0\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !828"", ""Utilities/cmcurl/lib/url.c"", ""+"", ""DEBUGF(fprintf(stderr, \""Error: realloc of buffer failed\\n\""));"", 0, ""/data/download/CMake/CMake/Kitware_CMake_10_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_10_new.cpp""]]",2268,2286
"["""", ""size_t Curl_cyassl_version(char *buffer, size_t size)"", ""{"", ""#ifdef WOLFSSL_VERSION"", ""#if LIBCYASSL_VERSION_HEX >= 0x03006000"", ""  return snprintf(buffer, size, \""wolfSSL/%s\"", wolfSSL_lib_version());"", ""#elif defined(WOLFSSL_VERSION)"", ""  return snprintf(buffer, size, \""wolfSSL/%s\"", WOLFSSL_VERSION);"", ""#elif defined(CYASSL_VERSION)"", ""  return snprintf(buffer, size, \""CyaSSL/%s\"", CYASSL_VERSION);""]","[0, 0, 0, -1, 1, 2, 1, 0, 0, 0]","[[5, ""8843120ded39b90423afd48ebfde4c059d9495ed"", ""Merge topic 'update-curl'\n\n95d3ebcc curl: Set TLS/SSL build options the way we need for CMake\n11ba72c6 curl: Skip building docs within CMake\n29997590 Merge branch 'upstream-curl' into update-curl\nfd7d521c curl 2017-04-19 (d957e218)\n5af9c8e2 curl: Update script to get curl 7.54.0\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !828"", ""Utilities/cmcurl/lib/vtls/cyassl.c"", ""+"", ""return snprintf(buffer, size, \""wolfSSL/%s\"", wolfSSL_lib_version());"", 0, ""/data/download/CMake/CMake/Kitware_CMake_11_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_11_new.cpp""]]",720,741
"[""  else"", ""    hostname = conn->host.name;"", """", ""  return aprintf(\""%s:%d\"", hostname, conn->port);"", ""  DEBUGASSERT(len > 32);"", """", ""  /* put the number first so that the hostname gets cut off if too long */"", ""  snprintf(buf, len, \""%ld%s\"", conn->port, hostname);"", ""}"", """", ""/* Look up the bundle with all the connections to the same host this""]","[0, 0, 0, -2, 1, 1, 1, 2, 0, 0, 0]","[[3, ""299975908ada992800791fac7f3739050e0ae2a9"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2017-04-19 (d957e218)\n\nResolve conflicts in `CMakeLists.txt` in favor of the upstream version.\nWe will re-apply our logic as needed in following commits."", ""Utilities/cmcurl/lib/conncache.c"", ""-"", ""return aprintf(\""%s:%d\"", hostname, conn->port);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_12_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_12_new.cpp""], [7, ""299975908ada992800791fac7f3739050e0ae2a9"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2017-04-19 (d957e218)\n\nResolve conflicts in `CMakeLists.txt` in favor of the upstream version.\nWe will re-apply our logic as needed in following commits."", ""Utilities/cmcurl/lib/conncache.c"", ""+"", ""snprintf(buf, len, \""%ld%s\"", conn->port, hostname);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_12_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_12_new.cpp""]]",141,136
"[""    time_t filetime;"", ""    struct tm buffer;"", ""    const struct tm *tm = &buffer;"", ""    snprintf(buf, sizeof(data->state.buffer),"", ""    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),"", ""             \""Content-Length: %\"" CURL_FORMAT_CURL_OFF_T \""\\r\\n\"", expected_size);"", ""    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);"", ""    if(result)""]","[0, 0, 0, -2, 2, 0, 0, 0]","[[3, ""299975908ada992800791fac7f3739050e0ae2a9"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2017-04-19 (d957e218)\n\nResolve conflicts in `CMakeLists.txt` in favor of the upstream version.\nWe will re-apply our logic as needed in following commits."", ""Utilities/cmcurl/lib/file.c"", ""-"", ""snprintf(buf, sizeof(data->state.buffer),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_13_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_13_new.cpp""], [4, ""299975908ada992800791fac7f3739050e0ae2a9"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2017-04-19 (d957e218)\n\nResolve conflicts in `CMakeLists.txt` in favor of the upstream version.\nWe will re-apply our logic as needed in following commits."", ""Utilities/cmcurl/lib/file.c"", ""+"", ""snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_13_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_13_new.cpp""]]",476,475
"[""        /* we have a time, reformat it */"", ""        time_t secs=time(NULL);"", ""        /* using the good old yacc/bison yuck */"", ""        snprintf(buf, sizeof(conn->data->state.buffer),"", ""        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),"", ""                 \""%04d%02d%02d %02d:%02d:%02d GMT\"","", ""                 year, month, day, hour, minute, second);"", ""        /* now, convert this into a time() value: */""]","[0, 0, 0, -2, 2, 0, 0, 0]","[[3, ""299975908ada992800791fac7f3739050e0ae2a9"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2017-04-19 (d957e218)\n\nResolve conflicts in `CMakeLists.txt` in favor of the upstream version.\nWe will re-apply our logic as needed in following commits."", ""Utilities/cmcurl/lib/ftp.c"", ""-"", ""snprintf(buf, sizeof(conn->data->state.buffer),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_14_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_14_new.cpp""], [4, ""299975908ada992800791fac7f3739050e0ae2a9"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2017-04-19 (d957e218)\n\nResolve conflicts in `CMakeLists.txt` in favor of the upstream version.\nWe will re-apply our logic as needed in following commits."", ""Utilities/cmcurl/lib/ftp.c"", ""+"", ""snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_14_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_14_new.cpp""]]",2107,2107
"[""  if(instate == FTP_SIZE) {"", ""#ifdef CURL_FTP_HTTPSTYLE_HEAD"", ""    if(-1 != filesize) {"", ""      snprintf(buf, sizeof(data->state.buffer),"", ""      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),"", ""               \""Content-Length: %\"" CURL_FORMAT_CURL_OFF_T \""\\r\\n\"", filesize);"", ""      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);"", ""      if(result)""]","[0, 0, 0, -2, 2, 0, 0, 0]","[[3, ""299975908ada992800791fac7f3739050e0ae2a9"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2017-04-19 (d957e218)\n\nResolve conflicts in `CMakeLists.txt` in favor of the upstream version.\nWe will re-apply our logic as needed in following commits."", ""Utilities/cmcurl/lib/ftp.c"", ""-"", ""snprintf(buf, sizeof(data->state.buffer),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_14_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_14_new.cpp""], [4, ""299975908ada992800791fac7f3739050e0ae2a9"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2017-04-19 (d957e218)\n\nResolve conflicts in `CMakeLists.txt` in favor of the upstream version.\nWe will re-apply our logic as needed in following commits."", ""Utilities/cmcurl/lib/ftp.c"", ""+"", ""snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_14_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_14_new.cpp""]]",2318,2318
"[""    pwd = conn->passwd;"", ""  }"", """", ""  snprintf(data->state.buffer, sizeof(data->state.buffer), \""%s:%s\"", user, pwd);"", ""  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),"", ""           \""%s:%s\"", user, pwd);"", """", ""  result = Curl_base64_encode(data,"", ""                              data->state.buffer, strlen(data->state.buffer),""]","[0, 0, 0, -2, 2, 1, 0, 0, 0]","[[3, ""299975908ada992800791fac7f3739050e0ae2a9"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2017-04-19 (d957e218)\n\nResolve conflicts in `CMakeLists.txt` in favor of the upstream version.\nWe will re-apply our logic as needed in following commits."", ""Utilities/cmcurl/lib/http.c"", ""-"", ""snprintf(data->state.buffer, sizeof(data->state.buffer), \""%s:%s\"", user, pwd);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_15_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_15_new.cpp""], [4, ""299975908ada992800791fac7f3739050e0ae2a9"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2017-04-19 (d957e218)\n\nResolve conflicts in `CMakeLists.txt` in favor of the upstream version.\nWe will re-apply our logic as needed in following commits."", ""Utilities/cmcurl/lib/http.c"", ""+"", ""snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_15_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_15_new.cpp""]]",297,297
"["""", ""  /* We do some initial setup here, all those fields that can't be just 0 */"", """", ""  data->state.buffer = malloc(BUFSIZE + 1);"", ""  if(!data->state.buffer) {"", ""    DEBUGF(fprintf(stderr, \""Error: malloc of buffer failed\\n\""));"", ""    result = CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  data->state.headerbuff = malloc(HEADERSIZE);"", ""  if(!data->state.headerbuff) {"", ""    DEBUGF(fprintf(stderr, \""Error: malloc of headerbuff failed\\n\""));""]","[0, 0, 0, 1, 1, 2, 1, 1, 1, 0, 0, 0]","[[5, ""299975908ada992800791fac7f3739050e0ae2a9"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2017-04-19 (d957e218)\n\nResolve conflicts in `CMakeLists.txt` in favor of the upstream version.\nWe will re-apply our logic as needed in following commits."", ""Utilities/cmcurl/lib/url.c"", ""+"", ""DEBUGF(fprintf(stderr, \""Error: malloc of buffer failed\\n\""));"", 0, ""/data/download/CMake/CMake/Kitware_CMake_16_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_16_new.cpp""]]",641,644
"[""     */"", ""    data->set.buffer_size = va_arg(param, long);"", """", ""    if((data->set.buffer_size> (BUFSIZE -1)) ||"", ""       (data->set.buffer_size < 1))"", ""      data->set.buffer_size = 0; /* huge internal default */"", ""    if(data->set.buffer_size > MAX_BUFSIZE)"", ""      data->set.buffer_size = MAX_BUFSIZE; /* huge internal default */"", ""    else if(data->set.buffer_size < 1)"", ""      data->set.buffer_size = BUFSIZE;"", """", ""    /* Resize only if larger than default buffer size. */"", ""    if(data->set.buffer_size > BUFSIZE) {"", ""      data->state.buffer = realloc(data->state.buffer,"", ""                                   data->set.buffer_size + 1);"", ""      if(!data->state.buffer) {"", ""        DEBUGF(fprintf(stderr, \""Error: realloc of buffer failed\\n\""));"", ""        result = CURLE_OUT_OF_MEMORY;"", ""      }"", ""    }"", """", ""    break;"", """"]","[0, 0, 0, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, 0, 0]","[[16, ""299975908ada992800791fac7f3739050e0ae2a9"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2017-04-19 (d957e218)\n\nResolve conflicts in `CMakeLists.txt` in favor of the upstream version.\nWe will re-apply our logic as needed in following commits."", ""Utilities/cmcurl/lib/url.c"", ""+"", ""DEBUGF(fprintf(stderr, \""Error: realloc of buffer failed\\n\""));"", 0, ""/data/download/CMake/CMake/Kitware_CMake_16_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_16_new.cpp""]]",2268,2286
"["""", ""size_t Curl_cyassl_version(char *buffer, size_t size)"", ""{"", ""#ifdef WOLFSSL_VERSION"", ""#if LIBCYASSL_VERSION_HEX >= 0x03006000"", ""  return snprintf(buffer, size, \""wolfSSL/%s\"", wolfSSL_lib_version());"", ""#elif defined(WOLFSSL_VERSION)"", ""  return snprintf(buffer, size, \""wolfSSL/%s\"", WOLFSSL_VERSION);"", ""#elif defined(CYASSL_VERSION)"", ""  return snprintf(buffer, size, \""CyaSSL/%s\"", CYASSL_VERSION);""]","[0, 0, 0, -1, 1, 2, 1, 0, 0, 0]","[[5, ""299975908ada992800791fac7f3739050e0ae2a9"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2017-04-19 (d957e218)\n\nResolve conflicts in `CMakeLists.txt` in favor of the upstream version.\nWe will re-apply our logic as needed in following commits."", ""Utilities/cmcurl/lib/vtls/cyassl.c"", ""+"", ""return snprintf(buffer, size, \""wolfSSL/%s\"", wolfSSL_lib_version());"", 0, ""/data/download/CMake/CMake/Kitware_CMake_17_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_17_new.cpp""]]",720,741
"[""  else"", ""    hostname = conn->host.name;"", """", ""  return aprintf(\""%s:%d\"", hostname, conn->port);"", ""  DEBUGASSERT(len > 32);"", """", ""  /* put the number first so that the hostname gets cut off if too long */"", ""  snprintf(buf, len, \""%ld%s\"", conn->port, hostname);"", ""}"", """", ""/* Look up the bundle with all the connections to the same host this""]","[0, 0, 0, -2, 1, 1, 1, 2, 0, 0, 0]","[[3, ""fd7d521c9d70655618db8232d45e5aaf81700f91"", ""curl 2017-04-19 (d957e218)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0)."", ""lib/conncache.c"", ""-"", ""return aprintf(\""%s:%d\"", hostname, conn->port);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_18_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_18_new.cpp""], [7, ""fd7d521c9d70655618db8232d45e5aaf81700f91"", ""curl 2017-04-19 (d957e218)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0)."", ""lib/conncache.c"", ""+"", ""snprintf(buf, len, \""%ld%s\"", conn->port, hostname);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_18_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_18_new.cpp""]]",141,136
"[""    time_t filetime;"", ""    struct tm buffer;"", ""    const struct tm *tm = &buffer;"", ""    snprintf(buf, sizeof(data->state.buffer),"", ""    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),"", ""             \""Content-Length: %\"" CURL_FORMAT_CURL_OFF_T \""\\r\\n\"", expected_size);"", ""    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);"", ""    if(result)""]","[0, 0, 0, -2, 2, 0, 0, 0]","[[3, ""fd7d521c9d70655618db8232d45e5aaf81700f91"", ""curl 2017-04-19 (d957e218)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0)."", ""lib/file.c"", ""-"", ""snprintf(buf, sizeof(data->state.buffer),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_19_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_19_new.cpp""], [4, ""fd7d521c9d70655618db8232d45e5aaf81700f91"", ""curl 2017-04-19 (d957e218)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0)."", ""lib/file.c"", ""+"", ""snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_19_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_19_new.cpp""]]",476,475
"[""        /* we have a time, reformat it */"", ""        time_t secs=time(NULL);"", ""        /* using the good old yacc/bison yuck */"", ""        snprintf(buf, sizeof(conn->data->state.buffer),"", ""        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),"", ""                 \""%04d%02d%02d %02d:%02d:%02d GMT\"","", ""                 year, month, day, hour, minute, second);"", ""        /* now, convert this into a time() value: */""]","[0, 0, 0, -2, 2, 0, 0, 0]","[[3, ""fd7d521c9d70655618db8232d45e5aaf81700f91"", ""curl 2017-04-19 (d957e218)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0)."", ""lib/ftp.c"", ""-"", ""snprintf(buf, sizeof(conn->data->state.buffer),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_20_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_20_new.cpp""], [4, ""fd7d521c9d70655618db8232d45e5aaf81700f91"", ""curl 2017-04-19 (d957e218)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0)."", ""lib/ftp.c"", ""+"", ""snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_20_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_20_new.cpp""]]",2107,2107
"[""  if(instate == FTP_SIZE) {"", ""#ifdef CURL_FTP_HTTPSTYLE_HEAD"", ""    if(-1 != filesize) {"", ""      snprintf(buf, sizeof(data->state.buffer),"", ""      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),"", ""               \""Content-Length: %\"" CURL_FORMAT_CURL_OFF_T \""\\r\\n\"", filesize);"", ""      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);"", ""      if(result)""]","[0, 0, 0, -2, 2, 0, 0, 0]","[[3, ""fd7d521c9d70655618db8232d45e5aaf81700f91"", ""curl 2017-04-19 (d957e218)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0)."", ""lib/ftp.c"", ""-"", ""snprintf(buf, sizeof(data->state.buffer),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_20_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_20_new.cpp""], [4, ""fd7d521c9d70655618db8232d45e5aaf81700f91"", ""curl 2017-04-19 (d957e218)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0)."", ""lib/ftp.c"", ""+"", ""snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_20_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_20_new.cpp""]]",2318,2318
"[""    pwd = conn->passwd;"", ""  }"", """", ""  snprintf(data->state.buffer, sizeof(data->state.buffer), \""%s:%s\"", user, pwd);"", ""  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),"", ""           \""%s:%s\"", user, pwd);"", """", ""  result = Curl_base64_encode(data,"", ""                              data->state.buffer, strlen(data->state.buffer),""]","[0, 0, 0, -2, 2, 1, 0, 0, 0]","[[3, ""fd7d521c9d70655618db8232d45e5aaf81700f91"", ""curl 2017-04-19 (d957e218)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0)."", ""lib/http.c"", ""-"", ""snprintf(data->state.buffer, sizeof(data->state.buffer), \""%s:%s\"", user, pwd);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_21_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_21_new.cpp""], [4, ""fd7d521c9d70655618db8232d45e5aaf81700f91"", ""curl 2017-04-19 (d957e218)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0)."", ""lib/http.c"", ""+"", ""snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_21_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_21_new.cpp""]]",297,297
"["""", ""  /* We do some initial setup here, all those fields that can't be just 0 */"", """", ""  data->state.buffer = malloc(BUFSIZE + 1);"", ""  if(!data->state.buffer) {"", ""    DEBUGF(fprintf(stderr, \""Error: malloc of buffer failed\\n\""));"", ""    result = CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  data->state.headerbuff = malloc(HEADERSIZE);"", ""  if(!data->state.headerbuff) {"", ""    DEBUGF(fprintf(stderr, \""Error: malloc of headerbuff failed\\n\""));""]","[0, 0, 0, 1, 1, 2, 1, 1, 1, 0, 0, 0]","[[5, ""fd7d521c9d70655618db8232d45e5aaf81700f91"", ""curl 2017-04-19 (d957e218)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0)."", ""lib/url.c"", ""+"", ""DEBUGF(fprintf(stderr, \""Error: malloc of buffer failed\\n\""));"", 0, ""/data/download/CMake/CMake/Kitware_CMake_22_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_22_new.cpp""]]",641,644
"[""     */"", ""    data->set.buffer_size = va_arg(param, long);"", """", ""    if((data->set.buffer_size> (BUFSIZE -1)) ||"", ""       (data->set.buffer_size < 1))"", ""      data->set.buffer_size = 0; /* huge internal default */"", ""    if(data->set.buffer_size > MAX_BUFSIZE)"", ""      data->set.buffer_size = MAX_BUFSIZE; /* huge internal default */"", ""    else if(data->set.buffer_size < 1)"", ""      data->set.buffer_size = BUFSIZE;"", """", ""    /* Resize only if larger than default buffer size. */"", ""    if(data->set.buffer_size > BUFSIZE) {"", ""      data->state.buffer = realloc(data->state.buffer,"", ""                                   data->set.buffer_size + 1);"", ""      if(!data->state.buffer) {"", ""        DEBUGF(fprintf(stderr, \""Error: realloc of buffer failed\\n\""));"", ""        result = CURLE_OUT_OF_MEMORY;"", ""      }"", ""    }"", """", ""    break;"", """"]","[0, 0, 0, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, 0, 0]","[[16, ""fd7d521c9d70655618db8232d45e5aaf81700f91"", ""curl 2017-04-19 (d957e218)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0)."", ""lib/url.c"", ""+"", ""DEBUGF(fprintf(stderr, \""Error: realloc of buffer failed\\n\""));"", 0, ""/data/download/CMake/CMake/Kitware_CMake_22_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_22_new.cpp""]]",2268,2286
"["""", ""size_t Curl_cyassl_version(char *buffer, size_t size)"", ""{"", ""#ifdef WOLFSSL_VERSION"", ""#if LIBCYASSL_VERSION_HEX >= 0x03006000"", ""  return snprintf(buffer, size, \""wolfSSL/%s\"", wolfSSL_lib_version());"", ""#elif defined(WOLFSSL_VERSION)"", ""  return snprintf(buffer, size, \""wolfSSL/%s\"", WOLFSSL_VERSION);"", ""#elif defined(CYASSL_VERSION)"", ""  return snprintf(buffer, size, \""CyaSSL/%s\"", CYASSL_VERSION);""]","[0, 0, 0, -1, 1, 2, 1, 0, 0, 0]","[[5, ""fd7d521c9d70655618db8232d45e5aaf81700f91"", ""curl 2017-04-19 (d957e218)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0)."", ""lib/vtls/cyassl.c"", ""+"", ""return snprintf(buffer, size, \""wolfSSL/%s\"", wolfSSL_lib_version());"", 0, ""/data/download/CMake/CMake/Kitware_CMake_23_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_23_new.cpp""]]",720,741
"[""      pSymbolTable++;"", ""    }"", ""  }"", """", ""private:"", ""  std::set<std::string>& Symbols;"", ""  std::set<std::string>& DataSymbols;"", ""  DWORD_PTR SymbolCount;"", ""  PIMAGE_SECTION_HEADER SectionHeaders;"", ""  ObjectHeaderType* ObjectImageHeader;"", ""  SymbolTableType*  SymbolTable;"", ""  bool Is64Bit;"", ""  SymbolTableType* SymbolTable;"", ""  bool IsI386;"", ""};"", """", ""bool"", ""DumpFile(const char* filename,"", ""         std::set<std::string>& symbols,"", ""         std::set<std::string>& dataSymbols)"", ""bool DumpFile(const char* filename, std::set<std::string>& symbols,"", ""              std::set<std::string>& dataSymbols)"", ""{"", ""   HANDLE hFile;"", ""   HANDLE hFileMapping;"", ""   LPVOID lpFileBase;"", ""   PIMAGE_DOS_HEADER dosHeader;"", ""  HANDLE hFile;"", ""  HANDLE hFileMapping;"", ""  LPVOID lpFileBase;"", ""  PIMAGE_DOS_HEADER dosHeader;"", """", ""   hFile = CreateFileW(cmsys::Encoding::ToWide(filename).c_str(),"", ""                       GENERIC_READ, FILE_SHARE_READ, NULL,"", ""      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);"", ""  hFile = CreateFileW(cmsys::Encoding::ToWide(filename).c_str(), GENERIC_READ,"", ""                      FILE_SHARE_READ, NULL, OPEN_EXISTING,"", ""                      FILE_ATTRIBUTE_NORMAL, 0);"", """", ""   if (hFile == INVALID_HANDLE_VALUE) {"", ""      fprintf(stderr, \""Couldn't open file '%s' with CreateFile()\\n\"", filename);"", ""      return false;"", ""   }"", ""  if (hFile == INVALID_HANDLE_VALUE) {"", ""    fprintf(stderr, \""Couldn't open file '%s' with CreateFile()\\n\"", filename);"", ""    return false;"", ""  }"", """", ""   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);"", ""   if (hFileMapping == 0) {"", ""      CloseHandle(hFile);"", ""      fprintf(stderr, \""Couldn't open file mapping with CreateFileMapping()\\n\"");"", ""      return false;"", ""   }"", ""  hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);"", ""  if (hFileMapping == 0) {"", ""    CloseHandle(hFile);"", ""    fprintf(stderr, \""Couldn't open file mapping with CreateFileMapping()\\n\"");"", ""    return false;"", ""  }"", """", ""   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);"", ""   if (lpFileBase == 0) {"", ""      CloseHandle(hFileMapping);"", ""      CloseHandle(hFile);"", ""      fprintf(stderr, \""Couldn't map view of file with MapViewOfFile()\\n\"");"", ""      return false;"", ""   }"", ""  lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);"", ""  if (lpFileBase == 0) {"", ""    CloseHandle(hFileMapping);"", ""    CloseHandle(hFile);"", ""    fprintf(stderr, \""Couldn't map view of file with MapViewOfFile()\\n\"");"", ""    return false;"", ""  }"", """", ""   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;"", ""   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {"", ""      fprintf(stderr, \""File is an executable.  I don't dump those.\\n\"");"", ""      return false;"", ""   }"", ""   /* Does it look like a i386 COFF OBJ file??? */"", ""   else if ("", ""           ((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||"", ""            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64))"", ""           && (dosHeader->e_sp == 0)"", ""           ) {"", ""      /*"", ""      * The two tests above aren't what they look like.  They're"", ""      * really checking for IMAGE_FILE_HEADER.Machine == i386 (0x14C)"", ""      * and IMAGE_FILE_HEADER.SizeOfOptionalHeader == 0;"", ""      */"", ""      DumpSymbols<IMAGE_FILE_HEADER, IMAGE_SYMBOL>"", ""        symbolDumper((PIMAGE_FILE_HEADER) lpFileBase, symbols, dataSymbols,"", ""                     (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64));"", ""  dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;"", ""  if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {"", ""    fprintf(stderr, \""File is an executable.  I don't dump those.\\n\"");"", ""    return false;"", ""  }"", ""  /* Does it look like a COFF OBJ file??? */"", ""  else if (((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||"", ""            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64) ||"", ""            (dosHeader->e_magic == IMAGE_FILE_MACHINE_ARMNT)) &&"", ""           (dosHeader->e_sp == 0)) {"", ""    /*"", ""    * The two tests above aren't what they look like.  They're"", ""    * really checking for IMAGE_FILE_HEADER.Machine == i386 (0x14C)"", ""    * and IMAGE_FILE_HEADER.SizeOfOptionalHeader == 0;"", ""    */"", ""    DumpSymbols<IMAGE_FILE_HEADER, IMAGE_SYMBOL> symbolDumper("", ""      (PIMAGE_FILE_HEADER)lpFileBase, symbols, dataSymbols,"", ""      (dosHeader->e_magic == IMAGE_FILE_MACHINE_I386));"", ""    symbolDumper.DumpObjFile();"", ""  } else {"", ""    // check for /bigobj format"", ""    cmANON_OBJECT_HEADER_BIGOBJ* h = (cmANON_OBJECT_HEADER_BIGOBJ*)lpFileBase;"", ""    if (h->Sig1 == 0x0 && h->Sig2 == 0xffff) {"", ""      DumpSymbols<cmANON_OBJECT_HEADER_BIGOBJ, cmIMAGE_SYMBOL_EX> symbolDumper("", ""        (cmANON_OBJECT_HEADER_BIGOBJ*)lpFileBase, symbols, dataSymbols,"", ""        (h->Machine == IMAGE_FILE_MACHINE_I386));"", ""      symbolDumper.DumpObjFile();"", ""   } else {"", ""      // check for /bigobj format"", ""      cmANON_OBJECT_HEADER_BIGOBJ* h ="", ""        (cmANON_OBJECT_HEADER_BIGOBJ*) lpFileBase;"", ""      if(h->Sig1 == 0x0 && h->Sig2 == 0xffff) {"", ""         DumpSymbols<cmANON_OBJECT_HEADER_BIGOBJ, cmIMAGE_SYMBOL_EX>"", ""           symbolDumper((cmANON_OBJECT_HEADER_BIGOBJ*) lpFileBase, symbols,"", ""                        dataSymbols,"", ""                        (h->Machine == IMAGE_FILE_MACHINE_AMD64));"", ""         symbolDumper.DumpObjFile();"", ""      } else {"", ""         printf(\""unrecognized file format in '%s'\\n\"", filename);"", ""         return false;"", ""      }"", ""   }"", ""   UnmapViewOfFile(lpFileBase);"", ""   CloseHandle(hFileMapping);"", ""   CloseHandle(hFile);"", ""   return true;"", ""    } else {"", ""      printf(\""unrecognized file format in '%s'\\n\"", filename);"", ""      return false;"", ""    }"", ""  }"", ""  UnmapViewOfFile(lpFileBase);"", ""  CloseHandle(hFileMapping);"", ""  CloseHandle(hFile);"", ""  return true;"", ""}"", """", ""bool bindexplib::AddObjectFile(const char* filename)""]","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, -2, -1, -1, 1, 2, 1, 1, 0, -1, -1, -1, -2, -1, -1, 1, 1, 1, 2, 1, 1, 0, -1, -1, -1, -1, -2, -1, -1, 1, 1, 1, 1, 2, 1, 1, 0, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[40, ""4046cb2d109bb91a16f53962219ad25c80d30755"", ""Merge topic 'bindexplib-arm'\n\n48fa2914 bindexplib: add ARM support\n97c605fd bindexplib: remove unused code\n7a8860af bindexplib: clang-format\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !604"", ""Source/bindexplib.cxx"", ""-"", ""fprintf(stderr, \""Couldn't open file '%s' with CreateFile()\\n\"", filename);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_new.cpp""], [44, ""4046cb2d109bb91a16f53962219ad25c80d30755"", ""Merge topic 'bindexplib-arm'\n\n48fa2914 bindexplib: add ARM support\n97c605fd bindexplib: remove unused code\n7a8860af bindexplib: clang-format\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !604"", ""Source/bindexplib.cxx"", ""+"", ""fprintf(stderr, \""Couldn't open file '%s' with CreateFile()\\n\"", filename);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_new.cpp""], [51, ""4046cb2d109bb91a16f53962219ad25c80d30755"", ""Merge topic 'bindexplib-arm'\n\n48fa2914 bindexplib: add ARM support\n97c605fd bindexplib: remove unused code\n7a8860af bindexplib: clang-format\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !604"", ""Source/bindexplib.cxx"", ""-"", ""fprintf(stderr, \""Couldn't open file mapping with CreateFileMapping()\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_new.cpp""], [57, ""4046cb2d109bb91a16f53962219ad25c80d30755"", ""Merge topic 'bindexplib-arm'\n\n48fa2914 bindexplib: add ARM support\n97c605fd bindexplib: remove unused code\n7a8860af bindexplib: clang-format\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !604"", ""Source/bindexplib.cxx"", ""+"", ""fprintf(stderr, \""Couldn't open file mapping with CreateFileMapping()\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_new.cpp""], [65, ""4046cb2d109bb91a16f53962219ad25c80d30755"", ""Merge topic 'bindexplib-arm'\n\n48fa2914 bindexplib: add ARM support\n97c605fd bindexplib: remove unused code\n7a8860af bindexplib: clang-format\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !604"", ""Source/bindexplib.cxx"", ""-"", ""fprintf(stderr, \""Couldn't map view of file with MapViewOfFile()\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_new.cpp""], [72, ""4046cb2d109bb91a16f53962219ad25c80d30755"", ""Merge topic 'bindexplib-arm'\n\n48fa2914 bindexplib: add ARM support\n97c605fd bindexplib: remove unused code\n7a8860af bindexplib: clang-format\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !604"", ""Source/bindexplib.cxx"", ""+"", ""fprintf(stderr, \""Couldn't map view of file with MapViewOfFile()\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_new.cpp""], [78, ""4046cb2d109bb91a16f53962219ad25c80d30755"", ""Merge topic 'bindexplib-arm'\n\n48fa2914 bindexplib: add ARM support\n97c605fd bindexplib: remove unused code\n7a8860af bindexplib: clang-format\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !604"", ""Source/bindexplib.cxx"", ""-"", ""fprintf(stderr, \""File is an executable.  I don't dump those.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_new.cpp""], [97, ""4046cb2d109bb91a16f53962219ad25c80d30755"", ""Merge topic 'bindexplib-arm'\n\n48fa2914 bindexplib: add ARM support\n97c605fd bindexplib: remove unused code\n7a8860af bindexplib: clang-format\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !604"", ""Source/bindexplib.cxx"", ""+"", ""fprintf(stderr, \""File is an executable.  I don't dump those.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_new.cpp""], [133, ""4046cb2d109bb91a16f53962219ad25c80d30755"", ""Merge topic 'bindexplib-arm'\n\n48fa2914 bindexplib: add ARM support\n97c605fd bindexplib: remove unused code\n7a8860af bindexplib: clang-format\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !604"", ""Source/bindexplib.cxx"", ""-"", ""printf(\""unrecognized file format in '%s'\\n\"", filename);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_new.cpp""], [142, ""4046cb2d109bb91a16f53962219ad25c80d30755"", ""Merge topic 'bindexplib-arm'\n\n48fa2914 bindexplib: add ARM support\n97c605fd bindexplib: remove unused code\n7a8860af bindexplib: clang-format\n\nAcked-by: Kitware Robot <kwrobot@kitware.com>\nMerge-request: !604"", ""Source/bindexplib.cxx"", ""+"", ""printf(\""unrecognized file format in '%s'\\n\"", filename);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_24_new.cpp""]]",339,278
"[""      pSymbolTable++;"", ""    }"", ""  }"", """", ""private:"", ""  std::set<std::string>& Symbols;"", ""  std::set<std::string>& DataSymbols;"", ""  DWORD_PTR SymbolCount;"", ""  PIMAGE_SECTION_HEADER SectionHeaders;"", ""  ObjectHeaderType* ObjectImageHeader;"", ""  SymbolTableType*  SymbolTable;"", ""  SymbolTableType* SymbolTable;"", ""  bool Is64Bit;"", ""};"", """", ""bool"", ""DumpFile(const char* filename,"", ""         std::set<std::string>& symbols,"", ""         std::set<std::string>& dataSymbols)"", ""bool DumpFile(const char* filename, std::set<std::string>& symbols,"", ""              std::set<std::string>& dataSymbols)"", ""{"", ""   HANDLE hFile;"", ""   HANDLE hFileMapping;"", ""   LPVOID lpFileBase;"", ""   PIMAGE_DOS_HEADER dosHeader;"", ""  HANDLE hFile;"", ""  HANDLE hFileMapping;"", ""  LPVOID lpFileBase;"", ""  PIMAGE_DOS_HEADER dosHeader;"", """", ""   hFile = CreateFileW(cmsys::Encoding::ToWide(filename).c_str(),"", ""                       GENERIC_READ, FILE_SHARE_READ, NULL,"", ""      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);"", ""  hFile = CreateFileW(cmsys::Encoding::ToWide(filename).c_str(), GENERIC_READ,"", ""                      FILE_SHARE_READ, NULL, OPEN_EXISTING,"", ""                      FILE_ATTRIBUTE_NORMAL, 0);"", """", ""   if (hFile == INVALID_HANDLE_VALUE) {"", ""      fprintf(stderr, \""Couldn't open file '%s' with CreateFile()\\n\"", filename);"", ""      return false;"", ""   }"", ""  if (hFile == INVALID_HANDLE_VALUE) {"", ""    fprintf(stderr, \""Couldn't open file '%s' with CreateFile()\\n\"", filename);"", ""    return false;"", ""  }"", """", ""   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);"", ""   if (hFileMapping == 0) {"", ""      CloseHandle(hFile);"", ""      fprintf(stderr, \""Couldn't open file mapping with CreateFileMapping()\\n\"");"", ""      return false;"", ""   }"", ""  hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);"", ""  if (hFileMapping == 0) {"", ""    CloseHandle(hFile);"", ""    fprintf(stderr, \""Couldn't open file mapping with CreateFileMapping()\\n\"");"", ""    return false;"", ""  }"", """", ""   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);"", ""   if (lpFileBase == 0) {"", ""      CloseHandle(hFileMapping);"", ""      CloseHandle(hFile);"", ""      fprintf(stderr, \""Couldn't map view of file with MapViewOfFile()\\n\"");"", ""      return false;"", ""   }"", ""  lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);"", ""  if (lpFileBase == 0) {"", ""    CloseHandle(hFileMapping);"", ""    CloseHandle(hFile);"", ""    fprintf(stderr, \""Couldn't map view of file with MapViewOfFile()\\n\"");"", ""    return false;"", ""  }"", """", ""   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;"", ""   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {"", ""      fprintf(stderr, \""File is an executable.  I don't dump those.\\n\"");"", ""      return false;"", ""   }"", ""   /* Does it look like a i386 COFF OBJ file??? */"", ""   else if ("", ""           ((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||"", ""            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64))"", ""           && (dosHeader->e_sp == 0)"", ""           ) {"", ""      /*"", ""      * The two tests above aren't what they look like.  They're"", ""      * really checking for IMAGE_FILE_HEADER.Machine == i386 (0x14C)"", ""      * and IMAGE_FILE_HEADER.SizeOfOptionalHeader == 0;"", ""      */"", ""      DumpSymbols<IMAGE_FILE_HEADER, IMAGE_SYMBOL>"", ""        symbolDumper((PIMAGE_FILE_HEADER) lpFileBase, symbols, dataSymbols,"", ""                     (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64));"", ""  dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;"", ""  if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {"", ""    fprintf(stderr, \""File is an executable.  I don't dump those.\\n\"");"", ""    return false;"", ""  }"", ""  /* Does it look like a i386 COFF OBJ file??? */"", ""  else if (((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||"", ""            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64)) &&"", ""           (dosHeader->e_sp == 0)) {"", ""    /*"", ""    * The two tests above aren't what they look like.  They're"", ""    * really checking for IMAGE_FILE_HEADER.Machine == i386 (0x14C)"", ""    * and IMAGE_FILE_HEADER.SizeOfOptionalHeader == 0;"", ""    */"", ""    DumpSymbols<IMAGE_FILE_HEADER, IMAGE_SYMBOL> symbolDumper("", ""      (PIMAGE_FILE_HEADER)lpFileBase, symbols, dataSymbols,"", ""      (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64));"", ""    symbolDumper.DumpObjFile();"", ""  } else {"", ""    // check for /bigobj format"", ""    cmANON_OBJECT_HEADER_BIGOBJ* h = (cmANON_OBJECT_HEADER_BIGOBJ*)lpFileBase;"", ""    if (h->Sig1 == 0x0 && h->Sig2 == 0xffff) {"", ""      DumpSymbols<cmANON_OBJECT_HEADER_BIGOBJ, cmIMAGE_SYMBOL_EX> symbolDumper("", ""        (cmANON_OBJECT_HEADER_BIGOBJ*)lpFileBase, symbols, dataSymbols,"", ""        (h->Machine == IMAGE_FILE_MACHINE_AMD64));"", ""      symbolDumper.DumpObjFile();"", ""   } else {"", ""      // check for /bigobj format"", ""      cmANON_OBJECT_HEADER_BIGOBJ* h ="", ""        (cmANON_OBJECT_HEADER_BIGOBJ*) lpFileBase;"", ""      if(h->Sig1 == 0x0 && h->Sig2 == 0xffff) {"", ""         DumpSymbols<cmANON_OBJECT_HEADER_BIGOBJ, cmIMAGE_SYMBOL_EX>"", ""           symbolDumper((cmANON_OBJECT_HEADER_BIGOBJ*) lpFileBase, symbols,"", ""                        dataSymbols,"", ""                        (h->Machine == IMAGE_FILE_MACHINE_AMD64));"", ""         symbolDumper.DumpObjFile();"", ""      } else {"", ""         printf(\""unrecognized file format in '%s'\\n\"", filename);"", ""         return false;"", ""      }"", ""   }"", ""   UnmapViewOfFile(lpFileBase);"", ""   CloseHandle(hFileMapping);"", ""   CloseHandle(hFile);"", ""   return true;"", ""    } else {"", ""      printf(\""unrecognized file format in '%s'\\n\"", filename);"", ""      return false;"", ""    }"", ""  }"", ""  UnmapViewOfFile(lpFileBase);"", ""  CloseHandle(hFileMapping);"", ""  CloseHandle(hFile);"", ""  return true;"", ""}"", """", ""bool bindexplib::AddObjectFile(const char* filename)""]","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, -1, -1, -1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, -2, -1, -1, 1, 2, 1, 1, 0, -1, -1, -1, -2, -1, -1, 1, 1, 1, 2, 1, 1, 0, -1, -1, -1, -1, -2, -1, -1, 1, 1, 1, 1, 2, 1, 1, 0, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[39, ""7a8860afbc614f2215e083adadb25963fe8f4dfe"", ""bindexplib: clang-format"", ""Source/bindexplib.cxx"", ""-"", ""fprintf(stderr, \""Couldn't open file '%s' with CreateFile()\\n\"", filename);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_new.cpp""], [43, ""7a8860afbc614f2215e083adadb25963fe8f4dfe"", ""bindexplib: clang-format"", ""Source/bindexplib.cxx"", ""+"", ""fprintf(stderr, \""Couldn't open file '%s' with CreateFile()\\n\"", filename);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_new.cpp""], [50, ""7a8860afbc614f2215e083adadb25963fe8f4dfe"", ""bindexplib: clang-format"", ""Source/bindexplib.cxx"", ""-"", ""fprintf(stderr, \""Couldn't open file mapping with CreateFileMapping()\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_new.cpp""], [56, ""7a8860afbc614f2215e083adadb25963fe8f4dfe"", ""bindexplib: clang-format"", ""Source/bindexplib.cxx"", ""+"", ""fprintf(stderr, \""Couldn't open file mapping with CreateFileMapping()\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_new.cpp""], [64, ""7a8860afbc614f2215e083adadb25963fe8f4dfe"", ""bindexplib: clang-format"", ""Source/bindexplib.cxx"", ""-"", ""fprintf(stderr, \""Couldn't map view of file with MapViewOfFile()\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_new.cpp""], [71, ""7a8860afbc614f2215e083adadb25963fe8f4dfe"", ""bindexplib: clang-format"", ""Source/bindexplib.cxx"", ""+"", ""fprintf(stderr, \""Couldn't map view of file with MapViewOfFile()\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_new.cpp""], [77, ""7a8860afbc614f2215e083adadb25963fe8f4dfe"", ""bindexplib: clang-format"", ""Source/bindexplib.cxx"", ""-"", ""fprintf(stderr, \""File is an executable.  I don't dump those.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_new.cpp""], [96, ""7a8860afbc614f2215e083adadb25963fe8f4dfe"", ""bindexplib: clang-format"", ""Source/bindexplib.cxx"", ""+"", ""fprintf(stderr, \""File is an executable.  I don't dump those.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_new.cpp""], [131, ""7a8860afbc614f2215e083adadb25963fe8f4dfe"", ""bindexplib: clang-format"", ""Source/bindexplib.cxx"", ""-"", ""printf(\""unrecognized file format in '%s'\\n\"", filename);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_new.cpp""], [140, ""7a8860afbc614f2215e083adadb25963fe8f4dfe"", ""bindexplib: clang-format"", ""Source/bindexplib.cxx"", ""+"", ""printf(\""unrecognized file format in '%s'\\n\"", filename);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_25_new.cpp""]]",339,342
"[""\tname = archive_entry_sourcepath(entry);"", ""\tif (name == NULL)"", ""\t\tname = archive_entry_pathname(entry);"", ""\telse if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {"", ""\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""Can't change dir to read extended attributes\"");"", ""\t\t\treturn (ARCHIVE_FAILED);"", ""\t}"", ""\tif (name == NULL) {"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Can't open file to read extended attributes: No name\"");"", ""\t\treturn (ARCHIVE_WARN);"", ""\t}"", """", ""\tif (a->tree != NULL) {"", ""\t\tif (a->tree_enter_working_dir(a->tree) != 0) {"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Couldn't change dir\"");"", ""\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t}"", ""\t}"", """", ""\t/* Short-circuit if there's nothing to do. */"", ""\thave_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);"", ""\tif (have_attrs == -1) {""]","[0, 0, 0, 1, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, -1, -1, -2, -1, -1, -1, -1, -1, 0, 0, 0]","[[4, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""], [16, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""-"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""]]",302,321
"[""}"", ""#endif"", """", ""#if HAVE_DARWIN_ACL"", ""static int translate_guid(struct archive *, acl_entry_t,"", ""    int *, int *, const char **);"", """", ""static void add_trivial_nfs4_acl(struct archive_entry *);"", ""#endif"", """", ""#if HAVE_SUN_ACL"", ""static int"", ""sun_acl_is_trivial(acl_t *, mode_t, int *trivialp);"", ""#endif"", """", ""#ifdef HAVE_POSIX_ACL"", ""#if HAVE_POSIX_ACL || HAVE_NFS4_ACL"", ""static int translate_acl(struct archive_read_disk *a,"", ""    struct archive_entry *entry, acl_t acl, int archive_entry_acl_type);"", ""    struct archive_entry *entry,"", ""#if HAVE_SUN_ACL"", ""    acl_t *acl,"", ""#else"", ""    acl_t acl,"", ""#endif"", ""    int archive_entry_acl_type);"", """", ""static int"", ""setup_acls(struct archive_read_disk *a,"", ""    struct archive_entry *entry, int *fd)"", ""{"", ""\tconst char\t*accpath;"", ""\tacl_t\t\t acl;"", ""#if HAVE_ACL_IS_TRIVIAL_NP"", ""\tint\t\tr;"", ""#if HAVE_SUN_ACL"", ""\tacl_t\t\t*acl;"", ""#else"", ""\tacl_t\t\tacl;"", ""#endif"", ""\tint\t\tr;"", """", ""\taccpath = archive_entry_sourcepath(entry);"", ""\tif (accpath == NULL)"", ""\t\taccpath = archive_entry_pathname(entry);"", ""\taccpath = NULL;"", """", ""#if HAVE_SUN_ACL || HAVE_DARWIN_ACL || HAVE_ACL_GET_FD_NP"", ""\tif (*fd < 0)"", ""#else"", ""\t/* For default ACLs on Linux we need reachable accpath */"", ""\tif (*fd < 0 || S_ISDIR(archive_entry_mode(entry)))"", ""#endif"", ""\t{"", ""\t\taccpath = archive_entry_sourcepath(entry);"", ""\t\tif (accpath == NULL || (a->tree != NULL &&"", ""\t\t    a->tree_enter_working_dir(a->tree) != 0))"", ""\t\t\taccpath = archive_entry_pathname(entry);"", ""\t\tif (accpath == NULL) {"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Couldn't determine file path to read ACLs\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tif (a->tree != NULL &&"", ""#if !HAVE_SUN_ACL && !HAVE_DARWIN_ACL && !HAVE_ACL_GET_FD_NP"", ""\t\t    *fd < 0 &&"", ""#endif"", ""\t\t    (a->follow_symlinks ||"", ""\t\t    archive_entry_filetype(entry) != AE_IFLNK)) {"", ""\t\t\t*fd = a->open_on_current_dir(a->tree,"", ""\t\t\t    accpath, O_RDONLY | O_NONBLOCK);"", ""\t\t}"", ""\t}"", """", ""\tarchive_entry_acl_clear(entry);"", """", ""#ifdef ACL_TYPE_NFS4"", ""\t/* Try NFS4 ACL first. */"", ""\tacl = NULL;"", """", ""#if HAVE_NFS4_ACL"", ""\t/* Try NFSv4 ACL first. */"", ""\tif (*fd >= 0)"", ""#if HAVE_SUN_ACL"", ""\t\t/* Solaris reads both POSIX.1e and NFSv4 ACL here */"", ""\t\tfacl_get(*fd, 0, &acl);"", ""#elif HAVE_ACL_GET_FD_NP"", ""\t\tacl = acl_get_fd_np(*fd, ARCHIVE_PLATFORM_ACL_TYPE_NFS4);"", ""#else"", ""\t\tacl = acl_get_fd(*fd);"", ""#endif"", ""#if HAVE_ACL_GET_LINK_NP"", ""\telse if (!a->follow_symlinks)"", ""\t\tacl = acl_get_link_np(accpath, ACL_TYPE_NFS4);"", ""\t\tacl = acl_get_link_np(accpath, ARCHIVE_PLATFORM_ACL_TYPE_NFS4);"", ""#else"", ""\telse if ((!a->follow_symlinks)"", ""\t    && (archive_entry_filetype(entry) == AE_IFLNK))""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, -1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 1, 0, 1, 0, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, -1, -1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, -1, 1, 0, 0, 0]","[[59, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""]]",400,416
"[""\t\tacl = NULL;"", ""#endif"", ""\telse"", ""\t\tacl = acl_get_file(accpath, ACL_TYPE_NFS4);"", ""#if HAVE_ACL_IS_TRIVIAL_NP"", ""#if HAVE_SUN_ACL"", ""\t\t/* Solaris reads both POSIX.1e and NFSv4 ACLs here */"", ""\t\tacl_get(accpath, 0, &acl);"", ""#else"", ""\t\tacl = acl_get_file(accpath, ARCHIVE_PLATFORM_ACL_TYPE_NFS4);"", ""#endif"", """", """", ""#if HAVE_ACL_IS_TRIVIAL_NP || HAVE_SUN_ACL"", ""\t/* Ignore \""trivial\"" ACLs that just mirror the file mode. */"", ""\tacl_is_trivial_np(acl, &r);"", ""\tif (r) {"", ""\t\tacl_free(acl);"", ""\t\tacl = NULL;"", ""\t}"", ""\tif (acl != NULL) {"", ""#if HAVE_SUN_ACL"", ""\t\tif (sun_acl_is_trivial(acl, archive_entry_mode(entry),"", ""\t\t    &r) == 0 && r == 1)"", ""#elif HAVE_ACL_IS_TRIVIAL_NP"", ""\t\tif (acl_is_trivial_np(acl, &r) == 0 && r == 1)"", ""#endif"", ""\t\t{"", ""\t\t\tacl_free(acl);"", ""\t\t\tacl = NULL;"", ""\t\t\t/*"", ""\t\t\t * Simultaneous NFSv4 and POSIX.1e ACLs for the same"", ""\t\t\t * entry are not allowed, so we should return here"", ""\t\t\t */"", ""\t\t\treturn (ARCHIVE_OK);"", ""\t\t}"", ""\t}"", ""#endif\t/* HAVE_ACL_IS_TRIVIAL_NP || HAVE_SUN_ACL */"", ""\tif (acl != NULL) {"", ""\t\ttranslate_acl(a, entry, acl, ARCHIVE_ENTRY_ACL_TYPE_NFS4);"", ""\t\tr = translate_acl(a, entry, acl, ARCHIVE_ENTRY_ACL_TYPE_NFS4);"", ""\t\tacl_free(acl);"", ""\t\treturn (ARCHIVE_OK);"", ""\t}"", ""\t\tif (r != ARCHIVE_OK) {"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""Couldn't translate \"""", ""#if !HAVE_SUN_ACL"", ""\t\t\t    \""NFSv4 \"""", ""#endif"", ""\t\t\t    \""ACLs\"");"", ""\t\t}"", ""#if HAVE_DARWIN_ACL"", ""\t\t/*"", ""\t\t * Because Mac OS doesn't support owner@, group@ and everyone@"", ""\t\t * ACLs we need to add NFSv4 ACLs mirroring the file mode to"", ""\t\t * the archive entry. Otherwise extraction on non-Mac platforms"", ""\t\t * would lead to an invalid file mode."", ""\t\t */"", ""\t\tif ((archive_entry_acl_types(entry) &"", ""\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0)"", ""\t\t\tadd_trivial_nfs4_acl(entry);"", ""#endif"", ""\t\treturn (r);"", ""\t}"", ""#endif\t/* HAVE_NFS4_ACL */"", """", ""#if HAVE_POSIX_ACL"", ""\t/* This code path is skipped on MacOS and Solaris */"", """", ""\t/* Retrieve access ACL from file. */"", ""\tif (*fd >= 0)""]","[0, 0, 0, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, -1, -1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[45, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""]]",436,505
"[""#endif"", ""\telse"", ""\t\tacl = acl_get_file(accpath, ACL_TYPE_ACCESS);"", """", ""#if HAVE_ACL_IS_TRIVIAL_NP"", ""\t/* Ignore \""trivial\"" ACLs that just mirror the file mode. */"", ""\tif (acl != NULL && acl_is_trivial_np(acl, &r) == 0) {"", ""\t\tif (r) {"", ""\t\t\tacl_free(acl);"", ""\t\t\tacl = NULL;"", ""\t\t}"", ""\t}"", ""#endif"", """", ""\tif (acl != NULL) {"", ""\t\ttranslate_acl(a, entry, acl,"", ""\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);"", ""\t\tr = translate_acl(a, entry, acl, ARCHIVE_ENTRY_ACL_TYPE_ACCESS);"", ""\t\tacl_free(acl);"", ""\t\tacl = NULL;"", ""\t\tif (r != ARCHIVE_OK) {"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""Couldn't translate access ACLs\"");"", ""\t\t\treturn (r);"", ""\t\t}"", ""\t}"", """", ""\t/* Only directories can have default ACLs. */"", ""\tif (S_ISDIR(archive_entry_mode(entry))) {"", ""#if HAVE_ACL_GET_FD_NP"", ""\t\tif (*fd >= 0)"", ""\t\t\tacl = acl_get_fd_np(*fd, ACL_TYPE_DEFAULT);"", ""\t\telse"", ""#endif"", ""\t\tacl = acl_get_file(accpath, ACL_TYPE_DEFAULT);"", ""\t\tif (acl != NULL) {"", ""\t\t\ttranslate_acl(a, entry, acl,"", ""\t\t\tr = translate_acl(a, entry, acl,"", ""\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);"", ""\t\t\tacl_free(acl);"", ""\t\t\tif (r != ARCHIVE_OK) {"", ""\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Couldn't translate default ACLs\"");"", ""\t\t\t\treturn (r);"", ""\t\t\t}"", ""\t\t}"", ""\t}"", ""#endif\t/* HAVE_POSIX_ACL */"", ""\treturn (ARCHIVE_OK);"", ""}"", """", ""/*"", "" * Translate system ACL into libarchive internal structure."", "" * Translate system ACL permissions into libarchive internal structure"", "" */"", """", ""static struct {"", ""        int archive_perm;"", ""        int platform_perm;"", ""static const struct {"", ""\tconst int archive_perm;"", ""\tconst int platform_perm;"", ""} acl_perm_map[] = {"", ""        {ARCHIVE_ENTRY_ACL_EXECUTE, ACL_EXECUTE},"", ""        {ARCHIVE_ENTRY_ACL_WRITE, ACL_WRITE},"", ""        {ARCHIVE_ENTRY_ACL_READ, ACL_READ},"", ""#ifdef ACL_TYPE_NFS4"", ""        {ARCHIVE_ENTRY_ACL_READ_DATA, ACL_READ_DATA},"", ""        {ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, ACL_LIST_DIRECTORY},"", ""        {ARCHIVE_ENTRY_ACL_WRITE_DATA, ACL_WRITE_DATA},"", ""        {ARCHIVE_ENTRY_ACL_ADD_FILE, ACL_ADD_FILE},"", ""        {ARCHIVE_ENTRY_ACL_APPEND_DATA, ACL_APPEND_DATA},"", ""        {ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY, ACL_ADD_SUBDIRECTORY},"", ""        {ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS, ACL_READ_NAMED_ATTRS},"", ""        {ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS, ACL_WRITE_NAMED_ATTRS},"", ""        {ARCHIVE_ENTRY_ACL_DELETE_CHILD, ACL_DELETE_CHILD},"", ""        {ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES, ACL_READ_ATTRIBUTES},"", ""        {ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES, ACL_WRITE_ATTRIBUTES},"", ""        {ARCHIVE_ENTRY_ACL_DELETE, ACL_DELETE},"", ""        {ARCHIVE_ENTRY_ACL_READ_ACL, ACL_READ_ACL},"", ""        {ARCHIVE_ENTRY_ACL_WRITE_ACL, ACL_WRITE_ACL},"", ""        {ARCHIVE_ENTRY_ACL_WRITE_OWNER, ACL_WRITE_OWNER},"", ""        {ARCHIVE_ENTRY_ACL_SYNCHRONIZE, ACL_SYNCHRONIZE}"", ""#if HAVE_SUN_ACL\t/* Solaris NFSv4 ACL permissions */"", ""\t{ARCHIVE_ENTRY_ACL_EXECUTE, ACE_EXECUTE},"", ""\t{ARCHIVE_ENTRY_ACL_READ_DATA, ACE_READ_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, ACE_LIST_DIRECTORY},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_DATA, ACE_WRITE_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_ADD_FILE, ACE_ADD_FILE},"", ""\t{ARCHIVE_ENTRY_ACL_APPEND_DATA, ACE_APPEND_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY, ACE_ADD_SUBDIRECTORY},"", ""\t{ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS, ACE_READ_NAMED_ATTRS},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS, ACE_WRITE_NAMED_ATTRS},"", ""\t{ARCHIVE_ENTRY_ACL_DELETE_CHILD, ACE_DELETE_CHILD},"", ""\t{ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES, ACE_READ_ATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES, ACE_WRITE_ATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_DELETE, ACE_DELETE},"", ""\t{ARCHIVE_ENTRY_ACL_READ_ACL, ACE_READ_ACL},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_ACL, ACE_WRITE_ACL},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_OWNER, ACE_WRITE_OWNER},"", ""\t{ARCHIVE_ENTRY_ACL_SYNCHRONIZE, ACE_SYNCHRONIZE}"", ""#elif HAVE_DARWIN_ACL\t/* MacOS ACL permissions */"", ""\t{ARCHIVE_ENTRY_ACL_READ_DATA, ACL_READ_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, ACL_LIST_DIRECTORY},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_DATA, ACL_WRITE_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_ADD_FILE, ACL_ADD_FILE},"", ""\t{ARCHIVE_ENTRY_ACL_EXECUTE, ACL_EXECUTE},"", ""\t{ARCHIVE_ENTRY_ACL_DELETE, ACL_DELETE},"", ""\t{ARCHIVE_ENTRY_ACL_APPEND_DATA, ACL_APPEND_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY, ACL_ADD_SUBDIRECTORY},"", ""\t{ARCHIVE_ENTRY_ACL_DELETE_CHILD, ACL_DELETE_CHILD},"", ""\t{ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES, ACL_READ_ATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES, ACL_WRITE_ATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS, ACL_READ_EXTATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS, ACL_WRITE_EXTATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_READ_ACL, ACL_READ_SECURITY},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_ACL, ACL_WRITE_SECURITY},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_OWNER, ACL_CHANGE_OWNER},"", ""\t{ARCHIVE_ENTRY_ACL_SYNCHRONIZE, ACL_SYNCHRONIZE}"", ""#else\t/* POSIX.1e ACL permissions */"", ""\t{ARCHIVE_ENTRY_ACL_EXECUTE, ACL_EXECUTE},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE, ACL_WRITE},"", ""\t{ARCHIVE_ENTRY_ACL_READ, ACL_READ},"", ""#if HAVE_ACL_TYPE_NFS4\t/* FreeBSD NFSv4 ACL permissions */"", ""\t{ARCHIVE_ENTRY_ACL_READ_DATA, ACL_READ_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, ACL_LIST_DIRECTORY},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_DATA, ACL_WRITE_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_ADD_FILE, ACL_ADD_FILE},"", ""\t{ARCHIVE_ENTRY_ACL_APPEND_DATA, ACL_APPEND_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY, ACL_ADD_SUBDIRECTORY},"", ""\t{ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS, ACL_READ_NAMED_ATTRS},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS, ACL_WRITE_NAMED_ATTRS},"", ""\t{ARCHIVE_ENTRY_ACL_DELETE_CHILD, ACL_DELETE_CHILD},"", ""\t{ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES, ACL_READ_ATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES, ACL_WRITE_ATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_DELETE, ACL_DELETE},"", ""\t{ARCHIVE_ENTRY_ACL_READ_ACL, ACL_READ_ACL},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_ACL, ACL_WRITE_ACL},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_OWNER, ACL_WRITE_OWNER},"", ""\t{ARCHIVE_ENTRY_ACL_SYNCHRONIZE, ACL_SYNCHRONIZE}"", ""#endif"", ""#endif\t/* !HAVE_SUN_ACL && !HAVE_DARWIN_ACL */"", ""};"", """", ""#ifdef ACL_TYPE_NFS4"", ""static struct {"", ""        int archive_inherit;"", ""        int platform_inherit;"", ""#if HAVE_NFS4_ACL"", ""/*"", "" * Translate system NFSv4 inheritance flags into libarchive internal structure"", "" */"", ""static const struct {"", ""\tconst int archive_inherit;"", ""\tconst int platform_inherit;"", ""} acl_inherit_map[] = {"", ""        {ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, ACL_ENTRY_FILE_INHERIT},"", ""#if HAVE_SUN_ACL\t/* Solaris ACL inheritance flags */"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, ACE_FILE_INHERIT_ACE},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT, ACE_DIRECTORY_INHERIT_ACE},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT, ACE_NO_PROPAGATE_INHERIT_ACE},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY, ACE_INHERIT_ONLY_ACE},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_SUCCESSFUL_ACCESS, ACE_SUCCESSFUL_ACCESS_ACE_FLAG},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_FAILED_ACCESS, ACE_FAILED_ACCESS_ACE_FLAG},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERITED, ACE_INHERITED_ACE}"", ""#elif HAVE_DARWIN_ACL\t/* MacOS NFSv4 inheritance flags */"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERITED, ACL_ENTRY_INHERITED},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, ACL_ENTRY_FILE_INHERIT},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT, ACL_ENTRY_DIRECTORY_INHERIT},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT, ACL_ENTRY_LIMIT_INHERIT},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY, ACL_ENTRY_ONLY_INHERIT}"", ""#else\t/* FreeBSD NFSv4 ACL inheritance flags */"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, ACL_ENTRY_FILE_INHERIT},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT, ACL_ENTRY_DIRECTORY_INHERIT},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT, ACL_ENTRY_NO_PROPAGATE_INHERIT},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY, ACL_ENTRY_INHERIT_ONLY}"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY, ACL_ENTRY_INHERIT_ONLY},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_SUCCESSFUL_ACCESS, ACL_ENTRY_SUCCESSFUL_ACCESS},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_FAILED_ACCESS, ACL_ENTRY_FAILED_ACCESS},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERITED, ACL_ENTRY_INHERITED}"", ""#endif\t/* !HAVE_SUN_ACL && !HAVE_DARWIN_ACL */"", ""};"", ""#endif"", ""#endif\t/* HAVE_NFS4_ACL */"", """", ""#if HAVE_DARWIN_ACL"", ""static int translate_guid(struct archive *a, acl_entry_t acl_entry,"", ""    int *ae_id, int *ae_tag, const char **ae_name)"", ""{"", ""\tvoid *q;"", ""\tuid_t ugid;"", ""\tint r, idtype;"", ""\tstruct passwd *pwd;"", ""\tstruct group *grp;"", """", ""\tq = acl_get_qualifier(acl_entry);"", ""\tif (q == NULL)"", ""\t\treturn (1);"", ""\tr = mbr_uuid_to_id((const unsigned char *)q, &ugid, &idtype);"", ""\tif (r != 0) {"", ""\t\tacl_free(q);"", ""\t\treturn (1);"", ""\t}"", ""\tif (idtype == ID_TYPE_UID) {"", ""\t\t*ae_tag = ARCHIVE_ENTRY_ACL_USER;"", ""\t\tpwd = getpwuuid(q);"", ""\t\tif (pwd == NULL) {"", ""\t\t\t*ae_id = ugid;"", ""\t\t\t*ae_name = NULL;"", ""\t\t} else {"", ""\t\t\t*ae_id = pwd->pw_uid;"", ""\t\t\t*ae_name = archive_read_disk_uname(a, *ae_id);"", ""\t\t}"", ""\t} else if (idtype == ID_TYPE_GID) {"", ""\t\t*ae_tag = ARCHIVE_ENTRY_ACL_GROUP;"", ""\t\tgrp = getgruuid(q);"", ""\t\tif (grp == NULL) {"", ""\t\t\t*ae_id = ugid;"", ""\t\t\t*ae_name = NULL;"", ""\t\t} else {"", ""\t\t\t*ae_id = grp->gr_gid;"", ""\t\t\t*ae_name = archive_read_disk_gname(a, *ae_id);"", ""\t\t}"", ""\t} else"", ""\t\tr = 1;"", """", ""\tacl_free(q);"", ""\treturn (r);"", ""}"", """", ""/*"", "" * Add trivial NFSv4 ACL entries from mode"", "" */"", ""static void"", ""add_trivial_nfs4_acl(struct archive_entry *entry)"", ""{"", ""\tmode_t mode;"", ""\tint i;"", ""\tconst int rperm = ARCHIVE_ENTRY_ACL_READ_DATA;"", ""\tconst int wperm = ARCHIVE_ENTRY_ACL_WRITE_DATA |"", ""\t    ARCHIVE_ENTRY_ACL_APPEND_DATA;"", ""\tconst int eperm = ARCHIVE_ENTRY_ACL_EXECUTE;"", ""\tconst int pubset = ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES |"", ""\t    ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS |"", ""\t    ARCHIVE_ENTRY_ACL_READ_ACL |"", ""\t    ARCHIVE_ENTRY_ACL_SYNCHRONIZE;"", ""\tconst int ownset = pubset | ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES |"", ""\t    ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS |"", ""\t    ARCHIVE_ENTRY_ACL_WRITE_ACL |"", ""\t    ARCHIVE_ENTRY_ACL_WRITE_OWNER;"", """", ""\tstruct {"", ""\t    const int type;"", ""\t    const int tag;"", ""\t    int permset;"", ""\t} tacl_entry[] = {"", ""\t    {ARCHIVE_ENTRY_ACL_TYPE_ALLOW, ARCHIVE_ENTRY_ACL_USER_OBJ, 0},"", ""\t    {ARCHIVE_ENTRY_ACL_TYPE_DENY, ARCHIVE_ENTRY_ACL_USER_OBJ, 0},"", ""\t    {ARCHIVE_ENTRY_ACL_TYPE_DENY, ARCHIVE_ENTRY_ACL_GROUP_OBJ, 0},"", ""\t    {ARCHIVE_ENTRY_ACL_TYPE_ALLOW, ARCHIVE_ENTRY_ACL_USER_OBJ, ownset},"", ""\t    {ARCHIVE_ENTRY_ACL_TYPE_ALLOW, ARCHIVE_ENTRY_ACL_GROUP_OBJ, pubset},"", ""\t    {ARCHIVE_ENTRY_ACL_TYPE_ALLOW, ARCHIVE_ENTRY_ACL_EVERYONE, pubset}"", ""\t};"", """", ""\tmode = archive_entry_mode(entry);"", """", ""\t/* Permissions for everyone@ */"", ""\tif (mode & 0004)"", ""\t\ttacl_entry[5].permset |= rperm;"", ""\tif (mode & 0002)"", ""\t\ttacl_entry[5].permset |= wperm;"", ""\tif (mode & 0001)"", ""\t\ttacl_entry[5].permset |= eperm;"", """", ""\t/* Permissions for group@ */"", ""\tif (mode & 0040)"", ""\t\ttacl_entry[4].permset |= rperm;"", ""\telse if (mode & 0004)"", ""\t\ttacl_entry[2].permset |= rperm;"", ""\tif (mode & 0020)"", ""\t\ttacl_entry[4].permset |= wperm;"", ""\telse if (mode & 0002)"", ""\t\ttacl_entry[2].permset |= wperm;"", ""\tif (mode & 0010)"", ""\t\ttacl_entry[4].permset |= eperm;"", ""\telse if (mode & 0001)"", ""\t\ttacl_entry[2].permset |= eperm;"", """", ""\t/* Permissions for owner@ */"", ""\tif (mode & 0400) {"", ""\t\ttacl_entry[3].permset |= rperm;"", ""\t\tif (!(mode & 0040) && (mode & 0004))"", ""\t\t\ttacl_entry[0].permset |= rperm;"", ""\t} else if ((mode & 0040) || (mode & 0004))"", ""\t\ttacl_entry[1].permset |= rperm;"", ""\tif (mode & 0200) {"", ""\t\ttacl_entry[3].permset |= wperm;"", ""\t\tif (!(mode & 0020) && (mode & 0002))"", ""\t\t\ttacl_entry[0].permset |= wperm;"", ""\t} else if ((mode & 0020) || (mode & 0002))"", ""\t\ttacl_entry[1].permset |= wperm;"", ""\tif (mode & 0100) {"", ""\t\ttacl_entry[3].permset |= eperm;"", ""\t\tif (!(mode & 0010) && (mode & 0001))"", ""\t\t\ttacl_entry[0].permset |= eperm;"", ""\t} else if ((mode & 0010) || (mode & 0001))"", ""\t\ttacl_entry[1].permset |= eperm;"", """", ""\tfor (i = 0; i < 6; i++) {"", ""\t\tif (tacl_entry[i].permset != 0) {"", ""\t\t\tarchive_entry_acl_add_entry(entry,"", ""\t\t\t    tacl_entry[i].type, tacl_entry[i].permset,"", ""\t\t\t    tacl_entry[i].tag, -1, NULL);"", ""\t\t}"", ""\t}"", """", ""\treturn;"", ""}"", ""#elif HAVE_SUN_ACL"", ""/*"", "" * Check if acl is trivial"", "" * This is a FreeBSD acl_is_trivial_np() implementation for Solaris"", "" */"", ""static int"", ""sun_acl_is_trivial(acl_t *acl, mode_t mode, int *trivialp)"", ""{"", ""\tint i, p;"", ""\tconst uint32_t rperm = ACE_READ_DATA;"", ""\tconst uint32_t wperm = ACE_WRITE_DATA | ACE_APPEND_DATA;"", ""\tconst uint32_t eperm = ACE_EXECUTE;"", ""\tconst uint32_t pubset = ACE_READ_ATTRIBUTES | ACE_READ_NAMED_ATTRS |"", ""\t    ACE_READ_ACL | ACE_SYNCHRONIZE;"", ""\tconst uint32_t ownset = pubset | ACE_WRITE_ATTRIBUTES |"", ""\t    ACE_WRITE_NAMED_ATTRS | ACE_WRITE_ACL | ACE_WRITE_OWNER;"", """", ""\tace_t *ace;"", ""\tace_t tace[6];"", """", ""\tif (acl == NULL || trivialp == NULL)"", ""\t\treturn (-1);"", """", ""\t*trivialp = 0;"", """", ""\t/* ACL_IS_TRIVIAL flag must be set for both POSIX.1e and NFSv4 ACLs */"", ""\tif ((acl->acl_flags & ACL_IS_TRIVIAL) == 0)"", ""\t\treturn (0);"", """", ""\t/*"", ""\t * POSIX.1e ACLs marked with ACL_IS_TRIVIAL are compatible with"", ""\t * FreeBSD acl_is_trivial_np(). On Solaris they have 4 entries,"", ""\t * including mask."", ""\t */"", ""\tif (acl->acl_type == ACLENT_T) {"", ""\t\tif (acl->acl_cnt == 4)"", ""\t\t\t*trivialp = 1;"", ""\t\treturn (0);"", ""\t}"", """", ""\tif (acl->acl_type != ACE_T || acl->acl_entry_size != sizeof(ace_t))"", ""\t\treturn (-1);"", """", ""\t/*"", ""\t * Continue with checking NFSv4 ACLs"", ""\t *"", ""\t * Create list of trivial ace's to be compared"", ""\t */"", """", ""\t/* owner@ allow pre */"", ""\ttace[0].a_flags = ACE_OWNER;"", ""\ttace[0].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;"", ""\ttace[0].a_access_mask = 0;"", """", ""\t/* owner@ deny */"", ""\ttace[1].a_flags = ACE_OWNER;"", ""\ttace[1].a_type = ACE_ACCESS_DENIED_ACE_TYPE;"", ""\ttace[1].a_access_mask = 0;"", """", ""\t/* group@ deny */"", ""\ttace[2].a_flags = ACE_GROUP | ACE_IDENTIFIER_GROUP;"", ""\ttace[2].a_type = ACE_ACCESS_DENIED_ACE_TYPE;"", ""\ttace[2].a_access_mask = 0;"", """", ""\t/* owner@ allow */"", ""\ttace[3].a_flags = ACE_OWNER;"", ""\ttace[3].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;"", ""\ttace[3].a_access_mask = ownset;"", """", ""\t/* group@ allow */"", ""\ttace[4].a_flags = ACE_GROUP | ACE_IDENTIFIER_GROUP;"", ""\ttace[4].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;"", ""\ttace[4].a_access_mask = pubset;"", """", ""\t/* everyone@ allow */"", ""\ttace[5].a_flags = ACE_EVERYONE;"", ""\ttace[5].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;"", ""\ttace[5].a_access_mask = pubset;"", """", ""\t/* Permissions for everyone@ */"", ""\tif (mode & 0004)"", ""\t\ttace[5].a_access_mask |= rperm;"", ""\tif (mode & 0002)"", ""\t\ttace[5].a_access_mask |= wperm;"", ""\tif (mode & 0001)"", ""\t\ttace[5].a_access_mask |= eperm;"", """", ""\t/* Permissions for group@ */"", ""\tif (mode & 0040)"", ""\t\ttace[4].a_access_mask |= rperm;"", ""\telse if (mode & 0004)"", ""\t\ttace[2].a_access_mask |= rperm;"", ""\tif (mode & 0020)"", ""\t\ttace[4].a_access_mask |= wperm;"", ""\telse if (mode & 0002)"", ""\t\ttace[2].a_access_mask |= wperm;"", ""\tif (mode & 0010)"", ""\t\ttace[4].a_access_mask |= eperm;"", ""\telse if (mode & 0001)"", ""\t\ttace[2].a_access_mask |= eperm;"", """", ""\t/* Permissions for owner@ */"", ""\tif (mode & 0400) {"", ""\t\ttace[3].a_access_mask |= rperm;"", ""\t\tif (!(mode & 0040) && (mode & 0004))"", ""\t\t\ttace[0].a_access_mask |= rperm;"", ""\t} else if ((mode & 0040) || (mode & 0004))"", ""\t\ttace[1].a_access_mask |= rperm;"", ""\tif (mode & 0200) {"", ""\t\ttace[3].a_access_mask |= wperm;"", ""\t\tif (!(mode & 0020) && (mode & 0002))"", ""\t\t\ttace[0].a_access_mask |= wperm;"", ""\t} else if ((mode & 0020) || (mode & 0002))"", ""\t\ttace[1].a_access_mask |= wperm;"", ""\tif (mode & 0100) {"", ""\t\ttace[3].a_access_mask |= eperm;"", ""\t\tif (!(mode & 0010) && (mode & 0001))"", ""\t\t\ttace[0].a_access_mask |= eperm;"", ""\t} else if ((mode & 0010) || (mode & 0001))"", ""\t\ttace[1].a_access_mask |= eperm;"", """", ""\t/* Check if the acl count matches */"", ""\tp = 3;"", ""\tfor (i = 0; i < 3; i++) {"", ""\t\tif (tace[i].a_access_mask != 0)"", ""\t\t\tp++;"", ""\t}"", ""\tif (acl->acl_cnt != p)"", ""\t\treturn (0);"", """", ""\tp = 0;"", ""\tfor (i = 0; i < 6; i++) {"", ""\t\tif (tace[i].a_access_mask != 0) {"", ""\t\t\tace = &((ace_t *)acl->acl_aclp)[p];"", ""\t\t\t/*"", ""\t\t\t * Illumos added ACE_DELETE_CHILD to write perms for"", ""\t\t\t * directories. We have to check against that, too."", ""\t\t\t */"", ""\t\t\tif (ace->a_flags != tace[i].a_flags ||"", ""\t\t\t    ace->a_type != tace[i].a_type ||"", ""\t\t\t    (ace->a_access_mask != tace[i].a_access_mask &&"", ""\t\t\t    ((acl->acl_flags & ACL_IS_DIR) == 0 ||"", ""\t\t\t    (tace[i].a_access_mask & wperm) == 0 ||"", ""\t\t\t    ace->a_access_mask !="", ""\t\t\t    (tace[i].a_access_mask | ACE_DELETE_CHILD))))"", ""\t\t\t\treturn (0);"", ""\t\t\tp++;"", ""\t\t}"", ""\t}"", """", ""\t*trivialp = 1;"", ""\treturn (0);"", ""}"", ""#endif\t/* HAVE_SUN_ACL */"", """", ""#if HAVE_SUN_ACL"", ""/*"", "" * Translate Solaris POSIX.1e and NFSv4 ACLs into libarchive internal ACL"", "" */"", ""static int"", ""translate_acl(struct archive_read_disk *a,"", ""    struct archive_entry *entry, acl_t *acl, int default_entry_acl_type)"", ""{"", ""\tint e, i;"", ""\tint ae_id, ae_tag, ae_perm;"", ""\tint entry_acl_type;"", ""\tconst char *ae_name;"", ""\taclent_t *aclent;"", ""\tace_t *ace;"", """", ""\t(void)default_entry_acl_type;"", """", ""\tif (acl->acl_cnt <= 0)"", ""\t\treturn (ARCHIVE_OK);"", """", ""\tfor (e = 0; e < acl->acl_cnt; e++) {"", ""\t\tae_name = NULL;"", ""\t\tae_tag = 0;"", ""\t\tae_perm = 0;"", """", ""\t\tif (acl->acl_type == ACE_T) {"", ""\t\t\tace = &((ace_t *)acl->acl_aclp)[e];"", ""\t\t\tae_id = ace->a_who;"", """", ""\t\t\tswitch(ace->a_type) {"", ""\t\t\tcase ACE_ACCESS_ALLOWED_ACE_TYPE:"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;"", ""\t\t\t\tbreak;"", ""\t\t\tcase ACE_ACCESS_DENIED_ACE_TYPE:"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DENY;"", ""\t\t\t\tbreak;"", ""\t\t\tcase ACE_SYSTEM_AUDIT_ACE_TYPE:"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;"", ""\t\t\t\tbreak;"", ""\t\t\tcase ACE_SYSTEM_ALARM_ACE_TYPE:"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALARM;"", ""\t\t\t\tbreak;"", ""\t\t\tdefault:"", ""\t\t\t\t/* Unknown entry type, skip */"", ""\t\t\t\tcontinue;"", ""\t\t\t}"", """", ""\t\t\tif ((ace->a_flags & ACE_OWNER) != 0)"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER_OBJ;"", ""\t\t\telse if ((ace->a_flags & ACE_GROUP) != 0)"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;"", ""\t\t\telse if ((ace->a_flags & ACE_EVERYONE) != 0)"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_EVERYONE;"", ""\t\t\telse if ((ace->a_flags & ACE_IDENTIFIER_GROUP) != 0) {"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;"", ""\t\t\t\tae_name = archive_read_disk_gname(&a->archive,"", ""\t\t\t\t    ae_id);"", ""\t\t\t} else {"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;"", ""\t\t\t\tae_name = archive_read_disk_uname(&a->archive,"", ""\t\t\t\t    ae_id);"", ""\t\t\t}"", """", ""\t\t\tfor (i = 0; i < (int)(sizeof(acl_inherit_map) /"", ""\t\t\t    sizeof(acl_inherit_map[0])); ++i) {"", ""\t\t\t\tif ((ace->a_flags &"", ""\t\t\t\t    acl_inherit_map[i].platform_inherit) != 0)"", ""\t\t\t\t\tae_perm |="", ""\t\t\t\t\t    acl_inherit_map[i].archive_inherit;"", ""\t\t\t}"", """", ""\t\t\tfor (i = 0; i < (int)(sizeof(acl_perm_map) /"", ""\t\t\t    sizeof(acl_perm_map[0])); ++i) {"", ""\t\t\t\tif ((ace->a_access_mask &"", ""\t\t\t\t    acl_perm_map[i].platform_perm) != 0)"", ""\t\t\t\t\tae_perm |="", ""\t\t\t\t\t    acl_perm_map[i].archive_perm;"", ""\t\t\t}"", ""\t\t} else {"", ""\t\t\taclent = &((aclent_t *)acl->acl_aclp)[e];"", ""\t\t\tif ((aclent->a_type & ACL_DEFAULT) != 0)"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;"", ""\t\t\telse"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;"", ""\t\t\tae_id = aclent->a_id;"", """", ""\t\t\tswitch(aclent->a_type) {"", ""\t\t\tcase DEF_USER:"", ""\t\t\tcase USER:"", ""\t\t\t\tae_name = archive_read_disk_uname(&a->archive,"", ""\t\t\t\t    ae_id);"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;"", ""\t\t\t\tbreak;"", ""\t\t\tcase DEF_GROUP:"", ""\t\t\tcase GROUP:"", ""\t\t\t\tae_name = archive_read_disk_gname(&a->archive,"", ""\t\t\t\t    ae_id);"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;"", ""\t\t\t\tbreak;"", ""\t\t\tcase DEF_CLASS_OBJ:"", ""\t\t\tcase CLASS_OBJ:"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_MASK;"", ""\t\t\t\tbreak;"", ""\t\t\tcase DEF_USER_OBJ:"", ""\t\t\tcase USER_OBJ:"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER_OBJ;"", ""\t\t\t\tbreak;"", ""\t\t\tcase DEF_GROUP_OBJ:"", ""\t\t\tcase GROUP_OBJ:"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;"", ""\t\t\t\tbreak;"", ""\t\t\tcase DEF_OTHER_OBJ:"", ""\t\t\tcase OTHER_OBJ:"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_OTHER;"", ""\t\t\t\tbreak;"", ""\t\t\tdefault:"", ""\t\t\t\t/* Unknown tag type, skip */"", ""\t\t\t\tcontinue;"", ""\t\t\t}"", """", ""\t\t\tif ((aclent->a_perm & 1) != 0)"", ""\t\t\t\tae_perm |= ARCHIVE_ENTRY_ACL_EXECUTE;"", ""\t\t\tif ((aclent->a_perm & 2) != 0)"", ""\t\t\t\tae_perm |= ARCHIVE_ENTRY_ACL_WRITE;"", ""\t\t\tif ((aclent->a_perm & 4) != 0)"", ""\t\t\t\tae_perm |= ARCHIVE_ENTRY_ACL_READ;"", ""\t\t} /* default_entry_acl_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4 */"", """", ""\t\tarchive_entry_acl_add_entry(entry, entry_acl_type,"", ""\t\t    ae_perm, ae_tag, ae_id, ae_name);"", ""\t}"", ""\treturn (ARCHIVE_OK);"", ""}"", ""#else\t/* !HAVE_SUN_ACL */"", ""/*"", "" * Translate POSIX.1e (Linux), FreeBSD (both POSIX.1e and NFSv4) and"", "" * MacOS (NFSv4 only) ACLs into libarchive internal structure"", "" */"", ""static int"", ""translate_acl(struct archive_read_disk *a,"", ""    struct archive_entry *entry, acl_t acl, int default_entry_acl_type)"", ""{"", ""\tacl_tag_t\t acl_tag;"", ""#ifdef ACL_TYPE_NFS4"", ""#if HAVE_ACL_TYPE_NFS4"", ""\tacl_entry_type_t acl_type;"", ""\tint brand;"", ""#endif"", ""#if HAVE_ACL_TYPE_NFS4 || HAVE_DARWIN_ACL"", ""\tacl_flagset_t\t acl_flagset;"", ""\tint brand, r;"", ""#endif"", ""\tacl_entry_t\t acl_entry;"", ""\tacl_permset_t\t acl_permset;"", ""\tint\t\t i, entry_acl_type;"", ""\tint\t\t s, ae_id, ae_tag, ae_perm;"", ""\tint\t\t r, s, ae_id, ae_tag, ae_perm;"", ""#if !HAVE_DARWIN_ACL"", ""\tvoid\t\t*q;"", ""#endif"", ""\tconst char\t*ae_name;"", """", """", ""#ifdef ACL_TYPE_NFS4"", ""#if HAVE_ACL_TYPE_NFS4"", ""\t// FreeBSD \""brands\"" ACLs as POSIX.1e or NFSv4"", ""\t// Make sure the \""brand\"" on this ACL is consistent"", ""\t// with the default_entry_acl_type bits provided."", ""\tacl_get_brand_np(acl, &brand);"", ""\tif (acl_get_brand_np(acl, &brand) != 0) {"", ""\t\tarchive_set_error(&a->archive, errno,"", ""\t\t    \""Failed to read ACL brand\"");"", ""\t\treturn (ARCHIVE_WARN);"", ""\t}"", ""\tswitch (brand) {"", ""\tcase ACL_BRAND_POSIX:"", ""\t\tswitch (default_entry_acl_type) {"", ""\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:"", ""\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:"", ""\t\t\tbreak;"", ""\t\tdefault:"", ""\t\t\t// XXX set warning message?"", ""\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Invalid ACL entry type for POSIX.1e ACL\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tbreak;"", ""\tcase ACL_BRAND_NFS4:"", ""\t\tif (default_entry_acl_type & ~ARCHIVE_ENTRY_ACL_TYPE_NFS4) {"", ""\t\t\t// XXX set warning message?"", ""\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Invalid ACL entry type for NFSv4 ACL\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tbreak;"", ""\tdefault:"", ""\t\t// XXX set warning message?"", ""\t\treturn ARCHIVE_FAILED;"", ""\t\tbreak;"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Unknown ACL brand\"");"", ""\t\treturn (ARCHIVE_WARN);"", ""\t}"", ""#endif"", """", """", ""\ts = acl_get_entry(acl, ACL_FIRST_ENTRY, &acl_entry);"", ""\twhile (s == 1) {"", ""\tif (s == -1) {"", ""\t\tarchive_set_error(&a->archive, errno,"", ""\t\t    \""Failed to get first ACL entry\"");"", ""\t\treturn (ARCHIVE_WARN);"", ""\t}"", """", ""#if HAVE_DARWIN_ACL"", ""\twhile (s == 0)"", ""#else\t/* FreeBSD, Linux */"", ""\twhile (s == 1)"", ""#endif"", ""\t{"", ""\t\tae_id = -1;"", ""\t\tae_name = NULL;"", ""\t\tae_perm = 0;"", """", ""\t\tacl_get_tag_type(acl_entry, &acl_tag);"", ""\t\tif (acl_get_tag_type(acl_entry, &acl_tag) != 0) {"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""Failed to get ACL tag type\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tswitch (acl_tag) {"", ""#if !HAVE_DARWIN_ACL\t/* FreeBSD, Linux */"", ""\t\tcase ACL_USER:"", ""\t\t\tae_id = (int)*(uid_t *)acl_get_qualifier(acl_entry);"", ""\t\t\tae_name = archive_read_disk_uname(&a->archive, ae_id);"", ""\t\t\tq = acl_get_qualifier(acl_entry);"", ""\t\t\tif (q != NULL) {"", ""\t\t\t\tae_id = (int)*(uid_t *)q;"", ""\t\t\t\tacl_free(q);"", ""\t\t\t\tae_name = archive_read_disk_uname(&a->archive,"", ""\t\t\t\t    ae_id);"", ""\t\t\t}"", ""\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;"", ""\t\t\tbreak;"", ""\t\tcase ACL_GROUP:"", ""\t\t\tae_id = (int)*(gid_t *)acl_get_qualifier(acl_entry);"", ""\t\t\tae_name = archive_read_disk_gname(&a->archive, ae_id);"", ""\t\t\tq = acl_get_qualifier(acl_entry);"", ""\t\t\tif (q != NULL) {"", ""\t\t\t\tae_id = (int)*(gid_t *)q;"", ""\t\t\t\tacl_free(q);"", ""\t\t\t\tae_name = archive_read_disk_gname(&a->archive,"", ""\t\t\t\t    ae_id);"", ""\t\t\t}"", ""\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;"", ""\t\t\tbreak;"", ""\t\tcase ACL_MASK:""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, 1, 0, 1, 1, 2, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, -1, 1, 0, 0, 1, 2, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, -1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, 1, 1, 1, 1, 1, 0, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, 1, 0, 1, 1, 1, 0, -1, 0, 0, 0, 0, -1, 1, 1, 1, 1, 0, 0, -1, -1, 1, 0, 0, 0, -1, 1, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, 2, 1, 1, 0, 0, 0, 0, -1, -1, 2, 1, 1, 0, 0, 0, -1, -1, -1, 2, 1, 1, 0, 0, 0, -1, 0, -1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, -1, 1, 2, 1, 1, 1, 0, 1, 0, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[21, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""], [41, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""], [643, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""], [656, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""], [665, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""], [674, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""], [684, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""], [701, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""]]",467,577
"[""\t\tcase ACL_OTHER:"", ""\t\t\tae_tag = ARCHIVE_ENTRY_ACL_OTHER;"", ""\t\t\tbreak;"", ""#ifdef ACL_TYPE_NFS4"", ""#if HAVE_ACL_TYPE_NFS4"", ""\t\tcase ACL_EVERYONE:"", ""\t\t\tae_tag = ARCHIVE_ENTRY_ACL_EVERYONE;"", ""\t\t\tbreak;"", ""#endif"", ""#else\t/* HAVE_DARWIN_ACL */"", ""\t\tcase ACL_EXTENDED_ALLOW:"", ""\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;"", ""\t\t\tr = translate_guid(&a->archive, acl_entry, &ae_id,"", ""\t\t\t    &ae_tag, &ae_name);"", ""\t\t\tbreak;"", ""\t\tcase ACL_EXTENDED_DENY:"", ""\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DENY;"", ""\t\t\tr = translate_guid(&a->archive, acl_entry, &ae_id,"", ""\t\t\t    &ae_tag, &ae_name);"", ""\t\t\tbreak;"", ""#endif\t/* HAVE_DARWIN_ACL */"", ""\t\tdefault:"", ""\t\t\t/* Skip types that libarchive can't support. */"", ""\t\t\ts = acl_get_entry(acl, ACL_NEXT_ENTRY, &acl_entry);"", ""\t\t\tcontinue;"", ""\t\t}"", """", ""\t\t// XXX acl type maps to allow/deny/audit/YYYY bits"", ""\t\t// XXX acl_get_entry_type_np on FreeBSD returns EINVAL for"", ""\t\t// non-NFSv4 ACLs"", ""#if HAVE_DARWIN_ACL"", ""\t\t/* Skip if translate_guid() above failed */"", ""\t\tif (r != 0) {"", ""\t\t\ts = acl_get_entry(acl, ACL_NEXT_ENTRY, &acl_entry);"", ""\t\t\tcontinue;"", ""\t\t}"", ""#endif"", """", ""#if !HAVE_DARWIN_ACL"", ""\t\t// XXX acl_type maps to allow/deny/audit/YYYY bits"", ""\t\tentry_acl_type = default_entry_acl_type;"", ""#ifdef ACL_TYPE_NFS4"", ""\t\tr = acl_get_entry_type_np(acl_entry, &acl_type);"", ""\t\tif (r == 0) {"", ""#endif"", ""#if HAVE_ACL_TYPE_NFS4 || HAVE_DARWIN_ACL"", ""\t\tif (default_entry_acl_type & ARCHIVE_ENTRY_ACL_TYPE_NFS4) {"", ""#if HAVE_ACL_TYPE_NFS4"", ""\t\t\t/*"", ""\t\t\t * acl_get_entry_type_np() fails with non-NFSv4 ACLs"", ""\t\t\t */"", ""\t\t\tif (acl_get_entry_type_np(acl_entry, &acl_type) != 0) {"", ""\t\t\t\tarchive_set_error(&a->archive, errno, \""Failed \"""", ""\t\t\t\t    \""to get ACL type from a NFSv4 ACL entry\"");"", ""\t\t\t\treturn (ARCHIVE_WARN);"", ""\t\t\t}"", ""\t\t\tswitch (acl_type) {"", ""\t\t\tcase ACL_ENTRY_TYPE_ALLOW:"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;""]","[0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, 0, 0]","[[52, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno, \""Failed \"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""]]",604,1262
"[""\t\t\tcase ACL_ENTRY_TYPE_ALARM:"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALARM;"", ""\t\t\t\tbreak;"", ""\t\t\tdefault:"", ""\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Invalid NFSv4 ACL entry type\"");"", ""\t\t\t\treturn (ARCHIVE_WARN);"", ""\t\t\t}"", ""\t\t}"", """", ""\t\t/*"", ""\t\t * Libarchive stores \""flag\"" (NFSv4 inheritance bits)"", ""\t\t * in the ae_perm bitmap."", ""\t\t */"", ""\t\tacl_get_flagset_np(acl_entry, &acl_flagset);"", ""                for (i = 0; i < (int)(sizeof(acl_inherit_map) / sizeof(acl_inherit_map[0])); ++i) {"", ""\t\t\tif (acl_get_flag_np(acl_flagset,"", ""\t\t\t\t\t    acl_inherit_map[i].platform_inherit))"", ""\t\t\t\tae_perm |= acl_inherit_map[i].archive_inherit;"", ""#endif\t/* HAVE_ACL_TYPE_NFS4 */"", """", ""                }"", ""#endif"", ""\t\t\t/*"", ""\t\t\t * Libarchive stores \""flag\"" (NFSv4 inheritance bits)"", ""\t\t\t * in the ae_perm bitmap."", ""\t\t\t *"", ""\t\t\t * acl_get_flagset_np() fails with non-NFSv4 ACLs"", ""\t\t\t */"", ""\t\t\tif (acl_get_flagset_np(acl_entry, &acl_flagset) != 0) {"", ""\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Failed to get flagset from a NFSv4 ACL entry\"");"", ""\t\t\t\treturn (ARCHIVE_WARN);"", ""\t\t\t}"", ""\t\t\tfor (i = 0; i < (int)(sizeof(acl_inherit_map) / sizeof(acl_inherit_map[0])); ++i) {"", ""\t\t\t\tr = acl_get_flag_np(acl_flagset,"", ""\t\t\t\t    acl_inherit_map[i].platform_inherit);"", ""\t\t\t\tif (r == -1) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t\t    \""Failed to check flag in a NFSv4 \"""", ""\t\t\t\t\t    \""ACL flagset\"");"", ""\t\t\t\t\treturn (ARCHIVE_WARN);"", ""\t\t\t\t} else if (r)"", ""\t\t\t\t\tae_perm |= acl_inherit_map[i].archive_inherit;"", ""\t\t\t}"", ""\t\t}"", ""#endif\t/* HAVE_ACL_TYPE_NFS4 || HAVE_DARWIN_ACL */"", """", ""\t\tacl_get_permset(acl_entry, &acl_permset);"", ""\t\tif (acl_get_permset(acl_entry, &acl_permset) != 0) {"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""Failed to get ACL permission set\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tfor (i = 0; i < (int)(sizeof(acl_perm_map) / sizeof(acl_perm_map[0])); ++i) {"", ""\t\t\t/*"", ""\t\t\t * acl_get_perm() is spelled differently on different"", ""\t\t\t * platforms; see above."", ""\t\t\t */"", ""\t\t\tif (ACL_GET_PERM(acl_permset, acl_perm_map[i].platform_perm))"", ""\t\t\tr = ACL_GET_PERM(acl_permset, acl_perm_map[i].platform_perm);"", ""\t\t\tif (r == -1) {"", ""\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Failed to check permission in an ACL permission set\"");"", ""\t\t\t\treturn (ARCHIVE_WARN);"", ""\t\t\t} else if (r)"", ""\t\t\t\tae_perm |= acl_perm_map[i].archive_perm;"", ""\t\t}"", """"]","[0, 0, 0, 1, 2, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, -1, -1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 2, 1, 1, 1, 0, 0, 0, 0, 0, -1, 1, 1, 2, 1, 1, 1, 0, 0, 0]","[[4, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""], [30, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""], [38, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""], [50, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""], [62, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""]]",635,1321
"[""\t\t\t\t\t    ae_id, ae_name);"", """", ""\t\ts = acl_get_entry(acl, ACL_NEXT_ENTRY, &acl_entry);"", ""#if !HAVE_DARWIN_ACL"", ""\t\tif (s == -1) {"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""Failed to get next ACL entry\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""#endif"", ""\t}"", ""\treturn (ARCHIVE_OK);"", ""}"", ""#else"", ""#endif\t/* !HAVE_SUN_ACL */"", ""#else\t/* !HAVE_POSIX_ACL && !HAVE_NFS4_ACL */"", ""static int"", ""setup_acls(struct archive_read_disk *a,"", ""    struct archive_entry *entry, int *fd)""]","[0, 0, 0, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, -1, 1, 1, 0, 0, 0]","[[5, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""]]",666,1377
"[""\tconst char *path;"", ""\tssize_t list_size;"", """", ""\tpath = archive_entry_sourcepath(entry);"", ""\tif (path == NULL)"", ""\t\tpath = archive_entry_pathname(entry);"", ""\tpath = NULL;"", """", ""\tif (*fd < 0 && a->tree != NULL) {"", ""\t\tif (a->follow_symlinks ||"", ""\t\t    archive_entry_filetype(entry) != AE_IFLNK)"", ""\t\t\t*fd = a->open_on_current_dir(a->tree, path,"", ""\t\t\t\tO_RDONLY | O_NONBLOCK);"", ""\t\tif (*fd < 0) {"", ""\t\t\tif (a->tree_enter_working_dir(a->tree) != 0) {"", ""\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Couldn't access %s\"", path);"", ""\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t\t}"", ""\tif (*fd < 0) {"", ""\t\tpath = archive_entry_sourcepath(entry);"", ""\t\tif (path == NULL || (a->tree != NULL &&"", ""\t\t    a->tree_enter_working_dir(a->tree) != 0))"", ""\t\t\tpath = archive_entry_pathname(entry);"", ""\t\tif (path == NULL) {"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Couldn't determine file path to read \"""", ""\t\t\t    \""extended attributes\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tif (a->tree != NULL && (a->follow_symlinks ||"", ""\t\t    archive_entry_filetype(entry) != AE_IFLNK)) {"", ""\t\t\t*fd = a->open_on_current_dir(a->tree,"", ""\t\t\t    path, O_RDONLY | O_NONBLOCK);"", ""\t\t}"", ""\t}"", """"]","[0, 0, 0, -1, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[15, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""-"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""], [25, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""]]",772,1486
"[""\tconst char *path;"", ""\tint namespace = EXTATTR_NAMESPACE_USER;"", """", ""\tpath = archive_entry_sourcepath(entry);"", ""\tif (path == NULL)"", ""\t\tpath = archive_entry_pathname(entry);"", ""\tpath = NULL;"", """", ""\tif (*fd < 0 && a->tree != NULL) {"", ""\t\tif (a->follow_symlinks ||"", ""\t\t    archive_entry_filetype(entry) != AE_IFLNK)"", ""\t\t\t*fd = a->open_on_current_dir(a->tree, path,"", ""\t\t\t\tO_RDONLY | O_NONBLOCK);"", ""\t\tif (*fd < 0) {"", ""\t\t\tif (a->tree_enter_working_dir(a->tree) != 0) {"", ""\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Couldn't access %s\"", path);"", ""\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t\t}"", ""\tif (*fd < 0) {"", ""\t\tpath = archive_entry_sourcepath(entry);"", ""\t\tif (path == NULL || (a->tree != NULL &&"", ""\t\t    a->tree_enter_working_dir(a->tree) != 0))"", ""\t\t\tpath = archive_entry_pathname(entry);"", ""\t\tif (path == NULL) {"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Couldn't determine file path to read \"""", ""\t\t\t    \""extended attributes\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tif (a->tree != NULL && (a->follow_symlinks ||"", ""\t\t    archive_entry_filetype(entry) != AE_IFLNK)) {"", ""\t\t\t*fd = a->open_on_current_dir(a->tree,"", ""\t\t\t    path, O_RDONLY | O_NONBLOCK);"", ""\t\t}"", ""\t}"", """"]","[0, 0, 0, -1, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[15, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""-"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""], [25, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_26_new.cpp""]]",932,1645
"[""\t\t}"", ""\t\tllen = len;"", ""\t\tif ((nl == 0) && (uudecode->state != ST_UUEND)) {"", ""\t\t\tif (total == 0 && ravail <= 0) {"", ""\t\t\t\t/* There is nothing more to read, fail */"", ""\t\t\t\tarchive_set_error(&self->archive->archive,"", ""\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t\t    \""Missing format data\"");"", ""\t\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t\t}"", ""\t\t\t/*"", ""\t\t\t * Save remaining data which does not contain"", ""\t\t\t * NL('\\n','\\r').""]","[0, 0, 0, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0]","[[5, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_filter_uu.c"", ""+"", ""archive_set_error(&self->archive->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_27_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_27_new.cpp""]]",510,495
"["""", ""#else"", """", ""#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC"", """", ""/*"", "" * If we have the older liblzmadec library, then we can handle"", "" * LZMA streams but not XZ streams."", "" */"", """", ""/*"", "" * Setup the callbacks."", "" */"", ""static int"", ""lzma_bidder_init(struct archive_read_filter *self)"", ""{"", ""\tstatic const size_t out_block_size = 64 * 1024;"", ""\tvoid *out_block;"", ""\tstruct private_data *state;"", ""\tssize_t ret, avail_in;"", """", ""\tself->code = ARCHIVE_FILTER_LZMA;"", ""\tself->name = \""lzma\"";"", """", ""\tstate = (struct private_data *)calloc(sizeof(*state), 1);"", ""\tout_block = (unsigned char *)malloc(out_block_size);"", ""\tif (state == NULL || out_block == NULL) {"", ""\t\tarchive_set_error(&self->archive->archive, ENOMEM,"", ""\t\t    \""Can't allocate data for lzma decompression\"");"", ""\t\tfree(out_block);"", ""\t\tfree(state);"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t}"", """", ""\tself->data = state;"", ""\tstate->out_block_size = out_block_size;"", ""\tstate->out_block = out_block;"", ""\tself->read = lzma_filter_read;"", ""\tself->skip = NULL; /* not supported */"", ""\tself->close = lzma_filter_close;"", """", ""\t/* Prime the lzma library with 18 bytes of input. */"", ""\tstate->stream.next_in = (unsigned char *)(uintptr_t)"", ""\t    __archive_read_filter_ahead(self->upstream, 18, &avail_in);"", ""\tif (state->stream.next_in == NULL)"", ""\t\treturn (ARCHIVE_FATAL);"", ""\tstate->stream.avail_in = avail_in;"", ""\tstate->stream.next_out = state->out_block;"", ""\tstate->stream.avail_out = state->out_block_size;"", """", ""\t/* Initialize compression library. */"", ""\tret = lzmadec_init(&(state->stream));"", ""\t__archive_read_filter_consume(self->upstream,"", ""\t    avail_in - state->stream.avail_in);"", ""\tif (ret == LZMADEC_OK)"", ""\t\treturn (ARCHIVE_OK);"", """", ""\t/* Library setup failed: Clean up. */"", ""\tarchive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,"", ""\t    \""Internal error initializing lzma library\"");"", """", ""\t/* Override the error message if we know what really went wrong. */"", ""\tswitch (ret) {"", ""\tcase LZMADEC_HEADER_ERROR:"", ""\t\tarchive_set_error(&self->archive->archive,"", ""\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Internal error initializing compression library: \"""", ""\t\t    \""invalid header\"");"", ""\t\tbreak;"", ""\tcase LZMADEC_MEM_ERROR:"", ""\t\tarchive_set_error(&self->archive->archive, ENOMEM,"", ""\t\t    \""Internal error initializing compression library: \"""", ""\t\t    \""out of memory\"");"", ""\t\tbreak;"", ""\t}"", """", ""\tfree(state->out_block);"", ""\tfree(state);"", ""\tself->data = NULL;"", ""\treturn (ARCHIVE_FATAL);"", ""}"", """", ""/*"", "" * Return the next block of decompressed data."", "" */"", ""static ssize_t"", ""lzma_filter_read(struct archive_read_filter *self, const void **p)"", ""{"", ""\tstruct private_data *state;"", ""\tsize_t decompressed;"", ""\tssize_t avail_in, ret;"", """", ""\tstate = (struct private_data *)self->data;"", """", ""\t/* Empty our output buffer. */"", ""\tstate->stream.next_out = state->out_block;"", ""\tstate->stream.avail_out = state->out_block_size;"", """", ""\t/* Try to fill the output buffer. */"", ""\twhile (state->stream.avail_out > 0 && !state->eof) {"", ""\t\tstate->stream.next_in = (unsigned char *)(uintptr_t)"", ""\t\t    __archive_read_filter_ahead(self->upstream, 1, &avail_in);"", ""\t\tif (state->stream.next_in == NULL && avail_in < 0) {"", ""\t\t\tarchive_set_error(&self->archive->archive,"", ""\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""truncated lzma input\"");"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t}"", ""\t\tstate->stream.avail_in = avail_in;"", """", ""\t\t/* Decompress as much as we can in one pass. */"", ""\t\tret = lzmadec_decode(&(state->stream), avail_in == 0);"", ""\t\tswitch (ret) {"", ""\t\tcase LZMADEC_STREAM_END: /* Found end of stream. */"", ""\t\t\tstate->eof = 1;"", ""\t\t\t/* FALL THROUGH */"", ""\t\tcase LZMADEC_OK: /* Decompressor made some progress. */"", ""\t\t\t__archive_read_filter_consume(self->upstream,"", ""\t\t\t    avail_in - state->stream.avail_in);"", ""\t\t\tbreak;"", ""\t\tcase LZMADEC_BUF_ERROR: /* Insufficient input data? */"", ""\t\t\tarchive_set_error(&self->archive->archive,"", ""\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Insufficient compressed data\"");"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\tdefault:"", ""\t\t\t/* Return an error. */"", ""\t\t\tarchive_set_error(&self->archive->archive,"", ""\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Lzma decompression failed\"");"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t}"", ""\t}"", """", ""\tdecompressed = state->stream.next_out - state->out_block;"", ""\tstate->total_out += decompressed;"", ""\tif (decompressed == 0)"", ""\t\t*p = NULL;"", ""\telse"", ""\t\t*p = state->out_block;"", ""\treturn (decompressed);"", ""}"", """", ""/*"", "" * Clean up the decompressor."", "" */"", ""static int"", ""lzma_filter_close(struct archive_read_filter *self)"", ""{"", ""\tstruct private_data *state;"", ""\tint ret;"", """", ""\tstate = (struct private_data *)self->data;"", ""\tret = ARCHIVE_OK;"", ""\tswitch (lzmadec_end(&(state->stream))) {"", ""\tcase LZMADEC_OK:"", ""\t\tbreak;"", ""\tdefault:"", ""\t\tarchive_set_error(&(self->archive->archive),"", ""\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Failed to clean up %s compressor\"","", ""\t\t    self->archive->archive.compression_name);"", ""\t\tret = ARCHIVE_FATAL;"", ""\t}"", """", ""\tfree(state->out_block);"", ""\tfree(state);"", ""\treturn (ret);"", ""}"", """", ""#else"", """", ""/*"", "" *"", "" * If we have no suitable library on this system, we can't actually do""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0]","[[27, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive, ENOMEM,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_28_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_28_new.cpp""], [58, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_28_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_28_new.cpp""], [64, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_28_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_28_new.cpp""], [70, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive, ENOMEM,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_28_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_28_new.cpp""], [103, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_28_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_28_new.cpp""], [121, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_28_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_28_new.cpp""], [127, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_28_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_28_new.cpp""], [158, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&(self->archive->archive),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_28_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_28_new.cpp""]]",763,744
"[""\tswitch ((int)type & ~0777777) {"", ""\tcase 01000000:"", ""\t\t/* POSIX.1e ACL */"", ""\t\tacl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;"", ""\t\tbreak;"", ""\tcase 03000000:"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Solaris NFSv4 ACLs not supported\"");"", ""\t\treturn (ARCHIVE_WARN);"", ""\t\t/* NFSv4 ACL */"", ""\t\tacl_type = ARCHIVE_ENTRY_ACL_TYPE_NFS4;"", ""\t\tbreak;"", ""\tdefault:"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Malformed Solaris ACL attribute (unsupported type %o)\"",""]","[0, 0, 0, 1, 0, 0, -2, -1, -1, 1, 1, 1, 0, 0, 0]","[[6, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""-"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_new.cpp""]]",935,989
"[""\tif (tar->entry_bytes_remaining < 0) {"", ""\t\ttar->entry_bytes_remaining = 0;"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Tar entry has negative size?\"");"", ""\t\terr = ARCHIVE_WARN;"", ""\t\t    \""Tar entry has negative size\"");"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t}"", ""\tif (tar->entry_bytes_remaining == INT64_MAX) {"", ""\t\t/* Note: tar_atol returns INT64_MAX on overflow */"", ""\t\ttar->entry_bytes_remaining = 0;"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Tar entry size overflow\"");"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t}"", ""\ttar->realsize = tar->entry_bytes_remaining;"", ""\tarchive_entry_set_size(entry, tar->entry_bytes_remaining);""]","[0, 0, 0, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 0, 0]","[[11, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_new.cpp""]]",1128,1183
"[""\treturn 0;"", ""}"", """", ""static int"", ""pax_attribute_schily_xattr(struct archive_entry *entry,"", ""\tconst char *name, const char *value, size_t value_length)"", ""{"", ""\tif (strlen(name) < 14 || (memcmp(name, \""SCHILY.xattr.\"", 13)) != 0)"", ""\t\treturn 1;"", """", ""\tname += 13;"", """", ""\tarchive_entry_xattr_add_entry(entry, name, value, value_length);"", """", ""\treturn 0;"", ""}"", """", ""static int"", ""pax_attribute_acl(struct archive_read *a, struct tar *tar,"", ""    struct archive_entry *entry, const char *value, int type)"", ""{"", ""\tint r;"", ""\tconst char* errstr;"", """", ""\tswitch (type) {"", ""\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:"", ""\t\terrstr = \""SCHILY.acl.access\"";"", ""\t\tbreak;"", ""\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:"", ""\t\terrstr = \""SCHILY.acl.default\"";"", ""\t\tbreak;"", ""\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:"", ""\t\terrstr = \""SCHILY.acl.ace\"";"", ""\t\tbreak;"", ""\tdefault:"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Unknown ACL type: %d\"", type);"", ""\t\treturn(ARCHIVE_FATAL);"", ""\t}"", """", ""\tif (tar->sconv_acl == NULL) {"", ""\t\ttar->sconv_acl ="", ""\t\t    archive_string_conversion_from_charset("", ""\t\t\t&(a->archive), \""UTF-8\"", 1);"", ""\t\tif (tar->sconv_acl == NULL)"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t}"", """", ""\tr = archive_acl_from_text_l(archive_entry_acl(entry), value, type,"", ""\t    tar->sconv_acl);"", ""\tif (r != ARCHIVE_OK) {"", ""\t\tif (r == ARCHIVE_FATAL) {"", ""\t\t\tarchive_set_error(&a->archive, ENOMEM,"", ""\t\t\t    \""%s %s\"", \""Can't allocate memory for \"","", ""\t\t\t    errstr);"", ""\t\t\treturn (r);"", ""\t\t}"", ""\t\tarchive_set_error(&a->archive,"", ""\t\t    ARCHIVE_ERRNO_MISC, \""%s %s\"", \""Parse error: \"", errstr);"", ""\t}"", ""\treturn (r);"", ""}"", """", ""/*"", "" * Parse a single key=value attribute.  key/value pointers are"", "" * assumed to point into reasonably long-lived storage.""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 0, 0]","[[35, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_new.cpp""], [52, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""+"", ""archive_set_error(&a->archive, ENOMEM,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_new.cpp""], [57, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_new.cpp""]]",1695,1768
"[""\t\t\t\t * NULL pointer to strlen().  */"", ""\tswitch (key[0]) {"", ""\tcase 'G':"", ""\t\t/* Reject GNU.sparse.* headers on non-regular files. */"", ""\t\tif (strncmp(key, \""GNU.sparse\"", 10) == 0 &&"", ""\t\t    !tar->sparse_allowed) {"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Non-regular file cannot be sparse\"");"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t}"", """", ""\t\t/* GNU \""0.0\"" sparse pax format. */"", ""\t\tif (strcmp(key, \""GNU.sparse.numblocks\"") == 0) {"", ""\t\t\ttar->sparse_offset = -1;""]","[0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0]","[[6, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_new.cpp""]]",1721,1854
"[""\tcase 'S':"", ""\t\t/* We support some keys used by the \""star\"" archiver */"", ""\t\tif (strcmp(key, \""SCHILY.acl.access\"") == 0) {"", ""\t\t\tif (tar->sconv_acl == NULL) {"", ""\t\t\t\ttar->sconv_acl ="", ""\t\t\t\t    archive_string_conversion_from_charset("", ""\t\t\t\t\t&(a->archive), \""UTF-8\"", 1);"", ""\t\t\t\tif (tar->sconv_acl == NULL)"", ""\t\t\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t\t}"", """", ""\t\t\tr = archive_acl_parse_l(archive_entry_acl(entry),"", ""\t\t\t    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,"", ""\t\t\t    tar->sconv_acl);"", ""\t\t\tif (r != ARCHIVE_OK) {"", ""\t\t\t\terr = r;"", ""\t\t\t\tif (err == ARCHIVE_FATAL) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, ENOMEM,"", ""\t\t\t\t\t    \""Can't allocate memory for \"""", ""\t\t\t\t\t    \""SCHILY.acl.access\"");"", ""\t\t\t\t\treturn (err);"", ""\t\t\t\t}"", ""\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t\t    \""Parse error: SCHILY.acl.access\"");"", ""\t\t\t}"", ""\t\t\tr = pax_attribute_acl(a, tar, entry, value,"", ""\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);"", ""\t\t\tif (r == ARCHIVE_FATAL)"", ""\t\t\t\treturn (r);"", ""\t\t} else if (strcmp(key, \""SCHILY.acl.default\"") == 0) {"", ""\t\t\tif (tar->sconv_acl == NULL) {"", ""\t\t\t\ttar->sconv_acl ="", ""\t\t\t\t    archive_string_conversion_from_charset("", ""\t\t\t\t\t&(a->archive), \""UTF-8\"", 1);"", ""\t\t\t\tif (tar->sconv_acl == NULL)"", ""\t\t\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t\t}"", """", ""\t\t\tr = archive_acl_parse_l(archive_entry_acl(entry),"", ""\t\t\t    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,"", ""\t\t\t    tar->sconv_acl);"", ""\t\t\tif (r != ARCHIVE_OK) {"", ""\t\t\t\terr = r;"", ""\t\t\t\tif (err == ARCHIVE_FATAL) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, ENOMEM,"", ""\t\t\t\t\t    \""Can't allocate memory for \"""", ""\t\t\t\t\t    \""SCHILY.acl.default\"");"", ""\t\t\t\t\treturn (err);"", ""\t\t\t\t}"", ""\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t\t    \""Parse error: SCHILY.acl.default\"");"", ""\t\t\t}"", ""\t\t\tr = pax_attribute_acl(a, tar, entry, value,"", ""\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);"", ""\t\t\tif (r == ARCHIVE_FATAL)"", ""\t\t\t\treturn (r);"", ""\t\t} else if (strcmp(key, \""SCHILY.acl.ace\"") == 0) {"", ""\t\t\tr = pax_attribute_acl(a, tar, entry, value,"", ""\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4);"", ""\t\t\tif (r == ARCHIVE_FATAL)"", ""\t\t\t\treturn (r);"", ""\t\t} else if (strcmp(key, \""SCHILY.devmajor\"") == 0) {"", ""\t\t\tarchive_entry_set_rdevmajor(entry,"", ""\t\t\t    (dev_t)tar_atol10(value, strlen(value)));""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[17, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""-"", ""archive_set_error(&a->archive, ENOMEM,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_new.cpp""], [22, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""-"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_new.cpp""], [45, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""-"", ""archive_set_error(&a->archive, ENOMEM,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_new.cpp""], [50, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""-"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_29_new.cpp""]]",1803,1944
"[""\t\t\t&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t\""Bad record header\"");"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {"", ""\t\t/* nawww, I wish they promised backward compatibility"", ""\t\t * anyhoo, in their infinite wisdom the 28500 guys might"", ""\t\t * come up with something we can't possibly handle so"", ""\t\t * best end things here */"", ""\t}"", ""\tver = _warc_rdver(buf, eoh - buf);"", ""\t/* we currently support WARC 0.12 to 1.0 */"", ""\tif (ver == 0U) {"", ""\t\tarchive_set_error("", ""\t\t\t&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t\""Unsupported record version\"");"", ""\t\t\t\""Invalid record version\"");"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {"", ""\t} else if (ver < 1200U || ver > 10000U) {"", ""\t\tarchive_set_error("", ""\t\t\t&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t\""Unsupported record version: %u.%u\"","", ""\t\t\tver / 10000, (ver % 10000) / 100);"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t}"", ""\tcntlen = _warc_rdlen(buf, eoh - buf);"", ""\tif (cntlen < 0) {"", ""\t\t/* nightmare!  the specs say content-length is mandatory"", ""\t\t * so I don't feel overly bad stopping the reader here */"", ""\t\tarchive_set_error("", ""\t\t\t&a->archive, EINVAL,"", ""\t\t\t\""Bad content length\"");"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {"", ""\t}"", ""\trtime = _warc_rdrtm(buf, eoh - buf);"", ""\tif (rtime == (time_t)-1) {"", ""\t\t/* record time is mandatory as per WARC/1.0,"", ""\t\t * so just barf here, fast and loud */"", ""\t\tarchive_set_error(""]","[0, 0, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 0, 0, -1, 1, 0, -1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 1, 1, 0, 0, 0]","[[19, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c"", ""+"", ""archive_set_error("", 0, ""/data/download/CMake/CMake/Kitware_CMake_30_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_30_new.cpp""]]",255,254
"[""\t\txar->lzstream.total_in = 0;"", ""\t\txar->lzstream.total_out = 0;"", ""\t\tbreak;"", ""#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)"", ""\tcase LZMA:"", ""\t\tif (xar->lzstream_valid)"", ""\t\t\tlzmadec_end(&(xar->lzstream));"", ""\t\tr = lzmadec_init(&(xar->lzstream));"", ""\t\tif (r != LZMADEC_OK) {"", ""\t\t\tswitch (r) {"", ""\t\t\tcase LZMADEC_HEADER_ERROR:"", ""\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t\t    \""Internal error initializing \"""", ""\t\t\t\t    \""compression library: \"""", ""\t\t\t\t    \""invalid header\"");"", ""\t\t\t\tbreak;"", ""\t\t\tcase LZMADEC_MEM_ERROR:"", ""\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t    ENOMEM,"", ""\t\t\t\t    \""Internal error initializing \"""", ""\t\t\t\t    \""compression library: \"""", ""\t\t\t\t    \""out of memory\"");"", ""\t\t\t\tbreak;"", ""\t\t\t}"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t}"", ""\t\txar->lzstream_valid = 1;"", ""\t\txar->lzstream.total_in = 0;"", ""\t\txar->lzstream.total_out = 0;"", ""\t\tbreak;"", ""#endif"", ""\t/*"", ""\t * Unsupported compression.""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0]","[[11, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c"", ""-"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_31_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_31_new.cpp""], [18, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c"", ""-"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_31_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_31_new.cpp""]]",1526,1524
"[""\t\t*used = avail_in - xar->lzstream.avail_in;"", ""\t\t*outbytes = avail_out - xar->lzstream.avail_out;"", ""\t\tbreak;"", ""#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)"", ""\tcase LZMA:"", ""\t\txar->lzstream.next_in = (unsigned char *)(uintptr_t)b;"", ""\t\txar->lzstream.avail_in = avail_in;"", ""\t\txar->lzstream.next_out = (unsigned char *)outbuff;"", ""\t\txar->lzstream.avail_out = avail_out;"", ""\t\tr = lzmadec_decode(&(xar->lzstream), 0);"", ""\t\tswitch (r) {"", ""\t\tcase LZMADEC_STREAM_END: /* Found end of stream. */"", ""\t\t\tswitch (lzmadec_end(&(xar->lzstream))) {"", ""\t\t\tcase LZMADEC_OK:"", ""\t\t\t\tbreak;"", ""\t\t\tdefault:"", ""\t\t\t\tarchive_set_error(&(a->archive),"", ""\t\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t\t    \""Failed to clean up lzmadec decompressor\"");"", ""\t\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t\t}"", ""\t\t\txar->lzstream_valid = 0;"", ""\t\t\t/* FALLTHROUGH */"", ""\t\tcase LZMADEC_OK: /* Decompressor made some progress. */"", ""\t\t\tbreak;"", ""\t\tdefault:"", ""\t\t\tarchive_set_error(&(a->archive),"", ""\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""lzmadec decompression failed(%d)\"","", ""\t\t\t    r);"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t}"", ""\t\t*used = avail_in - xar->lzstream.avail_in;"", ""\t\t*outbytes = avail_out - xar->lzstream.avail_out;"", ""\t\tbreak;"", ""#endif"", ""#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)"", ""\tcase BZIP2:"", ""#endif"", ""#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)"", ""#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)"", ""\tcase LZMA:"", ""#endif"", ""\tcase XZ:"", ""#endif"", ""\tcase NONE:""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0]","[[16, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c"", ""-"", ""archive_set_error(&(a->archive),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_31_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_31_new.cpp""], [26, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c"", ""-"", ""archive_set_error(&(a->archive),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_31_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_31_new.cpp""]]",1685,1653
"["" *\tid1+size1+data1 + id2+size2+data2 ..."", "" *  triplets.  id and size are 2 bytes each."", "" */"", ""static void"", ""process_extra(const char *p, size_t extra_length, struct zip_entry* zip_entry)"", ""static int"", ""process_extra(struct archive_read *a, const char *p, size_t extra_length, struct zip_entry* zip_entry)"", ""{"", ""\tunsigned offset = 0;"", """", ""\twhile (offset < extra_length - 4) {"", ""\tif (extra_length == 0) {"", ""\t\treturn ARCHIVE_OK;"", ""\t}"", """", ""\tif (extra_length < 4) {"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t    \""Too-small extra data: Need at least 4 bytes, but only found %d bytes\"", (int)extra_length);"", ""\t\treturn ARCHIVE_FAILED;"", ""\t}"", ""\twhile (offset <= extra_length - 4) {"", ""\t\tunsigned short headerid = archive_le16dec(p + offset);"", ""\t\tunsigned short datasize = archive_le16dec(p + offset + 2);"", """", ""\t\toffset += 4;"", ""\t\tif (offset + datasize > extra_length) {"", ""\t\t\tbreak;"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t    \""Extra data overflow: Need %d bytes but only found %d bytes\"","", ""\t\t\t    (int)datasize, (int)(extra_length - offset));"", ""\t\t\treturn ARCHIVE_FAILED;"", ""\t\t}"", ""#ifdef DEBUG"", ""\t\tfprintf(stderr, \""Header id 0x%04x, length %d\\n\"",""]","[0, 0, 0, -1, -1, 1, 1, 0, 0, 0, -1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, 2, 1, 1, 1, 0, 0, 0]","[[16, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_32_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_32_new.cpp""], [27, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_32_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_32_new.cpp""]]",418,418
"[""\t\t\t/* Zip64 extended information extra field. */"", ""\t\t\tzip_entry->flags |= LA_USED_ZIP64;"", ""\t\t\tif (zip_entry->uncompressed_size == 0xffffffff) {"", ""\t\t\t\tif (datasize < 8)"", ""\t\t\t\t\tbreak;"", ""\t\t\t\tzip_entry->uncompressed_size ="", ""\t\t\t\t    archive_le64dec(p + offset);"", ""\t\t\t\tuint64_t t = 0;"", ""\t\t\t\tif (datasize < 8"", ""\t\t\t\t    || (t = archive_le64dec(p + offset)) > INT64_MAX) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t\t\t    \""Malformed 64-bit uncompressed size\"");"", ""\t\t\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\t\t}"", ""\t\t\t\tzip_entry->uncompressed_size = t;"", ""\t\t\t\toffset += 8;"", ""\t\t\t\tdatasize -= 8;"", ""\t\t\t}"", ""\t\t\tif (zip_entry->compressed_size == 0xffffffff) {"", ""\t\t\t\tif (datasize < 8)"", ""\t\t\t\t\tbreak;"", ""\t\t\t\tzip_entry->compressed_size ="", ""\t\t\t\t    archive_le64dec(p + offset);"", ""\t\t\t\tuint64_t t = 0;"", ""\t\t\t\tif (datasize < 8"", ""\t\t\t\t    || (t = archive_le64dec(p + offset)) > INT64_MAX) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t\t\t    \""Malformed 64-bit compressed size\"");"", ""\t\t\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\t\t}"", ""\t\t\t\tzip_entry->compressed_size = t;"", ""\t\t\t\toffset += 8;"", ""\t\t\t\tdatasize -= 8;"", ""\t\t\t}"", ""\t\t\tif (zip_entry->local_header_offset == 0xffffffff) {"", ""\t\t\t\tif (datasize < 8)"", ""\t\t\t\t\tbreak;"", ""\t\t\t\tzip_entry->local_header_offset ="", ""\t\t\t\t    archive_le64dec(p + offset);"", ""\t\t\t\tuint64_t t = 0;"", ""\t\t\t\tif (datasize < 8"", ""\t\t\t\t    || (t = archive_le64dec(p + offset)) > INT64_MAX) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t\t\t    \""Malformed 64-bit local header offset\"");"", ""\t\t\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\t\t}"", ""\t\t\t\tzip_entry->local_header_offset = t;"", ""\t\t\t\toffset += 8;"", ""\t\t\t\tdatasize -= 8;"", ""\t\t\t}""]","[0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0]","[[10, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_32_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_32_new.cpp""], [26, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_32_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_32_new.cpp""], [42, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_32_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_32_new.cpp""]]",440,452
"[""\t\t}"", ""\t\toffset += datasize;"", ""\t}"", ""#ifdef DEBUG"", ""\tif (offset != extra_length)"", ""\t{"", ""\t\tfprintf(stderr,"", ""\t\t    \""Extra data field contents do not match reported size!\\n\"");"", ""\tif (offset != extra_length) {"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t    \""Malformed extra data: Consumed %d bytes of %d bytes\"","", ""\t\t    (int)offset, (int)extra_length);"", ""\t\treturn ARCHIVE_FAILED;"", ""\t}"", ""#endif"", ""\treturn ARCHIVE_OK;"", ""}"", """", ""/*""]","[0, 0, 0, -1, -1, -1, -2, -1, 1, 2, 1, 1, 1, 0, -1, 1, 0, 0, 0]","[[6, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c"", ""-"", ""fprintf(stderr,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_32_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_32_new.cpp""], [9, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_32_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_32_new.cpp""]]",715,739
"[""\t\t\t|| (zip->hctx_valid"", ""\t\t\t && zip->entry->aes_extra.vendor == AES_VENDOR_AE_2))) {"", ""\t\t\tif (zip->entry->flags & LA_USED_ZIP64) {"", ""\t\t\t\tuint64_t compressed, uncompressed;"", ""\t\t\t\tzip->entry->crc32 = archive_le32dec(p + 4);"", ""\t\t\t\tzip->entry->compressed_size ="", ""\t\t\t\t\tarchive_le64dec(p + 8);"", ""\t\t\t\tzip->entry->uncompressed_size ="", ""\t\t\t\t\tarchive_le64dec(p + 16);"", ""\t\t\t\tcompressed = archive_le64dec(p + 8);"", ""\t\t\t\tuncompressed = archive_le64dec(p + 16);"", ""\t\t\t\tif (compressed > INT64_MAX || uncompressed > INT64_MAX) {"", ""\t\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t\t\t    \""Overflow of 64-bit file sizes\"");"", ""\t\t\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\t\t}"", ""\t\t\t\tzip->entry->compressed_size = compressed;"", ""\t\t\t\tzip->entry->uncompressed_size = uncompressed;"", ""\t\t\t\tzip->unconsumed = 24;"", ""\t\t\t} else {"", ""\t\t\t\tzip->entry->crc32 = archive_le32dec(p + 4);""]","[0, 0, 0, 1, 0, -1, -1, -1, -1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[12, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_32_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_32_new.cpp""]]",1136,1168
"[""\t\t\tzip->unconsumed = 4;"", ""\t\t}"", ""\t\tif (zip->entry->flags & LA_USED_ZIP64) {"", ""\t\t\tuint64_t compressed, uncompressed;"", ""\t\t\tzip->entry->crc32 = archive_le32dec(p);"", ""\t\t\tzip->entry->compressed_size = archive_le64dec(p + 4);"", ""\t\t\tzip->entry->uncompressed_size = archive_le64dec(p + 12);"", ""\t\t\tcompressed = archive_le64dec(p + 4);"", ""\t\t\tuncompressed = archive_le64dec(p + 12);"", ""\t\t\tif (compressed > INT64_MAX || uncompressed > INT64_MAX) {"", ""\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t\t    \""Overflow of 64-bit file sizes\"");"", ""\t\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\t}"", ""\t\t\tzip->entry->compressed_size = compressed;"", ""\t\t\tzip->entry->uncompressed_size = uncompressed;"", ""\t\t\tzip->unconsumed += 20;"", ""\t\t} else {"", ""\t\t\tzip->entry->crc32 = archive_le32dec(p);""]","[0, 0, 0, 1, 0, -1, -1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[10, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_32_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_32_new.cpp""]]",1417,1456
"[""\tentries = archive_acl_reset(abstract_acl, ae_requested_type);"", ""\tif (entries == 0)"", ""\t\treturn (ARCHIVE_OK);"", """", ""#if HAVE_SUN_ACL"", ""\tacl = NULL;"", ""\tacl = malloc(sizeof(acl_t));"", ""\tif (acl == NULL) {"", ""\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,"", ""\t\t\t\""Invalid ACL type\"");"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t}"", ""\tif (acl_type == ACE_T)"", ""\t\tacl->acl_entry_size = sizeof(ace_t);"", ""\telse if (acl_type == ACLENT_T)"", ""\t\tacl->acl_entry_size = sizeof(aclent_t);"", ""\telse {"", ""\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,"", ""\t\t\t\""Invalid ACL type\"");"", ""\t\tacl_free(acl);"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t}"", ""\tacl->acl_type = acl_type;"", ""\tacl->acl_cnt = entries;"", """", ""\tacl->acl_aclp = malloc(entries * acl->acl_entry_size);"", ""\tif (acl->acl_aclp == NULL) {"", ""\t\tarchive_set_error(a, errno,"", ""\t\t    \""Can't allocate memory for acl buffer\"");"", ""\t\tacl_free(acl);"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t}"", ""#else\t/* !HAVE_SUN_ACL */"", ""\tacl = acl_init(entries);"", ""\tif (acl == (acl_t)NULL) {"", ""\t\tarchive_set_error(a, errno,"", ""\t\t    \""Failed to initialize ACL working storage\"");"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t}"", ""#endif\t/* !HAVE_SUN_ACL */"", ""#if HAVE_SUN_ACL"", ""\te = 0;"", ""#endif"", ""\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,"", ""\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {"", ""\t\tacl_create_entry(&acl, &acl_entry);"", """", ""#if HAVE_SUN_ACL"", ""\t\tace = NULL;"", ""\t\taclent = NULL;"", ""\t\tif (acl->acl_type == ACE_T)  {"", ""\t\t\tace = &((ace_t *)acl->acl_aclp)[e];"", ""\t\t\tace->a_who = -1;"", ""\t\t\tace->a_access_mask = 0;"", ""\t\t\tace->a_flags = 0;"", ""\t\t} else {"", ""\t\t\taclent = &((aclent_t *)acl->acl_aclp)[e];"", ""\t\t\taclent->a_id = -1;"", ""\t\t\taclent->a_type = 0;"", ""\t\t\taclent->a_perm = 0;"", ""\t\t}"", ""#else\t/* !HAVE_SUN_ACL  */"", ""#if HAVE_DARWIN_ACL"", ""\t\t/*"", ""\t\t * Mac OS doesn't support NFSv4 ACLs for"", ""\t\t * owner@, group@ and everyone@."", ""\t\t * We skip any of these ACLs found."", ""\t\t */"", ""\t\tif (ae_tag == ARCHIVE_ENTRY_ACL_USER_OBJ ||"", ""\t\t    ae_tag == ARCHIVE_ENTRY_ACL_GROUP_OBJ ||"", ""\t\t    ae_tag == ARCHIVE_ENTRY_ACL_EVERYONE)"", ""\t\t\tcontinue;"", ""#endif"", ""\t\tif (acl_create_entry(&acl, &acl_entry) != 0) {"", ""\t\t\tarchive_set_error(a, errno,"", ""\t\t\t    \""Failed to create a new ACL entry\"");"", ""\t\t\tret = ARCHIVE_FAILED;"", ""\t\t\tgoto exit_free;"", ""\t\t}"", ""#endif\t/* !HAVE_SUN_ACL */"", ""#if HAVE_DARWIN_ACL"", ""\t\tswitch (ae_type) {"", ""\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALLOW:"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_EXTENDED_ALLOW);"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DENY:"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_EXTENDED_DENY);"", ""\t\t\tbreak;"", ""\t\tdefault:"", ""\t\t\t/* We don't support any other types on MacOS */"", ""\t\t\tcontinue;"", ""\t\t}"", ""#endif"", ""\t\tswitch (ae_tag) {"", ""#if HAVE_SUN_ACL"", ""\t\tcase ARCHIVE_ENTRY_ACL_USER:"", ""\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);"", ""\t\t\tif (acl->acl_type == ACE_T)"", ""\t\t\t\tace->a_who = ae_uid;"", ""\t\t\telse {"", ""\t\t\t\taclent->a_id = ae_uid;"", ""\t\t\t\taclent->a_type |= USER;"", ""\t\t\t}"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_GROUP:"", ""\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);"", ""\t\t\tif (acl->acl_type == ACE_T) {"", ""\t\t\t\tace->a_who = ae_gid;"", ""\t\t\t\tace->a_flags |= ACE_IDENTIFIER_GROUP;"", ""\t\t\t} else {"", ""\t\t\t\taclent->a_id = ae_gid;"", ""\t\t\t\taclent->a_type |= GROUP;"", ""\t\t\t}"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:"", ""\t\t\tif (acl->acl_type == ACE_T)"", ""\t\t\t\tace->a_flags |= ACE_OWNER;"", ""\t\t\telse"", ""\t\t\t\taclent->a_type |= USER_OBJ;"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:"", ""\t\t\tif (acl->acl_type == ACE_T) {"", ""\t\t\t\tace->a_flags |= ACE_GROUP;"", ""\t\t\t\tace->a_flags |= ACE_IDENTIFIER_GROUP;"", ""\t\t\t} else"", ""\t\t\t\taclent->a_type |= GROUP_OBJ;"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_MASK:"", ""\t\t\taclent->a_type |= CLASS_OBJ;"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_OTHER:"", ""\t\t\taclent->a_type |= OTHER_OBJ;"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_EVERYONE:"", ""\t\t\tace->a_flags |= ACE_EVERYONE;"", ""\t\t\tbreak;"", ""#else\t/* !HAVE_SUN_ACL */"", ""\t\tcase ARCHIVE_ENTRY_ACL_USER:"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_USER);"", ""\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);"", ""#if !HAVE_DARWIN_ACL\t/* FreeBSD, Linux */"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_USER);"", ""\t\t\tacl_set_qualifier(acl_entry, &ae_uid);"", ""#else\t/* MacOS */"", ""\t\t\tif (mbr_identifier_to_uuid(ID_TYPE_UID, &ae_uid,"", ""\t\t\t    sizeof(uid_t), ae_uuid) != 0)"", ""\t\t\t\tcontinue;"", ""\t\t\tif (acl_set_qualifier(acl_entry, &ae_uuid) != 0)"", ""\t\t\t\tcontinue;"", ""#endif\t/* HAVE_DARWIN_ACL */"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_GROUP:"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP);"", ""\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);"", ""#if !HAVE_DARWIN_ACL\t/* FreeBSD, Linux */"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP);"", ""\t\t\tacl_set_qualifier(acl_entry, &ae_gid);"", ""#else\t/* MacOS */"", ""\t\t\tif (mbr_identifier_to_uuid(ID_TYPE_GID, &ae_gid,"", ""\t\t\t    sizeof(gid_t), ae_uuid) != 0)"", ""\t\t\t\tcontinue;"", ""\t\t\tif (acl_set_qualifier(acl_entry, &ae_uuid) != 0)"", ""\t\t\t\tcontinue;"", ""#endif\t/* HAVE_DARWIN_ACL */"", ""\t\t\tbreak;"", ""#if !HAVE_DARWIN_ACL\t/* FreeBSD, Linux */"", ""\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_USER_OBJ);"", ""\t\t\tbreak;""]","[0, 0, 0, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0]","[[8, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_acl.c"", ""+"", ""archive_set_error(a, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_33_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_33_new.cpp""], [17, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_acl.c"", ""+"", ""archive_set_error(a, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_33_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_33_new.cpp""], [27, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_acl.c"", ""+"", ""archive_set_error(a, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_33_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_33_new.cpp""], [35, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_acl.c"", ""+"", ""archive_set_error(a, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_33_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_33_new.cpp""], [74, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_acl.c"", ""+"", ""archive_set_error(a, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_33_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_33_new.cpp""]]",151,254
"["""", ""#define HFS_BLOCKS(s)\t((s) >> 12)"", """", ""static void\tfsobj_error(int *, struct archive_string *, int, const char *,"", ""\t\t    const char *);"", ""static int\tcheck_symlinks_fsobj(char *, int *, struct archive_string *,"", ""\t\t    int);"", ""static int\tcheck_symlinks(struct archive_write_disk *);"", ""static int\tcreate_filesystem_object(struct archive_write_disk *);"", ""static struct fixup_entry *current_fixup(struct archive_write_disk *, const char *pathname);"", ""static struct fixup_entry *current_fixup(struct archive_write_disk *,"", ""\t\t    const char *pathname);"", ""#if defined(HAVE_FCHDIR) && defined(PATH_MAX)"", ""static void\tedit_deep_directories(struct archive_write_disk *ad);"", ""#endif"", ""static int\tcleanup_pathname_fsobj(char *, int *, struct archive_string *,"", ""\t\t    int);"", ""static int\tcleanup_pathname(struct archive_write_disk *);"", ""static int\tcreate_dir(struct archive_write_disk *, char *);"", ""static int\tcreate_parent_dir(struct archive_write_disk *, char *);""]","[0, 0, 0, 2, 1, 1, 1, 0, 0, -1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0]","[[3, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""static void\tfsobj_error(int *, struct archive_string *, int, const char *,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""]]",326,348
"[""\tif (a->restore_pwd >= 0) {"", ""\t\tr = fchdir(a->restore_pwd);"", ""\t\tif (r != 0) {"", ""\t\t\tarchive_set_error(&a->archive, errno, \""chdir() failure\"");"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""chdir() failure\"");"", ""\t\t\tret = ARCHIVE_FATAL;"", ""\t\t}"", ""\t\tclose(a->restore_pwd);""]","[0, 0, 0, -2, 2, 1, 0, 0, 0]","[[3, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, errno, \""chdir() failure\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [4, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""]]",637,669
"["""", ""\tif (en) {"", ""\t\t/* Everything failed; give up here. */"", ""\t\tarchive_set_error(&a->archive, en, \""Can't create '%s'\"","", ""\t\t    a->name);"", ""\t\tif ((&a->archive)->error == NULL)"", ""\t\t\tarchive_set_error(&a->archive, en, \""Can't create '%s'\"","", ""\t\t\t    a->name);"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t}"", """"]","[0, 0, 0, -2, -1, 1, 2, 1, 0, 0, 0]","[[3, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, en, \""Can't create '%s'\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [6, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, en, \""Can't create '%s'\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""]]",1993,2043
"[""#if !HAVE_LINK"", ""\t\treturn (EPERM);"", ""#else"", ""\t\tarchive_string_init(&error_string);"", ""\t\tlinkname_copy = strdup(linkname);"", ""\t\tif (linkname_copy == NULL) {"", ""\t\t    return (EPERM);"", ""\t\t}"", ""\t\t/*"", ""\t\t * TODO: consider using the cleaned-up path as the link"", ""\t\t * target?"", ""\t\t */"", ""\t\tr = cleanup_pathname_fsobj(linkname_copy, &error_number,"", ""\t\t    &error_string, a->flags);"", ""\t\tif (r != ARCHIVE_OK) {"", ""\t\t\tarchive_set_error(&a->archive, error_number, \""%s\"","", ""\t\t\t    error_string.s);"", ""\t\t\tfree(linkname_copy);"", ""\t\t\tarchive_string_free(&error_string);"", ""\t\t\t/*"", ""\t\t\t * EPERM is more appropriate than error_number for our"", ""\t\t\t * callers"", ""\t\t\t */"", ""\t\t\treturn (EPERM);"", ""\t\t}"", ""\t\tr = check_symlinks_fsobj(linkname_copy, &error_number,"", ""\t\t    &error_string, a->flags);"", ""\t\tif (r != ARCHIVE_OK) {"", ""\t\t\tarchive_set_error(&a->archive, error_number, \""%s\"","", ""\t\t\t    error_string.s);"", ""\t\t\tfree(linkname_copy);"", ""\t\t\tarchive_string_free(&error_string);"", ""\t\t\t/*"", ""\t\t\t * EPERM is more appropriate than error_number for our"", ""\t\t\t * callers"", ""\t\t\t */"", ""\t\t\treturn (EPERM);"", ""\t\t}"", ""\t\tfree(linkname_copy);"", ""\t\tarchive_string_free(&error_string);"", ""\t\tr = link(linkname, a->name) ? errno : 0;"", ""\t\t/*"", ""\t\t * New cpio and pax formats allow hardlink entries""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[15, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, error_number, \""%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [28, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, error_number, \""%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""]]",2022,2078
"[""\treturn (a->current_fixup);"", ""}"", """", ""/* TODO: Make this work. */"", ""/*"", "" * TODO: The deep-directory support bypasses this; disable deep directory"", "" * support if we're doing symlink checks."", "" */"", ""/* Error helper for new *_fsobj functions */"", ""static void"", ""fsobj_error(int *a_eno, struct archive_string *a_estr,"", ""    int err, const char *errstr, const char *path)"", ""{"", ""\tif (a_eno)"", ""\t\t*a_eno = err;"", ""\tif (a_estr)"", ""\t\tarchive_string_sprintf(a_estr, errstr, path);"", ""}"", """", ""/*"", "" * TODO: Someday, integrate this with the deep dir support; they both"", "" * scan the path and both can be optimized by comparing against other"", "" * recent paths."", "" */"", ""/* TODO: Extend this to support symlinks on Windows Vista and later. */"", """", ""/*"", "" * Checks the given path to see if any elements along it are symlinks.  Returns"", "" * ARCHIVE_OK if there are none, otherwise puts an error in errmsg."", "" */"", ""static int"", ""check_symlinks(struct archive_write_disk *a)"", ""check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,"", ""    int flags)"", ""{"", ""#if !defined(HAVE_LSTAT)"", ""\t/* Platform doesn't have lstat, so we can't look for symlinks. */"", ""\t(void)a; /* UNUSED */"", ""\t(void)path; /* UNUSED */"", ""\t(void)error_number; /* UNUSED */"", ""\t(void)error_string; /* UNUSED */"", ""\t(void)flags; /* UNUSED */"", ""\treturn (ARCHIVE_OK);"", ""#else"", ""\tchar *pn;"", ""\tint res = ARCHIVE_OK;"", ""\tchar *tail;"", ""\tchar *head;"", ""\tint last;"", ""\tchar c;"", ""\tint r;"", ""\tstruct stat st;"", ""\tint restore_pwd;"", """", ""\t/* Nothing to do here if name is empty */"", ""\tif(path[0] == '\\0')"", ""\t    return (ARCHIVE_OK);"", """", ""\t/*"", ""\t * Guard against symlink tricks.  Reject any archive entry whose"", ""\t * destination would be altered by a symlink."", ""\t *"", ""\t * Walk the filename in chunks separated by '/'.  For each segment:"", ""\t *  - if it doesn't exist, continue"", ""\t *  - if it's symlink, abort or remove it"", ""\t *  - if it's a directory and it's not the last chunk, cd into it"", ""\t * As we go:"", ""\t *  head points to the current (relative) path"", ""\t *  tail points to the temporary \\0 terminating the segment we're"", ""\t *      currently examining"", ""\t *  c holds what used to be in *tail"", ""\t *  last is 1 if this is the last tail"", ""\t */"", ""\t/* Whatever we checked last time doesn't need to be re-checked. */"", ""\tpn = a->name;"", ""\tif (archive_strlen(&(a->path_safe)) > 0) {"", ""\t\tchar *p = a->path_safe.s;"", ""\t\twhile ((*pn != '\\0') && (*p == *pn))"", ""\t\t\t++p, ++pn;"", ""\t}"", ""\trestore_pwd = open(\"".\"", O_RDONLY | O_BINARY | O_CLOEXEC);"", ""\t__archive_ensure_cloexec_flag(restore_pwd);"", ""\tif (restore_pwd < 0)"", ""\t\treturn (ARCHIVE_FATAL);"", ""\thead = path;"", ""\ttail = path;"", ""\tlast = 0;"", ""\t/* TODO: reintroduce a safe cache here? */"", ""\t/* Skip the root directory if the path is absolute. */"", ""\tif(pn == a->name && pn[0] == '/')"", ""\t\t++pn;"", ""\tc = pn[0];"", ""\t/* Keep going until we've checked the entire name. */"", ""\twhile (pn[0] != '\\0' && (pn[0] != '/' || pn[1] != '\\0')) {"", ""\tif(tail == path && tail[0] == '/')"", ""\t\t++tail;"", ""\t/* Keep going until we've checked the entire name."", ""\t * head, tail, path all alias the same string, which is"", ""\t * temporarily zeroed at tail, so be careful restoring the"", ""\t * stashed (c=tail[0]) for error messages."", ""\t * Exiting the loop with break is okay; continue is not."", ""\t */"", ""\twhile (!last) {"", ""\t\t/*"", ""\t\t * Skip the separator we just consumed, plus any adjacent ones"", ""\t\t */"", ""\t\twhile (*tail == '/')"", ""\t\t    ++tail;"", ""\t\t/* Skip the next path element. */"", ""\t\twhile (*pn != '\\0' && *pn != '/')"", ""\t\t\t++pn;"", ""\t\tc = pn[0];"", ""\t\tpn[0] = '\\0';"", ""\t\twhile (*tail != '\\0' && *tail != '/')"", ""\t\t\t++tail;"", ""\t\t/* is this the last path component? */"", ""\t\tlast = (tail[0] == '\\0') || (tail[0] == '/' && tail[1] == '\\0');"", ""\t\t/* temporarily truncate the string here */"", ""\t\tc = tail[0];"", ""\t\ttail[0] = '\\0';"", ""\t\t/* Check that we haven't hit a symlink. */"", ""\t\tr = lstat(a->name, &st);"", ""\t\tr = lstat(head, &st);"", ""\t\tif (r != 0) {"", ""\t\t\ttail[0] = c;"", ""\t\t\t/* We've hit a dir that doesn't exist; stop now. */"", ""\t\t\tif (errno == ENOENT)"", ""\t\t\tif (errno == ENOENT) {"", ""\t\t\t\tbreak;"", ""\t\t\t} else {"", ""\t\t\t\t/*"", ""\t\t\t\t * Treat any other error as fatal - best to be"", ""\t\t\t\t * paranoid here."", ""\t\t\t\t * Note: This effectively disables deep"", ""\t\t\t\t * directory support when security checks are"", ""\t\t\t\t * enabled. Otherwise, very long pathnames that"", ""\t\t\t\t * trigger an error here could evade the"", ""\t\t\t\t * sandbox."", ""\t\t\t\t * TODO: We could do better, but it would"", ""\t\t\t\t * probably require merging the symlink checks"", ""\t\t\t\t * with the deep-directory editing."", ""\t\t\t\t */"", ""\t\t\t\tfsobj_error(a_eno, a_estr, errno,"", ""\t\t\t\t    \""Could not stat %s\"", path);"", ""\t\t\t\tres = ARCHIVE_FAILED;"", ""\t\t\t\tbreak;"", ""\t\t\t}"", ""\t\t} else if (S_ISDIR(st.st_mode)) {"", ""\t\t\tif (!last) {"", ""\t\t\t\tif (chdir(head) != 0) {"", ""\t\t\t\t\ttail[0] = c;"", ""\t\t\t\t\tfsobj_error(a_eno, a_estr, errno,"", ""\t\t\t\t\t    \""Could not chdir %s\"", path);"", ""\t\t\t\t\tres = (ARCHIVE_FATAL);"", ""\t\t\t\t\tbreak;"", ""\t\t\t\t}"", ""\t\t\t\t/* Our view is now from inside this dir: */"", ""\t\t\t\thead = tail + 1;"", ""\t\t\t}"", ""\t\t} else if (S_ISLNK(st.st_mode)) {"", ""\t\t\tif (c == '\\0') {"", ""\t\t\tif (last) {"", ""\t\t\t\t/*"", ""\t\t\t\t * Last element is symlink; remove it"", ""\t\t\t\t * so we can overwrite it with the"", ""\t\t\t\t * item being extracted."", ""\t\t\t\t */"", ""\t\t\t\tif (unlink(a->name)) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\tif (unlink(head)) {"", ""\t\t\t\t\ttail[0] = c;"", ""\t\t\t\t\tfsobj_error(a_eno, a_estr, errno,"", ""\t\t\t\t\t    \""Could not remove symlink %s\"","", ""\t\t\t\t\t    a->name);"", ""\t\t\t\t\tpn[0] = c;"", ""\t\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t\t\t\t    path);"", ""\t\t\t\t\tres = ARCHIVE_FAILED;"", ""\t\t\t\t\tbreak;"", ""\t\t\t\t}"", ""\t\t\t\ta->pst = NULL;"", ""\t\t\t\t/*"", ""\t\t\t\t * Even if we did remove it, a warning"", ""\t\t\t\t * is in order.  The warning is silly,"", ""\t\t\t\t * though, if we're just replacing one"", ""\t\t\t\t * symlink with another symlink."", ""\t\t\t\t */"", ""\t\t\t\tif (!S_ISLNK(a->mode)) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, 0,"", ""\t\t\t\t\t    \""Removing symlink %s\"","", ""\t\t\t\t\t    a->name);"", ""\t\t\t\ttail[0] = c;"", ""\t\t\t\t/*"", ""\t\t\t\t * FIXME:  not sure how important this is to"", ""\t\t\t\t * restore"", ""\t\t\t\t */"", ""\t\t\t\t/*"", ""\t\t\t\tif (!S_ISLNK(path)) {"", ""\t\t\t\t\tfsobj_error(a_eno, a_estr, 0,"", ""\t\t\t\t\t    \""Removing symlink %s\"", path);"", ""\t\t\t\t}"", ""\t\t\t\t*/"", ""\t\t\t\t/* Symlink gone.  No more problem! */"", ""\t\t\t\tpn[0] = c;"", ""\t\t\t\treturn (0);"", ""\t\t\t} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {"", ""\t\t\t\tres = ARCHIVE_OK;"", ""\t\t\t\tbreak;"", ""\t\t\t} else if (flags & ARCHIVE_EXTRACT_UNLINK) {"", ""\t\t\t\t/* User asked us to remove problems. */"", ""\t\t\t\tif (unlink(a->name) != 0) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, 0,"", ""\t\t\t\t\t    \""Cannot remove intervening symlink %s\"","", ""\t\t\t\t\t    a->name);"", ""\t\t\t\t\tpn[0] = c;"", ""\t\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t\t\tif (unlink(head) != 0) {"", ""\t\t\t\t\ttail[0] = c;"", ""\t\t\t\t\tfsobj_error(a_eno, a_estr, 0,"", ""\t\t\t\t\t    \""Cannot remove intervening \"""", ""\t\t\t\t\t    \""symlink %s\"", path);"", ""\t\t\t\t\tres = ARCHIVE_FAILED;"", ""\t\t\t\t\tbreak;"", ""\t\t\t\t}"", ""\t\t\t\ttail[0] = c;"", ""\t\t\t} else if ((flags &"", ""\t\t\t    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {"", ""\t\t\t\t/*"", ""\t\t\t\t * We are not the last element and we want to"", ""\t\t\t\t * follow symlinks if they are a directory."", ""\t\t\t\t * "", ""\t\t\t\t * This is needed to extract hardlinks over"", ""\t\t\t\t * symlinks."", ""\t\t\t\t */"", ""\t\t\t\tr = stat(head, &st);"", ""\t\t\t\tif (r != 0) {"", ""\t\t\t\t\ttail[0] = c;"", ""\t\t\t\t\tif (errno == ENOENT) {"", ""\t\t\t\t\t\tbreak;"", ""\t\t\t\t\t} else {"", ""\t\t\t\t\t\tfsobj_error(a_eno, a_estr,"", ""\t\t\t\t\t\t    errno,"", ""\t\t\t\t\t\t    \""Could not stat %s\"", path);"", ""\t\t\t\t\t\tres = (ARCHIVE_FAILED);"", ""\t\t\t\t\t\tbreak;"", ""\t\t\t\t\t}"", ""\t\t\t\t} else if (S_ISDIR(st.st_mode)) {"", ""\t\t\t\t\tif (chdir(head) != 0) {"", ""\t\t\t\t\t\ttail[0] = c;"", ""\t\t\t\t\t\tfsobj_error(a_eno, a_estr,"", ""\t\t\t\t\t\t    errno,"", ""\t\t\t\t\t\t    \""Could not chdir %s\"", path);"", ""\t\t\t\t\t\tres = (ARCHIVE_FATAL);"", ""\t\t\t\t\t\tbreak;"", ""\t\t\t\t\t}"", ""\t\t\t\t\t/*"", ""\t\t\t\t\t * Our view is now from inside"", ""\t\t\t\t\t * this dir:"", ""\t\t\t\t\t */"", ""\t\t\t\t\thead = tail + 1;"", ""\t\t\t\t} else {"", ""\t\t\t\t\ttail[0] = c;"", ""\t\t\t\t\tfsobj_error(a_eno, a_estr, 0,"", ""\t\t\t\t\t    \""Cannot extract through \"""", ""\t\t\t\t\t    \""symlink %s\"", path);"", ""\t\t\t\t\tres = ARCHIVE_FAILED;"", ""\t\t\t\t\tbreak;"", ""\t\t\t\t}"", ""\t\t\t\ta->pst = NULL;"", ""\t\t\t} else {"", ""\t\t\t\tarchive_set_error(&a->archive, 0,"", ""\t\t\t\t    \""Cannot extract through symlink %s\"","", ""\t\t\t\t    a->name);"", ""\t\t\t\tpn[0] = c;"", ""\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t\t\ttail[0] = c;"", ""\t\t\t\tfsobj_error(a_eno, a_estr, 0,"", ""\t\t\t\t    \""Cannot extract through symlink %s\"", path);"", ""\t\t\t\tres = ARCHIVE_FAILED;"", ""\t\t\t\tbreak;"", ""\t\t\t}"", ""\t\t}"", ""\t\tpn[0] = c;"", ""\t\tif (pn[0] != '\\0')"", ""\t\t\tpn++; /* Advance to the next segment. */"", ""\t\t/* be sure to always maintain this */"", ""\t\ttail[0] = c;"", ""\t\tif (tail[0] != '\\0')"", ""\t\t\ttail++; /* Advance to the next segment. */"", ""\t}"", ""\t/* Catches loop exits via break */"", ""\ttail[0] = c;"", ""#ifdef HAVE_FCHDIR"", ""\t/* If we changed directory above, restore it here. */"", ""\tif (restore_pwd >= 0) {"", ""\t\tr = fchdir(restore_pwd);"", ""\t\tif (r != 0) {"", ""\t\t\tfsobj_error(a_eno, a_estr, errno,"", ""\t\t\t    \""chdir() failure\"", \""\"");"", ""\t\t}"", ""\t\tclose(restore_pwd);"", ""\t\trestore_pwd = -1;"", ""\t\tif (r != 0) {"", ""\t\t\tres = (ARCHIVE_FATAL);"", ""\t\t}"", ""\t}"", ""\tpn[0] = c;"", ""\t/* We've checked and/or cleaned the whole path, so remember it. */"", ""\tarchive_strcpy(&a->path_safe, a->name);"", ""\treturn (ARCHIVE_OK);"", ""#endif"", ""\t/* TODO: reintroduce a safe cache here? */"", ""\treturn res;"", ""#endif"", ""}"", """", ""/*"", "" * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise"", "" * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}"", "" */"", ""static int"", ""check_symlinks(struct archive_write_disk *a)"", ""{"", ""\tstruct archive_string error_string;"", ""\tint error_number;"", ""\tint rc;"", ""\tarchive_string_init(&error_string);"", ""\trc = check_symlinks_fsobj(a->name, &error_number, &error_string,"", ""\t    a->flags);"", ""\tif (rc != ARCHIVE_OK) {"", ""\t\tarchive_set_error(&a->archive, error_number, \""%s\"","", ""\t\t    error_string.s);"", ""\t}"", ""\tarchive_string_free(&error_string);"", ""\ta->pst = NULL;\t/* to be safe */"", ""\treturn rc;"", ""}"", """", """", ""#if defined(__CYGWIN__)"", ""/*"", "" * 1. Convert a path separator from '\\' to '/' .""]","[0, 0, 0, -1, -1, -1, -1, -1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, -1, 1, 1, 0, 0, 0, -1, 1, 1, 1, 1, 0, 0, -1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, 1, 0, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, 0, 0, 0, 0, -1, -2, 1, 1, 2, 0, -1, -1, -1, 1, 1, 1, 0, -1, 0, 0, 0, 0, 0, 0, -1, -2, -1, -1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 0, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, -2, -1, -1, -1, -1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0, -1, 0, -2, -1, -1, -1, -1, 1, 2, 1, 1, 1, 0, 0, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[10, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(int *a_eno, struct archive_string *a_estr,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [16, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_string_sprintf(a_estr, errstr, path);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [142, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [151, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [168, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [171, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [188, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [198, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [211, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [218, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [240, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [249, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [262, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [270, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [276, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [297, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [330, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, error_number, \""%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""]]",2351,2457
"["" * is set) if the path is absolute."", "" */"", ""static int"", ""cleanup_pathname(struct archive_write_disk *a)"", ""cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,"", ""    int flags)"", ""{"", ""\tchar *dest, *src;"", ""\tchar separator = '\\0';"", """", ""\tdest = src = a->name;"", ""\tdest = src = path;"", ""\tif (*src == '\\0') {"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Invalid empty pathname\"");"", ""\t\tfsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Invalid empty \"", \""pathname\"");"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t}"", """", ""#if defined(__CYGWIN__)"", ""\tcleanup_pathname_win(a);"", ""\tcleanup_pathname_win(path);"", ""#endif"", ""\t/* Skip leading '/'. */"", ""\tif (*src == '/') {"", ""\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t                  \""Path is absolute\"");"", ""\t\tif (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {"", ""\t\t\tfsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Path is \"", \""absolute\"");"", ""\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t}"", """"]","[0, 0, 0, -1, 1, 1, 0, 0, 0, 0, -1, 1, 0, -2, -1, 2, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, -2, -1, 1, 2, 1, 0, 0, 0]","[[13, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [15, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [27, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [30, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""]]",2534,2807
"[""\t\t\t} else if (src[1] == '.') {"", ""\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {"", ""\t\t\t\t\t/* Conditionally warn about '..' */"", ""\t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {"", ""\t\t\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t\tif (flags"", ""\t\t\t\t\t    & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {"", ""\t\t\t\t\t\tfsobj_error(a_eno, a_estr,"", ""\t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t\t\t\t    \""Path contains '..'\"");"", ""\t\t\t\t\t\t    \""Path contains \"", \""'..'\"");"", ""\t\t\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t\t\t\t}"", ""\t\t\t\t}""]","[0, 0, 0, -1, -2, 1, 1, 2, 0, -1, 1, 0, 0, 0]","[[4, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [7, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""]]",2580,2854
"[""\treturn (ARCHIVE_OK);"", ""}"", """", ""static int"", ""cleanup_pathname(struct archive_write_disk *a)"", ""{"", ""\tstruct archive_string error_string;"", ""\tint error_number;"", ""\tint rc;"", ""\tarchive_string_init(&error_string);"", ""\trc = cleanup_pathname_fsobj(a->name, &error_number, &error_string,"", ""\t    a->flags);"", ""\tif (rc != ARCHIVE_OK) {"", ""\t\tarchive_set_error(&a->archive, error_number, \""%s\"","", ""\t\t    error_string.s);"", ""\t}"", ""\tarchive_string_free(&error_string);"", ""\treturn rc;"", ""}"", """", ""/*"", "" * Create the parent directory of the specified path, assuming path"", "" * is already in mutable storage.""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[13, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, error_number, \""%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""]]",2629,2904
"[""\t\t}"", ""\t} else if (errno != ENOENT && errno != ENOTDIR) {"", ""\t\t/* Stat failed? */"", ""\t\tarchive_set_error(&a->archive, errno, \""Can't test directory '%s'\"", path);"", ""\t\tarchive_set_error(&a->archive, errno,"", ""\t\t    \""Can't test directory '%s'\"", path);"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t} else if (slash != NULL) {"", ""\t\t*slash = '\\0';""]","[0, 0, 0, -2, 2, 1, 0, 0, 0]","[[3, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, errno, \""Can't test directory '%s'\"", path);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [4, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""]]",2707,2999
"[""\t\t\t\tif (errno == ENOTSUP || errno == ENOSYS) {"", ""\t\t\t\t\tif (!warning_done) {"", ""\t\t\t\t\t\twarning_done = 1;"", ""\t\t\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t\t\t    errno,"", ""\t\t\t\t\t\t    \""Cannot restore extended \"""", ""\t\t\t\t\t\t    \""attributes on this file \"""", ""\t\t\t\t\t\t    \""system\"");""]","[0, 0, 0, -2, 2, 1, 0, 0, 0]","[[3, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [4, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""]]",3753,4051
"[""\t\t\t\tret = ARCHIVE_WARN;"", ""\t\t\t}"", ""\t\t} else {"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t    \""Invalid extended attribute encountered\"");"", ""\t\t\tret = ARCHIVE_WARN;"", ""\t\t}""]","[0, 0, 0, -2, 2, 1, 0, 0, 0]","[[3, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [4, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""]]",3764,4063
"[""\t\t\terrno = 0;"", ""#if HAVE_EXTATTR_SET_FD"", ""\t\t\tif (a->fd >= 0)"", ""\t\t\t\te = extattr_set_fd(a->fd, namespace, name, value, size);"", ""\t\t\t\te = extattr_set_fd(a->fd, namespace, name,"", ""\t\t\t\t    value, size);"", ""\t\t\telse"", ""#endif"", ""\t\t\t/* TODO: should we use extattr_set_link() instead? */"", ""\t\t\t{"", ""\t\t\t\te = extattr_set_file(archive_entry_pathname(entry),"", ""\t\t\t\t    namespace, name, value, size);"", ""\t\t\t\te = extattr_set_file("", ""\t\t\t\t    archive_entry_pathname(entry), namespace,"", ""\t\t\t\t    name, value, size);"", ""\t\t\t}"", ""\t\t\tif (e != (int)size) {"", ""\t\t\t\tif (errno == ENOTSUP || errno == ENOSYS) {"", ""\t\t\t\t\tif (!warning_done) {"", ""\t\t\t\t\t\twarning_done = 1;"", ""\t\t\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t\t\t    errno,"", ""\t\t\t\t\t\t    \""Cannot restore extended \"""", ""\t\t\t\t\t\t    \""attributes on this file \"""", ""\t\t\t\t\t\t    \""system\"");""]","[0, 0, 0, -1, 1, 1, 0, 0, 0, 0, -1, -1, 1, 1, 1, 0, 0, 0, 0, 0, -2, 2, 1, 0, 0, 0]","[[20, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""], [21, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_34_new.cpp""]]",3808,4108
"[""\treturn (ARCHIVE_OK);"", ""}"", """", ""/* Add ACL to pax header */"", ""static int"", ""add_pax_acl(struct archive_write *a,"", ""    struct archive_entry *entry, struct pax *pax, int flags)"", ""{"", ""\tchar *p;"", ""\tconst char *attr;"", ""\tint acl_types;"", """", ""\tacl_types = archive_entry_acl_types(entry);"", """", ""\tif ((acl_types & ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0)"", ""\t\tattr = \""SCHILY.acl.ace\"";"", ""\telse if ((flags & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0)"", ""\t\tattr = \""SCHILY.acl.access\"";"", ""\telse if ((flags & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)"", ""\t\tattr = \""SCHILY.acl.default\"";"", ""\telse"", ""\t\treturn (ARCHIVE_FATAL);"", """", ""\tp = archive_entry_acl_to_text_l(entry, NULL, flags, pax->sconv_utf8);"", ""\tif (p == NULL) {"", ""\t\tif (errno == ENOMEM) {"", ""\t\t\tarchive_set_error(&a->archive, ENOMEM, \""%s %s\"","", ""\t\t\t    \""Can't allocate memory for \"", attr);"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t}"", ""\t\tarchive_set_error(&a->archive,"", ""\t\t    ARCHIVE_ERRNO_FILE_FORMAT, \""%s %s %s\"","", ""\t\t    \""Can't translate \"", attr, \"" to UTF-8\"");"", ""\t\treturn(ARCHIVE_WARN);"", ""\t} else if (*p != '\\0') {"", ""\t\tadd_pax_attr(&(pax->pax_header),"", ""\t\t    attr, p);"", ""\t\tfree(p);"", ""\t}"", ""\treturn(ARCHIVE_OK);"", ""}"", """", ""/*"", "" * TODO: Consider adding 'comment' and 'charset' fields to"", "" * archive_entry so that clients can specify them.  Also, consider""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[26, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_set_format_pax.c"", ""+"", ""archive_set_error(&a->archive, ENOMEM, \""%s %s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_35_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_35_new.cpp""], [30, ""33f636264a5d830f67316dc6184f4056b3a3629f"", ""Merge topic 'update-libarchive'\n\nd49176e9 libarchive: Avoid using isblank\nce8f117f libarchive: Avoid declaration after statement in C code\ne0f725f8 libarchive: Fix use of ssize_t in archive_entry.h\nae4861ec libarchive: Define __LA_DEPRECATED consistently\nfecb70dd Update CMake pre-cached values for libarchive 3.3.0\na59a7ee9 Merge branch 'upstream-LibArchive' into update-libarchive\nc206211a LibArchive 2017-02-19 (100ee75a)\ncdce7c61 libarchive: Update script to get 3.3.0"", ""Utilities/cmlibarchive/libarchive/archive_write_set_format_pax.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_35_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_35_new.cpp""]]",450,491
"["" */"", """", ""#include \""internal.h\"""", ""#include <sys/ioctl.h>"", ""#include <net/if.h>"", ""#include <utmpx.h>"", ""#include <unistd.h>"", ""#include <sys/ps.h>"", ""#if defined(__clang__)"", ""#include \""csrsic.h\"""", ""#else"", ""#include \""//'SYS1.SAMPLIB(CSRSIC)'\"""", ""#endif"", """", ""#define CVT_PTR           0x10"", ""#define CSD_OFFSET        0x294"", """", ""/*"", ""    Long-term average CPU service used by this logical partition,"", ""    in millions of service units per hour. If this value is above"", ""    the partition's defined capacity, the partition will be capped."", ""    It is calculated using the physical CPU adjustment factor"", ""    (RCTPCPUA) so it may not match other measures of service which"", ""    are based on the logical CPU adjustment factor. It is available"", ""    if the hardware supports LPAR cluster."", ""*/"", ""#define RCTLACS_OFFSET    0xC4"", """", ""/* 32-bit count of alive CPUs. This includes both CPs and IFAs */"", ""#define CSD_NUMBER_ONLINE_CPUS        0xD4"", """", ""/* Address of system resources manager (SRM) control table */"", ""#define CVTOPCTP_OFFSET   0x25C"", """", ""/* Address of the RCT table */"", ""#define RMCTRCT_OFFSET    0xE4"", """", ""/* Address of the rsm control and enumeration area. */"", ""#define CVTRCEP_OFFSET    0x490"", """", ""/*"", ""    Number of frames currently available to system."", ""    Excluded are frames backing perm storage, frames offline, and bad frames."", ""*/"", ""#define RCEPOOL_OFFSET    0x004"", """", ""/* Total number of frames currently on all available frame queues. */"", ""#define RCEAFC_OFFSET     0x088"", """", ""/* CPC model length from the CSRSI Service. */"", ""#define CPCMODEL_LENGTH   16"", """", ""/* Thread Entry constants */"", ""#define PGTH_CURRENT  1"", ""#define PGTH_LEN      26"", ""#define PGTHAPATH     0x20"", ""#pragma linkage(BPX4GTH, OS)"", ""#pragma linkage(BPX1GTH, OS)"", """", ""typedef unsigned data_area_ptr_assign_type;"", """", ""typedef union {"", ""  struct {"", ""#if defined(_LP64)"", ""    data_area_ptr_assign_type lower;"", ""#endif"", ""    data_area_ptr_assign_type assign;"", ""  };"", ""  char* deref;"", ""} data_area_ptr;"", """", """", ""void uv_loadavg(double avg[3]) {"", ""  /* TODO: implement the following */"", ""  avg[0] = 0;"", ""  avg[1] = 0;"", ""  avg[2] = 0;"", ""}"", """", """", ""int uv__platform_loop_init(uv_loop_t* loop) {"", ""  uv__os390_epoll* ep;"", """", ""  ep = epoll_create1(UV__EPOLL_CLOEXEC);"", ""  loop->ep = ep;"", ""  if (ep == NULL)"", ""    return -errno;"", """", ""  return 0;"", ""}"", """", """", ""void uv__platform_loop_delete(uv_loop_t* loop) {"", ""  if (loop->ep != NULL) {"", ""    epoll_queue_close(loop->ep);"", ""    loop->ep = NULL;"", ""  }"", ""}"", """", """", ""uint64_t uv__hrtime(uv_clocktype_t type) {"", ""  struct timeval time;"", ""  gettimeofday(&time, NULL);"", ""  return (uint64_t) time.tv_sec * 1e9 + time.tv_usec * 1e3;"", ""}"", """", """", ""/*"", ""    Get the exe path using the thread entry information"", ""    in the address space."", ""*/"", ""static int getexe(const int pid, char* buf, size_t len) {"", ""  struct {"", ""    int pid;"", ""    int thid[2];"", ""    char accesspid;"", ""    char accessthid;"", ""    char asid[2];"", ""    char loginname[8];"", ""    char flag;"", ""    char len;"", ""  } Input_data;"", """", ""  union {"", ""    struct {"", ""      char gthb[4];"", ""      int pid;"", ""      int thid[2];"", ""      char accesspid;"", ""      char accessthid[3];"", ""      int lenused;"", ""      int offsetProcess;"", ""      int offsetConTTY;"", ""      int offsetPath;"", ""      int offsetCommand;"", ""      int offsetFileData;"", ""      int offsetThread;"", ""    } Output_data;"", ""    char buf[2048];"", ""  } Output_buf;"", """", ""  struct Output_path_type {"", ""    char gthe[4];"", ""    short int len;"", ""    char path[1024];"", ""  };"", """", ""  int Input_length;"", ""  int Output_length;"", ""  void* Input_address;"", ""  void* Output_address;"", ""  struct Output_path_type* Output_path;"", ""  int rv;"", ""  int rc;"", ""  int rsn;"", """", ""  Input_length = PGTH_LEN;"", ""  Output_length = sizeof(Output_buf);"", ""  Output_address = &Output_buf;"", ""  Input_address = &Input_data;"", ""  memset(&Input_data, 0, sizeof Input_data);"", ""  Input_data.flag |= PGTHAPATH;"", ""  Input_data.pid = pid;"", ""  Input_data.accesspid = PGTH_CURRENT;"", """", ""#ifdef _LP64"", ""  BPX4GTH(&Input_length,"", ""          &Input_address,"", ""          &Output_length,"", ""          &Output_address,"", ""          &rv,"", ""          &rc,"", ""          &rsn);"", ""#else"", ""  BPX1GTH(&Input_length,"", ""          &Input_address,"", ""          &Output_length,"", ""          &Output_address,"", ""          &rv,"", ""          &rc,"", ""          &rsn);"", ""#endif"", """", ""  if (rv == -1) {"", ""    errno = rc;"", ""    return -1;"", ""  }"", """", ""  /* Check highest byte to ensure data availability */"", ""  assert(((Output_buf.Output_data.offsetPath >>24) & 0xFF) == 'A');"", """", ""  /* Get the offset from the lowest 3 bytes */"", ""  Output_path = (char*)(&Output_buf) +"", ""                (Output_buf.Output_data.offsetPath & 0x00FFFFFF);"", """", ""  if (Output_path->len >= len) {"", ""    errno = ENOBUFS;"", ""    return -1;"", ""  }"", """", ""  strncpy(buf, Output_path->path, len);"", """", ""  return 0;"", ""}"", """", """", ""/*"", "" * We could use a static buffer for the path manipulations that we need outside"", "" * of the function, but this function could be called by multiple consumers and"", "" * we don't want to potentially create a race condition in the use of snprintf."", "" * There is no direct way of getting the exe path in zOS - either through /procfs"", "" * or through some libc APIs. The below approach is to parse the argv[0]'s pattern"", "" * and use it in conjunction with PATH environment variable to craft one."", "" */"", ""int uv_exepath(char* buffer, size_t* size) {"", ""  int res;"", ""  char args[PATH_MAX];"", ""  char abspath[PATH_MAX];"", ""  size_t abspath_size;"", ""  int pid;"", """", ""  if (buffer == NULL || size == NULL || *size == 0)"", ""    return -EINVAL;"", """", ""  pid = getpid();"", ""  res = getexe(pid, args, sizeof(args));"", ""  if (res < 0)"", ""    return -EINVAL;"", """", ""  /*"", ""   * Possibilities for args:"", ""   * i) an absolute path such as: /home/user/myprojects/nodejs/node"", ""   * ii) a relative path such as: ./node or ../myprojects/nodejs/node"", ""   * iii) a bare filename such as \""node\"", after exporting PATH variable"", ""   *     to its location."", ""   */"", """", ""  /* Case i) and ii) absolute or relative paths */"", ""  if (strchr(args, '/') != NULL) {"", ""    if (realpath(args, abspath) != abspath)"", ""      return -errno;"", """", ""    abspath_size = strlen(abspath);"", """", ""    *size -= 1;"", ""    if (*size > abspath_size)"", ""      *size = abspath_size;"", """", ""    memcpy(buffer, abspath, *size);"", ""    buffer[*size] = '\\0';"", """", ""    return 0;"", ""  } else {"", ""    /* Case iii). Search PATH environment variable */"", ""    char trypath[PATH_MAX];"", ""    char* clonedpath = NULL;"", ""    char* token = NULL;"", ""    char* path = getenv(\""PATH\"");"", """", ""    if (path == NULL)"", ""      return -EINVAL;"", """", ""    clonedpath = uv__strdup(path);"", ""    if (clonedpath == NULL)"", ""      return -ENOMEM;"", """", ""    token = strtok(clonedpath, \"":\"");"", ""    while (token != NULL) {"", ""      snprintf(trypath, sizeof(trypath) - 1, \""%s/%s\"", token, args);"", ""      if (realpath(trypath, abspath) == abspath) {"", ""        /* Check the match is executable */"", ""        if (access(abspath, X_OK) == 0) {"", ""          abspath_size = strlen(abspath);"", """", ""          *size -= 1;"", ""          if (*size > abspath_size)"", ""            *size = abspath_size;"", """", ""          memcpy(buffer, abspath, *size);"", ""          buffer[*size] = '\\0';"", """", ""          uv__free(clonedpath);"", ""          return 0;"", ""        }"", ""      }"", ""      token = strtok(NULL, \"":\"");"", ""    }"", ""    uv__free(clonedpath);"", """", ""    /* Out of tokens (path entries), and no match found */"", ""    return -EINVAL;"", ""  }"", ""}"", """", """", ""uint64_t uv_get_free_memory(void) {"", ""  uint64_t freeram;"", """", ""  data_area_ptr cvt = {0};"", ""  data_area_ptr rcep = {0};"", ""  cvt.assign = *(data_area_ptr_assign_type*)(CVT_PTR);"", ""  rcep.assign = *(data_area_ptr_assign_type*)(cvt.deref + CVTRCEP_OFFSET);"", ""  freeram = *((uint64_t*)(rcep.deref + RCEAFC_OFFSET)) * 4;"", ""  return freeram;"", ""}"", """", """", ""uint64_t uv_get_total_memory(void) {"", ""  uint64_t totalram;"", """", ""  data_area_ptr cvt = {0};"", ""  data_area_ptr rcep = {0};"", ""  cvt.assign = *(data_area_ptr_assign_type*)(CVT_PTR);"", ""  rcep.assign = *(data_area_ptr_assign_type*)(cvt.deref + CVTRCEP_OFFSET);"", ""  totalram = *((uint64_t*)(rcep.deref + RCEPOOL_OFFSET)) * 4;"", ""  return totalram;"", ""}"", """", """", ""int uv_resident_set_memory(size_t* rss) {"", ""  W_PSPROC buf;"", """", ""  memset(&buf, 0, sizeof(buf));"", ""  if (w_getpsent(0, &buf, sizeof(W_PSPROC)) == -1)"", ""    return -EINVAL;"", """", ""  *rss = buf.ps_size;"", ""  return 0;"", ""}"", """", """", ""int uv_uptime(double* uptime) {"", ""  struct utmpx u ;"", ""  struct utmpx *v;"", ""  time64_t t;"", """", ""  u.ut_type = BOOT_TIME;"", ""  v = getutxid(&u);"", ""  if (v == NULL)"", ""    return -1;"", ""  *uptime = difftime64(time64(&t), v->ut_tv.tv_sec);"", ""  return 0;"", ""}"", """", """", ""int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {"", ""  uv_cpu_info_t* cpu_info;"", ""  int result;"", ""  int idx;"", ""  siv1v2 info;"", ""  data_area_ptr cvt = {0};"", ""  data_area_ptr csd = {0};"", ""  data_area_ptr rmctrct = {0};"", ""  data_area_ptr cvtopctp = {0};"", ""  int cpu_usage_avg;"", """", ""  cvt.assign = *(data_area_ptr_assign_type*)(CVT_PTR);"", """", ""  csd.assign = *((data_area_ptr_assign_type *) (cvt.deref + CSD_OFFSET));"", ""  cvtopctp.assign = *((data_area_ptr_assign_type *) (cvt.deref + CVTOPCTP_OFFSET));"", ""  rmctrct.assign = *((data_area_ptr_assign_type *) (cvtopctp.deref + RMCTRCT_OFFSET));"", """", ""  *count = *((int*) (csd.deref + CSD_NUMBER_ONLINE_CPUS));"", ""  cpu_usage_avg = *((unsigned short int*) (rmctrct.deref + RCTLACS_OFFSET));"", """", ""  *cpu_infos = uv__malloc(*count * sizeof(uv_cpu_info_t));"", ""  if (!*cpu_infos)"", ""    return -ENOMEM;"", """", ""  cpu_info = *cpu_infos;"", ""  idx = 0;"", ""  while (idx < *count) {"", ""    cpu_info->speed = *(int*)(info.siv1v2si22v1.si22v1cpucapability);"", ""    cpu_info->model = uv__malloc(CPCMODEL_LENGTH + 1);"", ""    memset(cpu_info->model, '\\0', CPCMODEL_LENGTH + 1);"", ""    memcpy(cpu_info->model, info.siv1v2si11v1.si11v1cpcmodel, CPCMODEL_LENGTH);"", ""    cpu_info->cpu_times.user = cpu_usage_avg;"", ""    /* TODO: implement the following */"", ""    cpu_info->cpu_times.sys = 0;"", ""    cpu_info->cpu_times.idle = 0;"", ""    cpu_info->cpu_times.irq = 0;"", ""    cpu_info->cpu_times.nice = 0;"", ""    ++cpu_info;"", ""    ++idx;"", ""  }"", """", ""  return 0;"", ""}"", """", """", ""void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count) {"", ""  for (int i = 0; i < count; ++i)"", ""    uv__free(cpu_infos[i].model);"", ""  uv__free(cpu_infos);"", ""}"", """", """", ""static int uv__interface_addresses_v6(uv_interface_address_t** addresses,"", ""                                      int* count) {"", ""  uv_interface_address_t* address;"", ""  int sockfd;"", ""  int maxsize;"", ""  __net_ifconf6header_t ifc;"", ""  __net_ifconf6entry_t* ifr;"", ""  __net_ifconf6entry_t* p;"", ""  __net_ifconf6entry_t flg;"", """", ""  *count = 0;"", ""  /* Assume maximum buffer size allowable */"", ""  maxsize = 16384;"", """", ""  if (0 > (sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP)))"", ""    return -errno;"", """", ""  ifc.__nif6h_version = 1;"", ""  ifc.__nif6h_buflen = maxsize;"", ""  ifc.__nif6h_buffer = uv__calloc(1, maxsize);;"", """", ""  if (ioctl(sockfd, SIOCGIFCONF6, &ifc) == -1) {"", ""    uv__close(sockfd);"", ""    return -errno;"", ""  }"", """", """", ""  *count = 0;"", ""  ifr = (__net_ifconf6entry_t*)(ifc.__nif6h_buffer);"", ""  while ((char*)ifr < (char*)ifc.__nif6h_buffer + ifc.__nif6h_buflen) {"", ""    p = ifr;"", ""    ifr = (__net_ifconf6entry_t*)((char*)ifr + ifc.__nif6h_entrylen);"", """", ""    if (!(p->__nif6e_addr.sin6_family == AF_INET6 ||"", ""          p->__nif6e_addr.sin6_family == AF_INET))"", ""      continue;"", """", ""    if (!(p->__nif6e_flags & _NIF6E_FLAGS_ON_LINK_ACTIVE))"", ""      continue;"", """", ""    ++(*count);"", ""  }"", """", ""  /* Alloc the return interface structs */"", ""  *addresses = uv__malloc(*count * sizeof(uv_interface_address_t));"", ""  if (!(*addresses)) {"", ""    uv__close(sockfd);"", ""    return -ENOMEM;"", ""  }"", ""  address = *addresses;"", """", ""  ifr = (__net_ifconf6entry_t*)(ifc.__nif6h_buffer);"", ""  while ((char*)ifr < (char*)ifc.__nif6h_buffer + ifc.__nif6h_buflen) {"", ""    p = ifr;"", ""    ifr = (__net_ifconf6entry_t*)((char*)ifr + ifc.__nif6h_entrylen);"", """", ""    if (!(p->__nif6e_addr.sin6_family == AF_INET6 ||"", ""          p->__nif6e_addr.sin6_family == AF_INET))"", ""      continue;"", """", ""    if (!(p->__nif6e_flags & _NIF6E_FLAGS_ON_LINK_ACTIVE))"", ""      continue;"", """", ""    /* All conditions above must match count loop */"", """", ""    address->name = uv__strdup(p->__nif6e_name);"", """", ""    if (p->__nif6e_addr.sin6_family == AF_INET6)"", ""      address->address.address6 = *((struct sockaddr_in6*) &p->__nif6e_addr);"", ""    else"", ""      address->address.address4 = *((struct sockaddr_in*) &p->__nif6e_addr);"", """", ""    /* TODO: Retrieve netmask using SIOCGIFNETMASK ioctl */"", """", ""    address->is_internal = flg.__nif6e_flags & _NIF6E_FLAGS_LOOPBACK ? 1 : 0;"", """", ""    address++;"", ""  }"", """", ""  uv__close(sockfd);"", ""  return 0;"", ""}"", """", """", ""int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {"", ""  uv_interface_address_t* address;"", ""  int sockfd;"", ""  int maxsize;"", ""  struct ifconf ifc;"", ""  struct ifreq flg;"", ""  struct ifreq* ifr;"", ""  struct ifreq* p;"", ""  int count_v6;"", """", ""  /* get the ipv6 addresses first */"", ""  uv_interface_address_t* addresses_v6;"", ""  uv__interface_addresses_v6(&addresses_v6, &count_v6);"", """", ""  /* now get the ipv4 addresses */"", ""  *count = 0;"", """", ""  /* Assume maximum buffer size allowable */"", ""  maxsize = 16384;"", """", ""  sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);"", ""  if (0 > sockfd)"", ""    return -errno;"", """", ""  ifc.ifc_req = uv__calloc(1, maxsize);"", ""  ifc.ifc_len = maxsize;"", ""  if (ioctl(sockfd, SIOCGIFCONF, &ifc) == -1) {"", ""    uv__close(sockfd);"", ""    return -errno;"", ""  }"", """", ""#define MAX(a,b) (((a)>(b))?(a):(b))"", ""#define ADDR_SIZE(p) MAX((p).sa_len, sizeof(p))"", """", ""  /* Count all up and running ipv4/ipv6 addresses */"", ""  ifr = ifc.ifc_req;"", ""  while ((char*)ifr < (char*)ifc.ifc_req + ifc.ifc_len) {"", ""    p = ifr;"", ""    ifr = (struct ifreq*)"", ""      ((char*)ifr + sizeof(ifr->ifr_name) + ADDR_SIZE(ifr->ifr_addr));"", """", ""    if (!(p->ifr_addr.sa_family == AF_INET6 ||"", ""          p->ifr_addr.sa_family == AF_INET))"", ""      continue;"", """", ""    memcpy(flg.ifr_name, p->ifr_name, sizeof(flg.ifr_name));"", ""    if (ioctl(sockfd, SIOCGIFFLAGS, &flg) == -1) {"", ""      uv__close(sockfd);"", ""      return -errno;"", ""    }"", """", ""    if (!(flg.ifr_flags & IFF_UP && flg.ifr_flags & IFF_RUNNING))"", ""      continue;"", """", ""    (*count)++;"", ""  }"", """", ""  /* Alloc the return interface structs */"", ""  *addresses = uv__malloc((*count + count_v6) *"", ""                          sizeof(uv_interface_address_t));"", """", ""  if (!(*addresses)) {"", ""    uv__close(sockfd);"", ""    return -ENOMEM;"", ""  }"", ""  address = *addresses;"", """", ""  /* copy over the ipv6 addresses */"", ""  memcpy(address, addresses_v6, count_v6 * sizeof(uv_interface_address_t));"", ""  address += count_v6;"", ""  *count += count_v6;"", ""  uv__free(addresses_v6);"", """", ""  ifr = ifc.ifc_req;"", ""  while ((char*)ifr < (char*)ifc.ifc_req + ifc.ifc_len) {"", ""    p = ifr;"", ""    ifr = (struct ifreq*)"", ""      ((char*)ifr + sizeof(ifr->ifr_name) + ADDR_SIZE(ifr->ifr_addr));"", """", ""    if (!(p->ifr_addr.sa_family == AF_INET6 ||"", ""          p->ifr_addr.sa_family == AF_INET))"", ""      continue;"", """", ""    memcpy(flg.ifr_name, p->ifr_name, sizeof(flg.ifr_name));"", ""    if (ioctl(sockfd, SIOCGIFFLAGS, &flg) == -1) {"", ""      uv__close(sockfd);"", ""      return -ENOSYS;"", ""    }"", """", ""    if (!(flg.ifr_flags & IFF_UP && flg.ifr_flags & IFF_RUNNING))"", ""      continue;"", """", ""    /* All conditions above must match count loop */"", """", ""    address->name = uv__strdup(p->ifr_name);"", """", ""    if (p->ifr_addr.sa_family == AF_INET6) {"", ""      address->address.address6 = *((struct sockaddr_in6*) &p->ifr_addr);"", ""    } else {"", ""      address->address.address4 = *((struct sockaddr_in*) &p->ifr_addr);"", ""    }"", """", ""    address->is_internal = flg.ifr_flags & IFF_LOOPBACK ? 1 : 0;"", ""    address++;"", ""  }"", """", ""#undef ADDR_SIZE"", ""#undef MAX"", """", ""  uv__close(sockfd);"", ""  return 0;"", ""}"", """", """", ""void uv_free_interface_addresses(uv_interface_address_t* addresses,"", ""                                 int count) {"", ""  int i;"", ""  for (i = 0; i < count; ++i)"", ""    uv__free(addresses[i].name);"", ""  uv__free(addresses);"", ""}"", """", """", ""void uv__platform_invalidate_fd(uv_loop_t* loop, int fd) {"", ""  struct epoll_event* events;"", ""  struct epoll_event dummy;"", ""  uintptr_t i;"", ""  uintptr_t nfds;"", """", ""  assert(loop->watchers != NULL);"", """", ""  events = (struct epoll_event*) loop->watchers[loop->nwatchers];"", ""  nfds = (uintptr_t) loop->watchers[loop->nwatchers + 1];"", ""  if (events != NULL)"", ""    /* Invalidate events with same file descriptor */"", ""    for (i = 0; i < nfds; i++)"", ""      if ((int) events[i].fd == fd)"", ""        events[i].fd = -1;"", """", ""  /* Remove the file descriptor from the epoll. */"", ""  if (loop->ep != NULL)"", ""    epoll_ctl(loop->ep, UV__EPOLL_CTL_DEL, fd, &dummy);"", ""}"", """", """", ""int uv__io_check_fd(uv_loop_t* loop, int fd) {"", ""  struct pollfd p[1];""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[268, ""8429068d7c37d06e53b871811760419ab3e36455"", ""Merge topic 'update-libuv'\n\n741b7621 Merge branch 'upstream-libuv' into update-libuv\n1f661e87 libuv 2017-02-21 (52ae8264)"", ""Utilities/cmlibuv/src/unix/os390.c"", ""+"", ""snprintf(trypath, sizeof(trypath) - 1, \""%s/%s\"", token, args);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_36_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_36_new.cpp""]]",20,20
"["" */"", """", ""#include \""internal.h\"""", ""#include <sys/ioctl.h>"", ""#include <net/if.h>"", ""#include <utmpx.h>"", ""#include <unistd.h>"", ""#include <sys/ps.h>"", ""#if defined(__clang__)"", ""#include \""csrsic.h\"""", ""#else"", ""#include \""//'SYS1.SAMPLIB(CSRSIC)'\"""", ""#endif"", """", ""#define CVT_PTR           0x10"", ""#define CSD_OFFSET        0x294"", """", ""/*"", ""    Long-term average CPU service used by this logical partition,"", ""    in millions of service units per hour. If this value is above"", ""    the partition's defined capacity, the partition will be capped."", ""    It is calculated using the physical CPU adjustment factor"", ""    (RCTPCPUA) so it may not match other measures of service which"", ""    are based on the logical CPU adjustment factor. It is available"", ""    if the hardware supports LPAR cluster."", ""*/"", ""#define RCTLACS_OFFSET    0xC4"", """", ""/* 32-bit count of alive CPUs. This includes both CPs and IFAs */"", ""#define CSD_NUMBER_ONLINE_CPUS        0xD4"", """", ""/* Address of system resources manager (SRM) control table */"", ""#define CVTOPCTP_OFFSET   0x25C"", """", ""/* Address of the RCT table */"", ""#define RMCTRCT_OFFSET    0xE4"", """", ""/* Address of the rsm control and enumeration area. */"", ""#define CVTRCEP_OFFSET    0x490"", """", ""/*"", ""    Number of frames currently available to system."", ""    Excluded are frames backing perm storage, frames offline, and bad frames."", ""*/"", ""#define RCEPOOL_OFFSET    0x004"", """", ""/* Total number of frames currently on all available frame queues. */"", ""#define RCEAFC_OFFSET     0x088"", """", ""/* CPC model length from the CSRSI Service. */"", ""#define CPCMODEL_LENGTH   16"", """", ""/* Thread Entry constants */"", ""#define PGTH_CURRENT  1"", ""#define PGTH_LEN      26"", ""#define PGTHAPATH     0x20"", ""#pragma linkage(BPX4GTH, OS)"", ""#pragma linkage(BPX1GTH, OS)"", """", ""typedef unsigned data_area_ptr_assign_type;"", """", ""typedef union {"", ""  struct {"", ""#if defined(_LP64)"", ""    data_area_ptr_assign_type lower;"", ""#endif"", ""    data_area_ptr_assign_type assign;"", ""  };"", ""  char* deref;"", ""} data_area_ptr;"", """", """", ""void uv_loadavg(double avg[3]) {"", ""  /* TODO: implement the following */"", ""  avg[0] = 0;"", ""  avg[1] = 0;"", ""  avg[2] = 0;"", ""}"", """", """", ""int uv__platform_loop_init(uv_loop_t* loop) {"", ""  uv__os390_epoll* ep;"", """", ""  ep = epoll_create1(UV__EPOLL_CLOEXEC);"", ""  loop->ep = ep;"", ""  if (ep == NULL)"", ""    return -errno;"", """", ""  return 0;"", ""}"", """", """", ""void uv__platform_loop_delete(uv_loop_t* loop) {"", ""  if (loop->ep != NULL) {"", ""    epoll_queue_close(loop->ep);"", ""    loop->ep = NULL;"", ""  }"", ""}"", """", """", ""uint64_t uv__hrtime(uv_clocktype_t type) {"", ""  struct timeval time;"", ""  gettimeofday(&time, NULL);"", ""  return (uint64_t) time.tv_sec * 1e9 + time.tv_usec * 1e3;"", ""}"", """", """", ""/*"", ""    Get the exe path using the thread entry information"", ""    in the address space."", ""*/"", ""static int getexe(const int pid, char* buf, size_t len) {"", ""  struct {"", ""    int pid;"", ""    int thid[2];"", ""    char accesspid;"", ""    char accessthid;"", ""    char asid[2];"", ""    char loginname[8];"", ""    char flag;"", ""    char len;"", ""  } Input_data;"", """", ""  union {"", ""    struct {"", ""      char gthb[4];"", ""      int pid;"", ""      int thid[2];"", ""      char accesspid;"", ""      char accessthid[3];"", ""      int lenused;"", ""      int offsetProcess;"", ""      int offsetConTTY;"", ""      int offsetPath;"", ""      int offsetCommand;"", ""      int offsetFileData;"", ""      int offsetThread;"", ""    } Output_data;"", ""    char buf[2048];"", ""  } Output_buf;"", """", ""  struct Output_path_type {"", ""    char gthe[4];"", ""    short int len;"", ""    char path[1024];"", ""  };"", """", ""  int Input_length;"", ""  int Output_length;"", ""  void* Input_address;"", ""  void* Output_address;"", ""  struct Output_path_type* Output_path;"", ""  int rv;"", ""  int rc;"", ""  int rsn;"", """", ""  Input_length = PGTH_LEN;"", ""  Output_length = sizeof(Output_buf);"", ""  Output_address = &Output_buf;"", ""  Input_address = &Input_data;"", ""  memset(&Input_data, 0, sizeof Input_data);"", ""  Input_data.flag |= PGTHAPATH;"", ""  Input_data.pid = pid;"", ""  Input_data.accesspid = PGTH_CURRENT;"", """", ""#ifdef _LP64"", ""  BPX4GTH(&Input_length,"", ""          &Input_address,"", ""          &Output_length,"", ""          &Output_address,"", ""          &rv,"", ""          &rc,"", ""          &rsn);"", ""#else"", ""  BPX1GTH(&Input_length,"", ""          &Input_address,"", ""          &Output_length,"", ""          &Output_address,"", ""          &rv,"", ""          &rc,"", ""          &rsn);"", ""#endif"", """", ""  if (rv == -1) {"", ""    errno = rc;"", ""    return -1;"", ""  }"", """", ""  /* Check highest byte to ensure data availability */"", ""  assert(((Output_buf.Output_data.offsetPath >>24) & 0xFF) == 'A');"", """", ""  /* Get the offset from the lowest 3 bytes */"", ""  Output_path = (char*)(&Output_buf) +"", ""                (Output_buf.Output_data.offsetPath & 0x00FFFFFF);"", """", ""  if (Output_path->len >= len) {"", ""    errno = ENOBUFS;"", ""    return -1;"", ""  }"", """", ""  strncpy(buf, Output_path->path, len);"", """", ""  return 0;"", ""}"", """", """", ""/*"", "" * We could use a static buffer for the path manipulations that we need outside"", "" * of the function, but this function could be called by multiple consumers and"", "" * we don't want to potentially create a race condition in the use of snprintf."", "" * There is no direct way of getting the exe path in zOS - either through /procfs"", "" * or through some libc APIs. The below approach is to parse the argv[0]'s pattern"", "" * and use it in conjunction with PATH environment variable to craft one."", "" */"", ""int uv_exepath(char* buffer, size_t* size) {"", ""  int res;"", ""  char args[PATH_MAX];"", ""  char abspath[PATH_MAX];"", ""  size_t abspath_size;"", ""  int pid;"", """", ""  if (buffer == NULL || size == NULL || *size == 0)"", ""    return -EINVAL;"", """", ""  pid = getpid();"", ""  res = getexe(pid, args, sizeof(args));"", ""  if (res < 0)"", ""    return -EINVAL;"", """", ""  /*"", ""   * Possibilities for args:"", ""   * i) an absolute path such as: /home/user/myprojects/nodejs/node"", ""   * ii) a relative path such as: ./node or ../myprojects/nodejs/node"", ""   * iii) a bare filename such as \""node\"", after exporting PATH variable"", ""   *     to its location."", ""   */"", """", ""  /* Case i) and ii) absolute or relative paths */"", ""  if (strchr(args, '/') != NULL) {"", ""    if (realpath(args, abspath) != abspath)"", ""      return -errno;"", """", ""    abspath_size = strlen(abspath);"", """", ""    *size -= 1;"", ""    if (*size > abspath_size)"", ""      *size = abspath_size;"", """", ""    memcpy(buffer, abspath, *size);"", ""    buffer[*size] = '\\0';"", """", ""    return 0;"", ""  } else {"", ""    /* Case iii). Search PATH environment variable */"", ""    char trypath[PATH_MAX];"", ""    char* clonedpath = NULL;"", ""    char* token = NULL;"", ""    char* path = getenv(\""PATH\"");"", """", ""    if (path == NULL)"", ""      return -EINVAL;"", """", ""    clonedpath = uv__strdup(path);"", ""    if (clonedpath == NULL)"", ""      return -ENOMEM;"", """", ""    token = strtok(clonedpath, \"":\"");"", ""    while (token != NULL) {"", ""      snprintf(trypath, sizeof(trypath) - 1, \""%s/%s\"", token, args);"", ""      if (realpath(trypath, abspath) == abspath) {"", ""        /* Check the match is executable */"", ""        if (access(abspath, X_OK) == 0) {"", ""          abspath_size = strlen(abspath);"", """", ""          *size -= 1;"", ""          if (*size > abspath_size)"", ""            *size = abspath_size;"", """", ""          memcpy(buffer, abspath, *size);"", ""          buffer[*size] = '\\0';"", """", ""          uv__free(clonedpath);"", ""          return 0;"", ""        }"", ""      }"", ""      token = strtok(NULL, \"":\"");"", ""    }"", ""    uv__free(clonedpath);"", """", ""    /* Out of tokens (path entries), and no match found */"", ""    return -EINVAL;"", ""  }"", ""}"", """", """", ""uint64_t uv_get_free_memory(void) {"", ""  uint64_t freeram;"", """", ""  data_area_ptr cvt = {0};"", ""  data_area_ptr rcep = {0};"", ""  cvt.assign = *(data_area_ptr_assign_type*)(CVT_PTR);"", ""  rcep.assign = *(data_area_ptr_assign_type*)(cvt.deref + CVTRCEP_OFFSET);"", ""  freeram = *((uint64_t*)(rcep.deref + RCEAFC_OFFSET)) * 4;"", ""  return freeram;"", ""}"", """", """", ""uint64_t uv_get_total_memory(void) {"", ""  uint64_t totalram;"", """", ""  data_area_ptr cvt = {0};"", ""  data_area_ptr rcep = {0};"", ""  cvt.assign = *(data_area_ptr_assign_type*)(CVT_PTR);"", ""  rcep.assign = *(data_area_ptr_assign_type*)(cvt.deref + CVTRCEP_OFFSET);"", ""  totalram = *((uint64_t*)(rcep.deref + RCEPOOL_OFFSET)) * 4;"", ""  return totalram;"", ""}"", """", """", ""int uv_resident_set_memory(size_t* rss) {"", ""  W_PSPROC buf;"", """", ""  memset(&buf, 0, sizeof(buf));"", ""  if (w_getpsent(0, &buf, sizeof(W_PSPROC)) == -1)"", ""    return -EINVAL;"", """", ""  *rss = buf.ps_size;"", ""  return 0;"", ""}"", """", """", ""int uv_uptime(double* uptime) {"", ""  struct utmpx u ;"", ""  struct utmpx *v;"", ""  time64_t t;"", """", ""  u.ut_type = BOOT_TIME;"", ""  v = getutxid(&u);"", ""  if (v == NULL)"", ""    return -1;"", ""  *uptime = difftime64(time64(&t), v->ut_tv.tv_sec);"", ""  return 0;"", ""}"", """", """", ""int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {"", ""  uv_cpu_info_t* cpu_info;"", ""  int result;"", ""  int idx;"", ""  siv1v2 info;"", ""  data_area_ptr cvt = {0};"", ""  data_area_ptr csd = {0};"", ""  data_area_ptr rmctrct = {0};"", ""  data_area_ptr cvtopctp = {0};"", ""  int cpu_usage_avg;"", """", ""  cvt.assign = *(data_area_ptr_assign_type*)(CVT_PTR);"", """", ""  csd.assign = *((data_area_ptr_assign_type *) (cvt.deref + CSD_OFFSET));"", ""  cvtopctp.assign = *((data_area_ptr_assign_type *) (cvt.deref + CVTOPCTP_OFFSET));"", ""  rmctrct.assign = *((data_area_ptr_assign_type *) (cvtopctp.deref + RMCTRCT_OFFSET));"", """", ""  *count = *((int*) (csd.deref + CSD_NUMBER_ONLINE_CPUS));"", ""  cpu_usage_avg = *((unsigned short int*) (rmctrct.deref + RCTLACS_OFFSET));"", """", ""  *cpu_infos = uv__malloc(*count * sizeof(uv_cpu_info_t));"", ""  if (!*cpu_infos)"", ""    return -ENOMEM;"", """", ""  cpu_info = *cpu_infos;"", ""  idx = 0;"", ""  while (idx < *count) {"", ""    cpu_info->speed = *(int*)(info.siv1v2si22v1.si22v1cpucapability);"", ""    cpu_info->model = uv__malloc(CPCMODEL_LENGTH + 1);"", ""    memset(cpu_info->model, '\\0', CPCMODEL_LENGTH + 1);"", ""    memcpy(cpu_info->model, info.siv1v2si11v1.si11v1cpcmodel, CPCMODEL_LENGTH);"", ""    cpu_info->cpu_times.user = cpu_usage_avg;"", ""    /* TODO: implement the following */"", ""    cpu_info->cpu_times.sys = 0;"", ""    cpu_info->cpu_times.idle = 0;"", ""    cpu_info->cpu_times.irq = 0;"", ""    cpu_info->cpu_times.nice = 0;"", ""    ++cpu_info;"", ""    ++idx;"", ""  }"", """", ""  return 0;"", ""}"", """", """", ""void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count) {"", ""  for (int i = 0; i < count; ++i)"", ""    uv__free(cpu_infos[i].model);"", ""  uv__free(cpu_infos);"", ""}"", """", """", ""static int uv__interface_addresses_v6(uv_interface_address_t** addresses,"", ""                                      int* count) {"", ""  uv_interface_address_t* address;"", ""  int sockfd;"", ""  int maxsize;"", ""  __net_ifconf6header_t ifc;"", ""  __net_ifconf6entry_t* ifr;"", ""  __net_ifconf6entry_t* p;"", ""  __net_ifconf6entry_t flg;"", """", ""  *count = 0;"", ""  /* Assume maximum buffer size allowable */"", ""  maxsize = 16384;"", """", ""  if (0 > (sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP)))"", ""    return -errno;"", """", ""  ifc.__nif6h_version = 1;"", ""  ifc.__nif6h_buflen = maxsize;"", ""  ifc.__nif6h_buffer = uv__calloc(1, maxsize);;"", """", ""  if (ioctl(sockfd, SIOCGIFCONF6, &ifc) == -1) {"", ""    uv__close(sockfd);"", ""    return -errno;"", ""  }"", """", """", ""  *count = 0;"", ""  ifr = (__net_ifconf6entry_t*)(ifc.__nif6h_buffer);"", ""  while ((char*)ifr < (char*)ifc.__nif6h_buffer + ifc.__nif6h_buflen) {"", ""    p = ifr;"", ""    ifr = (__net_ifconf6entry_t*)((char*)ifr + ifc.__nif6h_entrylen);"", """", ""    if (!(p->__nif6e_addr.sin6_family == AF_INET6 ||"", ""          p->__nif6e_addr.sin6_family == AF_INET))"", ""      continue;"", """", ""    if (!(p->__nif6e_flags & _NIF6E_FLAGS_ON_LINK_ACTIVE))"", ""      continue;"", """", ""    ++(*count);"", ""  }"", """", ""  /* Alloc the return interface structs */"", ""  *addresses = uv__malloc(*count * sizeof(uv_interface_address_t));"", ""  if (!(*addresses)) {"", ""    uv__close(sockfd);"", ""    return -ENOMEM;"", ""  }"", ""  address = *addresses;"", """", ""  ifr = (__net_ifconf6entry_t*)(ifc.__nif6h_buffer);"", ""  while ((char*)ifr < (char*)ifc.__nif6h_buffer + ifc.__nif6h_buflen) {"", ""    p = ifr;"", ""    ifr = (__net_ifconf6entry_t*)((char*)ifr + ifc.__nif6h_entrylen);"", """", ""    if (!(p->__nif6e_addr.sin6_family == AF_INET6 ||"", ""          p->__nif6e_addr.sin6_family == AF_INET))"", ""      continue;"", """", ""    if (!(p->__nif6e_flags & _NIF6E_FLAGS_ON_LINK_ACTIVE))"", ""      continue;"", """", ""    /* All conditions above must match count loop */"", """", ""    address->name = uv__strdup(p->__nif6e_name);"", """", ""    if (p->__nif6e_addr.sin6_family == AF_INET6)"", ""      address->address.address6 = *((struct sockaddr_in6*) &p->__nif6e_addr);"", ""    else"", ""      address->address.address4 = *((struct sockaddr_in*) &p->__nif6e_addr);"", """", ""    /* TODO: Retrieve netmask using SIOCGIFNETMASK ioctl */"", """", ""    address->is_internal = flg.__nif6e_flags & _NIF6E_FLAGS_LOOPBACK ? 1 : 0;"", """", ""    address++;"", ""  }"", """", ""  uv__close(sockfd);"", ""  return 0;"", ""}"", """", """", ""int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {"", ""  uv_interface_address_t* address;"", ""  int sockfd;"", ""  int maxsize;"", ""  struct ifconf ifc;"", ""  struct ifreq flg;"", ""  struct ifreq* ifr;"", ""  struct ifreq* p;"", ""  int count_v6;"", """", ""  /* get the ipv6 addresses first */"", ""  uv_interface_address_t* addresses_v6;"", ""  uv__interface_addresses_v6(&addresses_v6, &count_v6);"", """", ""  /* now get the ipv4 addresses */"", ""  *count = 0;"", """", ""  /* Assume maximum buffer size allowable */"", ""  maxsize = 16384;"", """", ""  sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);"", ""  if (0 > sockfd)"", ""    return -errno;"", """", ""  ifc.ifc_req = uv__calloc(1, maxsize);"", ""  ifc.ifc_len = maxsize;"", ""  if (ioctl(sockfd, SIOCGIFCONF, &ifc) == -1) {"", ""    uv__close(sockfd);"", ""    return -errno;"", ""  }"", """", ""#define MAX(a,b) (((a)>(b))?(a):(b))"", ""#define ADDR_SIZE(p) MAX((p).sa_len, sizeof(p))"", """", ""  /* Count all up and running ipv4/ipv6 addresses */"", ""  ifr = ifc.ifc_req;"", ""  while ((char*)ifr < (char*)ifc.ifc_req + ifc.ifc_len) {"", ""    p = ifr;"", ""    ifr = (struct ifreq*)"", ""      ((char*)ifr + sizeof(ifr->ifr_name) + ADDR_SIZE(ifr->ifr_addr));"", """", ""    if (!(p->ifr_addr.sa_family == AF_INET6 ||"", ""          p->ifr_addr.sa_family == AF_INET))"", ""      continue;"", """", ""    memcpy(flg.ifr_name, p->ifr_name, sizeof(flg.ifr_name));"", ""    if (ioctl(sockfd, SIOCGIFFLAGS, &flg) == -1) {"", ""      uv__close(sockfd);"", ""      return -errno;"", ""    }"", """", ""    if (!(flg.ifr_flags & IFF_UP && flg.ifr_flags & IFF_RUNNING))"", ""      continue;"", """", ""    (*count)++;"", ""  }"", """", ""  /* Alloc the return interface structs */"", ""  *addresses = uv__malloc((*count + count_v6) *"", ""                          sizeof(uv_interface_address_t));"", """", ""  if (!(*addresses)) {"", ""    uv__close(sockfd);"", ""    return -ENOMEM;"", ""  }"", ""  address = *addresses;"", """", ""  /* copy over the ipv6 addresses */"", ""  memcpy(address, addresses_v6, count_v6 * sizeof(uv_interface_address_t));"", ""  address += count_v6;"", ""  *count += count_v6;"", ""  uv__free(addresses_v6);"", """", ""  ifr = ifc.ifc_req;"", ""  while ((char*)ifr < (char*)ifc.ifc_req + ifc.ifc_len) {"", ""    p = ifr;"", ""    ifr = (struct ifreq*)"", ""      ((char*)ifr + sizeof(ifr->ifr_name) + ADDR_SIZE(ifr->ifr_addr));"", """", ""    if (!(p->ifr_addr.sa_family == AF_INET6 ||"", ""          p->ifr_addr.sa_family == AF_INET))"", ""      continue;"", """", ""    memcpy(flg.ifr_name, p->ifr_name, sizeof(flg.ifr_name));"", ""    if (ioctl(sockfd, SIOCGIFFLAGS, &flg) == -1) {"", ""      uv__close(sockfd);"", ""      return -ENOSYS;"", ""    }"", """", ""    if (!(flg.ifr_flags & IFF_UP && flg.ifr_flags & IFF_RUNNING))"", ""      continue;"", """", ""    /* All conditions above must match count loop */"", """", ""    address->name = uv__strdup(p->ifr_name);"", """", ""    if (p->ifr_addr.sa_family == AF_INET6) {"", ""      address->address.address6 = *((struct sockaddr_in6*) &p->ifr_addr);"", ""    } else {"", ""      address->address.address4 = *((struct sockaddr_in*) &p->ifr_addr);"", ""    }"", """", ""    address->is_internal = flg.ifr_flags & IFF_LOOPBACK ? 1 : 0;"", ""    address++;"", ""  }"", """", ""#undef ADDR_SIZE"", ""#undef MAX"", """", ""  uv__close(sockfd);"", ""  return 0;"", ""}"", """", """", ""void uv_free_interface_addresses(uv_interface_address_t* addresses,"", ""                                 int count) {"", ""  int i;"", ""  for (i = 0; i < count; ++i)"", ""    uv__free(addresses[i].name);"", ""  uv__free(addresses);"", ""}"", """", """", ""void uv__platform_invalidate_fd(uv_loop_t* loop, int fd) {"", ""  struct epoll_event* events;"", ""  struct epoll_event dummy;"", ""  uintptr_t i;"", ""  uintptr_t nfds;"", """", ""  assert(loop->watchers != NULL);"", """", ""  events = (struct epoll_event*) loop->watchers[loop->nwatchers];"", ""  nfds = (uintptr_t) loop->watchers[loop->nwatchers + 1];"", ""  if (events != NULL)"", ""    /* Invalidate events with same file descriptor */"", ""    for (i = 0; i < nfds; i++)"", ""      if ((int) events[i].fd == fd)"", ""        events[i].fd = -1;"", """", ""  /* Remove the file descriptor from the epoll. */"", ""  if (loop->ep != NULL)"", ""    epoll_ctl(loop->ep, UV__EPOLL_CTL_DEL, fd, &dummy);"", ""}"", """", """", ""int uv__io_check_fd(uv_loop_t* loop, int fd) {"", ""  struct pollfd p[1];""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[268, ""741b7621b3c71406359d75098f9bdf8d3567662f"", ""Merge branch 'upstream-libuv' into update-libuv\n\n* upstream-libuv:\n  libuv 2017-02-21 (52ae8264)"", ""Utilities/cmlibuv/src/unix/os390.c"", ""+"", ""snprintf(trypath, sizeof(trypath) - 1, \""%s/%s\"", token, args);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_37_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_37_new.cpp""]]",20,20
"["" */"", """", ""#include \""internal.h\"""", ""#include <sys/ioctl.h>"", ""#include <net/if.h>"", ""#include <utmpx.h>"", ""#include <unistd.h>"", ""#include <sys/ps.h>"", ""#if defined(__clang__)"", ""#include \""csrsic.h\"""", ""#else"", ""#include \""//'SYS1.SAMPLIB(CSRSIC)'\"""", ""#endif"", """", ""#define CVT_PTR           0x10"", ""#define CSD_OFFSET        0x294"", """", ""/*"", ""    Long-term average CPU service used by this logical partition,"", ""    in millions of service units per hour. If this value is above"", ""    the partition's defined capacity, the partition will be capped."", ""    It is calculated using the physical CPU adjustment factor"", ""    (RCTPCPUA) so it may not match other measures of service which"", ""    are based on the logical CPU adjustment factor. It is available"", ""    if the hardware supports LPAR cluster."", ""*/"", ""#define RCTLACS_OFFSET    0xC4"", """", ""/* 32-bit count of alive CPUs. This includes both CPs and IFAs */"", ""#define CSD_NUMBER_ONLINE_CPUS        0xD4"", """", ""/* Address of system resources manager (SRM) control table */"", ""#define CVTOPCTP_OFFSET   0x25C"", """", ""/* Address of the RCT table */"", ""#define RMCTRCT_OFFSET    0xE4"", """", ""/* Address of the rsm control and enumeration area. */"", ""#define CVTRCEP_OFFSET    0x490"", """", ""/*"", ""    Number of frames currently available to system."", ""    Excluded are frames backing perm storage, frames offline, and bad frames."", ""*/"", ""#define RCEPOOL_OFFSET    0x004"", """", ""/* Total number of frames currently on all available frame queues. */"", ""#define RCEAFC_OFFSET     0x088"", """", ""/* CPC model length from the CSRSI Service. */"", ""#define CPCMODEL_LENGTH   16"", """", ""/* Thread Entry constants */"", ""#define PGTH_CURRENT  1"", ""#define PGTH_LEN      26"", ""#define PGTHAPATH     0x20"", ""#pragma linkage(BPX4GTH, OS)"", ""#pragma linkage(BPX1GTH, OS)"", """", ""typedef unsigned data_area_ptr_assign_type;"", """", ""typedef union {"", ""  struct {"", ""#if defined(_LP64)"", ""    data_area_ptr_assign_type lower;"", ""#endif"", ""    data_area_ptr_assign_type assign;"", ""  };"", ""  char* deref;"", ""} data_area_ptr;"", """", """", ""void uv_loadavg(double avg[3]) {"", ""  /* TODO: implement the following */"", ""  avg[0] = 0;"", ""  avg[1] = 0;"", ""  avg[2] = 0;"", ""}"", """", """", ""int uv__platform_loop_init(uv_loop_t* loop) {"", ""  uv__os390_epoll* ep;"", """", ""  ep = epoll_create1(UV__EPOLL_CLOEXEC);"", ""  loop->ep = ep;"", ""  if (ep == NULL)"", ""    return -errno;"", """", ""  return 0;"", ""}"", """", """", ""void uv__platform_loop_delete(uv_loop_t* loop) {"", ""  if (loop->ep != NULL) {"", ""    epoll_queue_close(loop->ep);"", ""    loop->ep = NULL;"", ""  }"", ""}"", """", """", ""uint64_t uv__hrtime(uv_clocktype_t type) {"", ""  struct timeval time;"", ""  gettimeofday(&time, NULL);"", ""  return (uint64_t) time.tv_sec * 1e9 + time.tv_usec * 1e3;"", ""}"", """", """", ""/*"", ""    Get the exe path using the thread entry information"", ""    in the address space."", ""*/"", ""static int getexe(const int pid, char* buf, size_t len) {"", ""  struct {"", ""    int pid;"", ""    int thid[2];"", ""    char accesspid;"", ""    char accessthid;"", ""    char asid[2];"", ""    char loginname[8];"", ""    char flag;"", ""    char len;"", ""  } Input_data;"", """", ""  union {"", ""    struct {"", ""      char gthb[4];"", ""      int pid;"", ""      int thid[2];"", ""      char accesspid;"", ""      char accessthid[3];"", ""      int lenused;"", ""      int offsetProcess;"", ""      int offsetConTTY;"", ""      int offsetPath;"", ""      int offsetCommand;"", ""      int offsetFileData;"", ""      int offsetThread;"", ""    } Output_data;"", ""    char buf[2048];"", ""  } Output_buf;"", """", ""  struct Output_path_type {"", ""    char gthe[4];"", ""    short int len;"", ""    char path[1024];"", ""  };"", """", ""  int Input_length;"", ""  int Output_length;"", ""  void* Input_address;"", ""  void* Output_address;"", ""  struct Output_path_type* Output_path;"", ""  int rv;"", ""  int rc;"", ""  int rsn;"", """", ""  Input_length = PGTH_LEN;"", ""  Output_length = sizeof(Output_buf);"", ""  Output_address = &Output_buf;"", ""  Input_address = &Input_data;"", ""  memset(&Input_data, 0, sizeof Input_data);"", ""  Input_data.flag |= PGTHAPATH;"", ""  Input_data.pid = pid;"", ""  Input_data.accesspid = PGTH_CURRENT;"", """", ""#ifdef _LP64"", ""  BPX4GTH(&Input_length,"", ""          &Input_address,"", ""          &Output_length,"", ""          &Output_address,"", ""          &rv,"", ""          &rc,"", ""          &rsn);"", ""#else"", ""  BPX1GTH(&Input_length,"", ""          &Input_address,"", ""          &Output_length,"", ""          &Output_address,"", ""          &rv,"", ""          &rc,"", ""          &rsn);"", ""#endif"", """", ""  if (rv == -1) {"", ""    errno = rc;"", ""    return -1;"", ""  }"", """", ""  /* Check highest byte to ensure data availability */"", ""  assert(((Output_buf.Output_data.offsetPath >>24) & 0xFF) == 'A');"", """", ""  /* Get the offset from the lowest 3 bytes */"", ""  Output_path = (char*)(&Output_buf) +"", ""                (Output_buf.Output_data.offsetPath & 0x00FFFFFF);"", """", ""  if (Output_path->len >= len) {"", ""    errno = ENOBUFS;"", ""    return -1;"", ""  }"", """", ""  strncpy(buf, Output_path->path, len);"", """", ""  return 0;"", ""}"", """", """", ""/*"", "" * We could use a static buffer for the path manipulations that we need outside"", "" * of the function, but this function could be called by multiple consumers and"", "" * we don't want to potentially create a race condition in the use of snprintf."", "" * There is no direct way of getting the exe path in zOS - either through /procfs"", "" * or through some libc APIs. The below approach is to parse the argv[0]'s pattern"", "" * and use it in conjunction with PATH environment variable to craft one."", "" */"", ""int uv_exepath(char* buffer, size_t* size) {"", ""  int res;"", ""  char args[PATH_MAX];"", ""  char abspath[PATH_MAX];"", ""  size_t abspath_size;"", ""  int pid;"", """", ""  if (buffer == NULL || size == NULL || *size == 0)"", ""    return -EINVAL;"", """", ""  pid = getpid();"", ""  res = getexe(pid, args, sizeof(args));"", ""  if (res < 0)"", ""    return -EINVAL;"", """", ""  /*"", ""   * Possibilities for args:"", ""   * i) an absolute path such as: /home/user/myprojects/nodejs/node"", ""   * ii) a relative path such as: ./node or ../myprojects/nodejs/node"", ""   * iii) a bare filename such as \""node\"", after exporting PATH variable"", ""   *     to its location."", ""   */"", """", ""  /* Case i) and ii) absolute or relative paths */"", ""  if (strchr(args, '/') != NULL) {"", ""    if (realpath(args, abspath) != abspath)"", ""      return -errno;"", """", ""    abspath_size = strlen(abspath);"", """", ""    *size -= 1;"", ""    if (*size > abspath_size)"", ""      *size = abspath_size;"", """", ""    memcpy(buffer, abspath, *size);"", ""    buffer[*size] = '\\0';"", """", ""    return 0;"", ""  } else {"", ""    /* Case iii). Search PATH environment variable */"", ""    char trypath[PATH_MAX];"", ""    char* clonedpath = NULL;"", ""    char* token = NULL;"", ""    char* path = getenv(\""PATH\"");"", """", ""    if (path == NULL)"", ""      return -EINVAL;"", """", ""    clonedpath = uv__strdup(path);"", ""    if (clonedpath == NULL)"", ""      return -ENOMEM;"", """", ""    token = strtok(clonedpath, \"":\"");"", ""    while (token != NULL) {"", ""      snprintf(trypath, sizeof(trypath) - 1, \""%s/%s\"", token, args);"", ""      if (realpath(trypath, abspath) == abspath) {"", ""        /* Check the match is executable */"", ""        if (access(abspath, X_OK) == 0) {"", ""          abspath_size = strlen(abspath);"", """", ""          *size -= 1;"", ""          if (*size > abspath_size)"", ""            *size = abspath_size;"", """", ""          memcpy(buffer, abspath, *size);"", ""          buffer[*size] = '\\0';"", """", ""          uv__free(clonedpath);"", ""          return 0;"", ""        }"", ""      }"", ""      token = strtok(NULL, \"":\"");"", ""    }"", ""    uv__free(clonedpath);"", """", ""    /* Out of tokens (path entries), and no match found */"", ""    return -EINVAL;"", ""  }"", ""}"", """", """", ""uint64_t uv_get_free_memory(void) {"", ""  uint64_t freeram;"", """", ""  data_area_ptr cvt = {0};"", ""  data_area_ptr rcep = {0};"", ""  cvt.assign = *(data_area_ptr_assign_type*)(CVT_PTR);"", ""  rcep.assign = *(data_area_ptr_assign_type*)(cvt.deref + CVTRCEP_OFFSET);"", ""  freeram = *((uint64_t*)(rcep.deref + RCEAFC_OFFSET)) * 4;"", ""  return freeram;"", ""}"", """", """", ""uint64_t uv_get_total_memory(void) {"", ""  uint64_t totalram;"", """", ""  data_area_ptr cvt = {0};"", ""  data_area_ptr rcep = {0};"", ""  cvt.assign = *(data_area_ptr_assign_type*)(CVT_PTR);"", ""  rcep.assign = *(data_area_ptr_assign_type*)(cvt.deref + CVTRCEP_OFFSET);"", ""  totalram = *((uint64_t*)(rcep.deref + RCEPOOL_OFFSET)) * 4;"", ""  return totalram;"", ""}"", """", """", ""int uv_resident_set_memory(size_t* rss) {"", ""  W_PSPROC buf;"", """", ""  memset(&buf, 0, sizeof(buf));"", ""  if (w_getpsent(0, &buf, sizeof(W_PSPROC)) == -1)"", ""    return -EINVAL;"", """", ""  *rss = buf.ps_size;"", ""  return 0;"", ""}"", """", """", ""int uv_uptime(double* uptime) {"", ""  struct utmpx u ;"", ""  struct utmpx *v;"", ""  time64_t t;"", """", ""  u.ut_type = BOOT_TIME;"", ""  v = getutxid(&u);"", ""  if (v == NULL)"", ""    return -1;"", ""  *uptime = difftime64(time64(&t), v->ut_tv.tv_sec);"", ""  return 0;"", ""}"", """", """", ""int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {"", ""  uv_cpu_info_t* cpu_info;"", ""  int result;"", ""  int idx;"", ""  siv1v2 info;"", ""  data_area_ptr cvt = {0};"", ""  data_area_ptr csd = {0};"", ""  data_area_ptr rmctrct = {0};"", ""  data_area_ptr cvtopctp = {0};"", ""  int cpu_usage_avg;"", """", ""  cvt.assign = *(data_area_ptr_assign_type*)(CVT_PTR);"", """", ""  csd.assign = *((data_area_ptr_assign_type *) (cvt.deref + CSD_OFFSET));"", ""  cvtopctp.assign = *((data_area_ptr_assign_type *) (cvt.deref + CVTOPCTP_OFFSET));"", ""  rmctrct.assign = *((data_area_ptr_assign_type *) (cvtopctp.deref + RMCTRCT_OFFSET));"", """", ""  *count = *((int*) (csd.deref + CSD_NUMBER_ONLINE_CPUS));"", ""  cpu_usage_avg = *((unsigned short int*) (rmctrct.deref + RCTLACS_OFFSET));"", """", ""  *cpu_infos = uv__malloc(*count * sizeof(uv_cpu_info_t));"", ""  if (!*cpu_infos)"", ""    return -ENOMEM;"", """", ""  cpu_info = *cpu_infos;"", ""  idx = 0;"", ""  while (idx < *count) {"", ""    cpu_info->speed = *(int*)(info.siv1v2si22v1.si22v1cpucapability);"", ""    cpu_info->model = uv__malloc(CPCMODEL_LENGTH + 1);"", ""    memset(cpu_info->model, '\\0', CPCMODEL_LENGTH + 1);"", ""    memcpy(cpu_info->model, info.siv1v2si11v1.si11v1cpcmodel, CPCMODEL_LENGTH);"", ""    cpu_info->cpu_times.user = cpu_usage_avg;"", ""    /* TODO: implement the following */"", ""    cpu_info->cpu_times.sys = 0;"", ""    cpu_info->cpu_times.idle = 0;"", ""    cpu_info->cpu_times.irq = 0;"", ""    cpu_info->cpu_times.nice = 0;"", ""    ++cpu_info;"", ""    ++idx;"", ""  }"", """", ""  return 0;"", ""}"", """", """", ""void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count) {"", ""  for (int i = 0; i < count; ++i)"", ""    uv__free(cpu_infos[i].model);"", ""  uv__free(cpu_infos);"", ""}"", """", """", ""static int uv__interface_addresses_v6(uv_interface_address_t** addresses,"", ""                                      int* count) {"", ""  uv_interface_address_t* address;"", ""  int sockfd;"", ""  int maxsize;"", ""  __net_ifconf6header_t ifc;"", ""  __net_ifconf6entry_t* ifr;"", ""  __net_ifconf6entry_t* p;"", ""  __net_ifconf6entry_t flg;"", """", ""  *count = 0;"", ""  /* Assume maximum buffer size allowable */"", ""  maxsize = 16384;"", """", ""  if (0 > (sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP)))"", ""    return -errno;"", """", ""  ifc.__nif6h_version = 1;"", ""  ifc.__nif6h_buflen = maxsize;"", ""  ifc.__nif6h_buffer = uv__calloc(1, maxsize);;"", """", ""  if (ioctl(sockfd, SIOCGIFCONF6, &ifc) == -1) {"", ""    uv__close(sockfd);"", ""    return -errno;"", ""  }"", """", """", ""  *count = 0;"", ""  ifr = (__net_ifconf6entry_t*)(ifc.__nif6h_buffer);"", ""  while ((char*)ifr < (char*)ifc.__nif6h_buffer + ifc.__nif6h_buflen) {"", ""    p = ifr;"", ""    ifr = (__net_ifconf6entry_t*)((char*)ifr + ifc.__nif6h_entrylen);"", """", ""    if (!(p->__nif6e_addr.sin6_family == AF_INET6 ||"", ""          p->__nif6e_addr.sin6_family == AF_INET))"", ""      continue;"", """", ""    if (!(p->__nif6e_flags & _NIF6E_FLAGS_ON_LINK_ACTIVE))"", ""      continue;"", """", ""    ++(*count);"", ""  }"", """", ""  /* Alloc the return interface structs */"", ""  *addresses = uv__malloc(*count * sizeof(uv_interface_address_t));"", ""  if (!(*addresses)) {"", ""    uv__close(sockfd);"", ""    return -ENOMEM;"", ""  }"", ""  address = *addresses;"", """", ""  ifr = (__net_ifconf6entry_t*)(ifc.__nif6h_buffer);"", ""  while ((char*)ifr < (char*)ifc.__nif6h_buffer + ifc.__nif6h_buflen) {"", ""    p = ifr;"", ""    ifr = (__net_ifconf6entry_t*)((char*)ifr + ifc.__nif6h_entrylen);"", """", ""    if (!(p->__nif6e_addr.sin6_family == AF_INET6 ||"", ""          p->__nif6e_addr.sin6_family == AF_INET))"", ""      continue;"", """", ""    if (!(p->__nif6e_flags & _NIF6E_FLAGS_ON_LINK_ACTIVE))"", ""      continue;"", """", ""    /* All conditions above must match count loop */"", """", ""    address->name = uv__strdup(p->__nif6e_name);"", """", ""    if (p->__nif6e_addr.sin6_family == AF_INET6)"", ""      address->address.address6 = *((struct sockaddr_in6*) &p->__nif6e_addr);"", ""    else"", ""      address->address.address4 = *((struct sockaddr_in*) &p->__nif6e_addr);"", """", ""    /* TODO: Retrieve netmask using SIOCGIFNETMASK ioctl */"", """", ""    address->is_internal = flg.__nif6e_flags & _NIF6E_FLAGS_LOOPBACK ? 1 : 0;"", """", ""    address++;"", ""  }"", """", ""  uv__close(sockfd);"", ""  return 0;"", ""}"", """", """", ""int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {"", ""  uv_interface_address_t* address;"", ""  int sockfd;"", ""  int maxsize;"", ""  struct ifconf ifc;"", ""  struct ifreq flg;"", ""  struct ifreq* ifr;"", ""  struct ifreq* p;"", ""  int count_v6;"", """", ""  /* get the ipv6 addresses first */"", ""  uv_interface_address_t* addresses_v6;"", ""  uv__interface_addresses_v6(&addresses_v6, &count_v6);"", """", ""  /* now get the ipv4 addresses */"", ""  *count = 0;"", """", ""  /* Assume maximum buffer size allowable */"", ""  maxsize = 16384;"", """", ""  sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);"", ""  if (0 > sockfd)"", ""    return -errno;"", """", ""  ifc.ifc_req = uv__calloc(1, maxsize);"", ""  ifc.ifc_len = maxsize;"", ""  if (ioctl(sockfd, SIOCGIFCONF, &ifc) == -1) {"", ""    uv__close(sockfd);"", ""    return -errno;"", ""  }"", """", ""#define MAX(a,b) (((a)>(b))?(a):(b))"", ""#define ADDR_SIZE(p) MAX((p).sa_len, sizeof(p))"", """", ""  /* Count all up and running ipv4/ipv6 addresses */"", ""  ifr = ifc.ifc_req;"", ""  while ((char*)ifr < (char*)ifc.ifc_req + ifc.ifc_len) {"", ""    p = ifr;"", ""    ifr = (struct ifreq*)"", ""      ((char*)ifr + sizeof(ifr->ifr_name) + ADDR_SIZE(ifr->ifr_addr));"", """", ""    if (!(p->ifr_addr.sa_family == AF_INET6 ||"", ""          p->ifr_addr.sa_family == AF_INET))"", ""      continue;"", """", ""    memcpy(flg.ifr_name, p->ifr_name, sizeof(flg.ifr_name));"", ""    if (ioctl(sockfd, SIOCGIFFLAGS, &flg) == -1) {"", ""      uv__close(sockfd);"", ""      return -errno;"", ""    }"", """", ""    if (!(flg.ifr_flags & IFF_UP && flg.ifr_flags & IFF_RUNNING))"", ""      continue;"", """", ""    (*count)++;"", ""  }"", """", ""  /* Alloc the return interface structs */"", ""  *addresses = uv__malloc((*count + count_v6) *"", ""                          sizeof(uv_interface_address_t));"", """", ""  if (!(*addresses)) {"", ""    uv__close(sockfd);"", ""    return -ENOMEM;"", ""  }"", ""  address = *addresses;"", """", ""  /* copy over the ipv6 addresses */"", ""  memcpy(address, addresses_v6, count_v6 * sizeof(uv_interface_address_t));"", ""  address += count_v6;"", ""  *count += count_v6;"", ""  uv__free(addresses_v6);"", """", ""  ifr = ifc.ifc_req;"", ""  while ((char*)ifr < (char*)ifc.ifc_req + ifc.ifc_len) {"", ""    p = ifr;"", ""    ifr = (struct ifreq*)"", ""      ((char*)ifr + sizeof(ifr->ifr_name) + ADDR_SIZE(ifr->ifr_addr));"", """", ""    if (!(p->ifr_addr.sa_family == AF_INET6 ||"", ""          p->ifr_addr.sa_family == AF_INET))"", ""      continue;"", """", ""    memcpy(flg.ifr_name, p->ifr_name, sizeof(flg.ifr_name));"", ""    if (ioctl(sockfd, SIOCGIFFLAGS, &flg) == -1) {"", ""      uv__close(sockfd);"", ""      return -ENOSYS;"", ""    }"", """", ""    if (!(flg.ifr_flags & IFF_UP && flg.ifr_flags & IFF_RUNNING))"", ""      continue;"", """", ""    /* All conditions above must match count loop */"", """", ""    address->name = uv__strdup(p->ifr_name);"", """", ""    if (p->ifr_addr.sa_family == AF_INET6) {"", ""      address->address.address6 = *((struct sockaddr_in6*) &p->ifr_addr);"", ""    } else {"", ""      address->address.address4 = *((struct sockaddr_in*) &p->ifr_addr);"", ""    }"", """", ""    address->is_internal = flg.ifr_flags & IFF_LOOPBACK ? 1 : 0;"", ""    address++;"", ""  }"", """", ""#undef ADDR_SIZE"", ""#undef MAX"", """", ""  uv__close(sockfd);"", ""  return 0;"", ""}"", """", """", ""void uv_free_interface_addresses(uv_interface_address_t* addresses,"", ""                                 int count) {"", ""  int i;"", ""  for (i = 0; i < count; ++i)"", ""    uv__free(addresses[i].name);"", ""  uv__free(addresses);"", ""}"", """", """", ""void uv__platform_invalidate_fd(uv_loop_t* loop, int fd) {"", ""  struct epoll_event* events;"", ""  struct epoll_event dummy;"", ""  uintptr_t i;"", ""  uintptr_t nfds;"", """", ""  assert(loop->watchers != NULL);"", """", ""  events = (struct epoll_event*) loop->watchers[loop->nwatchers];"", ""  nfds = (uintptr_t) loop->watchers[loop->nwatchers + 1];"", ""  if (events != NULL)"", ""    /* Invalidate events with same file descriptor */"", ""    for (i = 0; i < nfds; i++)"", ""      if ((int) events[i].fd == fd)"", ""        events[i].fd = -1;"", """", ""  /* Remove the file descriptor from the epoll. */"", ""  if (loop->ep != NULL)"", ""    epoll_ctl(loop->ep, UV__EPOLL_CTL_DEL, fd, &dummy);"", ""}"", """", """", ""int uv__io_check_fd(uv_loop_t* loop, int fd) {"", ""  struct pollfd p[1];""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[268, ""1f661e87a6a8304edb77bd30b546e5d113477c59"", ""libuv 2017-02-21 (52ae8264)\n\nCode extracted from:\n\n    https://github.com/libuv/libuv.git\n\nat commit 52ae826492f50f151138ed115faa5e0ac8c803ce (v1.x)."", ""src/unix/os390.c"", ""+"", ""snprintf(trypath, sizeof(trypath) - 1, \""%s/%s\"", token, args);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_38_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_38_new.cpp""]]",20,20
"[""\tname = archive_entry_sourcepath(entry);"", ""\tif (name == NULL)"", ""\t\tname = archive_entry_pathname(entry);"", ""\telse if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {"", ""\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""Can't change dir to read extended attributes\"");"", ""\t\t\treturn (ARCHIVE_FAILED);"", ""\t}"", ""\tif (name == NULL) {"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Can't open file to read extended attributes: No name\"");"", ""\t\treturn (ARCHIVE_WARN);"", ""\t}"", """", ""\tif (a->tree != NULL) {"", ""\t\tif (a->tree_enter_working_dir(a->tree) != 0) {"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Couldn't change dir\"");"", ""\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t}"", ""\t}"", """", ""\t/* Short-circuit if there's nothing to do. */"", ""\thave_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);"", ""\tif (have_attrs == -1) {""]","[0, 0, 0, 1, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, -1, -1, -2, -1, -1, -1, -1, -1, 0, 0, 0]","[[4, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""], [16, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""-"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""]]",302,321
"[""}"", ""#endif"", """", ""#if HAVE_DARWIN_ACL"", ""static int translate_guid(struct archive *, acl_entry_t,"", ""    int *, int *, const char **);"", """", ""static void add_trivial_nfs4_acl(struct archive_entry *);"", ""#endif"", """", ""#if HAVE_SUN_ACL"", ""static int"", ""sun_acl_is_trivial(acl_t *, mode_t, int *trivialp);"", ""#endif"", """", ""#ifdef HAVE_POSIX_ACL"", ""#if HAVE_POSIX_ACL || HAVE_NFS4_ACL"", ""static int translate_acl(struct archive_read_disk *a,"", ""    struct archive_entry *entry, acl_t acl, int archive_entry_acl_type);"", ""    struct archive_entry *entry,"", ""#if HAVE_SUN_ACL"", ""    acl_t *acl,"", ""#else"", ""    acl_t acl,"", ""#endif"", ""    int archive_entry_acl_type);"", """", ""static int"", ""setup_acls(struct archive_read_disk *a,"", ""    struct archive_entry *entry, int *fd)"", ""{"", ""\tconst char\t*accpath;"", ""\tacl_t\t\t acl;"", ""#if HAVE_ACL_IS_TRIVIAL_NP"", ""\tint\t\tr;"", ""#if HAVE_SUN_ACL"", ""\tacl_t\t\t*acl;"", ""#else"", ""\tacl_t\t\tacl;"", ""#endif"", ""\tint\t\tr;"", """", ""\taccpath = archive_entry_sourcepath(entry);"", ""\tif (accpath == NULL)"", ""\t\taccpath = archive_entry_pathname(entry);"", ""\taccpath = NULL;"", """", ""#if HAVE_SUN_ACL || HAVE_DARWIN_ACL || HAVE_ACL_GET_FD_NP"", ""\tif (*fd < 0)"", ""#else"", ""\t/* For default ACLs on Linux we need reachable accpath */"", ""\tif (*fd < 0 || S_ISDIR(archive_entry_mode(entry)))"", ""#endif"", ""\t{"", ""\t\taccpath = archive_entry_sourcepath(entry);"", ""\t\tif (accpath == NULL || (a->tree != NULL &&"", ""\t\t    a->tree_enter_working_dir(a->tree) != 0))"", ""\t\t\taccpath = archive_entry_pathname(entry);"", ""\t\tif (accpath == NULL) {"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Couldn't determine file path to read ACLs\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tif (a->tree != NULL &&"", ""#if !HAVE_SUN_ACL && !HAVE_DARWIN_ACL && !HAVE_ACL_GET_FD_NP"", ""\t\t    *fd < 0 &&"", ""#endif"", ""\t\t    (a->follow_symlinks ||"", ""\t\t    archive_entry_filetype(entry) != AE_IFLNK)) {"", ""\t\t\t*fd = a->open_on_current_dir(a->tree,"", ""\t\t\t    accpath, O_RDONLY | O_NONBLOCK);"", ""\t\t}"", ""\t}"", """", ""\tarchive_entry_acl_clear(entry);"", """", ""#ifdef ACL_TYPE_NFS4"", ""\t/* Try NFS4 ACL first. */"", ""\tacl = NULL;"", """", ""#if HAVE_NFS4_ACL"", ""\t/* Try NFSv4 ACL first. */"", ""\tif (*fd >= 0)"", ""#if HAVE_SUN_ACL"", ""\t\t/* Solaris reads both POSIX.1e and NFSv4 ACL here */"", ""\t\tfacl_get(*fd, 0, &acl);"", ""#elif HAVE_ACL_GET_FD_NP"", ""\t\tacl = acl_get_fd_np(*fd, ARCHIVE_PLATFORM_ACL_TYPE_NFS4);"", ""#else"", ""\t\tacl = acl_get_fd(*fd);"", ""#endif"", ""#if HAVE_ACL_GET_LINK_NP"", ""\telse if (!a->follow_symlinks)"", ""\t\tacl = acl_get_link_np(accpath, ACL_TYPE_NFS4);"", ""\t\tacl = acl_get_link_np(accpath, ARCHIVE_PLATFORM_ACL_TYPE_NFS4);"", ""#else"", ""\telse if ((!a->follow_symlinks)"", ""\t    && (archive_entry_filetype(entry) == AE_IFLNK))""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, -1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 1, 0, 1, 0, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, -1, -1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, -1, 1, 0, 0, 0]","[[59, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""]]",400,416
"[""\t\tacl = NULL;"", ""#endif"", ""\telse"", ""\t\tacl = acl_get_file(accpath, ACL_TYPE_NFS4);"", ""#if HAVE_ACL_IS_TRIVIAL_NP"", ""#if HAVE_SUN_ACL"", ""\t\t/* Solaris reads both POSIX.1e and NFSv4 ACLs here */"", ""\t\tacl_get(accpath, 0, &acl);"", ""#else"", ""\t\tacl = acl_get_file(accpath, ARCHIVE_PLATFORM_ACL_TYPE_NFS4);"", ""#endif"", """", """", ""#if HAVE_ACL_IS_TRIVIAL_NP || HAVE_SUN_ACL"", ""\t/* Ignore \""trivial\"" ACLs that just mirror the file mode. */"", ""\tacl_is_trivial_np(acl, &r);"", ""\tif (r) {"", ""\t\tacl_free(acl);"", ""\t\tacl = NULL;"", ""\t}"", ""\tif (acl != NULL) {"", ""#if HAVE_SUN_ACL"", ""\t\tif (sun_acl_is_trivial(acl, archive_entry_mode(entry),"", ""\t\t    &r) == 0 && r == 1)"", ""#elif HAVE_ACL_IS_TRIVIAL_NP"", ""\t\tif (acl_is_trivial_np(acl, &r) == 0 && r == 1)"", ""#endif"", ""\t\t{"", ""\t\t\tacl_free(acl);"", ""\t\t\tacl = NULL;"", ""\t\t\t/*"", ""\t\t\t * Simultaneous NFSv4 and POSIX.1e ACLs for the same"", ""\t\t\t * entry are not allowed, so we should return here"", ""\t\t\t */"", ""\t\t\treturn (ARCHIVE_OK);"", ""\t\t}"", ""\t}"", ""#endif\t/* HAVE_ACL_IS_TRIVIAL_NP || HAVE_SUN_ACL */"", ""\tif (acl != NULL) {"", ""\t\ttranslate_acl(a, entry, acl, ARCHIVE_ENTRY_ACL_TYPE_NFS4);"", ""\t\tr = translate_acl(a, entry, acl, ARCHIVE_ENTRY_ACL_TYPE_NFS4);"", ""\t\tacl_free(acl);"", ""\t\treturn (ARCHIVE_OK);"", ""\t}"", ""\t\tif (r != ARCHIVE_OK) {"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""Couldn't translate \"""", ""#if !HAVE_SUN_ACL"", ""\t\t\t    \""NFSv4 \"""", ""#endif"", ""\t\t\t    \""ACLs\"");"", ""\t\t}"", ""#if HAVE_DARWIN_ACL"", ""\t\t/*"", ""\t\t * Because Mac OS doesn't support owner@, group@ and everyone@"", ""\t\t * ACLs we need to add NFSv4 ACLs mirroring the file mode to"", ""\t\t * the archive entry. Otherwise extraction on non-Mac platforms"", ""\t\t * would lead to an invalid file mode."", ""\t\t */"", ""\t\tif ((archive_entry_acl_types(entry) &"", ""\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0)"", ""\t\t\tadd_trivial_nfs4_acl(entry);"", ""#endif"", ""\t\treturn (r);"", ""\t}"", ""#endif\t/* HAVE_NFS4_ACL */"", """", ""#if HAVE_POSIX_ACL"", ""\t/* This code path is skipped on MacOS and Solaris */"", """", ""\t/* Retrieve access ACL from file. */"", ""\tif (*fd >= 0)""]","[0, 0, 0, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, -1, -1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[45, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""]]",436,505
"[""#endif"", ""\telse"", ""\t\tacl = acl_get_file(accpath, ACL_TYPE_ACCESS);"", """", ""#if HAVE_ACL_IS_TRIVIAL_NP"", ""\t/* Ignore \""trivial\"" ACLs that just mirror the file mode. */"", ""\tif (acl != NULL && acl_is_trivial_np(acl, &r) == 0) {"", ""\t\tif (r) {"", ""\t\t\tacl_free(acl);"", ""\t\t\tacl = NULL;"", ""\t\t}"", ""\t}"", ""#endif"", """", ""\tif (acl != NULL) {"", ""\t\ttranslate_acl(a, entry, acl,"", ""\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);"", ""\t\tr = translate_acl(a, entry, acl, ARCHIVE_ENTRY_ACL_TYPE_ACCESS);"", ""\t\tacl_free(acl);"", ""\t\tacl = NULL;"", ""\t\tif (r != ARCHIVE_OK) {"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""Couldn't translate access ACLs\"");"", ""\t\t\treturn (r);"", ""\t\t}"", ""\t}"", """", ""\t/* Only directories can have default ACLs. */"", ""\tif (S_ISDIR(archive_entry_mode(entry))) {"", ""#if HAVE_ACL_GET_FD_NP"", ""\t\tif (*fd >= 0)"", ""\t\t\tacl = acl_get_fd_np(*fd, ACL_TYPE_DEFAULT);"", ""\t\telse"", ""#endif"", ""\t\tacl = acl_get_file(accpath, ACL_TYPE_DEFAULT);"", ""\t\tif (acl != NULL) {"", ""\t\t\ttranslate_acl(a, entry, acl,"", ""\t\t\tr = translate_acl(a, entry, acl,"", ""\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);"", ""\t\t\tacl_free(acl);"", ""\t\t\tif (r != ARCHIVE_OK) {"", ""\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Couldn't translate default ACLs\"");"", ""\t\t\t\treturn (r);"", ""\t\t\t}"", ""\t\t}"", ""\t}"", ""#endif\t/* HAVE_POSIX_ACL */"", ""\treturn (ARCHIVE_OK);"", ""}"", """", ""/*"", "" * Translate system ACL into libarchive internal structure."", "" * Translate system ACL permissions into libarchive internal structure"", "" */"", """", ""static struct {"", ""        int archive_perm;"", ""        int platform_perm;"", ""static const struct {"", ""\tconst int archive_perm;"", ""\tconst int platform_perm;"", ""} acl_perm_map[] = {"", ""        {ARCHIVE_ENTRY_ACL_EXECUTE, ACL_EXECUTE},"", ""        {ARCHIVE_ENTRY_ACL_WRITE, ACL_WRITE},"", ""        {ARCHIVE_ENTRY_ACL_READ, ACL_READ},"", ""#ifdef ACL_TYPE_NFS4"", ""        {ARCHIVE_ENTRY_ACL_READ_DATA, ACL_READ_DATA},"", ""        {ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, ACL_LIST_DIRECTORY},"", ""        {ARCHIVE_ENTRY_ACL_WRITE_DATA, ACL_WRITE_DATA},"", ""        {ARCHIVE_ENTRY_ACL_ADD_FILE, ACL_ADD_FILE},"", ""        {ARCHIVE_ENTRY_ACL_APPEND_DATA, ACL_APPEND_DATA},"", ""        {ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY, ACL_ADD_SUBDIRECTORY},"", ""        {ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS, ACL_READ_NAMED_ATTRS},"", ""        {ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS, ACL_WRITE_NAMED_ATTRS},"", ""        {ARCHIVE_ENTRY_ACL_DELETE_CHILD, ACL_DELETE_CHILD},"", ""        {ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES, ACL_READ_ATTRIBUTES},"", ""        {ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES, ACL_WRITE_ATTRIBUTES},"", ""        {ARCHIVE_ENTRY_ACL_DELETE, ACL_DELETE},"", ""        {ARCHIVE_ENTRY_ACL_READ_ACL, ACL_READ_ACL},"", ""        {ARCHIVE_ENTRY_ACL_WRITE_ACL, ACL_WRITE_ACL},"", ""        {ARCHIVE_ENTRY_ACL_WRITE_OWNER, ACL_WRITE_OWNER},"", ""        {ARCHIVE_ENTRY_ACL_SYNCHRONIZE, ACL_SYNCHRONIZE}"", ""#if HAVE_SUN_ACL\t/* Solaris NFSv4 ACL permissions */"", ""\t{ARCHIVE_ENTRY_ACL_EXECUTE, ACE_EXECUTE},"", ""\t{ARCHIVE_ENTRY_ACL_READ_DATA, ACE_READ_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, ACE_LIST_DIRECTORY},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_DATA, ACE_WRITE_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_ADD_FILE, ACE_ADD_FILE},"", ""\t{ARCHIVE_ENTRY_ACL_APPEND_DATA, ACE_APPEND_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY, ACE_ADD_SUBDIRECTORY},"", ""\t{ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS, ACE_READ_NAMED_ATTRS},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS, ACE_WRITE_NAMED_ATTRS},"", ""\t{ARCHIVE_ENTRY_ACL_DELETE_CHILD, ACE_DELETE_CHILD},"", ""\t{ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES, ACE_READ_ATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES, ACE_WRITE_ATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_DELETE, ACE_DELETE},"", ""\t{ARCHIVE_ENTRY_ACL_READ_ACL, ACE_READ_ACL},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_ACL, ACE_WRITE_ACL},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_OWNER, ACE_WRITE_OWNER},"", ""\t{ARCHIVE_ENTRY_ACL_SYNCHRONIZE, ACE_SYNCHRONIZE}"", ""#elif HAVE_DARWIN_ACL\t/* MacOS ACL permissions */"", ""\t{ARCHIVE_ENTRY_ACL_READ_DATA, ACL_READ_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, ACL_LIST_DIRECTORY},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_DATA, ACL_WRITE_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_ADD_FILE, ACL_ADD_FILE},"", ""\t{ARCHIVE_ENTRY_ACL_EXECUTE, ACL_EXECUTE},"", ""\t{ARCHIVE_ENTRY_ACL_DELETE, ACL_DELETE},"", ""\t{ARCHIVE_ENTRY_ACL_APPEND_DATA, ACL_APPEND_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY, ACL_ADD_SUBDIRECTORY},"", ""\t{ARCHIVE_ENTRY_ACL_DELETE_CHILD, ACL_DELETE_CHILD},"", ""\t{ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES, ACL_READ_ATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES, ACL_WRITE_ATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS, ACL_READ_EXTATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS, ACL_WRITE_EXTATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_READ_ACL, ACL_READ_SECURITY},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_ACL, ACL_WRITE_SECURITY},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_OWNER, ACL_CHANGE_OWNER},"", ""\t{ARCHIVE_ENTRY_ACL_SYNCHRONIZE, ACL_SYNCHRONIZE}"", ""#else\t/* POSIX.1e ACL permissions */"", ""\t{ARCHIVE_ENTRY_ACL_EXECUTE, ACL_EXECUTE},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE, ACL_WRITE},"", ""\t{ARCHIVE_ENTRY_ACL_READ, ACL_READ},"", ""#if HAVE_ACL_TYPE_NFS4\t/* FreeBSD NFSv4 ACL permissions */"", ""\t{ARCHIVE_ENTRY_ACL_READ_DATA, ACL_READ_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, ACL_LIST_DIRECTORY},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_DATA, ACL_WRITE_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_ADD_FILE, ACL_ADD_FILE},"", ""\t{ARCHIVE_ENTRY_ACL_APPEND_DATA, ACL_APPEND_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY, ACL_ADD_SUBDIRECTORY},"", ""\t{ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS, ACL_READ_NAMED_ATTRS},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS, ACL_WRITE_NAMED_ATTRS},"", ""\t{ARCHIVE_ENTRY_ACL_DELETE_CHILD, ACL_DELETE_CHILD},"", ""\t{ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES, ACL_READ_ATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES, ACL_WRITE_ATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_DELETE, ACL_DELETE},"", ""\t{ARCHIVE_ENTRY_ACL_READ_ACL, ACL_READ_ACL},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_ACL, ACL_WRITE_ACL},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_OWNER, ACL_WRITE_OWNER},"", ""\t{ARCHIVE_ENTRY_ACL_SYNCHRONIZE, ACL_SYNCHRONIZE}"", ""#endif"", ""#endif\t/* !HAVE_SUN_ACL && !HAVE_DARWIN_ACL */"", ""};"", """", ""#ifdef ACL_TYPE_NFS4"", ""static struct {"", ""        int archive_inherit;"", ""        int platform_inherit;"", ""#if HAVE_NFS4_ACL"", ""/*"", "" * Translate system NFSv4 inheritance flags into libarchive internal structure"", "" */"", ""static const struct {"", ""\tconst int archive_inherit;"", ""\tconst int platform_inherit;"", ""} acl_inherit_map[] = {"", ""        {ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, ACL_ENTRY_FILE_INHERIT},"", ""#if HAVE_SUN_ACL\t/* Solaris ACL inheritance flags */"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, ACE_FILE_INHERIT_ACE},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT, ACE_DIRECTORY_INHERIT_ACE},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT, ACE_NO_PROPAGATE_INHERIT_ACE},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY, ACE_INHERIT_ONLY_ACE},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_SUCCESSFUL_ACCESS, ACE_SUCCESSFUL_ACCESS_ACE_FLAG},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_FAILED_ACCESS, ACE_FAILED_ACCESS_ACE_FLAG},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERITED, ACE_INHERITED_ACE}"", ""#elif HAVE_DARWIN_ACL\t/* MacOS NFSv4 inheritance flags */"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERITED, ACL_ENTRY_INHERITED},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, ACL_ENTRY_FILE_INHERIT},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT, ACL_ENTRY_DIRECTORY_INHERIT},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT, ACL_ENTRY_LIMIT_INHERIT},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY, ACL_ENTRY_ONLY_INHERIT}"", ""#else\t/* FreeBSD NFSv4 ACL inheritance flags */"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, ACL_ENTRY_FILE_INHERIT},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT, ACL_ENTRY_DIRECTORY_INHERIT},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT, ACL_ENTRY_NO_PROPAGATE_INHERIT},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY, ACL_ENTRY_INHERIT_ONLY}"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY, ACL_ENTRY_INHERIT_ONLY},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_SUCCESSFUL_ACCESS, ACL_ENTRY_SUCCESSFUL_ACCESS},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_FAILED_ACCESS, ACL_ENTRY_FAILED_ACCESS},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERITED, ACL_ENTRY_INHERITED}"", ""#endif\t/* !HAVE_SUN_ACL && !HAVE_DARWIN_ACL */"", ""};"", ""#endif"", ""#endif\t/* HAVE_NFS4_ACL */"", """", ""#if HAVE_DARWIN_ACL"", ""static int translate_guid(struct archive *a, acl_entry_t acl_entry,"", ""    int *ae_id, int *ae_tag, const char **ae_name)"", ""{"", ""\tvoid *q;"", ""\tuid_t ugid;"", ""\tint r, idtype;"", ""\tstruct passwd *pwd;"", ""\tstruct group *grp;"", """", ""\tq = acl_get_qualifier(acl_entry);"", ""\tif (q == NULL)"", ""\t\treturn (1);"", ""\tr = mbr_uuid_to_id((const unsigned char *)q, &ugid, &idtype);"", ""\tif (r != 0) {"", ""\t\tacl_free(q);"", ""\t\treturn (1);"", ""\t}"", ""\tif (idtype == ID_TYPE_UID) {"", ""\t\t*ae_tag = ARCHIVE_ENTRY_ACL_USER;"", ""\t\tpwd = getpwuuid(q);"", ""\t\tif (pwd == NULL) {"", ""\t\t\t*ae_id = ugid;"", ""\t\t\t*ae_name = NULL;"", ""\t\t} else {"", ""\t\t\t*ae_id = pwd->pw_uid;"", ""\t\t\t*ae_name = archive_read_disk_uname(a, *ae_id);"", ""\t\t}"", ""\t} else if (idtype == ID_TYPE_GID) {"", ""\t\t*ae_tag = ARCHIVE_ENTRY_ACL_GROUP;"", ""\t\tgrp = getgruuid(q);"", ""\t\tif (grp == NULL) {"", ""\t\t\t*ae_id = ugid;"", ""\t\t\t*ae_name = NULL;"", ""\t\t} else {"", ""\t\t\t*ae_id = grp->gr_gid;"", ""\t\t\t*ae_name = archive_read_disk_gname(a, *ae_id);"", ""\t\t}"", ""\t} else"", ""\t\tr = 1;"", """", ""\tacl_free(q);"", ""\treturn (r);"", ""}"", """", ""/*"", "" * Add trivial NFSv4 ACL entries from mode"", "" */"", ""static void"", ""add_trivial_nfs4_acl(struct archive_entry *entry)"", ""{"", ""\tmode_t mode;"", ""\tint i;"", ""\tconst int rperm = ARCHIVE_ENTRY_ACL_READ_DATA;"", ""\tconst int wperm = ARCHIVE_ENTRY_ACL_WRITE_DATA |"", ""\t    ARCHIVE_ENTRY_ACL_APPEND_DATA;"", ""\tconst int eperm = ARCHIVE_ENTRY_ACL_EXECUTE;"", ""\tconst int pubset = ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES |"", ""\t    ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS |"", ""\t    ARCHIVE_ENTRY_ACL_READ_ACL |"", ""\t    ARCHIVE_ENTRY_ACL_SYNCHRONIZE;"", ""\tconst int ownset = pubset | ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES |"", ""\t    ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS |"", ""\t    ARCHIVE_ENTRY_ACL_WRITE_ACL |"", ""\t    ARCHIVE_ENTRY_ACL_WRITE_OWNER;"", """", ""\tstruct {"", ""\t    const int type;"", ""\t    const int tag;"", ""\t    int permset;"", ""\t} tacl_entry[] = {"", ""\t    {ARCHIVE_ENTRY_ACL_TYPE_ALLOW, ARCHIVE_ENTRY_ACL_USER_OBJ, 0},"", ""\t    {ARCHIVE_ENTRY_ACL_TYPE_DENY, ARCHIVE_ENTRY_ACL_USER_OBJ, 0},"", ""\t    {ARCHIVE_ENTRY_ACL_TYPE_DENY, ARCHIVE_ENTRY_ACL_GROUP_OBJ, 0},"", ""\t    {ARCHIVE_ENTRY_ACL_TYPE_ALLOW, ARCHIVE_ENTRY_ACL_USER_OBJ, ownset},"", ""\t    {ARCHIVE_ENTRY_ACL_TYPE_ALLOW, ARCHIVE_ENTRY_ACL_GROUP_OBJ, pubset},"", ""\t    {ARCHIVE_ENTRY_ACL_TYPE_ALLOW, ARCHIVE_ENTRY_ACL_EVERYONE, pubset}"", ""\t};"", """", ""\tmode = archive_entry_mode(entry);"", """", ""\t/* Permissions for everyone@ */"", ""\tif (mode & 0004)"", ""\t\ttacl_entry[5].permset |= rperm;"", ""\tif (mode & 0002)"", ""\t\ttacl_entry[5].permset |= wperm;"", ""\tif (mode & 0001)"", ""\t\ttacl_entry[5].permset |= eperm;"", """", ""\t/* Permissions for group@ */"", ""\tif (mode & 0040)"", ""\t\ttacl_entry[4].permset |= rperm;"", ""\telse if (mode & 0004)"", ""\t\ttacl_entry[2].permset |= rperm;"", ""\tif (mode & 0020)"", ""\t\ttacl_entry[4].permset |= wperm;"", ""\telse if (mode & 0002)"", ""\t\ttacl_entry[2].permset |= wperm;"", ""\tif (mode & 0010)"", ""\t\ttacl_entry[4].permset |= eperm;"", ""\telse if (mode & 0001)"", ""\t\ttacl_entry[2].permset |= eperm;"", """", ""\t/* Permissions for owner@ */"", ""\tif (mode & 0400) {"", ""\t\ttacl_entry[3].permset |= rperm;"", ""\t\tif (!(mode & 0040) && (mode & 0004))"", ""\t\t\ttacl_entry[0].permset |= rperm;"", ""\t} else if ((mode & 0040) || (mode & 0004))"", ""\t\ttacl_entry[1].permset |= rperm;"", ""\tif (mode & 0200) {"", ""\t\ttacl_entry[3].permset |= wperm;"", ""\t\tif (!(mode & 0020) && (mode & 0002))"", ""\t\t\ttacl_entry[0].permset |= wperm;"", ""\t} else if ((mode & 0020) || (mode & 0002))"", ""\t\ttacl_entry[1].permset |= wperm;"", ""\tif (mode & 0100) {"", ""\t\ttacl_entry[3].permset |= eperm;"", ""\t\tif (!(mode & 0010) && (mode & 0001))"", ""\t\t\ttacl_entry[0].permset |= eperm;"", ""\t} else if ((mode & 0010) || (mode & 0001))"", ""\t\ttacl_entry[1].permset |= eperm;"", """", ""\tfor (i = 0; i < 6; i++) {"", ""\t\tif (tacl_entry[i].permset != 0) {"", ""\t\t\tarchive_entry_acl_add_entry(entry,"", ""\t\t\t    tacl_entry[i].type, tacl_entry[i].permset,"", ""\t\t\t    tacl_entry[i].tag, -1, NULL);"", ""\t\t}"", ""\t}"", """", ""\treturn;"", ""}"", ""#elif HAVE_SUN_ACL"", ""/*"", "" * Check if acl is trivial"", "" * This is a FreeBSD acl_is_trivial_np() implementation for Solaris"", "" */"", ""static int"", ""sun_acl_is_trivial(acl_t *acl, mode_t mode, int *trivialp)"", ""{"", ""\tint i, p;"", ""\tconst uint32_t rperm = ACE_READ_DATA;"", ""\tconst uint32_t wperm = ACE_WRITE_DATA | ACE_APPEND_DATA;"", ""\tconst uint32_t eperm = ACE_EXECUTE;"", ""\tconst uint32_t pubset = ACE_READ_ATTRIBUTES | ACE_READ_NAMED_ATTRS |"", ""\t    ACE_READ_ACL | ACE_SYNCHRONIZE;"", ""\tconst uint32_t ownset = pubset | ACE_WRITE_ATTRIBUTES |"", ""\t    ACE_WRITE_NAMED_ATTRS | ACE_WRITE_ACL | ACE_WRITE_OWNER;"", """", ""\tace_t *ace;"", ""\tace_t tace[6];"", """", ""\tif (acl == NULL || trivialp == NULL)"", ""\t\treturn (-1);"", """", ""\t*trivialp = 0;"", """", ""\t/* ACL_IS_TRIVIAL flag must be set for both POSIX.1e and NFSv4 ACLs */"", ""\tif ((acl->acl_flags & ACL_IS_TRIVIAL) == 0)"", ""\t\treturn (0);"", """", ""\t/*"", ""\t * POSIX.1e ACLs marked with ACL_IS_TRIVIAL are compatible with"", ""\t * FreeBSD acl_is_trivial_np(). On Solaris they have 4 entries,"", ""\t * including mask."", ""\t */"", ""\tif (acl->acl_type == ACLENT_T) {"", ""\t\tif (acl->acl_cnt == 4)"", ""\t\t\t*trivialp = 1;"", ""\t\treturn (0);"", ""\t}"", """", ""\tif (acl->acl_type != ACE_T || acl->acl_entry_size != sizeof(ace_t))"", ""\t\treturn (-1);"", """", ""\t/*"", ""\t * Continue with checking NFSv4 ACLs"", ""\t *"", ""\t * Create list of trivial ace's to be compared"", ""\t */"", """", ""\t/* owner@ allow pre */"", ""\ttace[0].a_flags = ACE_OWNER;"", ""\ttace[0].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;"", ""\ttace[0].a_access_mask = 0;"", """", ""\t/* owner@ deny */"", ""\ttace[1].a_flags = ACE_OWNER;"", ""\ttace[1].a_type = ACE_ACCESS_DENIED_ACE_TYPE;"", ""\ttace[1].a_access_mask = 0;"", """", ""\t/* group@ deny */"", ""\ttace[2].a_flags = ACE_GROUP | ACE_IDENTIFIER_GROUP;"", ""\ttace[2].a_type = ACE_ACCESS_DENIED_ACE_TYPE;"", ""\ttace[2].a_access_mask = 0;"", """", ""\t/* owner@ allow */"", ""\ttace[3].a_flags = ACE_OWNER;"", ""\ttace[3].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;"", ""\ttace[3].a_access_mask = ownset;"", """", ""\t/* group@ allow */"", ""\ttace[4].a_flags = ACE_GROUP | ACE_IDENTIFIER_GROUP;"", ""\ttace[4].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;"", ""\ttace[4].a_access_mask = pubset;"", """", ""\t/* everyone@ allow */"", ""\ttace[5].a_flags = ACE_EVERYONE;"", ""\ttace[5].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;"", ""\ttace[5].a_access_mask = pubset;"", """", ""\t/* Permissions for everyone@ */"", ""\tif (mode & 0004)"", ""\t\ttace[5].a_access_mask |= rperm;"", ""\tif (mode & 0002)"", ""\t\ttace[5].a_access_mask |= wperm;"", ""\tif (mode & 0001)"", ""\t\ttace[5].a_access_mask |= eperm;"", """", ""\t/* Permissions for group@ */"", ""\tif (mode & 0040)"", ""\t\ttace[4].a_access_mask |= rperm;"", ""\telse if (mode & 0004)"", ""\t\ttace[2].a_access_mask |= rperm;"", ""\tif (mode & 0020)"", ""\t\ttace[4].a_access_mask |= wperm;"", ""\telse if (mode & 0002)"", ""\t\ttace[2].a_access_mask |= wperm;"", ""\tif (mode & 0010)"", ""\t\ttace[4].a_access_mask |= eperm;"", ""\telse if (mode & 0001)"", ""\t\ttace[2].a_access_mask |= eperm;"", """", ""\t/* Permissions for owner@ */"", ""\tif (mode & 0400) {"", ""\t\ttace[3].a_access_mask |= rperm;"", ""\t\tif (!(mode & 0040) && (mode & 0004))"", ""\t\t\ttace[0].a_access_mask |= rperm;"", ""\t} else if ((mode & 0040) || (mode & 0004))"", ""\t\ttace[1].a_access_mask |= rperm;"", ""\tif (mode & 0200) {"", ""\t\ttace[3].a_access_mask |= wperm;"", ""\t\tif (!(mode & 0020) && (mode & 0002))"", ""\t\t\ttace[0].a_access_mask |= wperm;"", ""\t} else if ((mode & 0020) || (mode & 0002))"", ""\t\ttace[1].a_access_mask |= wperm;"", ""\tif (mode & 0100) {"", ""\t\ttace[3].a_access_mask |= eperm;"", ""\t\tif (!(mode & 0010) && (mode & 0001))"", ""\t\t\ttace[0].a_access_mask |= eperm;"", ""\t} else if ((mode & 0010) || (mode & 0001))"", ""\t\ttace[1].a_access_mask |= eperm;"", """", ""\t/* Check if the acl count matches */"", ""\tp = 3;"", ""\tfor (i = 0; i < 3; i++) {"", ""\t\tif (tace[i].a_access_mask != 0)"", ""\t\t\tp++;"", ""\t}"", ""\tif (acl->acl_cnt != p)"", ""\t\treturn (0);"", """", ""\tp = 0;"", ""\tfor (i = 0; i < 6; i++) {"", ""\t\tif (tace[i].a_access_mask != 0) {"", ""\t\t\tace = &((ace_t *)acl->acl_aclp)[p];"", ""\t\t\t/*"", ""\t\t\t * Illumos added ACE_DELETE_CHILD to write perms for"", ""\t\t\t * directories. We have to check against that, too."", ""\t\t\t */"", ""\t\t\tif (ace->a_flags != tace[i].a_flags ||"", ""\t\t\t    ace->a_type != tace[i].a_type ||"", ""\t\t\t    (ace->a_access_mask != tace[i].a_access_mask &&"", ""\t\t\t    ((acl->acl_flags & ACL_IS_DIR) == 0 ||"", ""\t\t\t    (tace[i].a_access_mask & wperm) == 0 ||"", ""\t\t\t    ace->a_access_mask !="", ""\t\t\t    (tace[i].a_access_mask | ACE_DELETE_CHILD))))"", ""\t\t\t\treturn (0);"", ""\t\t\tp++;"", ""\t\t}"", ""\t}"", """", ""\t*trivialp = 1;"", ""\treturn (0);"", ""}"", ""#endif\t/* HAVE_SUN_ACL */"", """", ""#if HAVE_SUN_ACL"", ""/*"", "" * Translate Solaris POSIX.1e and NFSv4 ACLs into libarchive internal ACL"", "" */"", ""static int"", ""translate_acl(struct archive_read_disk *a,"", ""    struct archive_entry *entry, acl_t *acl, int default_entry_acl_type)"", ""{"", ""\tint e, i;"", ""\tint ae_id, ae_tag, ae_perm;"", ""\tint entry_acl_type;"", ""\tconst char *ae_name;"", ""\taclent_t *aclent;"", ""\tace_t *ace;"", """", ""\t(void)default_entry_acl_type;"", """", ""\tif (acl->acl_cnt <= 0)"", ""\t\treturn (ARCHIVE_OK);"", """", ""\tfor (e = 0; e < acl->acl_cnt; e++) {"", ""\t\tae_name = NULL;"", ""\t\tae_tag = 0;"", ""\t\tae_perm = 0;"", """", ""\t\tif (acl->acl_type == ACE_T) {"", ""\t\t\tace = &((ace_t *)acl->acl_aclp)[e];"", ""\t\t\tae_id = ace->a_who;"", """", ""\t\t\tswitch(ace->a_type) {"", ""\t\t\tcase ACE_ACCESS_ALLOWED_ACE_TYPE:"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;"", ""\t\t\t\tbreak;"", ""\t\t\tcase ACE_ACCESS_DENIED_ACE_TYPE:"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DENY;"", ""\t\t\t\tbreak;"", ""\t\t\tcase ACE_SYSTEM_AUDIT_ACE_TYPE:"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;"", ""\t\t\t\tbreak;"", ""\t\t\tcase ACE_SYSTEM_ALARM_ACE_TYPE:"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALARM;"", ""\t\t\t\tbreak;"", ""\t\t\tdefault:"", ""\t\t\t\t/* Unknown entry type, skip */"", ""\t\t\t\tcontinue;"", ""\t\t\t}"", """", ""\t\t\tif ((ace->a_flags & ACE_OWNER) != 0)"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER_OBJ;"", ""\t\t\telse if ((ace->a_flags & ACE_GROUP) != 0)"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;"", ""\t\t\telse if ((ace->a_flags & ACE_EVERYONE) != 0)"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_EVERYONE;"", ""\t\t\telse if ((ace->a_flags & ACE_IDENTIFIER_GROUP) != 0) {"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;"", ""\t\t\t\tae_name = archive_read_disk_gname(&a->archive,"", ""\t\t\t\t    ae_id);"", ""\t\t\t} else {"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;"", ""\t\t\t\tae_name = archive_read_disk_uname(&a->archive,"", ""\t\t\t\t    ae_id);"", ""\t\t\t}"", """", ""\t\t\tfor (i = 0; i < (int)(sizeof(acl_inherit_map) /"", ""\t\t\t    sizeof(acl_inherit_map[0])); ++i) {"", ""\t\t\t\tif ((ace->a_flags &"", ""\t\t\t\t    acl_inherit_map[i].platform_inherit) != 0)"", ""\t\t\t\t\tae_perm |="", ""\t\t\t\t\t    acl_inherit_map[i].archive_inherit;"", ""\t\t\t}"", """", ""\t\t\tfor (i = 0; i < (int)(sizeof(acl_perm_map) /"", ""\t\t\t    sizeof(acl_perm_map[0])); ++i) {"", ""\t\t\t\tif ((ace->a_access_mask &"", ""\t\t\t\t    acl_perm_map[i].platform_perm) != 0)"", ""\t\t\t\t\tae_perm |="", ""\t\t\t\t\t    acl_perm_map[i].archive_perm;"", ""\t\t\t}"", ""\t\t} else {"", ""\t\t\taclent = &((aclent_t *)acl->acl_aclp)[e];"", ""\t\t\tif ((aclent->a_type & ACL_DEFAULT) != 0)"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;"", ""\t\t\telse"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;"", ""\t\t\tae_id = aclent->a_id;"", """", ""\t\t\tswitch(aclent->a_type) {"", ""\t\t\tcase DEF_USER:"", ""\t\t\tcase USER:"", ""\t\t\t\tae_name = archive_read_disk_uname(&a->archive,"", ""\t\t\t\t    ae_id);"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;"", ""\t\t\t\tbreak;"", ""\t\t\tcase DEF_GROUP:"", ""\t\t\tcase GROUP:"", ""\t\t\t\tae_name = archive_read_disk_gname(&a->archive,"", ""\t\t\t\t    ae_id);"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;"", ""\t\t\t\tbreak;"", ""\t\t\tcase DEF_CLASS_OBJ:"", ""\t\t\tcase CLASS_OBJ:"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_MASK;"", ""\t\t\t\tbreak;"", ""\t\t\tcase DEF_USER_OBJ:"", ""\t\t\tcase USER_OBJ:"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER_OBJ;"", ""\t\t\t\tbreak;"", ""\t\t\tcase DEF_GROUP_OBJ:"", ""\t\t\tcase GROUP_OBJ:"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;"", ""\t\t\t\tbreak;"", ""\t\t\tcase DEF_OTHER_OBJ:"", ""\t\t\tcase OTHER_OBJ:"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_OTHER;"", ""\t\t\t\tbreak;"", ""\t\t\tdefault:"", ""\t\t\t\t/* Unknown tag type, skip */"", ""\t\t\t\tcontinue;"", ""\t\t\t}"", """", ""\t\t\tif ((aclent->a_perm & 1) != 0)"", ""\t\t\t\tae_perm |= ARCHIVE_ENTRY_ACL_EXECUTE;"", ""\t\t\tif ((aclent->a_perm & 2) != 0)"", ""\t\t\t\tae_perm |= ARCHIVE_ENTRY_ACL_WRITE;"", ""\t\t\tif ((aclent->a_perm & 4) != 0)"", ""\t\t\t\tae_perm |= ARCHIVE_ENTRY_ACL_READ;"", ""\t\t} /* default_entry_acl_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4 */"", """", ""\t\tarchive_entry_acl_add_entry(entry, entry_acl_type,"", ""\t\t    ae_perm, ae_tag, ae_id, ae_name);"", ""\t}"", ""\treturn (ARCHIVE_OK);"", ""}"", ""#else\t/* !HAVE_SUN_ACL */"", ""/*"", "" * Translate POSIX.1e (Linux), FreeBSD (both POSIX.1e and NFSv4) and"", "" * MacOS (NFSv4 only) ACLs into libarchive internal structure"", "" */"", ""static int"", ""translate_acl(struct archive_read_disk *a,"", ""    struct archive_entry *entry, acl_t acl, int default_entry_acl_type)"", ""{"", ""\tacl_tag_t\t acl_tag;"", ""#ifdef ACL_TYPE_NFS4"", ""#if HAVE_ACL_TYPE_NFS4"", ""\tacl_entry_type_t acl_type;"", ""\tint brand;"", ""#endif"", ""#if HAVE_ACL_TYPE_NFS4 || HAVE_DARWIN_ACL"", ""\tacl_flagset_t\t acl_flagset;"", ""\tint brand, r;"", ""#endif"", ""\tacl_entry_t\t acl_entry;"", ""\tacl_permset_t\t acl_permset;"", ""\tint\t\t i, entry_acl_type;"", ""\tint\t\t s, ae_id, ae_tag, ae_perm;"", ""\tint\t\t r, s, ae_id, ae_tag, ae_perm;"", ""#if !HAVE_DARWIN_ACL"", ""\tvoid\t\t*q;"", ""#endif"", ""\tconst char\t*ae_name;"", """", """", ""#ifdef ACL_TYPE_NFS4"", ""#if HAVE_ACL_TYPE_NFS4"", ""\t// FreeBSD \""brands\"" ACLs as POSIX.1e or NFSv4"", ""\t// Make sure the \""brand\"" on this ACL is consistent"", ""\t// with the default_entry_acl_type bits provided."", ""\tacl_get_brand_np(acl, &brand);"", ""\tif (acl_get_brand_np(acl, &brand) != 0) {"", ""\t\tarchive_set_error(&a->archive, errno,"", ""\t\t    \""Failed to read ACL brand\"");"", ""\t\treturn (ARCHIVE_WARN);"", ""\t}"", ""\tswitch (brand) {"", ""\tcase ACL_BRAND_POSIX:"", ""\t\tswitch (default_entry_acl_type) {"", ""\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:"", ""\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:"", ""\t\t\tbreak;"", ""\t\tdefault:"", ""\t\t\t// XXX set warning message?"", ""\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Invalid ACL entry type for POSIX.1e ACL\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tbreak;"", ""\tcase ACL_BRAND_NFS4:"", ""\t\tif (default_entry_acl_type & ~ARCHIVE_ENTRY_ACL_TYPE_NFS4) {"", ""\t\t\t// XXX set warning message?"", ""\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Invalid ACL entry type for NFSv4 ACL\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tbreak;"", ""\tdefault:"", ""\t\t// XXX set warning message?"", ""\t\treturn ARCHIVE_FAILED;"", ""\t\tbreak;"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Unknown ACL brand\"");"", ""\t\treturn (ARCHIVE_WARN);"", ""\t}"", ""#endif"", """", """", ""\ts = acl_get_entry(acl, ACL_FIRST_ENTRY, &acl_entry);"", ""\twhile (s == 1) {"", ""\tif (s == -1) {"", ""\t\tarchive_set_error(&a->archive, errno,"", ""\t\t    \""Failed to get first ACL entry\"");"", ""\t\treturn (ARCHIVE_WARN);"", ""\t}"", """", ""#if HAVE_DARWIN_ACL"", ""\twhile (s == 0)"", ""#else\t/* FreeBSD, Linux */"", ""\twhile (s == 1)"", ""#endif"", ""\t{"", ""\t\tae_id = -1;"", ""\t\tae_name = NULL;"", ""\t\tae_perm = 0;"", """", ""\t\tacl_get_tag_type(acl_entry, &acl_tag);"", ""\t\tif (acl_get_tag_type(acl_entry, &acl_tag) != 0) {"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""Failed to get ACL tag type\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tswitch (acl_tag) {"", ""#if !HAVE_DARWIN_ACL\t/* FreeBSD, Linux */"", ""\t\tcase ACL_USER:"", ""\t\t\tae_id = (int)*(uid_t *)acl_get_qualifier(acl_entry);"", ""\t\t\tae_name = archive_read_disk_uname(&a->archive, ae_id);"", ""\t\t\tq = acl_get_qualifier(acl_entry);"", ""\t\t\tif (q != NULL) {"", ""\t\t\t\tae_id = (int)*(uid_t *)q;"", ""\t\t\t\tacl_free(q);"", ""\t\t\t\tae_name = archive_read_disk_uname(&a->archive,"", ""\t\t\t\t    ae_id);"", ""\t\t\t}"", ""\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;"", ""\t\t\tbreak;"", ""\t\tcase ACL_GROUP:"", ""\t\t\tae_id = (int)*(gid_t *)acl_get_qualifier(acl_entry);"", ""\t\t\tae_name = archive_read_disk_gname(&a->archive, ae_id);"", ""\t\t\tq = acl_get_qualifier(acl_entry);"", ""\t\t\tif (q != NULL) {"", ""\t\t\t\tae_id = (int)*(gid_t *)q;"", ""\t\t\t\tacl_free(q);"", ""\t\t\t\tae_name = archive_read_disk_gname(&a->archive,"", ""\t\t\t\t    ae_id);"", ""\t\t\t}"", ""\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;"", ""\t\t\tbreak;"", ""\t\tcase ACL_MASK:""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, 1, 0, 1, 1, 2, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, -1, 1, 0, 0, 1, 2, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, -1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, 1, 1, 1, 1, 1, 0, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, 1, 0, 1, 1, 1, 0, -1, 0, 0, 0, 0, -1, 1, 1, 1, 1, 0, 0, -1, -1, 1, 0, 0, 0, -1, 1, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, 2, 1, 1, 0, 0, 0, 0, -1, -1, 2, 1, 1, 0, 0, 0, -1, -1, -1, 2, 1, 1, 0, 0, 0, -1, 0, -1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, -1, 1, 2, 1, 1, 1, 0, 1, 0, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[21, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""], [41, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""], [643, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""], [656, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""], [665, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""], [674, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""], [684, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""], [701, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""]]",467,577
"[""\t\tcase ACL_OTHER:"", ""\t\t\tae_tag = ARCHIVE_ENTRY_ACL_OTHER;"", ""\t\t\tbreak;"", ""#ifdef ACL_TYPE_NFS4"", ""#if HAVE_ACL_TYPE_NFS4"", ""\t\tcase ACL_EVERYONE:"", ""\t\t\tae_tag = ARCHIVE_ENTRY_ACL_EVERYONE;"", ""\t\t\tbreak;"", ""#endif"", ""#else\t/* HAVE_DARWIN_ACL */"", ""\t\tcase ACL_EXTENDED_ALLOW:"", ""\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;"", ""\t\t\tr = translate_guid(&a->archive, acl_entry, &ae_id,"", ""\t\t\t    &ae_tag, &ae_name);"", ""\t\t\tbreak;"", ""\t\tcase ACL_EXTENDED_DENY:"", ""\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DENY;"", ""\t\t\tr = translate_guid(&a->archive, acl_entry, &ae_id,"", ""\t\t\t    &ae_tag, &ae_name);"", ""\t\t\tbreak;"", ""#endif\t/* HAVE_DARWIN_ACL */"", ""\t\tdefault:"", ""\t\t\t/* Skip types that libarchive can't support. */"", ""\t\t\ts = acl_get_entry(acl, ACL_NEXT_ENTRY, &acl_entry);"", ""\t\t\tcontinue;"", ""\t\t}"", """", ""\t\t// XXX acl type maps to allow/deny/audit/YYYY bits"", ""\t\t// XXX acl_get_entry_type_np on FreeBSD returns EINVAL for"", ""\t\t// non-NFSv4 ACLs"", ""#if HAVE_DARWIN_ACL"", ""\t\t/* Skip if translate_guid() above failed */"", ""\t\tif (r != 0) {"", ""\t\t\ts = acl_get_entry(acl, ACL_NEXT_ENTRY, &acl_entry);"", ""\t\t\tcontinue;"", ""\t\t}"", ""#endif"", """", ""#if !HAVE_DARWIN_ACL"", ""\t\t// XXX acl_type maps to allow/deny/audit/YYYY bits"", ""\t\tentry_acl_type = default_entry_acl_type;"", ""#ifdef ACL_TYPE_NFS4"", ""\t\tr = acl_get_entry_type_np(acl_entry, &acl_type);"", ""\t\tif (r == 0) {"", ""#endif"", ""#if HAVE_ACL_TYPE_NFS4 || HAVE_DARWIN_ACL"", ""\t\tif (default_entry_acl_type & ARCHIVE_ENTRY_ACL_TYPE_NFS4) {"", ""#if HAVE_ACL_TYPE_NFS4"", ""\t\t\t/*"", ""\t\t\t * acl_get_entry_type_np() fails with non-NFSv4 ACLs"", ""\t\t\t */"", ""\t\t\tif (acl_get_entry_type_np(acl_entry, &acl_type) != 0) {"", ""\t\t\t\tarchive_set_error(&a->archive, errno, \""Failed \"""", ""\t\t\t\t    \""to get ACL type from a NFSv4 ACL entry\"");"", ""\t\t\t\treturn (ARCHIVE_WARN);"", ""\t\t\t}"", ""\t\t\tswitch (acl_type) {"", ""\t\t\tcase ACL_ENTRY_TYPE_ALLOW:"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;""]","[0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, 0, 0]","[[52, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno, \""Failed \"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""]]",604,1262
"[""\t\t\tcase ACL_ENTRY_TYPE_ALARM:"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALARM;"", ""\t\t\t\tbreak;"", ""\t\t\tdefault:"", ""\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Invalid NFSv4 ACL entry type\"");"", ""\t\t\t\treturn (ARCHIVE_WARN);"", ""\t\t\t}"", ""\t\t}"", """", ""\t\t/*"", ""\t\t * Libarchive stores \""flag\"" (NFSv4 inheritance bits)"", ""\t\t * in the ae_perm bitmap."", ""\t\t */"", ""\t\tacl_get_flagset_np(acl_entry, &acl_flagset);"", ""                for (i = 0; i < (int)(sizeof(acl_inherit_map) / sizeof(acl_inherit_map[0])); ++i) {"", ""\t\t\tif (acl_get_flag_np(acl_flagset,"", ""\t\t\t\t\t    acl_inherit_map[i].platform_inherit))"", ""\t\t\t\tae_perm |= acl_inherit_map[i].archive_inherit;"", ""#endif\t/* HAVE_ACL_TYPE_NFS4 */"", """", ""                }"", ""#endif"", ""\t\t\t/*"", ""\t\t\t * Libarchive stores \""flag\"" (NFSv4 inheritance bits)"", ""\t\t\t * in the ae_perm bitmap."", ""\t\t\t *"", ""\t\t\t * acl_get_flagset_np() fails with non-NFSv4 ACLs"", ""\t\t\t */"", ""\t\t\tif (acl_get_flagset_np(acl_entry, &acl_flagset) != 0) {"", ""\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Failed to get flagset from a NFSv4 ACL entry\"");"", ""\t\t\t\treturn (ARCHIVE_WARN);"", ""\t\t\t}"", ""\t\t\tfor (i = 0; i < (int)(sizeof(acl_inherit_map) / sizeof(acl_inherit_map[0])); ++i) {"", ""\t\t\t\tr = acl_get_flag_np(acl_flagset,"", ""\t\t\t\t    acl_inherit_map[i].platform_inherit);"", ""\t\t\t\tif (r == -1) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t\t    \""Failed to check flag in a NFSv4 \"""", ""\t\t\t\t\t    \""ACL flagset\"");"", ""\t\t\t\t\treturn (ARCHIVE_WARN);"", ""\t\t\t\t} else if (r)"", ""\t\t\t\t\tae_perm |= acl_inherit_map[i].archive_inherit;"", ""\t\t\t}"", ""\t\t}"", ""#endif\t/* HAVE_ACL_TYPE_NFS4 || HAVE_DARWIN_ACL */"", """", ""\t\tacl_get_permset(acl_entry, &acl_permset);"", ""\t\tif (acl_get_permset(acl_entry, &acl_permset) != 0) {"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""Failed to get ACL permission set\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tfor (i = 0; i < (int)(sizeof(acl_perm_map) / sizeof(acl_perm_map[0])); ++i) {"", ""\t\t\t/*"", ""\t\t\t * acl_get_perm() is spelled differently on different"", ""\t\t\t * platforms; see above."", ""\t\t\t */"", ""\t\t\tif (ACL_GET_PERM(acl_permset, acl_perm_map[i].platform_perm))"", ""\t\t\tr = ACL_GET_PERM(acl_permset, acl_perm_map[i].platform_perm);"", ""\t\t\tif (r == -1) {"", ""\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Failed to check permission in an ACL permission set\"");"", ""\t\t\t\treturn (ARCHIVE_WARN);"", ""\t\t\t} else if (r)"", ""\t\t\t\tae_perm |= acl_perm_map[i].archive_perm;"", ""\t\t}"", """"]","[0, 0, 0, 1, 2, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, -1, -1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 2, 1, 1, 1, 0, 0, 0, 0, 0, -1, 1, 1, 2, 1, 1, 1, 0, 0, 0]","[[4, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""], [30, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""], [38, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""], [50, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""], [62, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""]]",635,1321
"[""\t\t\t\t\t    ae_id, ae_name);"", """", ""\t\ts = acl_get_entry(acl, ACL_NEXT_ENTRY, &acl_entry);"", ""#if !HAVE_DARWIN_ACL"", ""\t\tif (s == -1) {"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""Failed to get next ACL entry\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""#endif"", ""\t}"", ""\treturn (ARCHIVE_OK);"", ""}"", ""#else"", ""#endif\t/* !HAVE_SUN_ACL */"", ""#else\t/* !HAVE_POSIX_ACL && !HAVE_NFS4_ACL */"", ""static int"", ""setup_acls(struct archive_read_disk *a,"", ""    struct archive_entry *entry, int *fd)""]","[0, 0, 0, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, -1, 1, 1, 0, 0, 0]","[[5, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""]]",666,1377
"[""\tconst char *path;"", ""\tssize_t list_size;"", """", ""\tpath = archive_entry_sourcepath(entry);"", ""\tif (path == NULL)"", ""\t\tpath = archive_entry_pathname(entry);"", ""\tpath = NULL;"", """", ""\tif (*fd < 0 && a->tree != NULL) {"", ""\t\tif (a->follow_symlinks ||"", ""\t\t    archive_entry_filetype(entry) != AE_IFLNK)"", ""\t\t\t*fd = a->open_on_current_dir(a->tree, path,"", ""\t\t\t\tO_RDONLY | O_NONBLOCK);"", ""\t\tif (*fd < 0) {"", ""\t\t\tif (a->tree_enter_working_dir(a->tree) != 0) {"", ""\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Couldn't access %s\"", path);"", ""\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t\t}"", ""\tif (*fd < 0) {"", ""\t\tpath = archive_entry_sourcepath(entry);"", ""\t\tif (path == NULL || (a->tree != NULL &&"", ""\t\t    a->tree_enter_working_dir(a->tree) != 0))"", ""\t\t\tpath = archive_entry_pathname(entry);"", ""\t\tif (path == NULL) {"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Couldn't determine file path to read \"""", ""\t\t\t    \""extended attributes\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tif (a->tree != NULL && (a->follow_symlinks ||"", ""\t\t    archive_entry_filetype(entry) != AE_IFLNK)) {"", ""\t\t\t*fd = a->open_on_current_dir(a->tree,"", ""\t\t\t    path, O_RDONLY | O_NONBLOCK);"", ""\t\t}"", ""\t}"", """"]","[0, 0, 0, -1, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[15, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""-"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""], [25, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""]]",772,1486
"[""\tconst char *path;"", ""\tint namespace = EXTATTR_NAMESPACE_USER;"", """", ""\tpath = archive_entry_sourcepath(entry);"", ""\tif (path == NULL)"", ""\t\tpath = archive_entry_pathname(entry);"", ""\tpath = NULL;"", """", ""\tif (*fd < 0 && a->tree != NULL) {"", ""\t\tif (a->follow_symlinks ||"", ""\t\t    archive_entry_filetype(entry) != AE_IFLNK)"", ""\t\t\t*fd = a->open_on_current_dir(a->tree, path,"", ""\t\t\t\tO_RDONLY | O_NONBLOCK);"", ""\t\tif (*fd < 0) {"", ""\t\t\tif (a->tree_enter_working_dir(a->tree) != 0) {"", ""\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Couldn't access %s\"", path);"", ""\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t\t}"", ""\tif (*fd < 0) {"", ""\t\tpath = archive_entry_sourcepath(entry);"", ""\t\tif (path == NULL || (a->tree != NULL &&"", ""\t\t    a->tree_enter_working_dir(a->tree) != 0))"", ""\t\t\tpath = archive_entry_pathname(entry);"", ""\t\tif (path == NULL) {"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Couldn't determine file path to read \"""", ""\t\t\t    \""extended attributes\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tif (a->tree != NULL && (a->follow_symlinks ||"", ""\t\t    archive_entry_filetype(entry) != AE_IFLNK)) {"", ""\t\t\t*fd = a->open_on_current_dir(a->tree,"", ""\t\t\t    path, O_RDONLY | O_NONBLOCK);"", ""\t\t}"", ""\t}"", """"]","[0, 0, 0, -1, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[15, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""-"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""], [25, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_39_new.cpp""]]",932,1645
"[""\t\t}"", ""\t\tllen = len;"", ""\t\tif ((nl == 0) && (uudecode->state != ST_UUEND)) {"", ""\t\t\tif (total == 0 && ravail <= 0) {"", ""\t\t\t\t/* There is nothing more to read, fail */"", ""\t\t\t\tarchive_set_error(&self->archive->archive,"", ""\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t\t    \""Missing format data\"");"", ""\t\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t\t}"", ""\t\t\t/*"", ""\t\t\t * Save remaining data which does not contain"", ""\t\t\t * NL('\\n','\\r').""]","[0, 0, 0, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0]","[[5, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_filter_uu.c"", ""+"", ""archive_set_error(&self->archive->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_40_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_40_new.cpp""]]",510,495
"["""", ""#else"", """", ""#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC"", """", ""/*"", "" * If we have the older liblzmadec library, then we can handle"", "" * LZMA streams but not XZ streams."", "" */"", """", ""/*"", "" * Setup the callbacks."", "" */"", ""static int"", ""lzma_bidder_init(struct archive_read_filter *self)"", ""{"", ""\tstatic const size_t out_block_size = 64 * 1024;"", ""\tvoid *out_block;"", ""\tstruct private_data *state;"", ""\tssize_t ret, avail_in;"", """", ""\tself->code = ARCHIVE_FILTER_LZMA;"", ""\tself->name = \""lzma\"";"", """", ""\tstate = (struct private_data *)calloc(sizeof(*state), 1);"", ""\tout_block = (unsigned char *)malloc(out_block_size);"", ""\tif (state == NULL || out_block == NULL) {"", ""\t\tarchive_set_error(&self->archive->archive, ENOMEM,"", ""\t\t    \""Can't allocate data for lzma decompression\"");"", ""\t\tfree(out_block);"", ""\t\tfree(state);"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t}"", """", ""\tself->data = state;"", ""\tstate->out_block_size = out_block_size;"", ""\tstate->out_block = out_block;"", ""\tself->read = lzma_filter_read;"", ""\tself->skip = NULL; /* not supported */"", ""\tself->close = lzma_filter_close;"", """", ""\t/* Prime the lzma library with 18 bytes of input. */"", ""\tstate->stream.next_in = (unsigned char *)(uintptr_t)"", ""\t    __archive_read_filter_ahead(self->upstream, 18, &avail_in);"", ""\tif (state->stream.next_in == NULL)"", ""\t\treturn (ARCHIVE_FATAL);"", ""\tstate->stream.avail_in = avail_in;"", ""\tstate->stream.next_out = state->out_block;"", ""\tstate->stream.avail_out = state->out_block_size;"", """", ""\t/* Initialize compression library. */"", ""\tret = lzmadec_init(&(state->stream));"", ""\t__archive_read_filter_consume(self->upstream,"", ""\t    avail_in - state->stream.avail_in);"", ""\tif (ret == LZMADEC_OK)"", ""\t\treturn (ARCHIVE_OK);"", """", ""\t/* Library setup failed: Clean up. */"", ""\tarchive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,"", ""\t    \""Internal error initializing lzma library\"");"", """", ""\t/* Override the error message if we know what really went wrong. */"", ""\tswitch (ret) {"", ""\tcase LZMADEC_HEADER_ERROR:"", ""\t\tarchive_set_error(&self->archive->archive,"", ""\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Internal error initializing compression library: \"""", ""\t\t    \""invalid header\"");"", ""\t\tbreak;"", ""\tcase LZMADEC_MEM_ERROR:"", ""\t\tarchive_set_error(&self->archive->archive, ENOMEM,"", ""\t\t    \""Internal error initializing compression library: \"""", ""\t\t    \""out of memory\"");"", ""\t\tbreak;"", ""\t}"", """", ""\tfree(state->out_block);"", ""\tfree(state);"", ""\tself->data = NULL;"", ""\treturn (ARCHIVE_FATAL);"", ""}"", """", ""/*"", "" * Return the next block of decompressed data."", "" */"", ""static ssize_t"", ""lzma_filter_read(struct archive_read_filter *self, const void **p)"", ""{"", ""\tstruct private_data *state;"", ""\tsize_t decompressed;"", ""\tssize_t avail_in, ret;"", """", ""\tstate = (struct private_data *)self->data;"", """", ""\t/* Empty our output buffer. */"", ""\tstate->stream.next_out = state->out_block;"", ""\tstate->stream.avail_out = state->out_block_size;"", """", ""\t/* Try to fill the output buffer. */"", ""\twhile (state->stream.avail_out > 0 && !state->eof) {"", ""\t\tstate->stream.next_in = (unsigned char *)(uintptr_t)"", ""\t\t    __archive_read_filter_ahead(self->upstream, 1, &avail_in);"", ""\t\tif (state->stream.next_in == NULL && avail_in < 0) {"", ""\t\t\tarchive_set_error(&self->archive->archive,"", ""\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""truncated lzma input\"");"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t}"", ""\t\tstate->stream.avail_in = avail_in;"", """", ""\t\t/* Decompress as much as we can in one pass. */"", ""\t\tret = lzmadec_decode(&(state->stream), avail_in == 0);"", ""\t\tswitch (ret) {"", ""\t\tcase LZMADEC_STREAM_END: /* Found end of stream. */"", ""\t\t\tstate->eof = 1;"", ""\t\t\t/* FALL THROUGH */"", ""\t\tcase LZMADEC_OK: /* Decompressor made some progress. */"", ""\t\t\t__archive_read_filter_consume(self->upstream,"", ""\t\t\t    avail_in - state->stream.avail_in);"", ""\t\t\tbreak;"", ""\t\tcase LZMADEC_BUF_ERROR: /* Insufficient input data? */"", ""\t\t\tarchive_set_error(&self->archive->archive,"", ""\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Insufficient compressed data\"");"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\tdefault:"", ""\t\t\t/* Return an error. */"", ""\t\t\tarchive_set_error(&self->archive->archive,"", ""\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Lzma decompression failed\"");"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t}"", ""\t}"", """", ""\tdecompressed = state->stream.next_out - state->out_block;"", ""\tstate->total_out += decompressed;"", ""\tif (decompressed == 0)"", ""\t\t*p = NULL;"", ""\telse"", ""\t\t*p = state->out_block;"", ""\treturn (decompressed);"", ""}"", """", ""/*"", "" * Clean up the decompressor."", "" */"", ""static int"", ""lzma_filter_close(struct archive_read_filter *self)"", ""{"", ""\tstruct private_data *state;"", ""\tint ret;"", """", ""\tstate = (struct private_data *)self->data;"", ""\tret = ARCHIVE_OK;"", ""\tswitch (lzmadec_end(&(state->stream))) {"", ""\tcase LZMADEC_OK:"", ""\t\tbreak;"", ""\tdefault:"", ""\t\tarchive_set_error(&(self->archive->archive),"", ""\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Failed to clean up %s compressor\"","", ""\t\t    self->archive->archive.compression_name);"", ""\t\tret = ARCHIVE_FATAL;"", ""\t}"", """", ""\tfree(state->out_block);"", ""\tfree(state);"", ""\treturn (ret);"", ""}"", """", ""#else"", """", ""/*"", "" *"", "" * If we have no suitable library on this system, we can't actually do""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0]","[[27, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive, ENOMEM,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_41_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_41_new.cpp""], [58, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_41_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_41_new.cpp""], [64, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_41_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_41_new.cpp""], [70, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive, ENOMEM,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_41_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_41_new.cpp""], [103, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_41_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_41_new.cpp""], [121, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_41_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_41_new.cpp""], [127, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_41_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_41_new.cpp""], [158, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&(self->archive->archive),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_41_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_41_new.cpp""]]",763,744
"[""\tswitch ((int)type & ~0777777) {"", ""\tcase 01000000:"", ""\t\t/* POSIX.1e ACL */"", ""\t\tacl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;"", ""\t\tbreak;"", ""\tcase 03000000:"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Solaris NFSv4 ACLs not supported\"");"", ""\t\treturn (ARCHIVE_WARN);"", ""\t\t/* NFSv4 ACL */"", ""\t\tacl_type = ARCHIVE_ENTRY_ACL_TYPE_NFS4;"", ""\t\tbreak;"", ""\tdefault:"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Malformed Solaris ACL attribute (unsupported type %o)\"",""]","[0, 0, 0, 1, 0, 0, -2, -1, -1, 1, 1, 1, 0, 0, 0]","[[6, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""-"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_new.cpp""]]",935,989
"[""\tif (tar->entry_bytes_remaining < 0) {"", ""\t\ttar->entry_bytes_remaining = 0;"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Tar entry has negative size?\"");"", ""\t\terr = ARCHIVE_WARN;"", ""\t\t    \""Tar entry has negative size\"");"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t}"", ""\tif (tar->entry_bytes_remaining == INT64_MAX) {"", ""\t\t/* Note: tar_atol returns INT64_MAX on overflow */"", ""\t\ttar->entry_bytes_remaining = 0;"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Tar entry size overflow\"");"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t}"", ""\ttar->realsize = tar->entry_bytes_remaining;"", ""\tarchive_entry_set_size(entry, tar->entry_bytes_remaining);""]","[0, 0, 0, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 0, 0]","[[11, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_new.cpp""]]",1128,1183
"[""\treturn 0;"", ""}"", """", ""static int"", ""pax_attribute_schily_xattr(struct archive_entry *entry,"", ""\tconst char *name, const char *value, size_t value_length)"", ""{"", ""\tif (strlen(name) < 14 || (memcmp(name, \""SCHILY.xattr.\"", 13)) != 0)"", ""\t\treturn 1;"", """", ""\tname += 13;"", """", ""\tarchive_entry_xattr_add_entry(entry, name, value, value_length);"", """", ""\treturn 0;"", ""}"", """", ""static int"", ""pax_attribute_acl(struct archive_read *a, struct tar *tar,"", ""    struct archive_entry *entry, const char *value, int type)"", ""{"", ""\tint r;"", ""\tconst char* errstr;"", """", ""\tswitch (type) {"", ""\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:"", ""\t\terrstr = \""SCHILY.acl.access\"";"", ""\t\tbreak;"", ""\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:"", ""\t\terrstr = \""SCHILY.acl.default\"";"", ""\t\tbreak;"", ""\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:"", ""\t\terrstr = \""SCHILY.acl.ace\"";"", ""\t\tbreak;"", ""\tdefault:"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Unknown ACL type: %d\"", type);"", ""\t\treturn(ARCHIVE_FATAL);"", ""\t}"", """", ""\tif (tar->sconv_acl == NULL) {"", ""\t\ttar->sconv_acl ="", ""\t\t    archive_string_conversion_from_charset("", ""\t\t\t&(a->archive), \""UTF-8\"", 1);"", ""\t\tif (tar->sconv_acl == NULL)"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t}"", """", ""\tr = archive_acl_from_text_l(archive_entry_acl(entry), value, type,"", ""\t    tar->sconv_acl);"", ""\tif (r != ARCHIVE_OK) {"", ""\t\tif (r == ARCHIVE_FATAL) {"", ""\t\t\tarchive_set_error(&a->archive, ENOMEM,"", ""\t\t\t    \""%s %s\"", \""Can't allocate memory for \"","", ""\t\t\t    errstr);"", ""\t\t\treturn (r);"", ""\t\t}"", ""\t\tarchive_set_error(&a->archive,"", ""\t\t    ARCHIVE_ERRNO_MISC, \""%s %s\"", \""Parse error: \"", errstr);"", ""\t}"", ""\treturn (r);"", ""}"", """", ""/*"", "" * Parse a single key=value attribute.  key/value pointers are"", "" * assumed to point into reasonably long-lived storage.""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 0, 0]","[[35, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_new.cpp""], [52, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""+"", ""archive_set_error(&a->archive, ENOMEM,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_new.cpp""], [57, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_new.cpp""]]",1695,1768
"[""\t\t\t\t * NULL pointer to strlen().  */"", ""\tswitch (key[0]) {"", ""\tcase 'G':"", ""\t\t/* Reject GNU.sparse.* headers on non-regular files. */"", ""\t\tif (strncmp(key, \""GNU.sparse\"", 10) == 0 &&"", ""\t\t    !tar->sparse_allowed) {"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Non-regular file cannot be sparse\"");"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t}"", """", ""\t\t/* GNU \""0.0\"" sparse pax format. */"", ""\t\tif (strcmp(key, \""GNU.sparse.numblocks\"") == 0) {"", ""\t\t\ttar->sparse_offset = -1;""]","[0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0]","[[6, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_new.cpp""]]",1721,1854
"[""\tcase 'S':"", ""\t\t/* We support some keys used by the \""star\"" archiver */"", ""\t\tif (strcmp(key, \""SCHILY.acl.access\"") == 0) {"", ""\t\t\tif (tar->sconv_acl == NULL) {"", ""\t\t\t\ttar->sconv_acl ="", ""\t\t\t\t    archive_string_conversion_from_charset("", ""\t\t\t\t\t&(a->archive), \""UTF-8\"", 1);"", ""\t\t\t\tif (tar->sconv_acl == NULL)"", ""\t\t\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t\t}"", """", ""\t\t\tr = archive_acl_parse_l(archive_entry_acl(entry),"", ""\t\t\t    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,"", ""\t\t\t    tar->sconv_acl);"", ""\t\t\tif (r != ARCHIVE_OK) {"", ""\t\t\t\terr = r;"", ""\t\t\t\tif (err == ARCHIVE_FATAL) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, ENOMEM,"", ""\t\t\t\t\t    \""Can't allocate memory for \"""", ""\t\t\t\t\t    \""SCHILY.acl.access\"");"", ""\t\t\t\t\treturn (err);"", ""\t\t\t\t}"", ""\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t\t    \""Parse error: SCHILY.acl.access\"");"", ""\t\t\t}"", ""\t\t\tr = pax_attribute_acl(a, tar, entry, value,"", ""\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);"", ""\t\t\tif (r == ARCHIVE_FATAL)"", ""\t\t\t\treturn (r);"", ""\t\t} else if (strcmp(key, \""SCHILY.acl.default\"") == 0) {"", ""\t\t\tif (tar->sconv_acl == NULL) {"", ""\t\t\t\ttar->sconv_acl ="", ""\t\t\t\t    archive_string_conversion_from_charset("", ""\t\t\t\t\t&(a->archive), \""UTF-8\"", 1);"", ""\t\t\t\tif (tar->sconv_acl == NULL)"", ""\t\t\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t\t}"", """", ""\t\t\tr = archive_acl_parse_l(archive_entry_acl(entry),"", ""\t\t\t    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,"", ""\t\t\t    tar->sconv_acl);"", ""\t\t\tif (r != ARCHIVE_OK) {"", ""\t\t\t\terr = r;"", ""\t\t\t\tif (err == ARCHIVE_FATAL) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, ENOMEM,"", ""\t\t\t\t\t    \""Can't allocate memory for \"""", ""\t\t\t\t\t    \""SCHILY.acl.default\"");"", ""\t\t\t\t\treturn (err);"", ""\t\t\t\t}"", ""\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t\t    \""Parse error: SCHILY.acl.default\"");"", ""\t\t\t}"", ""\t\t\tr = pax_attribute_acl(a, tar, entry, value,"", ""\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);"", ""\t\t\tif (r == ARCHIVE_FATAL)"", ""\t\t\t\treturn (r);"", ""\t\t} else if (strcmp(key, \""SCHILY.acl.ace\"") == 0) {"", ""\t\t\tr = pax_attribute_acl(a, tar, entry, value,"", ""\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4);"", ""\t\t\tif (r == ARCHIVE_FATAL)"", ""\t\t\t\treturn (r);"", ""\t\t} else if (strcmp(key, \""SCHILY.devmajor\"") == 0) {"", ""\t\t\tarchive_entry_set_rdevmajor(entry,"", ""\t\t\t    (dev_t)tar_atol10(value, strlen(value)));""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[17, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""-"", ""archive_set_error(&a->archive, ENOMEM,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_new.cpp""], [22, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""-"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_new.cpp""], [45, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""-"", ""archive_set_error(&a->archive, ENOMEM,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_new.cpp""], [50, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c"", ""-"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_42_new.cpp""]]",1803,1944
"[""\t\t\t&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t\""Bad record header\"");"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {"", ""\t\t/* nawww, I wish they promised backward compatibility"", ""\t\t * anyhoo, in their infinite wisdom the 28500 guys might"", ""\t\t * come up with something we can't possibly handle so"", ""\t\t * best end things here */"", ""\t}"", ""\tver = _warc_rdver(buf, eoh - buf);"", ""\t/* we currently support WARC 0.12 to 1.0 */"", ""\tif (ver == 0U) {"", ""\t\tarchive_set_error("", ""\t\t\t&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t\""Unsupported record version\"");"", ""\t\t\t\""Invalid record version\"");"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {"", ""\t} else if (ver < 1200U || ver > 10000U) {"", ""\t\tarchive_set_error("", ""\t\t\t&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t\""Unsupported record version: %u.%u\"","", ""\t\t\tver / 10000, (ver % 10000) / 100);"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t}"", ""\tcntlen = _warc_rdlen(buf, eoh - buf);"", ""\tif (cntlen < 0) {"", ""\t\t/* nightmare!  the specs say content-length is mandatory"", ""\t\t * so I don't feel overly bad stopping the reader here */"", ""\t\tarchive_set_error("", ""\t\t\t&a->archive, EINVAL,"", ""\t\t\t\""Bad content length\"");"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {"", ""\t}"", ""\trtime = _warc_rdrtm(buf, eoh - buf);"", ""\tif (rtime == (time_t)-1) {"", ""\t\t/* record time is mandatory as per WARC/1.0,"", ""\t\t * so just barf here, fast and loud */"", ""\t\tarchive_set_error(""]","[0, 0, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 0, 0, -1, 1, 0, -1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 1, 1, 0, 0, 0]","[[19, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c"", ""+"", ""archive_set_error("", 0, ""/data/download/CMake/CMake/Kitware_CMake_43_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_43_new.cpp""]]",255,254
"[""\t\txar->lzstream.total_in = 0;"", ""\t\txar->lzstream.total_out = 0;"", ""\t\tbreak;"", ""#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)"", ""\tcase LZMA:"", ""\t\tif (xar->lzstream_valid)"", ""\t\t\tlzmadec_end(&(xar->lzstream));"", ""\t\tr = lzmadec_init(&(xar->lzstream));"", ""\t\tif (r != LZMADEC_OK) {"", ""\t\t\tswitch (r) {"", ""\t\t\tcase LZMADEC_HEADER_ERROR:"", ""\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t\t    \""Internal error initializing \"""", ""\t\t\t\t    \""compression library: \"""", ""\t\t\t\t    \""invalid header\"");"", ""\t\t\t\tbreak;"", ""\t\t\tcase LZMADEC_MEM_ERROR:"", ""\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t    ENOMEM,"", ""\t\t\t\t    \""Internal error initializing \"""", ""\t\t\t\t    \""compression library: \"""", ""\t\t\t\t    \""out of memory\"");"", ""\t\t\t\tbreak;"", ""\t\t\t}"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t}"", ""\t\txar->lzstream_valid = 1;"", ""\t\txar->lzstream.total_in = 0;"", ""\t\txar->lzstream.total_out = 0;"", ""\t\tbreak;"", ""#endif"", ""\t/*"", ""\t * Unsupported compression.""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0]","[[11, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c"", ""-"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_44_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_44_new.cpp""], [18, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c"", ""-"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_44_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_44_new.cpp""]]",1526,1524
"[""\t\t*used = avail_in - xar->lzstream.avail_in;"", ""\t\t*outbytes = avail_out - xar->lzstream.avail_out;"", ""\t\tbreak;"", ""#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)"", ""\tcase LZMA:"", ""\t\txar->lzstream.next_in = (unsigned char *)(uintptr_t)b;"", ""\t\txar->lzstream.avail_in = avail_in;"", ""\t\txar->lzstream.next_out = (unsigned char *)outbuff;"", ""\t\txar->lzstream.avail_out = avail_out;"", ""\t\tr = lzmadec_decode(&(xar->lzstream), 0);"", ""\t\tswitch (r) {"", ""\t\tcase LZMADEC_STREAM_END: /* Found end of stream. */"", ""\t\t\tswitch (lzmadec_end(&(xar->lzstream))) {"", ""\t\t\tcase LZMADEC_OK:"", ""\t\t\t\tbreak;"", ""\t\t\tdefault:"", ""\t\t\t\tarchive_set_error(&(a->archive),"", ""\t\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t\t    \""Failed to clean up lzmadec decompressor\"");"", ""\t\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t\t}"", ""\t\t\txar->lzstream_valid = 0;"", ""\t\t\t/* FALLTHROUGH */"", ""\t\tcase LZMADEC_OK: /* Decompressor made some progress. */"", ""\t\t\tbreak;"", ""\t\tdefault:"", ""\t\t\tarchive_set_error(&(a->archive),"", ""\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""lzmadec decompression failed(%d)\"","", ""\t\t\t    r);"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t}"", ""\t\t*used = avail_in - xar->lzstream.avail_in;"", ""\t\t*outbytes = avail_out - xar->lzstream.avail_out;"", ""\t\tbreak;"", ""#endif"", ""#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)"", ""\tcase BZIP2:"", ""#endif"", ""#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)"", ""#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)"", ""\tcase LZMA:"", ""#endif"", ""\tcase XZ:"", ""#endif"", ""\tcase NONE:""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0]","[[16, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c"", ""-"", ""archive_set_error(&(a->archive),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_44_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_44_new.cpp""], [26, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c"", ""-"", ""archive_set_error(&(a->archive),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_44_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_44_new.cpp""]]",1685,1653
"["" *\tid1+size1+data1 + id2+size2+data2 ..."", "" *  triplets.  id and size are 2 bytes each."", "" */"", ""static void"", ""process_extra(const char *p, size_t extra_length, struct zip_entry* zip_entry)"", ""static int"", ""process_extra(struct archive_read *a, const char *p, size_t extra_length, struct zip_entry* zip_entry)"", ""{"", ""\tunsigned offset = 0;"", """", ""\twhile (offset < extra_length - 4) {"", ""\tif (extra_length == 0) {"", ""\t\treturn ARCHIVE_OK;"", ""\t}"", """", ""\tif (extra_length < 4) {"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t    \""Too-small extra data: Need at least 4 bytes, but only found %d bytes\"", (int)extra_length);"", ""\t\treturn ARCHIVE_FAILED;"", ""\t}"", ""\twhile (offset <= extra_length - 4) {"", ""\t\tunsigned short headerid = archive_le16dec(p + offset);"", ""\t\tunsigned short datasize = archive_le16dec(p + offset + 2);"", """", ""\t\toffset += 4;"", ""\t\tif (offset + datasize > extra_length) {"", ""\t\t\tbreak;"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t    \""Extra data overflow: Need %d bytes but only found %d bytes\"","", ""\t\t\t    (int)datasize, (int)(extra_length - offset));"", ""\t\t\treturn ARCHIVE_FAILED;"", ""\t\t}"", ""#ifdef DEBUG"", ""\t\tfprintf(stderr, \""Header id 0x%04x, length %d\\n\"",""]","[0, 0, 0, -1, -1, 1, 1, 0, 0, 0, -1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, 2, 1, 1, 1, 0, 0, 0]","[[16, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_45_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_45_new.cpp""], [27, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_45_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_45_new.cpp""]]",418,418
"[""\t\t\t/* Zip64 extended information extra field. */"", ""\t\t\tzip_entry->flags |= LA_USED_ZIP64;"", ""\t\t\tif (zip_entry->uncompressed_size == 0xffffffff) {"", ""\t\t\t\tif (datasize < 8)"", ""\t\t\t\t\tbreak;"", ""\t\t\t\tzip_entry->uncompressed_size ="", ""\t\t\t\t    archive_le64dec(p + offset);"", ""\t\t\t\tuint64_t t = 0;"", ""\t\t\t\tif (datasize < 8"", ""\t\t\t\t    || (t = archive_le64dec(p + offset)) > INT64_MAX) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t\t\t    \""Malformed 64-bit uncompressed size\"");"", ""\t\t\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\t\t}"", ""\t\t\t\tzip_entry->uncompressed_size = t;"", ""\t\t\t\toffset += 8;"", ""\t\t\t\tdatasize -= 8;"", ""\t\t\t}"", ""\t\t\tif (zip_entry->compressed_size == 0xffffffff) {"", ""\t\t\t\tif (datasize < 8)"", ""\t\t\t\t\tbreak;"", ""\t\t\t\tzip_entry->compressed_size ="", ""\t\t\t\t    archive_le64dec(p + offset);"", ""\t\t\t\tuint64_t t = 0;"", ""\t\t\t\tif (datasize < 8"", ""\t\t\t\t    || (t = archive_le64dec(p + offset)) > INT64_MAX) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t\t\t    \""Malformed 64-bit compressed size\"");"", ""\t\t\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\t\t}"", ""\t\t\t\tzip_entry->compressed_size = t;"", ""\t\t\t\toffset += 8;"", ""\t\t\t\tdatasize -= 8;"", ""\t\t\t}"", ""\t\t\tif (zip_entry->local_header_offset == 0xffffffff) {"", ""\t\t\t\tif (datasize < 8)"", ""\t\t\t\t\tbreak;"", ""\t\t\t\tzip_entry->local_header_offset ="", ""\t\t\t\t    archive_le64dec(p + offset);"", ""\t\t\t\tuint64_t t = 0;"", ""\t\t\t\tif (datasize < 8"", ""\t\t\t\t    || (t = archive_le64dec(p + offset)) > INT64_MAX) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t\t\t    \""Malformed 64-bit local header offset\"");"", ""\t\t\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\t\t}"", ""\t\t\t\tzip_entry->local_header_offset = t;"", ""\t\t\t\toffset += 8;"", ""\t\t\t\tdatasize -= 8;"", ""\t\t\t}""]","[0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0]","[[10, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_45_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_45_new.cpp""], [26, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_45_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_45_new.cpp""], [42, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_45_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_45_new.cpp""]]",440,452
"[""\t\t}"", ""\t\toffset += datasize;"", ""\t}"", ""#ifdef DEBUG"", ""\tif (offset != extra_length)"", ""\t{"", ""\t\tfprintf(stderr,"", ""\t\t    \""Extra data field contents do not match reported size!\\n\"");"", ""\tif (offset != extra_length) {"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t    \""Malformed extra data: Consumed %d bytes of %d bytes\"","", ""\t\t    (int)offset, (int)extra_length);"", ""\t\treturn ARCHIVE_FAILED;"", ""\t}"", ""#endif"", ""\treturn ARCHIVE_OK;"", ""}"", """", ""/*""]","[0, 0, 0, -1, -1, -1, -2, -1, 1, 2, 1, 1, 1, 0, -1, 1, 0, 0, 0]","[[6, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c"", ""-"", ""fprintf(stderr,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_45_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_45_new.cpp""], [9, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_45_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_45_new.cpp""]]",715,739
"[""\t\t\t|| (zip->hctx_valid"", ""\t\t\t && zip->entry->aes_extra.vendor == AES_VENDOR_AE_2))) {"", ""\t\t\tif (zip->entry->flags & LA_USED_ZIP64) {"", ""\t\t\t\tuint64_t compressed, uncompressed;"", ""\t\t\t\tzip->entry->crc32 = archive_le32dec(p + 4);"", ""\t\t\t\tzip->entry->compressed_size ="", ""\t\t\t\t\tarchive_le64dec(p + 8);"", ""\t\t\t\tzip->entry->uncompressed_size ="", ""\t\t\t\t\tarchive_le64dec(p + 16);"", ""\t\t\t\tcompressed = archive_le64dec(p + 8);"", ""\t\t\t\tuncompressed = archive_le64dec(p + 16);"", ""\t\t\t\tif (compressed > INT64_MAX || uncompressed > INT64_MAX) {"", ""\t\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t\t\t    \""Overflow of 64-bit file sizes\"");"", ""\t\t\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\t\t}"", ""\t\t\t\tzip->entry->compressed_size = compressed;"", ""\t\t\t\tzip->entry->uncompressed_size = uncompressed;"", ""\t\t\t\tzip->unconsumed = 24;"", ""\t\t\t} else {"", ""\t\t\t\tzip->entry->crc32 = archive_le32dec(p + 4);""]","[0, 0, 0, 1, 0, -1, -1, -1, -1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[12, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_45_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_45_new.cpp""]]",1136,1168
"[""\t\t\tzip->unconsumed = 4;"", ""\t\t}"", ""\t\tif (zip->entry->flags & LA_USED_ZIP64) {"", ""\t\t\tuint64_t compressed, uncompressed;"", ""\t\t\tzip->entry->crc32 = archive_le32dec(p);"", ""\t\t\tzip->entry->compressed_size = archive_le64dec(p + 4);"", ""\t\t\tzip->entry->uncompressed_size = archive_le64dec(p + 12);"", ""\t\t\tcompressed = archive_le64dec(p + 4);"", ""\t\t\tuncompressed = archive_le64dec(p + 12);"", ""\t\t\tif (compressed > INT64_MAX || uncompressed > INT64_MAX) {"", ""\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t\t    \""Overflow of 64-bit file sizes\"");"", ""\t\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\t}"", ""\t\t\tzip->entry->compressed_size = compressed;"", ""\t\t\tzip->entry->uncompressed_size = uncompressed;"", ""\t\t\tzip->unconsumed += 20;"", ""\t\t} else {"", ""\t\t\tzip->entry->crc32 = archive_le32dec(p);""]","[0, 0, 0, 1, 0, -1, -1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[10, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_45_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_45_new.cpp""]]",1417,1456
"[""\tentries = archive_acl_reset(abstract_acl, ae_requested_type);"", ""\tif (entries == 0)"", ""\t\treturn (ARCHIVE_OK);"", """", ""#if HAVE_SUN_ACL"", ""\tacl = NULL;"", ""\tacl = malloc(sizeof(acl_t));"", ""\tif (acl == NULL) {"", ""\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,"", ""\t\t\t\""Invalid ACL type\"");"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t}"", ""\tif (acl_type == ACE_T)"", ""\t\tacl->acl_entry_size = sizeof(ace_t);"", ""\telse if (acl_type == ACLENT_T)"", ""\t\tacl->acl_entry_size = sizeof(aclent_t);"", ""\telse {"", ""\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,"", ""\t\t\t\""Invalid ACL type\"");"", ""\t\tacl_free(acl);"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t}"", ""\tacl->acl_type = acl_type;"", ""\tacl->acl_cnt = entries;"", """", ""\tacl->acl_aclp = malloc(entries * acl->acl_entry_size);"", ""\tif (acl->acl_aclp == NULL) {"", ""\t\tarchive_set_error(a, errno,"", ""\t\t    \""Can't allocate memory for acl buffer\"");"", ""\t\tacl_free(acl);"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t}"", ""#else\t/* !HAVE_SUN_ACL */"", ""\tacl = acl_init(entries);"", ""\tif (acl == (acl_t)NULL) {"", ""\t\tarchive_set_error(a, errno,"", ""\t\t    \""Failed to initialize ACL working storage\"");"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t}"", ""#endif\t/* !HAVE_SUN_ACL */"", ""#if HAVE_SUN_ACL"", ""\te = 0;"", ""#endif"", ""\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,"", ""\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {"", ""\t\tacl_create_entry(&acl, &acl_entry);"", """", ""#if HAVE_SUN_ACL"", ""\t\tace = NULL;"", ""\t\taclent = NULL;"", ""\t\tif (acl->acl_type == ACE_T)  {"", ""\t\t\tace = &((ace_t *)acl->acl_aclp)[e];"", ""\t\t\tace->a_who = -1;"", ""\t\t\tace->a_access_mask = 0;"", ""\t\t\tace->a_flags = 0;"", ""\t\t} else {"", ""\t\t\taclent = &((aclent_t *)acl->acl_aclp)[e];"", ""\t\t\taclent->a_id = -1;"", ""\t\t\taclent->a_type = 0;"", ""\t\t\taclent->a_perm = 0;"", ""\t\t}"", ""#else\t/* !HAVE_SUN_ACL  */"", ""#if HAVE_DARWIN_ACL"", ""\t\t/*"", ""\t\t * Mac OS doesn't support NFSv4 ACLs for"", ""\t\t * owner@, group@ and everyone@."", ""\t\t * We skip any of these ACLs found."", ""\t\t */"", ""\t\tif (ae_tag == ARCHIVE_ENTRY_ACL_USER_OBJ ||"", ""\t\t    ae_tag == ARCHIVE_ENTRY_ACL_GROUP_OBJ ||"", ""\t\t    ae_tag == ARCHIVE_ENTRY_ACL_EVERYONE)"", ""\t\t\tcontinue;"", ""#endif"", ""\t\tif (acl_create_entry(&acl, &acl_entry) != 0) {"", ""\t\t\tarchive_set_error(a, errno,"", ""\t\t\t    \""Failed to create a new ACL entry\"");"", ""\t\t\tret = ARCHIVE_FAILED;"", ""\t\t\tgoto exit_free;"", ""\t\t}"", ""#endif\t/* !HAVE_SUN_ACL */"", ""#if HAVE_DARWIN_ACL"", ""\t\tswitch (ae_type) {"", ""\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALLOW:"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_EXTENDED_ALLOW);"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DENY:"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_EXTENDED_DENY);"", ""\t\t\tbreak;"", ""\t\tdefault:"", ""\t\t\t/* We don't support any other types on MacOS */"", ""\t\t\tcontinue;"", ""\t\t}"", ""#endif"", ""\t\tswitch (ae_tag) {"", ""#if HAVE_SUN_ACL"", ""\t\tcase ARCHIVE_ENTRY_ACL_USER:"", ""\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);"", ""\t\t\tif (acl->acl_type == ACE_T)"", ""\t\t\t\tace->a_who = ae_uid;"", ""\t\t\telse {"", ""\t\t\t\taclent->a_id = ae_uid;"", ""\t\t\t\taclent->a_type |= USER;"", ""\t\t\t}"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_GROUP:"", ""\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);"", ""\t\t\tif (acl->acl_type == ACE_T) {"", ""\t\t\t\tace->a_who = ae_gid;"", ""\t\t\t\tace->a_flags |= ACE_IDENTIFIER_GROUP;"", ""\t\t\t} else {"", ""\t\t\t\taclent->a_id = ae_gid;"", ""\t\t\t\taclent->a_type |= GROUP;"", ""\t\t\t}"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:"", ""\t\t\tif (acl->acl_type == ACE_T)"", ""\t\t\t\tace->a_flags |= ACE_OWNER;"", ""\t\t\telse"", ""\t\t\t\taclent->a_type |= USER_OBJ;"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:"", ""\t\t\tif (acl->acl_type == ACE_T) {"", ""\t\t\t\tace->a_flags |= ACE_GROUP;"", ""\t\t\t\tace->a_flags |= ACE_IDENTIFIER_GROUP;"", ""\t\t\t} else"", ""\t\t\t\taclent->a_type |= GROUP_OBJ;"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_MASK:"", ""\t\t\taclent->a_type |= CLASS_OBJ;"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_OTHER:"", ""\t\t\taclent->a_type |= OTHER_OBJ;"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_EVERYONE:"", ""\t\t\tace->a_flags |= ACE_EVERYONE;"", ""\t\t\tbreak;"", ""#else\t/* !HAVE_SUN_ACL */"", ""\t\tcase ARCHIVE_ENTRY_ACL_USER:"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_USER);"", ""\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);"", ""#if !HAVE_DARWIN_ACL\t/* FreeBSD, Linux */"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_USER);"", ""\t\t\tacl_set_qualifier(acl_entry, &ae_uid);"", ""#else\t/* MacOS */"", ""\t\t\tif (mbr_identifier_to_uuid(ID_TYPE_UID, &ae_uid,"", ""\t\t\t    sizeof(uid_t), ae_uuid) != 0)"", ""\t\t\t\tcontinue;"", ""\t\t\tif (acl_set_qualifier(acl_entry, &ae_uuid) != 0)"", ""\t\t\t\tcontinue;"", ""#endif\t/* HAVE_DARWIN_ACL */"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_GROUP:"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP);"", ""\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);"", ""#if !HAVE_DARWIN_ACL\t/* FreeBSD, Linux */"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP);"", ""\t\t\tacl_set_qualifier(acl_entry, &ae_gid);"", ""#else\t/* MacOS */"", ""\t\t\tif (mbr_identifier_to_uuid(ID_TYPE_GID, &ae_gid,"", ""\t\t\t    sizeof(gid_t), ae_uuid) != 0)"", ""\t\t\t\tcontinue;"", ""\t\t\tif (acl_set_qualifier(acl_entry, &ae_uuid) != 0)"", ""\t\t\t\tcontinue;"", ""#endif\t/* HAVE_DARWIN_ACL */"", ""\t\t\tbreak;"", ""#if !HAVE_DARWIN_ACL\t/* FreeBSD, Linux */"", ""\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_USER_OBJ);"", ""\t\t\tbreak;""]","[0, 0, 0, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0]","[[8, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_acl.c"", ""+"", ""archive_set_error(a, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_46_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_46_new.cpp""], [17, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_acl.c"", ""+"", ""archive_set_error(a, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_46_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_46_new.cpp""], [27, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_acl.c"", ""+"", ""archive_set_error(a, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_46_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_46_new.cpp""], [35, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_acl.c"", ""+"", ""archive_set_error(a, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_46_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_46_new.cpp""], [74, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_acl.c"", ""+"", ""archive_set_error(a, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_46_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_46_new.cpp""]]",151,254
"["""", ""#define HFS_BLOCKS(s)\t((s) >> 12)"", """", ""static void\tfsobj_error(int *, struct archive_string *, int, const char *,"", ""\t\t    const char *);"", ""static int\tcheck_symlinks_fsobj(char *, int *, struct archive_string *,"", ""\t\t    int);"", ""static int\tcheck_symlinks(struct archive_write_disk *);"", ""static int\tcreate_filesystem_object(struct archive_write_disk *);"", ""static struct fixup_entry *current_fixup(struct archive_write_disk *, const char *pathname);"", ""static struct fixup_entry *current_fixup(struct archive_write_disk *,"", ""\t\t    const char *pathname);"", ""#if defined(HAVE_FCHDIR) && defined(PATH_MAX)"", ""static void\tedit_deep_directories(struct archive_write_disk *ad);"", ""#endif"", ""static int\tcleanup_pathname_fsobj(char *, int *, struct archive_string *,"", ""\t\t    int);"", ""static int\tcleanup_pathname(struct archive_write_disk *);"", ""static int\tcreate_dir(struct archive_write_disk *, char *);"", ""static int\tcreate_parent_dir(struct archive_write_disk *, char *);""]","[0, 0, 0, 2, 1, 1, 1, 0, 0, -1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0]","[[3, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""static void\tfsobj_error(int *, struct archive_string *, int, const char *,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""]]",326,348
"[""\tif (a->restore_pwd >= 0) {"", ""\t\tr = fchdir(a->restore_pwd);"", ""\t\tif (r != 0) {"", ""\t\t\tarchive_set_error(&a->archive, errno, \""chdir() failure\"");"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""chdir() failure\"");"", ""\t\t\tret = ARCHIVE_FATAL;"", ""\t\t}"", ""\t\tclose(a->restore_pwd);""]","[0, 0, 0, -2, 2, 1, 0, 0, 0]","[[3, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, errno, \""chdir() failure\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [4, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""]]",637,669
"["""", ""\tif (en) {"", ""\t\t/* Everything failed; give up here. */"", ""\t\tarchive_set_error(&a->archive, en, \""Can't create '%s'\"","", ""\t\t    a->name);"", ""\t\tif ((&a->archive)->error == NULL)"", ""\t\t\tarchive_set_error(&a->archive, en, \""Can't create '%s'\"","", ""\t\t\t    a->name);"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t}"", """"]","[0, 0, 0, -2, -1, 1, 2, 1, 0, 0, 0]","[[3, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, en, \""Can't create '%s'\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [6, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, en, \""Can't create '%s'\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""]]",1993,2043
"[""#if !HAVE_LINK"", ""\t\treturn (EPERM);"", ""#else"", ""\t\tarchive_string_init(&error_string);"", ""\t\tlinkname_copy = strdup(linkname);"", ""\t\tif (linkname_copy == NULL) {"", ""\t\t    return (EPERM);"", ""\t\t}"", ""\t\t/*"", ""\t\t * TODO: consider using the cleaned-up path as the link"", ""\t\t * target?"", ""\t\t */"", ""\t\tr = cleanup_pathname_fsobj(linkname_copy, &error_number,"", ""\t\t    &error_string, a->flags);"", ""\t\tif (r != ARCHIVE_OK) {"", ""\t\t\tarchive_set_error(&a->archive, error_number, \""%s\"","", ""\t\t\t    error_string.s);"", ""\t\t\tfree(linkname_copy);"", ""\t\t\tarchive_string_free(&error_string);"", ""\t\t\t/*"", ""\t\t\t * EPERM is more appropriate than error_number for our"", ""\t\t\t * callers"", ""\t\t\t */"", ""\t\t\treturn (EPERM);"", ""\t\t}"", ""\t\tr = check_symlinks_fsobj(linkname_copy, &error_number,"", ""\t\t    &error_string, a->flags);"", ""\t\tif (r != ARCHIVE_OK) {"", ""\t\t\tarchive_set_error(&a->archive, error_number, \""%s\"","", ""\t\t\t    error_string.s);"", ""\t\t\tfree(linkname_copy);"", ""\t\t\tarchive_string_free(&error_string);"", ""\t\t\t/*"", ""\t\t\t * EPERM is more appropriate than error_number for our"", ""\t\t\t * callers"", ""\t\t\t */"", ""\t\t\treturn (EPERM);"", ""\t\t}"", ""\t\tfree(linkname_copy);"", ""\t\tarchive_string_free(&error_string);"", ""\t\tr = link(linkname, a->name) ? errno : 0;"", ""\t\t/*"", ""\t\t * New cpio and pax formats allow hardlink entries""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[15, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, error_number, \""%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [28, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, error_number, \""%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""]]",2022,2078
"[""\treturn (a->current_fixup);"", ""}"", """", ""/* TODO: Make this work. */"", ""/*"", "" * TODO: The deep-directory support bypasses this; disable deep directory"", "" * support if we're doing symlink checks."", "" */"", ""/* Error helper for new *_fsobj functions */"", ""static void"", ""fsobj_error(int *a_eno, struct archive_string *a_estr,"", ""    int err, const char *errstr, const char *path)"", ""{"", ""\tif (a_eno)"", ""\t\t*a_eno = err;"", ""\tif (a_estr)"", ""\t\tarchive_string_sprintf(a_estr, errstr, path);"", ""}"", """", ""/*"", "" * TODO: Someday, integrate this with the deep dir support; they both"", "" * scan the path and both can be optimized by comparing against other"", "" * recent paths."", "" */"", ""/* TODO: Extend this to support symlinks on Windows Vista and later. */"", """", ""/*"", "" * Checks the given path to see if any elements along it are symlinks.  Returns"", "" * ARCHIVE_OK if there are none, otherwise puts an error in errmsg."", "" */"", ""static int"", ""check_symlinks(struct archive_write_disk *a)"", ""check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,"", ""    int flags)"", ""{"", ""#if !defined(HAVE_LSTAT)"", ""\t/* Platform doesn't have lstat, so we can't look for symlinks. */"", ""\t(void)a; /* UNUSED */"", ""\t(void)path; /* UNUSED */"", ""\t(void)error_number; /* UNUSED */"", ""\t(void)error_string; /* UNUSED */"", ""\t(void)flags; /* UNUSED */"", ""\treturn (ARCHIVE_OK);"", ""#else"", ""\tchar *pn;"", ""\tint res = ARCHIVE_OK;"", ""\tchar *tail;"", ""\tchar *head;"", ""\tint last;"", ""\tchar c;"", ""\tint r;"", ""\tstruct stat st;"", ""\tint restore_pwd;"", """", ""\t/* Nothing to do here if name is empty */"", ""\tif(path[0] == '\\0')"", ""\t    return (ARCHIVE_OK);"", """", ""\t/*"", ""\t * Guard against symlink tricks.  Reject any archive entry whose"", ""\t * destination would be altered by a symlink."", ""\t *"", ""\t * Walk the filename in chunks separated by '/'.  For each segment:"", ""\t *  - if it doesn't exist, continue"", ""\t *  - if it's symlink, abort or remove it"", ""\t *  - if it's a directory and it's not the last chunk, cd into it"", ""\t * As we go:"", ""\t *  head points to the current (relative) path"", ""\t *  tail points to the temporary \\0 terminating the segment we're"", ""\t *      currently examining"", ""\t *  c holds what used to be in *tail"", ""\t *  last is 1 if this is the last tail"", ""\t */"", ""\t/* Whatever we checked last time doesn't need to be re-checked. */"", ""\tpn = a->name;"", ""\tif (archive_strlen(&(a->path_safe)) > 0) {"", ""\t\tchar *p = a->path_safe.s;"", ""\t\twhile ((*pn != '\\0') && (*p == *pn))"", ""\t\t\t++p, ++pn;"", ""\t}"", ""\trestore_pwd = open(\"".\"", O_RDONLY | O_BINARY | O_CLOEXEC);"", ""\t__archive_ensure_cloexec_flag(restore_pwd);"", ""\tif (restore_pwd < 0)"", ""\t\treturn (ARCHIVE_FATAL);"", ""\thead = path;"", ""\ttail = path;"", ""\tlast = 0;"", ""\t/* TODO: reintroduce a safe cache here? */"", ""\t/* Skip the root directory if the path is absolute. */"", ""\tif(pn == a->name && pn[0] == '/')"", ""\t\t++pn;"", ""\tc = pn[0];"", ""\t/* Keep going until we've checked the entire name. */"", ""\twhile (pn[0] != '\\0' && (pn[0] != '/' || pn[1] != '\\0')) {"", ""\tif(tail == path && tail[0] == '/')"", ""\t\t++tail;"", ""\t/* Keep going until we've checked the entire name."", ""\t * head, tail, path all alias the same string, which is"", ""\t * temporarily zeroed at tail, so be careful restoring the"", ""\t * stashed (c=tail[0]) for error messages."", ""\t * Exiting the loop with break is okay; continue is not."", ""\t */"", ""\twhile (!last) {"", ""\t\t/*"", ""\t\t * Skip the separator we just consumed, plus any adjacent ones"", ""\t\t */"", ""\t\twhile (*tail == '/')"", ""\t\t    ++tail;"", ""\t\t/* Skip the next path element. */"", ""\t\twhile (*pn != '\\0' && *pn != '/')"", ""\t\t\t++pn;"", ""\t\tc = pn[0];"", ""\t\tpn[0] = '\\0';"", ""\t\twhile (*tail != '\\0' && *tail != '/')"", ""\t\t\t++tail;"", ""\t\t/* is this the last path component? */"", ""\t\tlast = (tail[0] == '\\0') || (tail[0] == '/' && tail[1] == '\\0');"", ""\t\t/* temporarily truncate the string here */"", ""\t\tc = tail[0];"", ""\t\ttail[0] = '\\0';"", ""\t\t/* Check that we haven't hit a symlink. */"", ""\t\tr = lstat(a->name, &st);"", ""\t\tr = lstat(head, &st);"", ""\t\tif (r != 0) {"", ""\t\t\ttail[0] = c;"", ""\t\t\t/* We've hit a dir that doesn't exist; stop now. */"", ""\t\t\tif (errno == ENOENT)"", ""\t\t\tif (errno == ENOENT) {"", ""\t\t\t\tbreak;"", ""\t\t\t} else {"", ""\t\t\t\t/*"", ""\t\t\t\t * Treat any other error as fatal - best to be"", ""\t\t\t\t * paranoid here."", ""\t\t\t\t * Note: This effectively disables deep"", ""\t\t\t\t * directory support when security checks are"", ""\t\t\t\t * enabled. Otherwise, very long pathnames that"", ""\t\t\t\t * trigger an error here could evade the"", ""\t\t\t\t * sandbox."", ""\t\t\t\t * TODO: We could do better, but it would"", ""\t\t\t\t * probably require merging the symlink checks"", ""\t\t\t\t * with the deep-directory editing."", ""\t\t\t\t */"", ""\t\t\t\tfsobj_error(a_eno, a_estr, errno,"", ""\t\t\t\t    \""Could not stat %s\"", path);"", ""\t\t\t\tres = ARCHIVE_FAILED;"", ""\t\t\t\tbreak;"", ""\t\t\t}"", ""\t\t} else if (S_ISDIR(st.st_mode)) {"", ""\t\t\tif (!last) {"", ""\t\t\t\tif (chdir(head) != 0) {"", ""\t\t\t\t\ttail[0] = c;"", ""\t\t\t\t\tfsobj_error(a_eno, a_estr, errno,"", ""\t\t\t\t\t    \""Could not chdir %s\"", path);"", ""\t\t\t\t\tres = (ARCHIVE_FATAL);"", ""\t\t\t\t\tbreak;"", ""\t\t\t\t}"", ""\t\t\t\t/* Our view is now from inside this dir: */"", ""\t\t\t\thead = tail + 1;"", ""\t\t\t}"", ""\t\t} else if (S_ISLNK(st.st_mode)) {"", ""\t\t\tif (c == '\\0') {"", ""\t\t\tif (last) {"", ""\t\t\t\t/*"", ""\t\t\t\t * Last element is symlink; remove it"", ""\t\t\t\t * so we can overwrite it with the"", ""\t\t\t\t * item being extracted."", ""\t\t\t\t */"", ""\t\t\t\tif (unlink(a->name)) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\tif (unlink(head)) {"", ""\t\t\t\t\ttail[0] = c;"", ""\t\t\t\t\tfsobj_error(a_eno, a_estr, errno,"", ""\t\t\t\t\t    \""Could not remove symlink %s\"","", ""\t\t\t\t\t    a->name);"", ""\t\t\t\t\tpn[0] = c;"", ""\t\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t\t\t\t    path);"", ""\t\t\t\t\tres = ARCHIVE_FAILED;"", ""\t\t\t\t\tbreak;"", ""\t\t\t\t}"", ""\t\t\t\ta->pst = NULL;"", ""\t\t\t\t/*"", ""\t\t\t\t * Even if we did remove it, a warning"", ""\t\t\t\t * is in order.  The warning is silly,"", ""\t\t\t\t * though, if we're just replacing one"", ""\t\t\t\t * symlink with another symlink."", ""\t\t\t\t */"", ""\t\t\t\tif (!S_ISLNK(a->mode)) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, 0,"", ""\t\t\t\t\t    \""Removing symlink %s\"","", ""\t\t\t\t\t    a->name);"", ""\t\t\t\ttail[0] = c;"", ""\t\t\t\t/*"", ""\t\t\t\t * FIXME:  not sure how important this is to"", ""\t\t\t\t * restore"", ""\t\t\t\t */"", ""\t\t\t\t/*"", ""\t\t\t\tif (!S_ISLNK(path)) {"", ""\t\t\t\t\tfsobj_error(a_eno, a_estr, 0,"", ""\t\t\t\t\t    \""Removing symlink %s\"", path);"", ""\t\t\t\t}"", ""\t\t\t\t*/"", ""\t\t\t\t/* Symlink gone.  No more problem! */"", ""\t\t\t\tpn[0] = c;"", ""\t\t\t\treturn (0);"", ""\t\t\t} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {"", ""\t\t\t\tres = ARCHIVE_OK;"", ""\t\t\t\tbreak;"", ""\t\t\t} else if (flags & ARCHIVE_EXTRACT_UNLINK) {"", ""\t\t\t\t/* User asked us to remove problems. */"", ""\t\t\t\tif (unlink(a->name) != 0) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, 0,"", ""\t\t\t\t\t    \""Cannot remove intervening symlink %s\"","", ""\t\t\t\t\t    a->name);"", ""\t\t\t\t\tpn[0] = c;"", ""\t\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t\t\tif (unlink(head) != 0) {"", ""\t\t\t\t\ttail[0] = c;"", ""\t\t\t\t\tfsobj_error(a_eno, a_estr, 0,"", ""\t\t\t\t\t    \""Cannot remove intervening \"""", ""\t\t\t\t\t    \""symlink %s\"", path);"", ""\t\t\t\t\tres = ARCHIVE_FAILED;"", ""\t\t\t\t\tbreak;"", ""\t\t\t\t}"", ""\t\t\t\ttail[0] = c;"", ""\t\t\t} else if ((flags &"", ""\t\t\t    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {"", ""\t\t\t\t/*"", ""\t\t\t\t * We are not the last element and we want to"", ""\t\t\t\t * follow symlinks if they are a directory."", ""\t\t\t\t * "", ""\t\t\t\t * This is needed to extract hardlinks over"", ""\t\t\t\t * symlinks."", ""\t\t\t\t */"", ""\t\t\t\tr = stat(head, &st);"", ""\t\t\t\tif (r != 0) {"", ""\t\t\t\t\ttail[0] = c;"", ""\t\t\t\t\tif (errno == ENOENT) {"", ""\t\t\t\t\t\tbreak;"", ""\t\t\t\t\t} else {"", ""\t\t\t\t\t\tfsobj_error(a_eno, a_estr,"", ""\t\t\t\t\t\t    errno,"", ""\t\t\t\t\t\t    \""Could not stat %s\"", path);"", ""\t\t\t\t\t\tres = (ARCHIVE_FAILED);"", ""\t\t\t\t\t\tbreak;"", ""\t\t\t\t\t}"", ""\t\t\t\t} else if (S_ISDIR(st.st_mode)) {"", ""\t\t\t\t\tif (chdir(head) != 0) {"", ""\t\t\t\t\t\ttail[0] = c;"", ""\t\t\t\t\t\tfsobj_error(a_eno, a_estr,"", ""\t\t\t\t\t\t    errno,"", ""\t\t\t\t\t\t    \""Could not chdir %s\"", path);"", ""\t\t\t\t\t\tres = (ARCHIVE_FATAL);"", ""\t\t\t\t\t\tbreak;"", ""\t\t\t\t\t}"", ""\t\t\t\t\t/*"", ""\t\t\t\t\t * Our view is now from inside"", ""\t\t\t\t\t * this dir:"", ""\t\t\t\t\t */"", ""\t\t\t\t\thead = tail + 1;"", ""\t\t\t\t} else {"", ""\t\t\t\t\ttail[0] = c;"", ""\t\t\t\t\tfsobj_error(a_eno, a_estr, 0,"", ""\t\t\t\t\t    \""Cannot extract through \"""", ""\t\t\t\t\t    \""symlink %s\"", path);"", ""\t\t\t\t\tres = ARCHIVE_FAILED;"", ""\t\t\t\t\tbreak;"", ""\t\t\t\t}"", ""\t\t\t\ta->pst = NULL;"", ""\t\t\t} else {"", ""\t\t\t\tarchive_set_error(&a->archive, 0,"", ""\t\t\t\t    \""Cannot extract through symlink %s\"","", ""\t\t\t\t    a->name);"", ""\t\t\t\tpn[0] = c;"", ""\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t\t\ttail[0] = c;"", ""\t\t\t\tfsobj_error(a_eno, a_estr, 0,"", ""\t\t\t\t    \""Cannot extract through symlink %s\"", path);"", ""\t\t\t\tres = ARCHIVE_FAILED;"", ""\t\t\t\tbreak;"", ""\t\t\t}"", ""\t\t}"", ""\t\tpn[0] = c;"", ""\t\tif (pn[0] != '\\0')"", ""\t\t\tpn++; /* Advance to the next segment. */"", ""\t\t/* be sure to always maintain this */"", ""\t\ttail[0] = c;"", ""\t\tif (tail[0] != '\\0')"", ""\t\t\ttail++; /* Advance to the next segment. */"", ""\t}"", ""\t/* Catches loop exits via break */"", ""\ttail[0] = c;"", ""#ifdef HAVE_FCHDIR"", ""\t/* If we changed directory above, restore it here. */"", ""\tif (restore_pwd >= 0) {"", ""\t\tr = fchdir(restore_pwd);"", ""\t\tif (r != 0) {"", ""\t\t\tfsobj_error(a_eno, a_estr, errno,"", ""\t\t\t    \""chdir() failure\"", \""\"");"", ""\t\t}"", ""\t\tclose(restore_pwd);"", ""\t\trestore_pwd = -1;"", ""\t\tif (r != 0) {"", ""\t\t\tres = (ARCHIVE_FATAL);"", ""\t\t}"", ""\t}"", ""\tpn[0] = c;"", ""\t/* We've checked and/or cleaned the whole path, so remember it. */"", ""\tarchive_strcpy(&a->path_safe, a->name);"", ""\treturn (ARCHIVE_OK);"", ""#endif"", ""\t/* TODO: reintroduce a safe cache here? */"", ""\treturn res;"", ""#endif"", ""}"", """", ""/*"", "" * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise"", "" * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}"", "" */"", ""static int"", ""check_symlinks(struct archive_write_disk *a)"", ""{"", ""\tstruct archive_string error_string;"", ""\tint error_number;"", ""\tint rc;"", ""\tarchive_string_init(&error_string);"", ""\trc = check_symlinks_fsobj(a->name, &error_number, &error_string,"", ""\t    a->flags);"", ""\tif (rc != ARCHIVE_OK) {"", ""\t\tarchive_set_error(&a->archive, error_number, \""%s\"","", ""\t\t    error_string.s);"", ""\t}"", ""\tarchive_string_free(&error_string);"", ""\ta->pst = NULL;\t/* to be safe */"", ""\treturn rc;"", ""}"", """", """", ""#if defined(__CYGWIN__)"", ""/*"", "" * 1. Convert a path separator from '\\' to '/' .""]","[0, 0, 0, -1, -1, -1, -1, -1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, -1, 1, 1, 0, 0, 0, -1, 1, 1, 1, 1, 0, 0, -1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, 1, 0, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, 0, 0, 0, 0, -1, -2, 1, 1, 2, 0, -1, -1, -1, 1, 1, 1, 0, -1, 0, 0, 0, 0, 0, 0, -1, -2, -1, -1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 0, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, -2, -1, -1, -1, -1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0, -1, 0, -2, -1, -1, -1, -1, 1, 2, 1, 1, 1, 0, 0, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[10, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(int *a_eno, struct archive_string *a_estr,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [16, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_string_sprintf(a_estr, errstr, path);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [142, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [151, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [168, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [171, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [188, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [198, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [211, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [218, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [240, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [249, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [262, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [270, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [276, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [297, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [330, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, error_number, \""%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""]]",2351,2457
"["" * is set) if the path is absolute."", "" */"", ""static int"", ""cleanup_pathname(struct archive_write_disk *a)"", ""cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,"", ""    int flags)"", ""{"", ""\tchar *dest, *src;"", ""\tchar separator = '\\0';"", """", ""\tdest = src = a->name;"", ""\tdest = src = path;"", ""\tif (*src == '\\0') {"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Invalid empty pathname\"");"", ""\t\tfsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Invalid empty \"", \""pathname\"");"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t}"", """", ""#if defined(__CYGWIN__)"", ""\tcleanup_pathname_win(a);"", ""\tcleanup_pathname_win(path);"", ""#endif"", ""\t/* Skip leading '/'. */"", ""\tif (*src == '/') {"", ""\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t                  \""Path is absolute\"");"", ""\t\tif (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {"", ""\t\t\tfsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Path is \"", \""absolute\"");"", ""\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t}"", """"]","[0, 0, 0, -1, 1, 1, 0, 0, 0, 0, -1, 1, 0, -2, -1, 2, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, -2, -1, 1, 2, 1, 0, 0, 0]","[[13, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [15, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [27, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [30, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""]]",2534,2807
"[""\t\t\t} else if (src[1] == '.') {"", ""\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {"", ""\t\t\t\t\t/* Conditionally warn about '..' */"", ""\t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {"", ""\t\t\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t\tif (flags"", ""\t\t\t\t\t    & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {"", ""\t\t\t\t\t\tfsobj_error(a_eno, a_estr,"", ""\t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t\t\t\t    \""Path contains '..'\"");"", ""\t\t\t\t\t\t    \""Path contains \"", \""'..'\"");"", ""\t\t\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t\t\t\t}"", ""\t\t\t\t}""]","[0, 0, 0, -1, -2, 1, 1, 2, 0, -1, 1, 0, 0, 0]","[[4, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [7, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""]]",2580,2854
"[""\treturn (ARCHIVE_OK);"", ""}"", """", ""static int"", ""cleanup_pathname(struct archive_write_disk *a)"", ""{"", ""\tstruct archive_string error_string;"", ""\tint error_number;"", ""\tint rc;"", ""\tarchive_string_init(&error_string);"", ""\trc = cleanup_pathname_fsobj(a->name, &error_number, &error_string,"", ""\t    a->flags);"", ""\tif (rc != ARCHIVE_OK) {"", ""\t\tarchive_set_error(&a->archive, error_number, \""%s\"","", ""\t\t    error_string.s);"", ""\t}"", ""\tarchive_string_free(&error_string);"", ""\treturn rc;"", ""}"", """", ""/*"", "" * Create the parent directory of the specified path, assuming path"", "" * is already in mutable storage.""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[13, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, error_number, \""%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""]]",2629,2904
"[""\t\t}"", ""\t} else if (errno != ENOENT && errno != ENOTDIR) {"", ""\t\t/* Stat failed? */"", ""\t\tarchive_set_error(&a->archive, errno, \""Can't test directory '%s'\"", path);"", ""\t\tarchive_set_error(&a->archive, errno,"", ""\t\t    \""Can't test directory '%s'\"", path);"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t} else if (slash != NULL) {"", ""\t\t*slash = '\\0';""]","[0, 0, 0, -2, 2, 1, 0, 0, 0]","[[3, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, errno, \""Can't test directory '%s'\"", path);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [4, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""]]",2707,2999
"[""\t\t\t\tif (errno == ENOTSUP || errno == ENOSYS) {"", ""\t\t\t\t\tif (!warning_done) {"", ""\t\t\t\t\t\twarning_done = 1;"", ""\t\t\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t\t\t    errno,"", ""\t\t\t\t\t\t    \""Cannot restore extended \"""", ""\t\t\t\t\t\t    \""attributes on this file \"""", ""\t\t\t\t\t\t    \""system\"");""]","[0, 0, 0, -2, 2, 1, 0, 0, 0]","[[3, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [4, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""]]",3753,4051
"[""\t\t\t\tret = ARCHIVE_WARN;"", ""\t\t\t}"", ""\t\t} else {"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t    \""Invalid extended attribute encountered\"");"", ""\t\t\tret = ARCHIVE_WARN;"", ""\t\t}""]","[0, 0, 0, -2, 2, 1, 0, 0, 0]","[[3, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [4, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""]]",3764,4063
"[""\t\t\terrno = 0;"", ""#if HAVE_EXTATTR_SET_FD"", ""\t\t\tif (a->fd >= 0)"", ""\t\t\t\te = extattr_set_fd(a->fd, namespace, name, value, size);"", ""\t\t\t\te = extattr_set_fd(a->fd, namespace, name,"", ""\t\t\t\t    value, size);"", ""\t\t\telse"", ""#endif"", ""\t\t\t/* TODO: should we use extattr_set_link() instead? */"", ""\t\t\t{"", ""\t\t\t\te = extattr_set_file(archive_entry_pathname(entry),"", ""\t\t\t\t    namespace, name, value, size);"", ""\t\t\t\te = extattr_set_file("", ""\t\t\t\t    archive_entry_pathname(entry), namespace,"", ""\t\t\t\t    name, value, size);"", ""\t\t\t}"", ""\t\t\tif (e != (int)size) {"", ""\t\t\t\tif (errno == ENOTSUP || errno == ENOSYS) {"", ""\t\t\t\t\tif (!warning_done) {"", ""\t\t\t\t\t\twarning_done = 1;"", ""\t\t\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t\t\t    errno,"", ""\t\t\t\t\t\t    \""Cannot restore extended \"""", ""\t\t\t\t\t\t    \""attributes on this file \"""", ""\t\t\t\t\t\t    \""system\"");""]","[0, 0, 0, -1, 1, 1, 0, 0, 0, 0, -1, -1, 1, 1, 1, 0, 0, 0, 0, 0, -2, 2, 1, 0, 0, 0]","[[20, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""], [21, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_47_new.cpp""]]",3808,4108
"[""\treturn (ARCHIVE_OK);"", ""}"", """", ""/* Add ACL to pax header */"", ""static int"", ""add_pax_acl(struct archive_write *a,"", ""    struct archive_entry *entry, struct pax *pax, int flags)"", ""{"", ""\tchar *p;"", ""\tconst char *attr;"", ""\tint acl_types;"", """", ""\tacl_types = archive_entry_acl_types(entry);"", """", ""\tif ((acl_types & ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0)"", ""\t\tattr = \""SCHILY.acl.ace\"";"", ""\telse if ((flags & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0)"", ""\t\tattr = \""SCHILY.acl.access\"";"", ""\telse if ((flags & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)"", ""\t\tattr = \""SCHILY.acl.default\"";"", ""\telse"", ""\t\treturn (ARCHIVE_FATAL);"", """", ""\tp = archive_entry_acl_to_text_l(entry, NULL, flags, pax->sconv_utf8);"", ""\tif (p == NULL) {"", ""\t\tif (errno == ENOMEM) {"", ""\t\t\tarchive_set_error(&a->archive, ENOMEM, \""%s %s\"","", ""\t\t\t    \""Can't allocate memory for \"", attr);"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t}"", ""\t\tarchive_set_error(&a->archive,"", ""\t\t    ARCHIVE_ERRNO_FILE_FORMAT, \""%s %s %s\"","", ""\t\t    \""Can't translate \"", attr, \"" to UTF-8\"");"", ""\t\treturn(ARCHIVE_WARN);"", ""\t} else if (*p != '\\0') {"", ""\t\tadd_pax_attr(&(pax->pax_header),"", ""\t\t    attr, p);"", ""\t\tfree(p);"", ""\t}"", ""\treturn(ARCHIVE_OK);"", ""}"", """", ""/*"", "" * TODO: Consider adding 'comment' and 'charset' fields to"", "" * archive_entry so that clients can specify them.  Also, consider""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[26, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_set_format_pax.c"", ""+"", ""archive_set_error(&a->archive, ENOMEM, \""%s %s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_48_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_48_new.cpp""], [30, ""a59a7ee95601f3496ec9ba9ae1283a8d980460bf"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2017-02-19 (100ee75a)"", ""Utilities/cmlibarchive/libarchive/archive_write_set_format_pax.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_48_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_48_new.cpp""]]",450,491
"[""\tname = archive_entry_sourcepath(entry);"", ""\tif (name == NULL)"", ""\t\tname = archive_entry_pathname(entry);"", ""\telse if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {"", ""\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""Can't change dir to read extended attributes\"");"", ""\t\t\treturn (ARCHIVE_FAILED);"", ""\t}"", ""\tif (name == NULL) {"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Can't open file to read extended attributes: No name\"");"", ""\t\treturn (ARCHIVE_WARN);"", ""\t}"", """", ""\tif (a->tree != NULL) {"", ""\t\tif (a->tree_enter_working_dir(a->tree) != 0) {"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Couldn't change dir\"");"", ""\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t}"", ""\t}"", """", ""\t/* Short-circuit if there's nothing to do. */"", ""\thave_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);"", ""\tif (have_attrs == -1) {""]","[0, 0, 0, 1, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, -1, -1, -2, -1, -1, -1, -1, -1, 0, 0, 0]","[[4, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""], [16, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""-"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""]]",302,321
"[""}"", ""#endif"", """", ""#if HAVE_DARWIN_ACL"", ""static int translate_guid(struct archive *, acl_entry_t,"", ""    int *, int *, const char **);"", """", ""static void add_trivial_nfs4_acl(struct archive_entry *);"", ""#endif"", """", ""#if HAVE_SUN_ACL"", ""static int"", ""sun_acl_is_trivial(acl_t *, mode_t, int *trivialp);"", ""#endif"", """", ""#ifdef HAVE_POSIX_ACL"", ""#if HAVE_POSIX_ACL || HAVE_NFS4_ACL"", ""static int translate_acl(struct archive_read_disk *a,"", ""    struct archive_entry *entry, acl_t acl, int archive_entry_acl_type);"", ""    struct archive_entry *entry,"", ""#if HAVE_SUN_ACL"", ""    acl_t *acl,"", ""#else"", ""    acl_t acl,"", ""#endif"", ""    int archive_entry_acl_type);"", """", ""static int"", ""setup_acls(struct archive_read_disk *a,"", ""    struct archive_entry *entry, int *fd)"", ""{"", ""\tconst char\t*accpath;"", ""\tacl_t\t\t acl;"", ""#if HAVE_ACL_IS_TRIVIAL_NP"", ""\tint\t\tr;"", ""#if HAVE_SUN_ACL"", ""\tacl_t\t\t*acl;"", ""#else"", ""\tacl_t\t\tacl;"", ""#endif"", ""\tint\t\tr;"", """", ""\taccpath = archive_entry_sourcepath(entry);"", ""\tif (accpath == NULL)"", ""\t\taccpath = archive_entry_pathname(entry);"", ""\taccpath = NULL;"", """", ""#if HAVE_SUN_ACL || HAVE_DARWIN_ACL || HAVE_ACL_GET_FD_NP"", ""\tif (*fd < 0)"", ""#else"", ""\t/* For default ACLs on Linux we need reachable accpath */"", ""\tif (*fd < 0 || S_ISDIR(archive_entry_mode(entry)))"", ""#endif"", ""\t{"", ""\t\taccpath = archive_entry_sourcepath(entry);"", ""\t\tif (accpath == NULL || (a->tree != NULL &&"", ""\t\t    a->tree_enter_working_dir(a->tree) != 0))"", ""\t\t\taccpath = archive_entry_pathname(entry);"", ""\t\tif (accpath == NULL) {"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Couldn't determine file path to read ACLs\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tif (a->tree != NULL &&"", ""#if !HAVE_SUN_ACL && !HAVE_DARWIN_ACL && !HAVE_ACL_GET_FD_NP"", ""\t\t    *fd < 0 &&"", ""#endif"", ""\t\t    (a->follow_symlinks ||"", ""\t\t    archive_entry_filetype(entry) != AE_IFLNK)) {"", ""\t\t\t*fd = a->open_on_current_dir(a->tree,"", ""\t\t\t    accpath, O_RDONLY | O_NONBLOCK);"", ""\t\t}"", ""\t}"", """", ""\tarchive_entry_acl_clear(entry);"", """", ""#ifdef ACL_TYPE_NFS4"", ""\t/* Try NFS4 ACL first. */"", ""\tacl = NULL;"", """", ""#if HAVE_NFS4_ACL"", ""\t/* Try NFSv4 ACL first. */"", ""\tif (*fd >= 0)"", ""#if HAVE_SUN_ACL"", ""\t\t/* Solaris reads both POSIX.1e and NFSv4 ACL here */"", ""\t\tfacl_get(*fd, 0, &acl);"", ""#elif HAVE_ACL_GET_FD_NP"", ""\t\tacl = acl_get_fd_np(*fd, ARCHIVE_PLATFORM_ACL_TYPE_NFS4);"", ""#else"", ""\t\tacl = acl_get_fd(*fd);"", ""#endif"", ""#if HAVE_ACL_GET_LINK_NP"", ""\telse if (!a->follow_symlinks)"", ""\t\tacl = acl_get_link_np(accpath, ACL_TYPE_NFS4);"", ""\t\tacl = acl_get_link_np(accpath, ARCHIVE_PLATFORM_ACL_TYPE_NFS4);"", ""#else"", ""\telse if ((!a->follow_symlinks)"", ""\t    && (archive_entry_filetype(entry) == AE_IFLNK))""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, -1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 1, 0, 1, 0, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, -1, -1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, -1, 1, 0, 0, 0]","[[59, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""]]",400,416
"[""\t\tacl = NULL;"", ""#endif"", ""\telse"", ""\t\tacl = acl_get_file(accpath, ACL_TYPE_NFS4);"", ""#if HAVE_ACL_IS_TRIVIAL_NP"", ""#if HAVE_SUN_ACL"", ""\t\t/* Solaris reads both POSIX.1e and NFSv4 ACLs here */"", ""\t\tacl_get(accpath, 0, &acl);"", ""#else"", ""\t\tacl = acl_get_file(accpath, ARCHIVE_PLATFORM_ACL_TYPE_NFS4);"", ""#endif"", """", """", ""#if HAVE_ACL_IS_TRIVIAL_NP || HAVE_SUN_ACL"", ""\t/* Ignore \""trivial\"" ACLs that just mirror the file mode. */"", ""\tacl_is_trivial_np(acl, &r);"", ""\tif (r) {"", ""\t\tacl_free(acl);"", ""\t\tacl = NULL;"", ""\t}"", ""\tif (acl != NULL) {"", ""#if HAVE_SUN_ACL"", ""\t\tif (sun_acl_is_trivial(acl, archive_entry_mode(entry),"", ""\t\t    &r) == 0 && r == 1)"", ""#elif HAVE_ACL_IS_TRIVIAL_NP"", ""\t\tif (acl_is_trivial_np(acl, &r) == 0 && r == 1)"", ""#endif"", ""\t\t{"", ""\t\t\tacl_free(acl);"", ""\t\t\tacl = NULL;"", ""\t\t\t/*"", ""\t\t\t * Simultaneous NFSv4 and POSIX.1e ACLs for the same"", ""\t\t\t * entry are not allowed, so we should return here"", ""\t\t\t */"", ""\t\t\treturn (ARCHIVE_OK);"", ""\t\t}"", ""\t}"", ""#endif\t/* HAVE_ACL_IS_TRIVIAL_NP || HAVE_SUN_ACL */"", ""\tif (acl != NULL) {"", ""\t\ttranslate_acl(a, entry, acl, ARCHIVE_ENTRY_ACL_TYPE_NFS4);"", ""\t\tr = translate_acl(a, entry, acl, ARCHIVE_ENTRY_ACL_TYPE_NFS4);"", ""\t\tacl_free(acl);"", ""\t\treturn (ARCHIVE_OK);"", ""\t}"", ""\t\tif (r != ARCHIVE_OK) {"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""Couldn't translate \"""", ""#if !HAVE_SUN_ACL"", ""\t\t\t    \""NFSv4 \"""", ""#endif"", ""\t\t\t    \""ACLs\"");"", ""\t\t}"", ""#if HAVE_DARWIN_ACL"", ""\t\t/*"", ""\t\t * Because Mac OS doesn't support owner@, group@ and everyone@"", ""\t\t * ACLs we need to add NFSv4 ACLs mirroring the file mode to"", ""\t\t * the archive entry. Otherwise extraction on non-Mac platforms"", ""\t\t * would lead to an invalid file mode."", ""\t\t */"", ""\t\tif ((archive_entry_acl_types(entry) &"", ""\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0)"", ""\t\t\tadd_trivial_nfs4_acl(entry);"", ""#endif"", ""\t\treturn (r);"", ""\t}"", ""#endif\t/* HAVE_NFS4_ACL */"", """", ""#if HAVE_POSIX_ACL"", ""\t/* This code path is skipped on MacOS and Solaris */"", """", ""\t/* Retrieve access ACL from file. */"", ""\tif (*fd >= 0)""]","[0, 0, 0, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, -1, -1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[45, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""]]",436,505
"[""#endif"", ""\telse"", ""\t\tacl = acl_get_file(accpath, ACL_TYPE_ACCESS);"", """", ""#if HAVE_ACL_IS_TRIVIAL_NP"", ""\t/* Ignore \""trivial\"" ACLs that just mirror the file mode. */"", ""\tif (acl != NULL && acl_is_trivial_np(acl, &r) == 0) {"", ""\t\tif (r) {"", ""\t\t\tacl_free(acl);"", ""\t\t\tacl = NULL;"", ""\t\t}"", ""\t}"", ""#endif"", """", ""\tif (acl != NULL) {"", ""\t\ttranslate_acl(a, entry, acl,"", ""\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);"", ""\t\tr = translate_acl(a, entry, acl, ARCHIVE_ENTRY_ACL_TYPE_ACCESS);"", ""\t\tacl_free(acl);"", ""\t\tacl = NULL;"", ""\t\tif (r != ARCHIVE_OK) {"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""Couldn't translate access ACLs\"");"", ""\t\t\treturn (r);"", ""\t\t}"", ""\t}"", """", ""\t/* Only directories can have default ACLs. */"", ""\tif (S_ISDIR(archive_entry_mode(entry))) {"", ""#if HAVE_ACL_GET_FD_NP"", ""\t\tif (*fd >= 0)"", ""\t\t\tacl = acl_get_fd_np(*fd, ACL_TYPE_DEFAULT);"", ""\t\telse"", ""#endif"", ""\t\tacl = acl_get_file(accpath, ACL_TYPE_DEFAULT);"", ""\t\tif (acl != NULL) {"", ""\t\t\ttranslate_acl(a, entry, acl,"", ""\t\t\tr = translate_acl(a, entry, acl,"", ""\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);"", ""\t\t\tacl_free(acl);"", ""\t\t\tif (r != ARCHIVE_OK) {"", ""\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Couldn't translate default ACLs\"");"", ""\t\t\t\treturn (r);"", ""\t\t\t}"", ""\t\t}"", ""\t}"", ""#endif\t/* HAVE_POSIX_ACL */"", ""\treturn (ARCHIVE_OK);"", ""}"", """", ""/*"", "" * Translate system ACL into libarchive internal structure."", "" * Translate system ACL permissions into libarchive internal structure"", "" */"", """", ""static struct {"", ""        int archive_perm;"", ""        int platform_perm;"", ""static const struct {"", ""\tconst int archive_perm;"", ""\tconst int platform_perm;"", ""} acl_perm_map[] = {"", ""        {ARCHIVE_ENTRY_ACL_EXECUTE, ACL_EXECUTE},"", ""        {ARCHIVE_ENTRY_ACL_WRITE, ACL_WRITE},"", ""        {ARCHIVE_ENTRY_ACL_READ, ACL_READ},"", ""#ifdef ACL_TYPE_NFS4"", ""        {ARCHIVE_ENTRY_ACL_READ_DATA, ACL_READ_DATA},"", ""        {ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, ACL_LIST_DIRECTORY},"", ""        {ARCHIVE_ENTRY_ACL_WRITE_DATA, ACL_WRITE_DATA},"", ""        {ARCHIVE_ENTRY_ACL_ADD_FILE, ACL_ADD_FILE},"", ""        {ARCHIVE_ENTRY_ACL_APPEND_DATA, ACL_APPEND_DATA},"", ""        {ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY, ACL_ADD_SUBDIRECTORY},"", ""        {ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS, ACL_READ_NAMED_ATTRS},"", ""        {ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS, ACL_WRITE_NAMED_ATTRS},"", ""        {ARCHIVE_ENTRY_ACL_DELETE_CHILD, ACL_DELETE_CHILD},"", ""        {ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES, ACL_READ_ATTRIBUTES},"", ""        {ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES, ACL_WRITE_ATTRIBUTES},"", ""        {ARCHIVE_ENTRY_ACL_DELETE, ACL_DELETE},"", ""        {ARCHIVE_ENTRY_ACL_READ_ACL, ACL_READ_ACL},"", ""        {ARCHIVE_ENTRY_ACL_WRITE_ACL, ACL_WRITE_ACL},"", ""        {ARCHIVE_ENTRY_ACL_WRITE_OWNER, ACL_WRITE_OWNER},"", ""        {ARCHIVE_ENTRY_ACL_SYNCHRONIZE, ACL_SYNCHRONIZE}"", ""#if HAVE_SUN_ACL\t/* Solaris NFSv4 ACL permissions */"", ""\t{ARCHIVE_ENTRY_ACL_EXECUTE, ACE_EXECUTE},"", ""\t{ARCHIVE_ENTRY_ACL_READ_DATA, ACE_READ_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, ACE_LIST_DIRECTORY},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_DATA, ACE_WRITE_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_ADD_FILE, ACE_ADD_FILE},"", ""\t{ARCHIVE_ENTRY_ACL_APPEND_DATA, ACE_APPEND_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY, ACE_ADD_SUBDIRECTORY},"", ""\t{ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS, ACE_READ_NAMED_ATTRS},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS, ACE_WRITE_NAMED_ATTRS},"", ""\t{ARCHIVE_ENTRY_ACL_DELETE_CHILD, ACE_DELETE_CHILD},"", ""\t{ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES, ACE_READ_ATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES, ACE_WRITE_ATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_DELETE, ACE_DELETE},"", ""\t{ARCHIVE_ENTRY_ACL_READ_ACL, ACE_READ_ACL},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_ACL, ACE_WRITE_ACL},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_OWNER, ACE_WRITE_OWNER},"", ""\t{ARCHIVE_ENTRY_ACL_SYNCHRONIZE, ACE_SYNCHRONIZE}"", ""#elif HAVE_DARWIN_ACL\t/* MacOS ACL permissions */"", ""\t{ARCHIVE_ENTRY_ACL_READ_DATA, ACL_READ_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, ACL_LIST_DIRECTORY},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_DATA, ACL_WRITE_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_ADD_FILE, ACL_ADD_FILE},"", ""\t{ARCHIVE_ENTRY_ACL_EXECUTE, ACL_EXECUTE},"", ""\t{ARCHIVE_ENTRY_ACL_DELETE, ACL_DELETE},"", ""\t{ARCHIVE_ENTRY_ACL_APPEND_DATA, ACL_APPEND_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY, ACL_ADD_SUBDIRECTORY},"", ""\t{ARCHIVE_ENTRY_ACL_DELETE_CHILD, ACL_DELETE_CHILD},"", ""\t{ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES, ACL_READ_ATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES, ACL_WRITE_ATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS, ACL_READ_EXTATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS, ACL_WRITE_EXTATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_READ_ACL, ACL_READ_SECURITY},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_ACL, ACL_WRITE_SECURITY},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_OWNER, ACL_CHANGE_OWNER},"", ""\t{ARCHIVE_ENTRY_ACL_SYNCHRONIZE, ACL_SYNCHRONIZE}"", ""#else\t/* POSIX.1e ACL permissions */"", ""\t{ARCHIVE_ENTRY_ACL_EXECUTE, ACL_EXECUTE},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE, ACL_WRITE},"", ""\t{ARCHIVE_ENTRY_ACL_READ, ACL_READ},"", ""#if HAVE_ACL_TYPE_NFS4\t/* FreeBSD NFSv4 ACL permissions */"", ""\t{ARCHIVE_ENTRY_ACL_READ_DATA, ACL_READ_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, ACL_LIST_DIRECTORY},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_DATA, ACL_WRITE_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_ADD_FILE, ACL_ADD_FILE},"", ""\t{ARCHIVE_ENTRY_ACL_APPEND_DATA, ACL_APPEND_DATA},"", ""\t{ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY, ACL_ADD_SUBDIRECTORY},"", ""\t{ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS, ACL_READ_NAMED_ATTRS},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS, ACL_WRITE_NAMED_ATTRS},"", ""\t{ARCHIVE_ENTRY_ACL_DELETE_CHILD, ACL_DELETE_CHILD},"", ""\t{ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES, ACL_READ_ATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES, ACL_WRITE_ATTRIBUTES},"", ""\t{ARCHIVE_ENTRY_ACL_DELETE, ACL_DELETE},"", ""\t{ARCHIVE_ENTRY_ACL_READ_ACL, ACL_READ_ACL},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_ACL, ACL_WRITE_ACL},"", ""\t{ARCHIVE_ENTRY_ACL_WRITE_OWNER, ACL_WRITE_OWNER},"", ""\t{ARCHIVE_ENTRY_ACL_SYNCHRONIZE, ACL_SYNCHRONIZE}"", ""#endif"", ""#endif\t/* !HAVE_SUN_ACL && !HAVE_DARWIN_ACL */"", ""};"", """", ""#ifdef ACL_TYPE_NFS4"", ""static struct {"", ""        int archive_inherit;"", ""        int platform_inherit;"", ""#if HAVE_NFS4_ACL"", ""/*"", "" * Translate system NFSv4 inheritance flags into libarchive internal structure"", "" */"", ""static const struct {"", ""\tconst int archive_inherit;"", ""\tconst int platform_inherit;"", ""} acl_inherit_map[] = {"", ""        {ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, ACL_ENTRY_FILE_INHERIT},"", ""#if HAVE_SUN_ACL\t/* Solaris ACL inheritance flags */"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, ACE_FILE_INHERIT_ACE},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT, ACE_DIRECTORY_INHERIT_ACE},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT, ACE_NO_PROPAGATE_INHERIT_ACE},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY, ACE_INHERIT_ONLY_ACE},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_SUCCESSFUL_ACCESS, ACE_SUCCESSFUL_ACCESS_ACE_FLAG},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_FAILED_ACCESS, ACE_FAILED_ACCESS_ACE_FLAG},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERITED, ACE_INHERITED_ACE}"", ""#elif HAVE_DARWIN_ACL\t/* MacOS NFSv4 inheritance flags */"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERITED, ACL_ENTRY_INHERITED},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, ACL_ENTRY_FILE_INHERIT},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT, ACL_ENTRY_DIRECTORY_INHERIT},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT, ACL_ENTRY_LIMIT_INHERIT},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY, ACL_ENTRY_ONLY_INHERIT}"", ""#else\t/* FreeBSD NFSv4 ACL inheritance flags */"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, ACL_ENTRY_FILE_INHERIT},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT, ACL_ENTRY_DIRECTORY_INHERIT},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT, ACL_ENTRY_NO_PROPAGATE_INHERIT},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY, ACL_ENTRY_INHERIT_ONLY}"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY, ACL_ENTRY_INHERIT_ONLY},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_SUCCESSFUL_ACCESS, ACL_ENTRY_SUCCESSFUL_ACCESS},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_FAILED_ACCESS, ACL_ENTRY_FAILED_ACCESS},"", ""\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERITED, ACL_ENTRY_INHERITED}"", ""#endif\t/* !HAVE_SUN_ACL && !HAVE_DARWIN_ACL */"", ""};"", ""#endif"", ""#endif\t/* HAVE_NFS4_ACL */"", """", ""#if HAVE_DARWIN_ACL"", ""static int translate_guid(struct archive *a, acl_entry_t acl_entry,"", ""    int *ae_id, int *ae_tag, const char **ae_name)"", ""{"", ""\tvoid *q;"", ""\tuid_t ugid;"", ""\tint r, idtype;"", ""\tstruct passwd *pwd;"", ""\tstruct group *grp;"", """", ""\tq = acl_get_qualifier(acl_entry);"", ""\tif (q == NULL)"", ""\t\treturn (1);"", ""\tr = mbr_uuid_to_id((const unsigned char *)q, &ugid, &idtype);"", ""\tif (r != 0) {"", ""\t\tacl_free(q);"", ""\t\treturn (1);"", ""\t}"", ""\tif (idtype == ID_TYPE_UID) {"", ""\t\t*ae_tag = ARCHIVE_ENTRY_ACL_USER;"", ""\t\tpwd = getpwuuid(q);"", ""\t\tif (pwd == NULL) {"", ""\t\t\t*ae_id = ugid;"", ""\t\t\t*ae_name = NULL;"", ""\t\t} else {"", ""\t\t\t*ae_id = pwd->pw_uid;"", ""\t\t\t*ae_name = archive_read_disk_uname(a, *ae_id);"", ""\t\t}"", ""\t} else if (idtype == ID_TYPE_GID) {"", ""\t\t*ae_tag = ARCHIVE_ENTRY_ACL_GROUP;"", ""\t\tgrp = getgruuid(q);"", ""\t\tif (grp == NULL) {"", ""\t\t\t*ae_id = ugid;"", ""\t\t\t*ae_name = NULL;"", ""\t\t} else {"", ""\t\t\t*ae_id = grp->gr_gid;"", ""\t\t\t*ae_name = archive_read_disk_gname(a, *ae_id);"", ""\t\t}"", ""\t} else"", ""\t\tr = 1;"", """", ""\tacl_free(q);"", ""\treturn (r);"", ""}"", """", ""/*"", "" * Add trivial NFSv4 ACL entries from mode"", "" */"", ""static void"", ""add_trivial_nfs4_acl(struct archive_entry *entry)"", ""{"", ""\tmode_t mode;"", ""\tint i;"", ""\tconst int rperm = ARCHIVE_ENTRY_ACL_READ_DATA;"", ""\tconst int wperm = ARCHIVE_ENTRY_ACL_WRITE_DATA |"", ""\t    ARCHIVE_ENTRY_ACL_APPEND_DATA;"", ""\tconst int eperm = ARCHIVE_ENTRY_ACL_EXECUTE;"", ""\tconst int pubset = ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES |"", ""\t    ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS |"", ""\t    ARCHIVE_ENTRY_ACL_READ_ACL |"", ""\t    ARCHIVE_ENTRY_ACL_SYNCHRONIZE;"", ""\tconst int ownset = pubset | ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES |"", ""\t    ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS |"", ""\t    ARCHIVE_ENTRY_ACL_WRITE_ACL |"", ""\t    ARCHIVE_ENTRY_ACL_WRITE_OWNER;"", """", ""\tstruct {"", ""\t    const int type;"", ""\t    const int tag;"", ""\t    int permset;"", ""\t} tacl_entry[] = {"", ""\t    {ARCHIVE_ENTRY_ACL_TYPE_ALLOW, ARCHIVE_ENTRY_ACL_USER_OBJ, 0},"", ""\t    {ARCHIVE_ENTRY_ACL_TYPE_DENY, ARCHIVE_ENTRY_ACL_USER_OBJ, 0},"", ""\t    {ARCHIVE_ENTRY_ACL_TYPE_DENY, ARCHIVE_ENTRY_ACL_GROUP_OBJ, 0},"", ""\t    {ARCHIVE_ENTRY_ACL_TYPE_ALLOW, ARCHIVE_ENTRY_ACL_USER_OBJ, ownset},"", ""\t    {ARCHIVE_ENTRY_ACL_TYPE_ALLOW, ARCHIVE_ENTRY_ACL_GROUP_OBJ, pubset},"", ""\t    {ARCHIVE_ENTRY_ACL_TYPE_ALLOW, ARCHIVE_ENTRY_ACL_EVERYONE, pubset}"", ""\t};"", """", ""\tmode = archive_entry_mode(entry);"", """", ""\t/* Permissions for everyone@ */"", ""\tif (mode & 0004)"", ""\t\ttacl_entry[5].permset |= rperm;"", ""\tif (mode & 0002)"", ""\t\ttacl_entry[5].permset |= wperm;"", ""\tif (mode & 0001)"", ""\t\ttacl_entry[5].permset |= eperm;"", """", ""\t/* Permissions for group@ */"", ""\tif (mode & 0040)"", ""\t\ttacl_entry[4].permset |= rperm;"", ""\telse if (mode & 0004)"", ""\t\ttacl_entry[2].permset |= rperm;"", ""\tif (mode & 0020)"", ""\t\ttacl_entry[4].permset |= wperm;"", ""\telse if (mode & 0002)"", ""\t\ttacl_entry[2].permset |= wperm;"", ""\tif (mode & 0010)"", ""\t\ttacl_entry[4].permset |= eperm;"", ""\telse if (mode & 0001)"", ""\t\ttacl_entry[2].permset |= eperm;"", """", ""\t/* Permissions for owner@ */"", ""\tif (mode & 0400) {"", ""\t\ttacl_entry[3].permset |= rperm;"", ""\t\tif (!(mode & 0040) && (mode & 0004))"", ""\t\t\ttacl_entry[0].permset |= rperm;"", ""\t} else if ((mode & 0040) || (mode & 0004))"", ""\t\ttacl_entry[1].permset |= rperm;"", ""\tif (mode & 0200) {"", ""\t\ttacl_entry[3].permset |= wperm;"", ""\t\tif (!(mode & 0020) && (mode & 0002))"", ""\t\t\ttacl_entry[0].permset |= wperm;"", ""\t} else if ((mode & 0020) || (mode & 0002))"", ""\t\ttacl_entry[1].permset |= wperm;"", ""\tif (mode & 0100) {"", ""\t\ttacl_entry[3].permset |= eperm;"", ""\t\tif (!(mode & 0010) && (mode & 0001))"", ""\t\t\ttacl_entry[0].permset |= eperm;"", ""\t} else if ((mode & 0010) || (mode & 0001))"", ""\t\ttacl_entry[1].permset |= eperm;"", """", ""\tfor (i = 0; i < 6; i++) {"", ""\t\tif (tacl_entry[i].permset != 0) {"", ""\t\t\tarchive_entry_acl_add_entry(entry,"", ""\t\t\t    tacl_entry[i].type, tacl_entry[i].permset,"", ""\t\t\t    tacl_entry[i].tag, -1, NULL);"", ""\t\t}"", ""\t}"", """", ""\treturn;"", ""}"", ""#elif HAVE_SUN_ACL"", ""/*"", "" * Check if acl is trivial"", "" * This is a FreeBSD acl_is_trivial_np() implementation for Solaris"", "" */"", ""static int"", ""sun_acl_is_trivial(acl_t *acl, mode_t mode, int *trivialp)"", ""{"", ""\tint i, p;"", ""\tconst uint32_t rperm = ACE_READ_DATA;"", ""\tconst uint32_t wperm = ACE_WRITE_DATA | ACE_APPEND_DATA;"", ""\tconst uint32_t eperm = ACE_EXECUTE;"", ""\tconst uint32_t pubset = ACE_READ_ATTRIBUTES | ACE_READ_NAMED_ATTRS |"", ""\t    ACE_READ_ACL | ACE_SYNCHRONIZE;"", ""\tconst uint32_t ownset = pubset | ACE_WRITE_ATTRIBUTES |"", ""\t    ACE_WRITE_NAMED_ATTRS | ACE_WRITE_ACL | ACE_WRITE_OWNER;"", """", ""\tace_t *ace;"", ""\tace_t tace[6];"", """", ""\tif (acl == NULL || trivialp == NULL)"", ""\t\treturn (-1);"", """", ""\t*trivialp = 0;"", """", ""\t/* ACL_IS_TRIVIAL flag must be set for both POSIX.1e and NFSv4 ACLs */"", ""\tif ((acl->acl_flags & ACL_IS_TRIVIAL) == 0)"", ""\t\treturn (0);"", """", ""\t/*"", ""\t * POSIX.1e ACLs marked with ACL_IS_TRIVIAL are compatible with"", ""\t * FreeBSD acl_is_trivial_np(). On Solaris they have 4 entries,"", ""\t * including mask."", ""\t */"", ""\tif (acl->acl_type == ACLENT_T) {"", ""\t\tif (acl->acl_cnt == 4)"", ""\t\t\t*trivialp = 1;"", ""\t\treturn (0);"", ""\t}"", """", ""\tif (acl->acl_type != ACE_T || acl->acl_entry_size != sizeof(ace_t))"", ""\t\treturn (-1);"", """", ""\t/*"", ""\t * Continue with checking NFSv4 ACLs"", ""\t *"", ""\t * Create list of trivial ace's to be compared"", ""\t */"", """", ""\t/* owner@ allow pre */"", ""\ttace[0].a_flags = ACE_OWNER;"", ""\ttace[0].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;"", ""\ttace[0].a_access_mask = 0;"", """", ""\t/* owner@ deny */"", ""\ttace[1].a_flags = ACE_OWNER;"", ""\ttace[1].a_type = ACE_ACCESS_DENIED_ACE_TYPE;"", ""\ttace[1].a_access_mask = 0;"", """", ""\t/* group@ deny */"", ""\ttace[2].a_flags = ACE_GROUP | ACE_IDENTIFIER_GROUP;"", ""\ttace[2].a_type = ACE_ACCESS_DENIED_ACE_TYPE;"", ""\ttace[2].a_access_mask = 0;"", """", ""\t/* owner@ allow */"", ""\ttace[3].a_flags = ACE_OWNER;"", ""\ttace[3].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;"", ""\ttace[3].a_access_mask = ownset;"", """", ""\t/* group@ allow */"", ""\ttace[4].a_flags = ACE_GROUP | ACE_IDENTIFIER_GROUP;"", ""\ttace[4].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;"", ""\ttace[4].a_access_mask = pubset;"", """", ""\t/* everyone@ allow */"", ""\ttace[5].a_flags = ACE_EVERYONE;"", ""\ttace[5].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;"", ""\ttace[5].a_access_mask = pubset;"", """", ""\t/* Permissions for everyone@ */"", ""\tif (mode & 0004)"", ""\t\ttace[5].a_access_mask |= rperm;"", ""\tif (mode & 0002)"", ""\t\ttace[5].a_access_mask |= wperm;"", ""\tif (mode & 0001)"", ""\t\ttace[5].a_access_mask |= eperm;"", """", ""\t/* Permissions for group@ */"", ""\tif (mode & 0040)"", ""\t\ttace[4].a_access_mask |= rperm;"", ""\telse if (mode & 0004)"", ""\t\ttace[2].a_access_mask |= rperm;"", ""\tif (mode & 0020)"", ""\t\ttace[4].a_access_mask |= wperm;"", ""\telse if (mode & 0002)"", ""\t\ttace[2].a_access_mask |= wperm;"", ""\tif (mode & 0010)"", ""\t\ttace[4].a_access_mask |= eperm;"", ""\telse if (mode & 0001)"", ""\t\ttace[2].a_access_mask |= eperm;"", """", ""\t/* Permissions for owner@ */"", ""\tif (mode & 0400) {"", ""\t\ttace[3].a_access_mask |= rperm;"", ""\t\tif (!(mode & 0040) && (mode & 0004))"", ""\t\t\ttace[0].a_access_mask |= rperm;"", ""\t} else if ((mode & 0040) || (mode & 0004))"", ""\t\ttace[1].a_access_mask |= rperm;"", ""\tif (mode & 0200) {"", ""\t\ttace[3].a_access_mask |= wperm;"", ""\t\tif (!(mode & 0020) && (mode & 0002))"", ""\t\t\ttace[0].a_access_mask |= wperm;"", ""\t} else if ((mode & 0020) || (mode & 0002))"", ""\t\ttace[1].a_access_mask |= wperm;"", ""\tif (mode & 0100) {"", ""\t\ttace[3].a_access_mask |= eperm;"", ""\t\tif (!(mode & 0010) && (mode & 0001))"", ""\t\t\ttace[0].a_access_mask |= eperm;"", ""\t} else if ((mode & 0010) || (mode & 0001))"", ""\t\ttace[1].a_access_mask |= eperm;"", """", ""\t/* Check if the acl count matches */"", ""\tp = 3;"", ""\tfor (i = 0; i < 3; i++) {"", ""\t\tif (tace[i].a_access_mask != 0)"", ""\t\t\tp++;"", ""\t}"", ""\tif (acl->acl_cnt != p)"", ""\t\treturn (0);"", """", ""\tp = 0;"", ""\tfor (i = 0; i < 6; i++) {"", ""\t\tif (tace[i].a_access_mask != 0) {"", ""\t\t\tace = &((ace_t *)acl->acl_aclp)[p];"", ""\t\t\t/*"", ""\t\t\t * Illumos added ACE_DELETE_CHILD to write perms for"", ""\t\t\t * directories. We have to check against that, too."", ""\t\t\t */"", ""\t\t\tif (ace->a_flags != tace[i].a_flags ||"", ""\t\t\t    ace->a_type != tace[i].a_type ||"", ""\t\t\t    (ace->a_access_mask != tace[i].a_access_mask &&"", ""\t\t\t    ((acl->acl_flags & ACL_IS_DIR) == 0 ||"", ""\t\t\t    (tace[i].a_access_mask & wperm) == 0 ||"", ""\t\t\t    ace->a_access_mask !="", ""\t\t\t    (tace[i].a_access_mask | ACE_DELETE_CHILD))))"", ""\t\t\t\treturn (0);"", ""\t\t\tp++;"", ""\t\t}"", ""\t}"", """", ""\t*trivialp = 1;"", ""\treturn (0);"", ""}"", ""#endif\t/* HAVE_SUN_ACL */"", """", ""#if HAVE_SUN_ACL"", ""/*"", "" * Translate Solaris POSIX.1e and NFSv4 ACLs into libarchive internal ACL"", "" */"", ""static int"", ""translate_acl(struct archive_read_disk *a,"", ""    struct archive_entry *entry, acl_t *acl, int default_entry_acl_type)"", ""{"", ""\tint e, i;"", ""\tint ae_id, ae_tag, ae_perm;"", ""\tint entry_acl_type;"", ""\tconst char *ae_name;"", ""\taclent_t *aclent;"", ""\tace_t *ace;"", """", ""\t(void)default_entry_acl_type;"", """", ""\tif (acl->acl_cnt <= 0)"", ""\t\treturn (ARCHIVE_OK);"", """", ""\tfor (e = 0; e < acl->acl_cnt; e++) {"", ""\t\tae_name = NULL;"", ""\t\tae_tag = 0;"", ""\t\tae_perm = 0;"", """", ""\t\tif (acl->acl_type == ACE_T) {"", ""\t\t\tace = &((ace_t *)acl->acl_aclp)[e];"", ""\t\t\tae_id = ace->a_who;"", """", ""\t\t\tswitch(ace->a_type) {"", ""\t\t\tcase ACE_ACCESS_ALLOWED_ACE_TYPE:"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;"", ""\t\t\t\tbreak;"", ""\t\t\tcase ACE_ACCESS_DENIED_ACE_TYPE:"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DENY;"", ""\t\t\t\tbreak;"", ""\t\t\tcase ACE_SYSTEM_AUDIT_ACE_TYPE:"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;"", ""\t\t\t\tbreak;"", ""\t\t\tcase ACE_SYSTEM_ALARM_ACE_TYPE:"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALARM;"", ""\t\t\t\tbreak;"", ""\t\t\tdefault:"", ""\t\t\t\t/* Unknown entry type, skip */"", ""\t\t\t\tcontinue;"", ""\t\t\t}"", """", ""\t\t\tif ((ace->a_flags & ACE_OWNER) != 0)"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER_OBJ;"", ""\t\t\telse if ((ace->a_flags & ACE_GROUP) != 0)"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;"", ""\t\t\telse if ((ace->a_flags & ACE_EVERYONE) != 0)"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_EVERYONE;"", ""\t\t\telse if ((ace->a_flags & ACE_IDENTIFIER_GROUP) != 0) {"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;"", ""\t\t\t\tae_name = archive_read_disk_gname(&a->archive,"", ""\t\t\t\t    ae_id);"", ""\t\t\t} else {"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;"", ""\t\t\t\tae_name = archive_read_disk_uname(&a->archive,"", ""\t\t\t\t    ae_id);"", ""\t\t\t}"", """", ""\t\t\tfor (i = 0; i < (int)(sizeof(acl_inherit_map) /"", ""\t\t\t    sizeof(acl_inherit_map[0])); ++i) {"", ""\t\t\t\tif ((ace->a_flags &"", ""\t\t\t\t    acl_inherit_map[i].platform_inherit) != 0)"", ""\t\t\t\t\tae_perm |="", ""\t\t\t\t\t    acl_inherit_map[i].archive_inherit;"", ""\t\t\t}"", """", ""\t\t\tfor (i = 0; i < (int)(sizeof(acl_perm_map) /"", ""\t\t\t    sizeof(acl_perm_map[0])); ++i) {"", ""\t\t\t\tif ((ace->a_access_mask &"", ""\t\t\t\t    acl_perm_map[i].platform_perm) != 0)"", ""\t\t\t\t\tae_perm |="", ""\t\t\t\t\t    acl_perm_map[i].archive_perm;"", ""\t\t\t}"", ""\t\t} else {"", ""\t\t\taclent = &((aclent_t *)acl->acl_aclp)[e];"", ""\t\t\tif ((aclent->a_type & ACL_DEFAULT) != 0)"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;"", ""\t\t\telse"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;"", ""\t\t\tae_id = aclent->a_id;"", """", ""\t\t\tswitch(aclent->a_type) {"", ""\t\t\tcase DEF_USER:"", ""\t\t\tcase USER:"", ""\t\t\t\tae_name = archive_read_disk_uname(&a->archive,"", ""\t\t\t\t    ae_id);"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;"", ""\t\t\t\tbreak;"", ""\t\t\tcase DEF_GROUP:"", ""\t\t\tcase GROUP:"", ""\t\t\t\tae_name = archive_read_disk_gname(&a->archive,"", ""\t\t\t\t    ae_id);"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;"", ""\t\t\t\tbreak;"", ""\t\t\tcase DEF_CLASS_OBJ:"", ""\t\t\tcase CLASS_OBJ:"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_MASK;"", ""\t\t\t\tbreak;"", ""\t\t\tcase DEF_USER_OBJ:"", ""\t\t\tcase USER_OBJ:"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER_OBJ;"", ""\t\t\t\tbreak;"", ""\t\t\tcase DEF_GROUP_OBJ:"", ""\t\t\tcase GROUP_OBJ:"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;"", ""\t\t\t\tbreak;"", ""\t\t\tcase DEF_OTHER_OBJ:"", ""\t\t\tcase OTHER_OBJ:"", ""\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_OTHER;"", ""\t\t\t\tbreak;"", ""\t\t\tdefault:"", ""\t\t\t\t/* Unknown tag type, skip */"", ""\t\t\t\tcontinue;"", ""\t\t\t}"", """", ""\t\t\tif ((aclent->a_perm & 1) != 0)"", ""\t\t\t\tae_perm |= ARCHIVE_ENTRY_ACL_EXECUTE;"", ""\t\t\tif ((aclent->a_perm & 2) != 0)"", ""\t\t\t\tae_perm |= ARCHIVE_ENTRY_ACL_WRITE;"", ""\t\t\tif ((aclent->a_perm & 4) != 0)"", ""\t\t\t\tae_perm |= ARCHIVE_ENTRY_ACL_READ;"", ""\t\t} /* default_entry_acl_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4 */"", """", ""\t\tarchive_entry_acl_add_entry(entry, entry_acl_type,"", ""\t\t    ae_perm, ae_tag, ae_id, ae_name);"", ""\t}"", ""\treturn (ARCHIVE_OK);"", ""}"", ""#else\t/* !HAVE_SUN_ACL */"", ""/*"", "" * Translate POSIX.1e (Linux), FreeBSD (both POSIX.1e and NFSv4) and"", "" * MacOS (NFSv4 only) ACLs into libarchive internal structure"", "" */"", ""static int"", ""translate_acl(struct archive_read_disk *a,"", ""    struct archive_entry *entry, acl_t acl, int default_entry_acl_type)"", ""{"", ""\tacl_tag_t\t acl_tag;"", ""#ifdef ACL_TYPE_NFS4"", ""#if HAVE_ACL_TYPE_NFS4"", ""\tacl_entry_type_t acl_type;"", ""\tint brand;"", ""#endif"", ""#if HAVE_ACL_TYPE_NFS4 || HAVE_DARWIN_ACL"", ""\tacl_flagset_t\t acl_flagset;"", ""\tint brand, r;"", ""#endif"", ""\tacl_entry_t\t acl_entry;"", ""\tacl_permset_t\t acl_permset;"", ""\tint\t\t i, entry_acl_type;"", ""\tint\t\t s, ae_id, ae_tag, ae_perm;"", ""\tint\t\t r, s, ae_id, ae_tag, ae_perm;"", ""#if !HAVE_DARWIN_ACL"", ""\tvoid\t\t*q;"", ""#endif"", ""\tconst char\t*ae_name;"", """", """", ""#ifdef ACL_TYPE_NFS4"", ""#if HAVE_ACL_TYPE_NFS4"", ""\t// FreeBSD \""brands\"" ACLs as POSIX.1e or NFSv4"", ""\t// Make sure the \""brand\"" on this ACL is consistent"", ""\t// with the default_entry_acl_type bits provided."", ""\tacl_get_brand_np(acl, &brand);"", ""\tif (acl_get_brand_np(acl, &brand) != 0) {"", ""\t\tarchive_set_error(&a->archive, errno,"", ""\t\t    \""Failed to read ACL brand\"");"", ""\t\treturn (ARCHIVE_WARN);"", ""\t}"", ""\tswitch (brand) {"", ""\tcase ACL_BRAND_POSIX:"", ""\t\tswitch (default_entry_acl_type) {"", ""\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:"", ""\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:"", ""\t\t\tbreak;"", ""\t\tdefault:"", ""\t\t\t// XXX set warning message?"", ""\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Invalid ACL entry type for POSIX.1e ACL\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tbreak;"", ""\tcase ACL_BRAND_NFS4:"", ""\t\tif (default_entry_acl_type & ~ARCHIVE_ENTRY_ACL_TYPE_NFS4) {"", ""\t\t\t// XXX set warning message?"", ""\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Invalid ACL entry type for NFSv4 ACL\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tbreak;"", ""\tdefault:"", ""\t\t// XXX set warning message?"", ""\t\treturn ARCHIVE_FAILED;"", ""\t\tbreak;"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Unknown ACL brand\"");"", ""\t\treturn (ARCHIVE_WARN);"", ""\t}"", ""#endif"", """", """", ""\ts = acl_get_entry(acl, ACL_FIRST_ENTRY, &acl_entry);"", ""\twhile (s == 1) {"", ""\tif (s == -1) {"", ""\t\tarchive_set_error(&a->archive, errno,"", ""\t\t    \""Failed to get first ACL entry\"");"", ""\t\treturn (ARCHIVE_WARN);"", ""\t}"", """", ""#if HAVE_DARWIN_ACL"", ""\twhile (s == 0)"", ""#else\t/* FreeBSD, Linux */"", ""\twhile (s == 1)"", ""#endif"", ""\t{"", ""\t\tae_id = -1;"", ""\t\tae_name = NULL;"", ""\t\tae_perm = 0;"", """", ""\t\tacl_get_tag_type(acl_entry, &acl_tag);"", ""\t\tif (acl_get_tag_type(acl_entry, &acl_tag) != 0) {"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""Failed to get ACL tag type\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tswitch (acl_tag) {"", ""#if !HAVE_DARWIN_ACL\t/* FreeBSD, Linux */"", ""\t\tcase ACL_USER:"", ""\t\t\tae_id = (int)*(uid_t *)acl_get_qualifier(acl_entry);"", ""\t\t\tae_name = archive_read_disk_uname(&a->archive, ae_id);"", ""\t\t\tq = acl_get_qualifier(acl_entry);"", ""\t\t\tif (q != NULL) {"", ""\t\t\t\tae_id = (int)*(uid_t *)q;"", ""\t\t\t\tacl_free(q);"", ""\t\t\t\tae_name = archive_read_disk_uname(&a->archive,"", ""\t\t\t\t    ae_id);"", ""\t\t\t}"", ""\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;"", ""\t\t\tbreak;"", ""\t\tcase ACL_GROUP:"", ""\t\t\tae_id = (int)*(gid_t *)acl_get_qualifier(acl_entry);"", ""\t\t\tae_name = archive_read_disk_gname(&a->archive, ae_id);"", ""\t\t\tq = acl_get_qualifier(acl_entry);"", ""\t\t\tif (q != NULL) {"", ""\t\t\t\tae_id = (int)*(gid_t *)q;"", ""\t\t\t\tacl_free(q);"", ""\t\t\t\tae_name = archive_read_disk_gname(&a->archive,"", ""\t\t\t\t    ae_id);"", ""\t\t\t}"", ""\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;"", ""\t\t\tbreak;"", ""\t\tcase ACL_MASK:""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, 1, 0, 1, 1, 2, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, -1, 1, 0, 0, 1, 2, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, -1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, 1, 1, 1, 1, 1, 0, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, 1, 0, 1, 1, 1, 0, -1, 0, 0, 0, 0, -1, 1, 1, 1, 1, 0, 0, -1, -1, 1, 0, 0, 0, -1, 1, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, 2, 1, 1, 0, 0, 0, 0, -1, -1, 2, 1, 1, 0, 0, 0, -1, -1, -1, 2, 1, 1, 0, 0, 0, -1, 0, -1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, -1, 1, 2, 1, 1, 1, 0, 1, 0, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[21, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""], [41, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""], [643, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""], [656, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""], [665, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""], [674, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""], [684, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""], [701, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""]]",467,577
"[""\t\tcase ACL_OTHER:"", ""\t\t\tae_tag = ARCHIVE_ENTRY_ACL_OTHER;"", ""\t\t\tbreak;"", ""#ifdef ACL_TYPE_NFS4"", ""#if HAVE_ACL_TYPE_NFS4"", ""\t\tcase ACL_EVERYONE:"", ""\t\t\tae_tag = ARCHIVE_ENTRY_ACL_EVERYONE;"", ""\t\t\tbreak;"", ""#endif"", ""#else\t/* HAVE_DARWIN_ACL */"", ""\t\tcase ACL_EXTENDED_ALLOW:"", ""\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;"", ""\t\t\tr = translate_guid(&a->archive, acl_entry, &ae_id,"", ""\t\t\t    &ae_tag, &ae_name);"", ""\t\t\tbreak;"", ""\t\tcase ACL_EXTENDED_DENY:"", ""\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DENY;"", ""\t\t\tr = translate_guid(&a->archive, acl_entry, &ae_id,"", ""\t\t\t    &ae_tag, &ae_name);"", ""\t\t\tbreak;"", ""#endif\t/* HAVE_DARWIN_ACL */"", ""\t\tdefault:"", ""\t\t\t/* Skip types that libarchive can't support. */"", ""\t\t\ts = acl_get_entry(acl, ACL_NEXT_ENTRY, &acl_entry);"", ""\t\t\tcontinue;"", ""\t\t}"", """", ""\t\t// XXX acl type maps to allow/deny/audit/YYYY bits"", ""\t\t// XXX acl_get_entry_type_np on FreeBSD returns EINVAL for"", ""\t\t// non-NFSv4 ACLs"", ""#if HAVE_DARWIN_ACL"", ""\t\t/* Skip if translate_guid() above failed */"", ""\t\tif (r != 0) {"", ""\t\t\ts = acl_get_entry(acl, ACL_NEXT_ENTRY, &acl_entry);"", ""\t\t\tcontinue;"", ""\t\t}"", ""#endif"", """", ""#if !HAVE_DARWIN_ACL"", ""\t\t// XXX acl_type maps to allow/deny/audit/YYYY bits"", ""\t\tentry_acl_type = default_entry_acl_type;"", ""#ifdef ACL_TYPE_NFS4"", ""\t\tr = acl_get_entry_type_np(acl_entry, &acl_type);"", ""\t\tif (r == 0) {"", ""#endif"", ""#if HAVE_ACL_TYPE_NFS4 || HAVE_DARWIN_ACL"", ""\t\tif (default_entry_acl_type & ARCHIVE_ENTRY_ACL_TYPE_NFS4) {"", ""#if HAVE_ACL_TYPE_NFS4"", ""\t\t\t/*"", ""\t\t\t * acl_get_entry_type_np() fails with non-NFSv4 ACLs"", ""\t\t\t */"", ""\t\t\tif (acl_get_entry_type_np(acl_entry, &acl_type) != 0) {"", ""\t\t\t\tarchive_set_error(&a->archive, errno, \""Failed \"""", ""\t\t\t\t    \""to get ACL type from a NFSv4 ACL entry\"");"", ""\t\t\t\treturn (ARCHIVE_WARN);"", ""\t\t\t}"", ""\t\t\tswitch (acl_type) {"", ""\t\t\tcase ACL_ENTRY_TYPE_ALLOW:"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;""]","[0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, 0, 0]","[[52, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno, \""Failed \"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""]]",604,1262
"[""\t\t\tcase ACL_ENTRY_TYPE_ALARM:"", ""\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALARM;"", ""\t\t\t\tbreak;"", ""\t\t\tdefault:"", ""\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Invalid NFSv4 ACL entry type\"");"", ""\t\t\t\treturn (ARCHIVE_WARN);"", ""\t\t\t}"", ""\t\t}"", """", ""\t\t/*"", ""\t\t * Libarchive stores \""flag\"" (NFSv4 inheritance bits)"", ""\t\t * in the ae_perm bitmap."", ""\t\t */"", ""\t\tacl_get_flagset_np(acl_entry, &acl_flagset);"", ""                for (i = 0; i < (int)(sizeof(acl_inherit_map) / sizeof(acl_inherit_map[0])); ++i) {"", ""\t\t\tif (acl_get_flag_np(acl_flagset,"", ""\t\t\t\t\t    acl_inherit_map[i].platform_inherit))"", ""\t\t\t\tae_perm |= acl_inherit_map[i].archive_inherit;"", ""#endif\t/* HAVE_ACL_TYPE_NFS4 */"", """", ""                }"", ""#endif"", ""\t\t\t/*"", ""\t\t\t * Libarchive stores \""flag\"" (NFSv4 inheritance bits)"", ""\t\t\t * in the ae_perm bitmap."", ""\t\t\t *"", ""\t\t\t * acl_get_flagset_np() fails with non-NFSv4 ACLs"", ""\t\t\t */"", ""\t\t\tif (acl_get_flagset_np(acl_entry, &acl_flagset) != 0) {"", ""\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Failed to get flagset from a NFSv4 ACL entry\"");"", ""\t\t\t\treturn (ARCHIVE_WARN);"", ""\t\t\t}"", ""\t\t\tfor (i = 0; i < (int)(sizeof(acl_inherit_map) / sizeof(acl_inherit_map[0])); ++i) {"", ""\t\t\t\tr = acl_get_flag_np(acl_flagset,"", ""\t\t\t\t    acl_inherit_map[i].platform_inherit);"", ""\t\t\t\tif (r == -1) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t\t    \""Failed to check flag in a NFSv4 \"""", ""\t\t\t\t\t    \""ACL flagset\"");"", ""\t\t\t\t\treturn (ARCHIVE_WARN);"", ""\t\t\t\t} else if (r)"", ""\t\t\t\t\tae_perm |= acl_inherit_map[i].archive_inherit;"", ""\t\t\t}"", ""\t\t}"", ""#endif\t/* HAVE_ACL_TYPE_NFS4 || HAVE_DARWIN_ACL */"", """", ""\t\tacl_get_permset(acl_entry, &acl_permset);"", ""\t\tif (acl_get_permset(acl_entry, &acl_permset) != 0) {"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""Failed to get ACL permission set\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tfor (i = 0; i < (int)(sizeof(acl_perm_map) / sizeof(acl_perm_map[0])); ++i) {"", ""\t\t\t/*"", ""\t\t\t * acl_get_perm() is spelled differently on different"", ""\t\t\t * platforms; see above."", ""\t\t\t */"", ""\t\t\tif (ACL_GET_PERM(acl_permset, acl_perm_map[i].platform_perm))"", ""\t\t\tr = ACL_GET_PERM(acl_permset, acl_perm_map[i].platform_perm);"", ""\t\t\tif (r == -1) {"", ""\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Failed to check permission in an ACL permission set\"");"", ""\t\t\t\treturn (ARCHIVE_WARN);"", ""\t\t\t} else if (r)"", ""\t\t\t\tae_perm |= acl_perm_map[i].archive_perm;"", ""\t\t}"", """"]","[0, 0, 0, 1, 2, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, -1, -1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 2, 1, 1, 1, 0, 0, 0, 0, 0, -1, 1, 1, 2, 1, 1, 1, 0, 0, 0]","[[4, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""], [30, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""], [38, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""], [50, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""], [62, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""]]",635,1321
"[""\t\t\t\t\t    ae_id, ae_name);"", """", ""\t\ts = acl_get_entry(acl, ACL_NEXT_ENTRY, &acl_entry);"", ""#if !HAVE_DARWIN_ACL"", ""\t\tif (s == -1) {"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""Failed to get next ACL entry\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""#endif"", ""\t}"", ""\treturn (ARCHIVE_OK);"", ""}"", ""#else"", ""#endif\t/* !HAVE_SUN_ACL */"", ""#else\t/* !HAVE_POSIX_ACL && !HAVE_NFS4_ACL */"", ""static int"", ""setup_acls(struct archive_read_disk *a,"", ""    struct archive_entry *entry, int *fd)""]","[0, 0, 0, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, -1, 1, 1, 0, 0, 0]","[[5, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""]]",666,1377
"[""\tconst char *path;"", ""\tssize_t list_size;"", """", ""\tpath = archive_entry_sourcepath(entry);"", ""\tif (path == NULL)"", ""\t\tpath = archive_entry_pathname(entry);"", ""\tpath = NULL;"", """", ""\tif (*fd < 0 && a->tree != NULL) {"", ""\t\tif (a->follow_symlinks ||"", ""\t\t    archive_entry_filetype(entry) != AE_IFLNK)"", ""\t\t\t*fd = a->open_on_current_dir(a->tree, path,"", ""\t\t\t\tO_RDONLY | O_NONBLOCK);"", ""\t\tif (*fd < 0) {"", ""\t\t\tif (a->tree_enter_working_dir(a->tree) != 0) {"", ""\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Couldn't access %s\"", path);"", ""\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t\t}"", ""\tif (*fd < 0) {"", ""\t\tpath = archive_entry_sourcepath(entry);"", ""\t\tif (path == NULL || (a->tree != NULL &&"", ""\t\t    a->tree_enter_working_dir(a->tree) != 0))"", ""\t\t\tpath = archive_entry_pathname(entry);"", ""\t\tif (path == NULL) {"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Couldn't determine file path to read \"""", ""\t\t\t    \""extended attributes\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tif (a->tree != NULL && (a->follow_symlinks ||"", ""\t\t    archive_entry_filetype(entry) != AE_IFLNK)) {"", ""\t\t\t*fd = a->open_on_current_dir(a->tree,"", ""\t\t\t    path, O_RDONLY | O_NONBLOCK);"", ""\t\t}"", ""\t}"", """"]","[0, 0, 0, -1, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[15, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""-"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""], [25, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""]]",772,1486
"[""\tconst char *path;"", ""\tint namespace = EXTATTR_NAMESPACE_USER;"", """", ""\tpath = archive_entry_sourcepath(entry);"", ""\tif (path == NULL)"", ""\t\tpath = archive_entry_pathname(entry);"", ""\tpath = NULL;"", """", ""\tif (*fd < 0 && a->tree != NULL) {"", ""\t\tif (a->follow_symlinks ||"", ""\t\t    archive_entry_filetype(entry) != AE_IFLNK)"", ""\t\t\t*fd = a->open_on_current_dir(a->tree, path,"", ""\t\t\t\tO_RDONLY | O_NONBLOCK);"", ""\t\tif (*fd < 0) {"", ""\t\t\tif (a->tree_enter_working_dir(a->tree) != 0) {"", ""\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t    \""Couldn't access %s\"", path);"", ""\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t\t}"", ""\tif (*fd < 0) {"", ""\t\tpath = archive_entry_sourcepath(entry);"", ""\t\tif (path == NULL || (a->tree != NULL &&"", ""\t\t    a->tree_enter_working_dir(a->tree) != 0))"", ""\t\t\tpath = archive_entry_pathname(entry);"", ""\t\tif (path == NULL) {"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Couldn't determine file path to read \"""", ""\t\t\t    \""extended attributes\"");"", ""\t\t\treturn (ARCHIVE_WARN);"", ""\t\t}"", ""\t\tif (a->tree != NULL && (a->follow_symlinks ||"", ""\t\t    archive_entry_filetype(entry) != AE_IFLNK)) {"", ""\t\t\t*fd = a->open_on_current_dir(a->tree,"", ""\t\t\t    path, O_RDONLY | O_NONBLOCK);"", ""\t\t}"", ""\t}"", """"]","[0, 0, 0, -1, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[15, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""-"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""], [25, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_disk_entry_from_file.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_49_new.cpp""]]",932,1645
"[""\t\t}"", ""\t\tllen = len;"", ""\t\tif ((nl == 0) && (uudecode->state != ST_UUEND)) {"", ""\t\t\tif (total == 0 && ravail <= 0) {"", ""\t\t\t\t/* There is nothing more to read, fail */"", ""\t\t\t\tarchive_set_error(&self->archive->archive,"", ""\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t\t    \""Missing format data\"");"", ""\t\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t\t}"", ""\t\t\t/*"", ""\t\t\t * Save remaining data which does not contain"", ""\t\t\t * NL('\\n','\\r').""]","[0, 0, 0, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0]","[[5, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_filter_uu.c"", ""+"", ""archive_set_error(&self->archive->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_50_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_50_new.cpp""]]",510,495
"["""", ""#else"", """", ""#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC"", """", ""/*"", "" * If we have the older liblzmadec library, then we can handle"", "" * LZMA streams but not XZ streams."", "" */"", """", ""/*"", "" * Setup the callbacks."", "" */"", ""static int"", ""lzma_bidder_init(struct archive_read_filter *self)"", ""{"", ""\tstatic const size_t out_block_size = 64 * 1024;"", ""\tvoid *out_block;"", ""\tstruct private_data *state;"", ""\tssize_t ret, avail_in;"", """", ""\tself->code = ARCHIVE_FILTER_LZMA;"", ""\tself->name = \""lzma\"";"", """", ""\tstate = (struct private_data *)calloc(sizeof(*state), 1);"", ""\tout_block = (unsigned char *)malloc(out_block_size);"", ""\tif (state == NULL || out_block == NULL) {"", ""\t\tarchive_set_error(&self->archive->archive, ENOMEM,"", ""\t\t    \""Can't allocate data for lzma decompression\"");"", ""\t\tfree(out_block);"", ""\t\tfree(state);"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t}"", """", ""\tself->data = state;"", ""\tstate->out_block_size = out_block_size;"", ""\tstate->out_block = out_block;"", ""\tself->read = lzma_filter_read;"", ""\tself->skip = NULL; /* not supported */"", ""\tself->close = lzma_filter_close;"", """", ""\t/* Prime the lzma library with 18 bytes of input. */"", ""\tstate->stream.next_in = (unsigned char *)(uintptr_t)"", ""\t    __archive_read_filter_ahead(self->upstream, 18, &avail_in);"", ""\tif (state->stream.next_in == NULL)"", ""\t\treturn (ARCHIVE_FATAL);"", ""\tstate->stream.avail_in = avail_in;"", ""\tstate->stream.next_out = state->out_block;"", ""\tstate->stream.avail_out = state->out_block_size;"", """", ""\t/* Initialize compression library. */"", ""\tret = lzmadec_init(&(state->stream));"", ""\t__archive_read_filter_consume(self->upstream,"", ""\t    avail_in - state->stream.avail_in);"", ""\tif (ret == LZMADEC_OK)"", ""\t\treturn (ARCHIVE_OK);"", """", ""\t/* Library setup failed: Clean up. */"", ""\tarchive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,"", ""\t    \""Internal error initializing lzma library\"");"", """", ""\t/* Override the error message if we know what really went wrong. */"", ""\tswitch (ret) {"", ""\tcase LZMADEC_HEADER_ERROR:"", ""\t\tarchive_set_error(&self->archive->archive,"", ""\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Internal error initializing compression library: \"""", ""\t\t    \""invalid header\"");"", ""\t\tbreak;"", ""\tcase LZMADEC_MEM_ERROR:"", ""\t\tarchive_set_error(&self->archive->archive, ENOMEM,"", ""\t\t    \""Internal error initializing compression library: \"""", ""\t\t    \""out of memory\"");"", ""\t\tbreak;"", ""\t}"", """", ""\tfree(state->out_block);"", ""\tfree(state);"", ""\tself->data = NULL;"", ""\treturn (ARCHIVE_FATAL);"", ""}"", """", ""/*"", "" * Return the next block of decompressed data."", "" */"", ""static ssize_t"", ""lzma_filter_read(struct archive_read_filter *self, const void **p)"", ""{"", ""\tstruct private_data *state;"", ""\tsize_t decompressed;"", ""\tssize_t avail_in, ret;"", """", ""\tstate = (struct private_data *)self->data;"", """", ""\t/* Empty our output buffer. */"", ""\tstate->stream.next_out = state->out_block;"", ""\tstate->stream.avail_out = state->out_block_size;"", """", ""\t/* Try to fill the output buffer. */"", ""\twhile (state->stream.avail_out > 0 && !state->eof) {"", ""\t\tstate->stream.next_in = (unsigned char *)(uintptr_t)"", ""\t\t    __archive_read_filter_ahead(self->upstream, 1, &avail_in);"", ""\t\tif (state->stream.next_in == NULL && avail_in < 0) {"", ""\t\t\tarchive_set_error(&self->archive->archive,"", ""\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""truncated lzma input\"");"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t}"", ""\t\tstate->stream.avail_in = avail_in;"", """", ""\t\t/* Decompress as much as we can in one pass. */"", ""\t\tret = lzmadec_decode(&(state->stream), avail_in == 0);"", ""\t\tswitch (ret) {"", ""\t\tcase LZMADEC_STREAM_END: /* Found end of stream. */"", ""\t\t\tstate->eof = 1;"", ""\t\t\t/* FALL THROUGH */"", ""\t\tcase LZMADEC_OK: /* Decompressor made some progress. */"", ""\t\t\t__archive_read_filter_consume(self->upstream,"", ""\t\t\t    avail_in - state->stream.avail_in);"", ""\t\t\tbreak;"", ""\t\tcase LZMADEC_BUF_ERROR: /* Insufficient input data? */"", ""\t\t\tarchive_set_error(&self->archive->archive,"", ""\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Insufficient compressed data\"");"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\tdefault:"", ""\t\t\t/* Return an error. */"", ""\t\t\tarchive_set_error(&self->archive->archive,"", ""\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Lzma decompression failed\"");"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t}"", ""\t}"", """", ""\tdecompressed = state->stream.next_out - state->out_block;"", ""\tstate->total_out += decompressed;"", ""\tif (decompressed == 0)"", ""\t\t*p = NULL;"", ""\telse"", ""\t\t*p = state->out_block;"", ""\treturn (decompressed);"", ""}"", """", ""/*"", "" * Clean up the decompressor."", "" */"", ""static int"", ""lzma_filter_close(struct archive_read_filter *self)"", ""{"", ""\tstruct private_data *state;"", ""\tint ret;"", """", ""\tstate = (struct private_data *)self->data;"", ""\tret = ARCHIVE_OK;"", ""\tswitch (lzmadec_end(&(state->stream))) {"", ""\tcase LZMADEC_OK:"", ""\t\tbreak;"", ""\tdefault:"", ""\t\tarchive_set_error(&(self->archive->archive),"", ""\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Failed to clean up %s compressor\"","", ""\t\t    self->archive->archive.compression_name);"", ""\t\tret = ARCHIVE_FATAL;"", ""\t}"", """", ""\tfree(state->out_block);"", ""\tfree(state);"", ""\treturn (ret);"", ""}"", """", ""#else"", """", ""/*"", "" *"", "" * If we have no suitable library on this system, we can't actually do""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0]","[[27, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive, ENOMEM,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_51_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_51_new.cpp""], [58, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_51_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_51_new.cpp""], [64, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_51_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_51_new.cpp""], [70, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive, ENOMEM,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_51_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_51_new.cpp""], [103, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_51_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_51_new.cpp""], [121, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_51_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_51_new.cpp""], [127, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&self->archive->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_51_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_51_new.cpp""], [158, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_filter_xz.c"", ""-"", ""archive_set_error(&(self->archive->archive),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_51_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_51_new.cpp""]]",763,744
"[""\tswitch ((int)type & ~0777777) {"", ""\tcase 01000000:"", ""\t\t/* POSIX.1e ACL */"", ""\t\tacl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;"", ""\t\tbreak;"", ""\tcase 03000000:"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Solaris NFSv4 ACLs not supported\"");"", ""\t\treturn (ARCHIVE_WARN);"", ""\t\t/* NFSv4 ACL */"", ""\t\tacl_type = ARCHIVE_ENTRY_ACL_TYPE_NFS4;"", ""\t\tbreak;"", ""\tdefault:"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Malformed Solaris ACL attribute (unsupported type %o)\"",""]","[0, 0, 0, 1, 0, 0, -2, -1, -1, 1, 1, 1, 0, 0, 0]","[[6, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_tar.c"", ""-"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_new.cpp""]]",935,989
"[""\tif (tar->entry_bytes_remaining < 0) {"", ""\t\ttar->entry_bytes_remaining = 0;"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Tar entry has negative size?\"");"", ""\t\terr = ARCHIVE_WARN;"", ""\t\t    \""Tar entry has negative size\"");"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t}"", ""\tif (tar->entry_bytes_remaining == INT64_MAX) {"", ""\t\t/* Note: tar_atol returns INT64_MAX on overflow */"", ""\t\ttar->entry_bytes_remaining = 0;"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Tar entry size overflow\"");"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t}"", ""\ttar->realsize = tar->entry_bytes_remaining;"", ""\tarchive_entry_set_size(entry, tar->entry_bytes_remaining);""]","[0, 0, 0, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 0, 0]","[[11, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_tar.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_new.cpp""]]",1128,1183
"[""\treturn 0;"", ""}"", """", ""static int"", ""pax_attribute_schily_xattr(struct archive_entry *entry,"", ""\tconst char *name, const char *value, size_t value_length)"", ""{"", ""\tif (strlen(name) < 14 || (memcmp(name, \""SCHILY.xattr.\"", 13)) != 0)"", ""\t\treturn 1;"", """", ""\tname += 13;"", """", ""\tarchive_entry_xattr_add_entry(entry, name, value, value_length);"", """", ""\treturn 0;"", ""}"", """", ""static int"", ""pax_attribute_acl(struct archive_read *a, struct tar *tar,"", ""    struct archive_entry *entry, const char *value, int type)"", ""{"", ""\tint r;"", ""\tconst char* errstr;"", """", ""\tswitch (type) {"", ""\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:"", ""\t\terrstr = \""SCHILY.acl.access\"";"", ""\t\tbreak;"", ""\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:"", ""\t\terrstr = \""SCHILY.acl.default\"";"", ""\t\tbreak;"", ""\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:"", ""\t\terrstr = \""SCHILY.acl.ace\"";"", ""\t\tbreak;"", ""\tdefault:"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Unknown ACL type: %d\"", type);"", ""\t\treturn(ARCHIVE_FATAL);"", ""\t}"", """", ""\tif (tar->sconv_acl == NULL) {"", ""\t\ttar->sconv_acl ="", ""\t\t    archive_string_conversion_from_charset("", ""\t\t\t&(a->archive), \""UTF-8\"", 1);"", ""\t\tif (tar->sconv_acl == NULL)"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t}"", """", ""\tr = archive_acl_from_text_l(archive_entry_acl(entry), value, type,"", ""\t    tar->sconv_acl);"", ""\tif (r != ARCHIVE_OK) {"", ""\t\tif (r == ARCHIVE_FATAL) {"", ""\t\t\tarchive_set_error(&a->archive, ENOMEM,"", ""\t\t\t    \""%s %s\"", \""Can't allocate memory for \"","", ""\t\t\t    errstr);"", ""\t\t\treturn (r);"", ""\t\t}"", ""\t\tarchive_set_error(&a->archive,"", ""\t\t    ARCHIVE_ERRNO_MISC, \""%s %s\"", \""Parse error: \"", errstr);"", ""\t}"", ""\treturn (r);"", ""}"", """", ""/*"", "" * Parse a single key=value attribute.  key/value pointers are"", "" * assumed to point into reasonably long-lived storage.""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 0, 0]","[[35, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_tar.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_new.cpp""], [52, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_tar.c"", ""+"", ""archive_set_error(&a->archive, ENOMEM,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_new.cpp""], [57, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_tar.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_new.cpp""]]",1695,1768
"[""\t\t\t\t * NULL pointer to strlen().  */"", ""\tswitch (key[0]) {"", ""\tcase 'G':"", ""\t\t/* Reject GNU.sparse.* headers on non-regular files. */"", ""\t\tif (strncmp(key, \""GNU.sparse\"", 10) == 0 &&"", ""\t\t    !tar->sparse_allowed) {"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Non-regular file cannot be sparse\"");"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t}"", """", ""\t\t/* GNU \""0.0\"" sparse pax format. */"", ""\t\tif (strcmp(key, \""GNU.sparse.numblocks\"") == 0) {"", ""\t\t\ttar->sparse_offset = -1;""]","[0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0]","[[6, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_tar.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_new.cpp""]]",1721,1854
"[""\tcase 'S':"", ""\t\t/* We support some keys used by the \""star\"" archiver */"", ""\t\tif (strcmp(key, \""SCHILY.acl.access\"") == 0) {"", ""\t\t\tif (tar->sconv_acl == NULL) {"", ""\t\t\t\ttar->sconv_acl ="", ""\t\t\t\t    archive_string_conversion_from_charset("", ""\t\t\t\t\t&(a->archive), \""UTF-8\"", 1);"", ""\t\t\t\tif (tar->sconv_acl == NULL)"", ""\t\t\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t\t}"", """", ""\t\t\tr = archive_acl_parse_l(archive_entry_acl(entry),"", ""\t\t\t    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,"", ""\t\t\t    tar->sconv_acl);"", ""\t\t\tif (r != ARCHIVE_OK) {"", ""\t\t\t\terr = r;"", ""\t\t\t\tif (err == ARCHIVE_FATAL) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, ENOMEM,"", ""\t\t\t\t\t    \""Can't allocate memory for \"""", ""\t\t\t\t\t    \""SCHILY.acl.access\"");"", ""\t\t\t\t\treturn (err);"", ""\t\t\t\t}"", ""\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t\t    \""Parse error: SCHILY.acl.access\"");"", ""\t\t\t}"", ""\t\t\tr = pax_attribute_acl(a, tar, entry, value,"", ""\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);"", ""\t\t\tif (r == ARCHIVE_FATAL)"", ""\t\t\t\treturn (r);"", ""\t\t} else if (strcmp(key, \""SCHILY.acl.default\"") == 0) {"", ""\t\t\tif (tar->sconv_acl == NULL) {"", ""\t\t\t\ttar->sconv_acl ="", ""\t\t\t\t    archive_string_conversion_from_charset("", ""\t\t\t\t\t&(a->archive), \""UTF-8\"", 1);"", ""\t\t\t\tif (tar->sconv_acl == NULL)"", ""\t\t\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t\t}"", """", ""\t\t\tr = archive_acl_parse_l(archive_entry_acl(entry),"", ""\t\t\t    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,"", ""\t\t\t    tar->sconv_acl);"", ""\t\t\tif (r != ARCHIVE_OK) {"", ""\t\t\t\terr = r;"", ""\t\t\t\tif (err == ARCHIVE_FATAL) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, ENOMEM,"", ""\t\t\t\t\t    \""Can't allocate memory for \"""", ""\t\t\t\t\t    \""SCHILY.acl.default\"");"", ""\t\t\t\t\treturn (err);"", ""\t\t\t\t}"", ""\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t\t    \""Parse error: SCHILY.acl.default\"");"", ""\t\t\t}"", ""\t\t\tr = pax_attribute_acl(a, tar, entry, value,"", ""\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);"", ""\t\t\tif (r == ARCHIVE_FATAL)"", ""\t\t\t\treturn (r);"", ""\t\t} else if (strcmp(key, \""SCHILY.acl.ace\"") == 0) {"", ""\t\t\tr = pax_attribute_acl(a, tar, entry, value,"", ""\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4);"", ""\t\t\tif (r == ARCHIVE_FATAL)"", ""\t\t\t\treturn (r);"", ""\t\t} else if (strcmp(key, \""SCHILY.devmajor\"") == 0) {"", ""\t\t\tarchive_entry_set_rdevmajor(entry,"", ""\t\t\t    (dev_t)tar_atol10(value, strlen(value)));""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[17, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_tar.c"", ""-"", ""archive_set_error(&a->archive, ENOMEM,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_new.cpp""], [22, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_tar.c"", ""-"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_new.cpp""], [45, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_tar.c"", ""-"", ""archive_set_error(&a->archive, ENOMEM,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_new.cpp""], [50, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_tar.c"", ""-"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_52_new.cpp""]]",1803,1944
"[""\t\t\t&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t\""Bad record header\"");"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {"", ""\t\t/* nawww, I wish they promised backward compatibility"", ""\t\t * anyhoo, in their infinite wisdom the 28500 guys might"", ""\t\t * come up with something we can't possibly handle so"", ""\t\t * best end things here */"", ""\t}"", ""\tver = _warc_rdver(buf, eoh - buf);"", ""\t/* we currently support WARC 0.12 to 1.0 */"", ""\tif (ver == 0U) {"", ""\t\tarchive_set_error("", ""\t\t\t&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t\""Unsupported record version\"");"", ""\t\t\t\""Invalid record version\"");"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {"", ""\t} else if (ver < 1200U || ver > 10000U) {"", ""\t\tarchive_set_error("", ""\t\t\t&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t\""Unsupported record version: %u.%u\"","", ""\t\t\tver / 10000, (ver % 10000) / 100);"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t}"", ""\tcntlen = _warc_rdlen(buf, eoh - buf);"", ""\tif (cntlen < 0) {"", ""\t\t/* nightmare!  the specs say content-length is mandatory"", ""\t\t * so I don't feel overly bad stopping the reader here */"", ""\t\tarchive_set_error("", ""\t\t\t&a->archive, EINVAL,"", ""\t\t\t\""Bad content length\"");"", ""\t\treturn (ARCHIVE_FATAL);"", ""\t} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {"", ""\t}"", ""\trtime = _warc_rdrtm(buf, eoh - buf);"", ""\tif (rtime == (time_t)-1) {"", ""\t\t/* record time is mandatory as per WARC/1.0,"", ""\t\t * so just barf here, fast and loud */"", ""\t\tarchive_set_error(""]","[0, 0, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 0, 0, -1, 1, 0, -1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 1, 1, 0, 0, 0]","[[19, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_warc.c"", ""+"", ""archive_set_error("", 0, ""/data/download/CMake/CMake/Kitware_CMake_53_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_53_new.cpp""]]",255,254
"[""\t\txar->lzstream.total_in = 0;"", ""\t\txar->lzstream.total_out = 0;"", ""\t\tbreak;"", ""#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)"", ""\tcase LZMA:"", ""\t\tif (xar->lzstream_valid)"", ""\t\t\tlzmadec_end(&(xar->lzstream));"", ""\t\tr = lzmadec_init(&(xar->lzstream));"", ""\t\tif (r != LZMADEC_OK) {"", ""\t\t\tswitch (r) {"", ""\t\t\tcase LZMADEC_HEADER_ERROR:"", ""\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t\t    \""Internal error initializing \"""", ""\t\t\t\t    \""compression library: \"""", ""\t\t\t\t    \""invalid header\"");"", ""\t\t\t\tbreak;"", ""\t\t\tcase LZMADEC_MEM_ERROR:"", ""\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t    ENOMEM,"", ""\t\t\t\t    \""Internal error initializing \"""", ""\t\t\t\t    \""compression library: \"""", ""\t\t\t\t    \""out of memory\"");"", ""\t\t\t\tbreak;"", ""\t\t\t}"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t}"", ""\t\txar->lzstream_valid = 1;"", ""\t\txar->lzstream.total_in = 0;"", ""\t\txar->lzstream.total_out = 0;"", ""\t\tbreak;"", ""#endif"", ""\t/*"", ""\t * Unsupported compression.""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0]","[[11, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_xar.c"", ""-"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_54_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_54_new.cpp""], [18, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_xar.c"", ""-"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_54_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_54_new.cpp""]]",1526,1524
"[""\t\t*used = avail_in - xar->lzstream.avail_in;"", ""\t\t*outbytes = avail_out - xar->lzstream.avail_out;"", ""\t\tbreak;"", ""#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)"", ""\tcase LZMA:"", ""\t\txar->lzstream.next_in = (unsigned char *)(uintptr_t)b;"", ""\t\txar->lzstream.avail_in = avail_in;"", ""\t\txar->lzstream.next_out = (unsigned char *)outbuff;"", ""\t\txar->lzstream.avail_out = avail_out;"", ""\t\tr = lzmadec_decode(&(xar->lzstream), 0);"", ""\t\tswitch (r) {"", ""\t\tcase LZMADEC_STREAM_END: /* Found end of stream. */"", ""\t\t\tswitch (lzmadec_end(&(xar->lzstream))) {"", ""\t\t\tcase LZMADEC_OK:"", ""\t\t\t\tbreak;"", ""\t\t\tdefault:"", ""\t\t\t\tarchive_set_error(&(a->archive),"", ""\t\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t\t    \""Failed to clean up lzmadec decompressor\"");"", ""\t\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t\t}"", ""\t\t\txar->lzstream_valid = 0;"", ""\t\t\t/* FALLTHROUGH */"", ""\t\tcase LZMADEC_OK: /* Decompressor made some progress. */"", ""\t\t\tbreak;"", ""\t\tdefault:"", ""\t\t\tarchive_set_error(&(a->archive),"", ""\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""lzmadec decompression failed(%d)\"","", ""\t\t\t    r);"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t}"", ""\t\t*used = avail_in - xar->lzstream.avail_in;"", ""\t\t*outbytes = avail_out - xar->lzstream.avail_out;"", ""\t\tbreak;"", ""#endif"", ""#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)"", ""\tcase BZIP2:"", ""#endif"", ""#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)"", ""#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)"", ""\tcase LZMA:"", ""#endif"", ""\tcase XZ:"", ""#endif"", ""\tcase NONE:""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0]","[[16, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_xar.c"", ""-"", ""archive_set_error(&(a->archive),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_54_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_54_new.cpp""], [26, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_xar.c"", ""-"", ""archive_set_error(&(a->archive),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_54_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_54_new.cpp""]]",1685,1653
"["" *\tid1+size1+data1 + id2+size2+data2 ..."", "" *  triplets.  id and size are 2 bytes each."", "" */"", ""static void"", ""process_extra(const char *p, size_t extra_length, struct zip_entry* zip_entry)"", ""static int"", ""process_extra(struct archive_read *a, const char *p, size_t extra_length, struct zip_entry* zip_entry)"", ""{"", ""\tunsigned offset = 0;"", """", ""\twhile (offset < extra_length - 4) {"", ""\tif (extra_length == 0) {"", ""\t\treturn ARCHIVE_OK;"", ""\t}"", """", ""\tif (extra_length < 4) {"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t    \""Too-small extra data: Need at least 4 bytes, but only found %d bytes\"", (int)extra_length);"", ""\t\treturn ARCHIVE_FAILED;"", ""\t}"", ""\twhile (offset <= extra_length - 4) {"", ""\t\tunsigned short headerid = archive_le16dec(p + offset);"", ""\t\tunsigned short datasize = archive_le16dec(p + offset + 2);"", """", ""\t\toffset += 4;"", ""\t\tif (offset + datasize > extra_length) {"", ""\t\t\tbreak;"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t    \""Extra data overflow: Need %d bytes but only found %d bytes\"","", ""\t\t\t    (int)datasize, (int)(extra_length - offset));"", ""\t\t\treturn ARCHIVE_FAILED;"", ""\t\t}"", ""#ifdef DEBUG"", ""\t\tfprintf(stderr, \""Header id 0x%04x, length %d\\n\"",""]","[0, 0, 0, -1, -1, 1, 1, 0, 0, 0, -1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, 2, 1, 1, 1, 0, 0, 0]","[[16, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_55_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_55_new.cpp""], [27, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_55_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_55_new.cpp""]]",418,418
"[""\t\t\t/* Zip64 extended information extra field. */"", ""\t\t\tzip_entry->flags |= LA_USED_ZIP64;"", ""\t\t\tif (zip_entry->uncompressed_size == 0xffffffff) {"", ""\t\t\t\tif (datasize < 8)"", ""\t\t\t\t\tbreak;"", ""\t\t\t\tzip_entry->uncompressed_size ="", ""\t\t\t\t    archive_le64dec(p + offset);"", ""\t\t\t\tuint64_t t = 0;"", ""\t\t\t\tif (datasize < 8"", ""\t\t\t\t    || (t = archive_le64dec(p + offset)) > INT64_MAX) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t\t\t    \""Malformed 64-bit uncompressed size\"");"", ""\t\t\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\t\t}"", ""\t\t\t\tzip_entry->uncompressed_size = t;"", ""\t\t\t\toffset += 8;"", ""\t\t\t\tdatasize -= 8;"", ""\t\t\t}"", ""\t\t\tif (zip_entry->compressed_size == 0xffffffff) {"", ""\t\t\t\tif (datasize < 8)"", ""\t\t\t\t\tbreak;"", ""\t\t\t\tzip_entry->compressed_size ="", ""\t\t\t\t    archive_le64dec(p + offset);"", ""\t\t\t\tuint64_t t = 0;"", ""\t\t\t\tif (datasize < 8"", ""\t\t\t\t    || (t = archive_le64dec(p + offset)) > INT64_MAX) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t\t\t    \""Malformed 64-bit compressed size\"");"", ""\t\t\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\t\t}"", ""\t\t\t\tzip_entry->compressed_size = t;"", ""\t\t\t\toffset += 8;"", ""\t\t\t\tdatasize -= 8;"", ""\t\t\t}"", ""\t\t\tif (zip_entry->local_header_offset == 0xffffffff) {"", ""\t\t\t\tif (datasize < 8)"", ""\t\t\t\t\tbreak;"", ""\t\t\t\tzip_entry->local_header_offset ="", ""\t\t\t\t    archive_le64dec(p + offset);"", ""\t\t\t\tuint64_t t = 0;"", ""\t\t\t\tif (datasize < 8"", ""\t\t\t\t    || (t = archive_le64dec(p + offset)) > INT64_MAX) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t\t\t    \""Malformed 64-bit local header offset\"");"", ""\t\t\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\t\t}"", ""\t\t\t\tzip_entry->local_header_offset = t;"", ""\t\t\t\toffset += 8;"", ""\t\t\t\tdatasize -= 8;"", ""\t\t\t}""]","[0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0]","[[10, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_55_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_55_new.cpp""], [26, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_55_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_55_new.cpp""], [42, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_55_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_55_new.cpp""]]",440,452
"[""\t\t}"", ""\t\toffset += datasize;"", ""\t}"", ""#ifdef DEBUG"", ""\tif (offset != extra_length)"", ""\t{"", ""\t\tfprintf(stderr,"", ""\t\t    \""Extra data field contents do not match reported size!\\n\"");"", ""\tif (offset != extra_length) {"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t    \""Malformed extra data: Consumed %d bytes of %d bytes\"","", ""\t\t    (int)offset, (int)extra_length);"", ""\t\treturn ARCHIVE_FAILED;"", ""\t}"", ""#endif"", ""\treturn ARCHIVE_OK;"", ""}"", """", ""/*""]","[0, 0, 0, -1, -1, -1, -2, -1, 1, 2, 1, 1, 1, 0, -1, 1, 0, 0, 0]","[[6, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_zip.c"", ""-"", ""fprintf(stderr,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_55_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_55_new.cpp""], [9, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_55_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_55_new.cpp""]]",715,739
"[""\t\t\t|| (zip->hctx_valid"", ""\t\t\t && zip->entry->aes_extra.vendor == AES_VENDOR_AE_2))) {"", ""\t\t\tif (zip->entry->flags & LA_USED_ZIP64) {"", ""\t\t\t\tuint64_t compressed, uncompressed;"", ""\t\t\t\tzip->entry->crc32 = archive_le32dec(p + 4);"", ""\t\t\t\tzip->entry->compressed_size ="", ""\t\t\t\t\tarchive_le64dec(p + 8);"", ""\t\t\t\tzip->entry->uncompressed_size ="", ""\t\t\t\t\tarchive_le64dec(p + 16);"", ""\t\t\t\tcompressed = archive_le64dec(p + 8);"", ""\t\t\t\tuncompressed = archive_le64dec(p + 16);"", ""\t\t\t\tif (compressed > INT64_MAX || uncompressed > INT64_MAX) {"", ""\t\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t\t\t    \""Overflow of 64-bit file sizes\"");"", ""\t\t\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\t\t}"", ""\t\t\t\tzip->entry->compressed_size = compressed;"", ""\t\t\t\tzip->entry->uncompressed_size = uncompressed;"", ""\t\t\t\tzip->unconsumed = 24;"", ""\t\t\t} else {"", ""\t\t\t\tzip->entry->crc32 = archive_le32dec(p + 4);""]","[0, 0, 0, 1, 0, -1, -1, -1, -1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[12, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_55_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_55_new.cpp""]]",1136,1168
"[""\t\t\tzip->unconsumed = 4;"", ""\t\t}"", ""\t\tif (zip->entry->flags & LA_USED_ZIP64) {"", ""\t\t\tuint64_t compressed, uncompressed;"", ""\t\t\tzip->entry->crc32 = archive_le32dec(p);"", ""\t\t\tzip->entry->compressed_size = archive_le64dec(p + 4);"", ""\t\t\tzip->entry->uncompressed_size = archive_le64dec(p + 12);"", ""\t\t\tcompressed = archive_le64dec(p + 4);"", ""\t\t\tuncompressed = archive_le64dec(p + 12);"", ""\t\t\tif (compressed > INT64_MAX || uncompressed > INT64_MAX) {"", ""\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t\t    \""Overflow of 64-bit file sizes\"");"", ""\t\t\t\treturn ARCHIVE_FAILED;"", ""\t\t\t}"", ""\t\t\tzip->entry->compressed_size = compressed;"", ""\t\t\tzip->entry->uncompressed_size = uncompressed;"", ""\t\t\tzip->unconsumed += 20;"", ""\t\t} else {"", ""\t\t\tzip->entry->crc32 = archive_le32dec(p);""]","[0, 0, 0, 1, 0, -1, -1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[10, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_read_support_format_zip.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_55_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_55_new.cpp""]]",1417,1456
"[""\tentries = archive_acl_reset(abstract_acl, ae_requested_type);"", ""\tif (entries == 0)"", ""\t\treturn (ARCHIVE_OK);"", """", ""#if HAVE_SUN_ACL"", ""\tacl = NULL;"", ""\tacl = malloc(sizeof(acl_t));"", ""\tif (acl == NULL) {"", ""\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,"", ""\t\t\t\""Invalid ACL type\"");"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t}"", ""\tif (acl_type == ACE_T)"", ""\t\tacl->acl_entry_size = sizeof(ace_t);"", ""\telse if (acl_type == ACLENT_T)"", ""\t\tacl->acl_entry_size = sizeof(aclent_t);"", ""\telse {"", ""\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,"", ""\t\t\t\""Invalid ACL type\"");"", ""\t\tacl_free(acl);"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t}"", ""\tacl->acl_type = acl_type;"", ""\tacl->acl_cnt = entries;"", """", ""\tacl->acl_aclp = malloc(entries * acl->acl_entry_size);"", ""\tif (acl->acl_aclp == NULL) {"", ""\t\tarchive_set_error(a, errno,"", ""\t\t    \""Can't allocate memory for acl buffer\"");"", ""\t\tacl_free(acl);"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t}"", ""#else\t/* !HAVE_SUN_ACL */"", ""\tacl = acl_init(entries);"", ""\tif (acl == (acl_t)NULL) {"", ""\t\tarchive_set_error(a, errno,"", ""\t\t    \""Failed to initialize ACL working storage\"");"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t}"", ""#endif\t/* !HAVE_SUN_ACL */"", ""#if HAVE_SUN_ACL"", ""\te = 0;"", ""#endif"", ""\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,"", ""\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {"", ""\t\tacl_create_entry(&acl, &acl_entry);"", """", ""#if HAVE_SUN_ACL"", ""\t\tace = NULL;"", ""\t\taclent = NULL;"", ""\t\tif (acl->acl_type == ACE_T)  {"", ""\t\t\tace = &((ace_t *)acl->acl_aclp)[e];"", ""\t\t\tace->a_who = -1;"", ""\t\t\tace->a_access_mask = 0;"", ""\t\t\tace->a_flags = 0;"", ""\t\t} else {"", ""\t\t\taclent = &((aclent_t *)acl->acl_aclp)[e];"", ""\t\t\taclent->a_id = -1;"", ""\t\t\taclent->a_type = 0;"", ""\t\t\taclent->a_perm = 0;"", ""\t\t}"", ""#else\t/* !HAVE_SUN_ACL  */"", ""#if HAVE_DARWIN_ACL"", ""\t\t/*"", ""\t\t * Mac OS doesn't support NFSv4 ACLs for"", ""\t\t * owner@, group@ and everyone@."", ""\t\t * We skip any of these ACLs found."", ""\t\t */"", ""\t\tif (ae_tag == ARCHIVE_ENTRY_ACL_USER_OBJ ||"", ""\t\t    ae_tag == ARCHIVE_ENTRY_ACL_GROUP_OBJ ||"", ""\t\t    ae_tag == ARCHIVE_ENTRY_ACL_EVERYONE)"", ""\t\t\tcontinue;"", ""#endif"", ""\t\tif (acl_create_entry(&acl, &acl_entry) != 0) {"", ""\t\t\tarchive_set_error(a, errno,"", ""\t\t\t    \""Failed to create a new ACL entry\"");"", ""\t\t\tret = ARCHIVE_FAILED;"", ""\t\t\tgoto exit_free;"", ""\t\t}"", ""#endif\t/* !HAVE_SUN_ACL */"", ""#if HAVE_DARWIN_ACL"", ""\t\tswitch (ae_type) {"", ""\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALLOW:"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_EXTENDED_ALLOW);"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DENY:"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_EXTENDED_DENY);"", ""\t\t\tbreak;"", ""\t\tdefault:"", ""\t\t\t/* We don't support any other types on MacOS */"", ""\t\t\tcontinue;"", ""\t\t}"", ""#endif"", ""\t\tswitch (ae_tag) {"", ""#if HAVE_SUN_ACL"", ""\t\tcase ARCHIVE_ENTRY_ACL_USER:"", ""\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);"", ""\t\t\tif (acl->acl_type == ACE_T)"", ""\t\t\t\tace->a_who = ae_uid;"", ""\t\t\telse {"", ""\t\t\t\taclent->a_id = ae_uid;"", ""\t\t\t\taclent->a_type |= USER;"", ""\t\t\t}"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_GROUP:"", ""\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);"", ""\t\t\tif (acl->acl_type == ACE_T) {"", ""\t\t\t\tace->a_who = ae_gid;"", ""\t\t\t\tace->a_flags |= ACE_IDENTIFIER_GROUP;"", ""\t\t\t} else {"", ""\t\t\t\taclent->a_id = ae_gid;"", ""\t\t\t\taclent->a_type |= GROUP;"", ""\t\t\t}"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:"", ""\t\t\tif (acl->acl_type == ACE_T)"", ""\t\t\t\tace->a_flags |= ACE_OWNER;"", ""\t\t\telse"", ""\t\t\t\taclent->a_type |= USER_OBJ;"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:"", ""\t\t\tif (acl->acl_type == ACE_T) {"", ""\t\t\t\tace->a_flags |= ACE_GROUP;"", ""\t\t\t\tace->a_flags |= ACE_IDENTIFIER_GROUP;"", ""\t\t\t} else"", ""\t\t\t\taclent->a_type |= GROUP_OBJ;"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_MASK:"", ""\t\t\taclent->a_type |= CLASS_OBJ;"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_OTHER:"", ""\t\t\taclent->a_type |= OTHER_OBJ;"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_EVERYONE:"", ""\t\t\tace->a_flags |= ACE_EVERYONE;"", ""\t\t\tbreak;"", ""#else\t/* !HAVE_SUN_ACL */"", ""\t\tcase ARCHIVE_ENTRY_ACL_USER:"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_USER);"", ""\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);"", ""#if !HAVE_DARWIN_ACL\t/* FreeBSD, Linux */"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_USER);"", ""\t\t\tacl_set_qualifier(acl_entry, &ae_uid);"", ""#else\t/* MacOS */"", ""\t\t\tif (mbr_identifier_to_uuid(ID_TYPE_UID, &ae_uid,"", ""\t\t\t    sizeof(uid_t), ae_uuid) != 0)"", ""\t\t\t\tcontinue;"", ""\t\t\tif (acl_set_qualifier(acl_entry, &ae_uuid) != 0)"", ""\t\t\t\tcontinue;"", ""#endif\t/* HAVE_DARWIN_ACL */"", ""\t\t\tbreak;"", ""\t\tcase ARCHIVE_ENTRY_ACL_GROUP:"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP);"", ""\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);"", ""#if !HAVE_DARWIN_ACL\t/* FreeBSD, Linux */"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP);"", ""\t\t\tacl_set_qualifier(acl_entry, &ae_gid);"", ""#else\t/* MacOS */"", ""\t\t\tif (mbr_identifier_to_uuid(ID_TYPE_GID, &ae_gid,"", ""\t\t\t    sizeof(gid_t), ae_uuid) != 0)"", ""\t\t\t\tcontinue;"", ""\t\t\tif (acl_set_qualifier(acl_entry, &ae_uuid) != 0)"", ""\t\t\t\tcontinue;"", ""#endif\t/* HAVE_DARWIN_ACL */"", ""\t\t\tbreak;"", ""#if !HAVE_DARWIN_ACL\t/* FreeBSD, Linux */"", ""\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:"", ""\t\t\tacl_set_tag_type(acl_entry, ACL_USER_OBJ);"", ""\t\t\tbreak;""]","[0, 0, 0, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0]","[[8, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_acl.c"", ""+"", ""archive_set_error(a, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_56_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_56_new.cpp""], [17, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_acl.c"", ""+"", ""archive_set_error(a, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_56_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_56_new.cpp""], [27, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_acl.c"", ""+"", ""archive_set_error(a, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_56_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_56_new.cpp""], [35, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_acl.c"", ""+"", ""archive_set_error(a, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_56_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_56_new.cpp""], [74, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_acl.c"", ""+"", ""archive_set_error(a, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_56_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_56_new.cpp""]]",151,254
"["""", ""#define HFS_BLOCKS(s)\t((s) >> 12)"", """", ""static void\tfsobj_error(int *, struct archive_string *, int, const char *,"", ""\t\t    const char *);"", ""static int\tcheck_symlinks_fsobj(char *, int *, struct archive_string *,"", ""\t\t    int);"", ""static int\tcheck_symlinks(struct archive_write_disk *);"", ""static int\tcreate_filesystem_object(struct archive_write_disk *);"", ""static struct fixup_entry *current_fixup(struct archive_write_disk *, const char *pathname);"", ""static struct fixup_entry *current_fixup(struct archive_write_disk *,"", ""\t\t    const char *pathname);"", ""#if defined(HAVE_FCHDIR) && defined(PATH_MAX)"", ""static void\tedit_deep_directories(struct archive_write_disk *ad);"", ""#endif"", ""static int\tcleanup_pathname_fsobj(char *, int *, struct archive_string *,"", ""\t\t    int);"", ""static int\tcleanup_pathname(struct archive_write_disk *);"", ""static int\tcreate_dir(struct archive_write_disk *, char *);"", ""static int\tcreate_parent_dir(struct archive_write_disk *, char *);""]","[0, 0, 0, 2, 1, 1, 1, 0, 0, -1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0]","[[3, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""static void\tfsobj_error(int *, struct archive_string *, int, const char *,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""]]",326,348
"[""\tif (a->restore_pwd >= 0) {"", ""\t\tr = fchdir(a->restore_pwd);"", ""\t\tif (r != 0) {"", ""\t\t\tarchive_set_error(&a->archive, errno, \""chdir() failure\"");"", ""\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t    \""chdir() failure\"");"", ""\t\t\tret = ARCHIVE_FATAL;"", ""\t\t}"", ""\t\tclose(a->restore_pwd);""]","[0, 0, 0, -2, 2, 1, 0, 0, 0]","[[3, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, errno, \""chdir() failure\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [4, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""]]",637,669
"["""", ""\tif (en) {"", ""\t\t/* Everything failed; give up here. */"", ""\t\tarchive_set_error(&a->archive, en, \""Can't create '%s'\"","", ""\t\t    a->name);"", ""\t\tif ((&a->archive)->error == NULL)"", ""\t\t\tarchive_set_error(&a->archive, en, \""Can't create '%s'\"","", ""\t\t\t    a->name);"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t}"", """"]","[0, 0, 0, -2, -1, 1, 2, 1, 0, 0, 0]","[[3, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, en, \""Can't create '%s'\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [6, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, en, \""Can't create '%s'\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""]]",1993,2043
"[""#if !HAVE_LINK"", ""\t\treturn (EPERM);"", ""#else"", ""\t\tarchive_string_init(&error_string);"", ""\t\tlinkname_copy = strdup(linkname);"", ""\t\tif (linkname_copy == NULL) {"", ""\t\t    return (EPERM);"", ""\t\t}"", ""\t\t/*"", ""\t\t * TODO: consider using the cleaned-up path as the link"", ""\t\t * target?"", ""\t\t */"", ""\t\tr = cleanup_pathname_fsobj(linkname_copy, &error_number,"", ""\t\t    &error_string, a->flags);"", ""\t\tif (r != ARCHIVE_OK) {"", ""\t\t\tarchive_set_error(&a->archive, error_number, \""%s\"","", ""\t\t\t    error_string.s);"", ""\t\t\tfree(linkname_copy);"", ""\t\t\tarchive_string_free(&error_string);"", ""\t\t\t/*"", ""\t\t\t * EPERM is more appropriate than error_number for our"", ""\t\t\t * callers"", ""\t\t\t */"", ""\t\t\treturn (EPERM);"", ""\t\t}"", ""\t\tr = check_symlinks_fsobj(linkname_copy, &error_number,"", ""\t\t    &error_string, a->flags);"", ""\t\tif (r != ARCHIVE_OK) {"", ""\t\t\tarchive_set_error(&a->archive, error_number, \""%s\"","", ""\t\t\t    error_string.s);"", ""\t\t\tfree(linkname_copy);"", ""\t\t\tarchive_string_free(&error_string);"", ""\t\t\t/*"", ""\t\t\t * EPERM is more appropriate than error_number for our"", ""\t\t\t * callers"", ""\t\t\t */"", ""\t\t\treturn (EPERM);"", ""\t\t}"", ""\t\tfree(linkname_copy);"", ""\t\tarchive_string_free(&error_string);"", ""\t\tr = link(linkname, a->name) ? errno : 0;"", ""\t\t/*"", ""\t\t * New cpio and pax formats allow hardlink entries""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[15, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, error_number, \""%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [28, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, error_number, \""%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""]]",2022,2078
"[""\treturn (a->current_fixup);"", ""}"", """", ""/* TODO: Make this work. */"", ""/*"", "" * TODO: The deep-directory support bypasses this; disable deep directory"", "" * support if we're doing symlink checks."", "" */"", ""/* Error helper for new *_fsobj functions */"", ""static void"", ""fsobj_error(int *a_eno, struct archive_string *a_estr,"", ""    int err, const char *errstr, const char *path)"", ""{"", ""\tif (a_eno)"", ""\t\t*a_eno = err;"", ""\tif (a_estr)"", ""\t\tarchive_string_sprintf(a_estr, errstr, path);"", ""}"", """", ""/*"", "" * TODO: Someday, integrate this with the deep dir support; they both"", "" * scan the path and both can be optimized by comparing against other"", "" * recent paths."", "" */"", ""/* TODO: Extend this to support symlinks on Windows Vista and later. */"", """", ""/*"", "" * Checks the given path to see if any elements along it are symlinks.  Returns"", "" * ARCHIVE_OK if there are none, otherwise puts an error in errmsg."", "" */"", ""static int"", ""check_symlinks(struct archive_write_disk *a)"", ""check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,"", ""    int flags)"", ""{"", ""#if !defined(HAVE_LSTAT)"", ""\t/* Platform doesn't have lstat, so we can't look for symlinks. */"", ""\t(void)a; /* UNUSED */"", ""\t(void)path; /* UNUSED */"", ""\t(void)error_number; /* UNUSED */"", ""\t(void)error_string; /* UNUSED */"", ""\t(void)flags; /* UNUSED */"", ""\treturn (ARCHIVE_OK);"", ""#else"", ""\tchar *pn;"", ""\tint res = ARCHIVE_OK;"", ""\tchar *tail;"", ""\tchar *head;"", ""\tint last;"", ""\tchar c;"", ""\tint r;"", ""\tstruct stat st;"", ""\tint restore_pwd;"", """", ""\t/* Nothing to do here if name is empty */"", ""\tif(path[0] == '\\0')"", ""\t    return (ARCHIVE_OK);"", """", ""\t/*"", ""\t * Guard against symlink tricks.  Reject any archive entry whose"", ""\t * destination would be altered by a symlink."", ""\t *"", ""\t * Walk the filename in chunks separated by '/'.  For each segment:"", ""\t *  - if it doesn't exist, continue"", ""\t *  - if it's symlink, abort or remove it"", ""\t *  - if it's a directory and it's not the last chunk, cd into it"", ""\t * As we go:"", ""\t *  head points to the current (relative) path"", ""\t *  tail points to the temporary \\0 terminating the segment we're"", ""\t *      currently examining"", ""\t *  c holds what used to be in *tail"", ""\t *  last is 1 if this is the last tail"", ""\t */"", ""\t/* Whatever we checked last time doesn't need to be re-checked. */"", ""\tpn = a->name;"", ""\tif (archive_strlen(&(a->path_safe)) > 0) {"", ""\t\tchar *p = a->path_safe.s;"", ""\t\twhile ((*pn != '\\0') && (*p == *pn))"", ""\t\t\t++p, ++pn;"", ""\t}"", ""\trestore_pwd = open(\"".\"", O_RDONLY | O_BINARY | O_CLOEXEC);"", ""\t__archive_ensure_cloexec_flag(restore_pwd);"", ""\tif (restore_pwd < 0)"", ""\t\treturn (ARCHIVE_FATAL);"", ""\thead = path;"", ""\ttail = path;"", ""\tlast = 0;"", ""\t/* TODO: reintroduce a safe cache here? */"", ""\t/* Skip the root directory if the path is absolute. */"", ""\tif(pn == a->name && pn[0] == '/')"", ""\t\t++pn;"", ""\tc = pn[0];"", ""\t/* Keep going until we've checked the entire name. */"", ""\twhile (pn[0] != '\\0' && (pn[0] != '/' || pn[1] != '\\0')) {"", ""\tif(tail == path && tail[0] == '/')"", ""\t\t++tail;"", ""\t/* Keep going until we've checked the entire name."", ""\t * head, tail, path all alias the same string, which is"", ""\t * temporarily zeroed at tail, so be careful restoring the"", ""\t * stashed (c=tail[0]) for error messages."", ""\t * Exiting the loop with break is okay; continue is not."", ""\t */"", ""\twhile (!last) {"", ""\t\t/*"", ""\t\t * Skip the separator we just consumed, plus any adjacent ones"", ""\t\t */"", ""\t\twhile (*tail == '/')"", ""\t\t    ++tail;"", ""\t\t/* Skip the next path element. */"", ""\t\twhile (*pn != '\\0' && *pn != '/')"", ""\t\t\t++pn;"", ""\t\tc = pn[0];"", ""\t\tpn[0] = '\\0';"", ""\t\twhile (*tail != '\\0' && *tail != '/')"", ""\t\t\t++tail;"", ""\t\t/* is this the last path component? */"", ""\t\tlast = (tail[0] == '\\0') || (tail[0] == '/' && tail[1] == '\\0');"", ""\t\t/* temporarily truncate the string here */"", ""\t\tc = tail[0];"", ""\t\ttail[0] = '\\0';"", ""\t\t/* Check that we haven't hit a symlink. */"", ""\t\tr = lstat(a->name, &st);"", ""\t\tr = lstat(head, &st);"", ""\t\tif (r != 0) {"", ""\t\t\ttail[0] = c;"", ""\t\t\t/* We've hit a dir that doesn't exist; stop now. */"", ""\t\t\tif (errno == ENOENT)"", ""\t\t\tif (errno == ENOENT) {"", ""\t\t\t\tbreak;"", ""\t\t\t} else {"", ""\t\t\t\t/*"", ""\t\t\t\t * Treat any other error as fatal - best to be"", ""\t\t\t\t * paranoid here."", ""\t\t\t\t * Note: This effectively disables deep"", ""\t\t\t\t * directory support when security checks are"", ""\t\t\t\t * enabled. Otherwise, very long pathnames that"", ""\t\t\t\t * trigger an error here could evade the"", ""\t\t\t\t * sandbox."", ""\t\t\t\t * TODO: We could do better, but it would"", ""\t\t\t\t * probably require merging the symlink checks"", ""\t\t\t\t * with the deep-directory editing."", ""\t\t\t\t */"", ""\t\t\t\tfsobj_error(a_eno, a_estr, errno,"", ""\t\t\t\t    \""Could not stat %s\"", path);"", ""\t\t\t\tres = ARCHIVE_FAILED;"", ""\t\t\t\tbreak;"", ""\t\t\t}"", ""\t\t} else if (S_ISDIR(st.st_mode)) {"", ""\t\t\tif (!last) {"", ""\t\t\t\tif (chdir(head) != 0) {"", ""\t\t\t\t\ttail[0] = c;"", ""\t\t\t\t\tfsobj_error(a_eno, a_estr, errno,"", ""\t\t\t\t\t    \""Could not chdir %s\"", path);"", ""\t\t\t\t\tres = (ARCHIVE_FATAL);"", ""\t\t\t\t\tbreak;"", ""\t\t\t\t}"", ""\t\t\t\t/* Our view is now from inside this dir: */"", ""\t\t\t\thead = tail + 1;"", ""\t\t\t}"", ""\t\t} else if (S_ISLNK(st.st_mode)) {"", ""\t\t\tif (c == '\\0') {"", ""\t\t\tif (last) {"", ""\t\t\t\t/*"", ""\t\t\t\t * Last element is symlink; remove it"", ""\t\t\t\t * so we can overwrite it with the"", ""\t\t\t\t * item being extracted."", ""\t\t\t\t */"", ""\t\t\t\tif (unlink(a->name)) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\tif (unlink(head)) {"", ""\t\t\t\t\ttail[0] = c;"", ""\t\t\t\t\tfsobj_error(a_eno, a_estr, errno,"", ""\t\t\t\t\t    \""Could not remove symlink %s\"","", ""\t\t\t\t\t    a->name);"", ""\t\t\t\t\tpn[0] = c;"", ""\t\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t\t\t\t    path);"", ""\t\t\t\t\tres = ARCHIVE_FAILED;"", ""\t\t\t\t\tbreak;"", ""\t\t\t\t}"", ""\t\t\t\ta->pst = NULL;"", ""\t\t\t\t/*"", ""\t\t\t\t * Even if we did remove it, a warning"", ""\t\t\t\t * is in order.  The warning is silly,"", ""\t\t\t\t * though, if we're just replacing one"", ""\t\t\t\t * symlink with another symlink."", ""\t\t\t\t */"", ""\t\t\t\tif (!S_ISLNK(a->mode)) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, 0,"", ""\t\t\t\t\t    \""Removing symlink %s\"","", ""\t\t\t\t\t    a->name);"", ""\t\t\t\ttail[0] = c;"", ""\t\t\t\t/*"", ""\t\t\t\t * FIXME:  not sure how important this is to"", ""\t\t\t\t * restore"", ""\t\t\t\t */"", ""\t\t\t\t/*"", ""\t\t\t\tif (!S_ISLNK(path)) {"", ""\t\t\t\t\tfsobj_error(a_eno, a_estr, 0,"", ""\t\t\t\t\t    \""Removing symlink %s\"", path);"", ""\t\t\t\t}"", ""\t\t\t\t*/"", ""\t\t\t\t/* Symlink gone.  No more problem! */"", ""\t\t\t\tpn[0] = c;"", ""\t\t\t\treturn (0);"", ""\t\t\t} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {"", ""\t\t\t\tres = ARCHIVE_OK;"", ""\t\t\t\tbreak;"", ""\t\t\t} else if (flags & ARCHIVE_EXTRACT_UNLINK) {"", ""\t\t\t\t/* User asked us to remove problems. */"", ""\t\t\t\tif (unlink(a->name) != 0) {"", ""\t\t\t\t\tarchive_set_error(&a->archive, 0,"", ""\t\t\t\t\t    \""Cannot remove intervening symlink %s\"","", ""\t\t\t\t\t    a->name);"", ""\t\t\t\t\tpn[0] = c;"", ""\t\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t\t\tif (unlink(head) != 0) {"", ""\t\t\t\t\ttail[0] = c;"", ""\t\t\t\t\tfsobj_error(a_eno, a_estr, 0,"", ""\t\t\t\t\t    \""Cannot remove intervening \"""", ""\t\t\t\t\t    \""symlink %s\"", path);"", ""\t\t\t\t\tres = ARCHIVE_FAILED;"", ""\t\t\t\t\tbreak;"", ""\t\t\t\t}"", ""\t\t\t\ttail[0] = c;"", ""\t\t\t} else if ((flags &"", ""\t\t\t    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {"", ""\t\t\t\t/*"", ""\t\t\t\t * We are not the last element and we want to"", ""\t\t\t\t * follow symlinks if they are a directory."", ""\t\t\t\t * "", ""\t\t\t\t * This is needed to extract hardlinks over"", ""\t\t\t\t * symlinks."", ""\t\t\t\t */"", ""\t\t\t\tr = stat(head, &st);"", ""\t\t\t\tif (r != 0) {"", ""\t\t\t\t\ttail[0] = c;"", ""\t\t\t\t\tif (errno == ENOENT) {"", ""\t\t\t\t\t\tbreak;"", ""\t\t\t\t\t} else {"", ""\t\t\t\t\t\tfsobj_error(a_eno, a_estr,"", ""\t\t\t\t\t\t    errno,"", ""\t\t\t\t\t\t    \""Could not stat %s\"", path);"", ""\t\t\t\t\t\tres = (ARCHIVE_FAILED);"", ""\t\t\t\t\t\tbreak;"", ""\t\t\t\t\t}"", ""\t\t\t\t} else if (S_ISDIR(st.st_mode)) {"", ""\t\t\t\t\tif (chdir(head) != 0) {"", ""\t\t\t\t\t\ttail[0] = c;"", ""\t\t\t\t\t\tfsobj_error(a_eno, a_estr,"", ""\t\t\t\t\t\t    errno,"", ""\t\t\t\t\t\t    \""Could not chdir %s\"", path);"", ""\t\t\t\t\t\tres = (ARCHIVE_FATAL);"", ""\t\t\t\t\t\tbreak;"", ""\t\t\t\t\t}"", ""\t\t\t\t\t/*"", ""\t\t\t\t\t * Our view is now from inside"", ""\t\t\t\t\t * this dir:"", ""\t\t\t\t\t */"", ""\t\t\t\t\thead = tail + 1;"", ""\t\t\t\t} else {"", ""\t\t\t\t\ttail[0] = c;"", ""\t\t\t\t\tfsobj_error(a_eno, a_estr, 0,"", ""\t\t\t\t\t    \""Cannot extract through \"""", ""\t\t\t\t\t    \""symlink %s\"", path);"", ""\t\t\t\t\tres = ARCHIVE_FAILED;"", ""\t\t\t\t\tbreak;"", ""\t\t\t\t}"", ""\t\t\t\ta->pst = NULL;"", ""\t\t\t} else {"", ""\t\t\t\tarchive_set_error(&a->archive, 0,"", ""\t\t\t\t    \""Cannot extract through symlink %s\"","", ""\t\t\t\t    a->name);"", ""\t\t\t\tpn[0] = c;"", ""\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t\t\ttail[0] = c;"", ""\t\t\t\tfsobj_error(a_eno, a_estr, 0,"", ""\t\t\t\t    \""Cannot extract through symlink %s\"", path);"", ""\t\t\t\tres = ARCHIVE_FAILED;"", ""\t\t\t\tbreak;"", ""\t\t\t}"", ""\t\t}"", ""\t\tpn[0] = c;"", ""\t\tif (pn[0] != '\\0')"", ""\t\t\tpn++; /* Advance to the next segment. */"", ""\t\t/* be sure to always maintain this */"", ""\t\ttail[0] = c;"", ""\t\tif (tail[0] != '\\0')"", ""\t\t\ttail++; /* Advance to the next segment. */"", ""\t}"", ""\t/* Catches loop exits via break */"", ""\ttail[0] = c;"", ""#ifdef HAVE_FCHDIR"", ""\t/* If we changed directory above, restore it here. */"", ""\tif (restore_pwd >= 0) {"", ""\t\tr = fchdir(restore_pwd);"", ""\t\tif (r != 0) {"", ""\t\t\tfsobj_error(a_eno, a_estr, errno,"", ""\t\t\t    \""chdir() failure\"", \""\"");"", ""\t\t}"", ""\t\tclose(restore_pwd);"", ""\t\trestore_pwd = -1;"", ""\t\tif (r != 0) {"", ""\t\t\tres = (ARCHIVE_FATAL);"", ""\t\t}"", ""\t}"", ""\tpn[0] = c;"", ""\t/* We've checked and/or cleaned the whole path, so remember it. */"", ""\tarchive_strcpy(&a->path_safe, a->name);"", ""\treturn (ARCHIVE_OK);"", ""#endif"", ""\t/* TODO: reintroduce a safe cache here? */"", ""\treturn res;"", ""#endif"", ""}"", """", ""/*"", "" * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise"", "" * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}"", "" */"", ""static int"", ""check_symlinks(struct archive_write_disk *a)"", ""{"", ""\tstruct archive_string error_string;"", ""\tint error_number;"", ""\tint rc;"", ""\tarchive_string_init(&error_string);"", ""\trc = check_symlinks_fsobj(a->name, &error_number, &error_string,"", ""\t    a->flags);"", ""\tif (rc != ARCHIVE_OK) {"", ""\t\tarchive_set_error(&a->archive, error_number, \""%s\"","", ""\t\t    error_string.s);"", ""\t}"", ""\tarchive_string_free(&error_string);"", ""\ta->pst = NULL;\t/* to be safe */"", ""\treturn rc;"", ""}"", """", """", ""#if defined(__CYGWIN__)"", ""/*"", "" * 1. Convert a path separator from '\\' to '/' .""]","[0, 0, 0, -1, -1, -1, -1, -1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, -1, 1, 1, 0, 0, 0, -1, 1, 1, 1, 1, 0, 0, -1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, 1, 0, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, 0, 0, 0, 0, -1, -2, 1, 1, 2, 0, -1, -1, -1, 1, 1, 1, 0, -1, 0, 0, 0, 0, 0, 0, -1, -2, -1, -1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 0, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, -2, -1, -1, -1, -1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0, -1, 0, -2, -1, -1, -1, -1, 1, 2, 1, 1, 1, 0, 0, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[10, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(int *a_eno, struct archive_string *a_estr,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [16, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""archive_string_sprintf(a_estr, errstr, path);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [142, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [151, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [168, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [171, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [188, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [198, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [211, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [218, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [240, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [249, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [262, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [270, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [276, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, 0,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [297, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [330, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, error_number, \""%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""]]",2351,2457
"["" * is set) if the path is absolute."", "" */"", ""static int"", ""cleanup_pathname(struct archive_write_disk *a)"", ""cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,"", ""    int flags)"", ""{"", ""\tchar *dest, *src;"", ""\tchar separator = '\\0';"", """", ""\tdest = src = a->name;"", ""\tdest = src = path;"", ""\tif (*src == '\\0') {"", ""\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Invalid empty pathname\"");"", ""\t\tfsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,"", ""\t\t    \""Invalid empty \"", \""pathname\"");"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t}"", """", ""#if defined(__CYGWIN__)"", ""\tcleanup_pathname_win(a);"", ""\tcleanup_pathname_win(path);"", ""#endif"", ""\t/* Skip leading '/'. */"", ""\tif (*src == '/') {"", ""\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", ""\t\t\t                  \""Path is absolute\"");"", ""\t\tif (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {"", ""\t\t\tfsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,"", ""\t\t\t    \""Path is \"", \""absolute\"");"", ""\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t}"", """"]","[0, 0, 0, -1, 1, 1, 0, 0, 0, 0, -1, 1, 0, -2, -1, 2, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, -2, -1, 1, 2, 1, 0, 0, 0]","[[13, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [15, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [27, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [30, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""]]",2534,2807
"[""\t\t\t} else if (src[1] == '.') {"", ""\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {"", ""\t\t\t\t\t/* Conditionally warn about '..' */"", ""\t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {"", ""\t\t\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t\tif (flags"", ""\t\t\t\t\t    & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {"", ""\t\t\t\t\t\tfsobj_error(a_eno, a_estr,"", ""\t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,"", ""\t\t\t\t\t\t    \""Path contains '..'\"");"", ""\t\t\t\t\t\t    \""Path contains \"", \""'..'\"");"", ""\t\t\t\t\t\treturn (ARCHIVE_FAILED);"", ""\t\t\t\t\t}"", ""\t\t\t\t}""]","[0, 0, 0, -1, -2, 1, 1, 2, 0, -1, 1, 0, 0, 0]","[[4, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [7, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""fsobj_error(a_eno, a_estr,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""]]",2580,2854
"[""\treturn (ARCHIVE_OK);"", ""}"", """", ""static int"", ""cleanup_pathname(struct archive_write_disk *a)"", ""{"", ""\tstruct archive_string error_string;"", ""\tint error_number;"", ""\tint rc;"", ""\tarchive_string_init(&error_string);"", ""\trc = cleanup_pathname_fsobj(a->name, &error_number, &error_string,"", ""\t    a->flags);"", ""\tif (rc != ARCHIVE_OK) {"", ""\t\tarchive_set_error(&a->archive, error_number, \""%s\"","", ""\t\t    error_string.s);"", ""\t}"", ""\tarchive_string_free(&error_string);"", ""\treturn rc;"", ""}"", """", ""/*"", "" * Create the parent directory of the specified path, assuming path"", "" * is already in mutable storage.""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[13, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, error_number, \""%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""]]",2629,2904
"[""\t\t}"", ""\t} else if (errno != ENOENT && errno != ENOTDIR) {"", ""\t\t/* Stat failed? */"", ""\t\tarchive_set_error(&a->archive, errno, \""Can't test directory '%s'\"", path);"", ""\t\tarchive_set_error(&a->archive, errno,"", ""\t\t    \""Can't test directory '%s'\"", path);"", ""\t\treturn (ARCHIVE_FAILED);"", ""\t} else if (slash != NULL) {"", ""\t\t*slash = '\\0';""]","[0, 0, 0, -2, 2, 1, 0, 0, 0]","[[3, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, errno, \""Can't test directory '%s'\"", path);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [4, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""]]",2707,2999
"[""\t\t\t\tif (errno == ENOTSUP || errno == ENOSYS) {"", ""\t\t\t\t\tif (!warning_done) {"", ""\t\t\t\t\t\twarning_done = 1;"", ""\t\t\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t\t\t    errno,"", ""\t\t\t\t\t\t    \""Cannot restore extended \"""", ""\t\t\t\t\t\t    \""attributes on this file \"""", ""\t\t\t\t\t\t    \""system\"");""]","[0, 0, 0, -2, 2, 1, 0, 0, 0]","[[3, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [4, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""]]",3753,4051
"[""\t\t\t\tret = ARCHIVE_WARN;"", ""\t\t\t}"", ""\t\t} else {"", ""\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,"", ""\t\t\t    \""Invalid extended attribute encountered\"");"", ""\t\t\tret = ARCHIVE_WARN;"", ""\t\t}""]","[0, 0, 0, -2, 2, 1, 0, 0, 0]","[[3, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [4, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""]]",3764,4063
"[""\t\t\terrno = 0;"", ""#if HAVE_EXTATTR_SET_FD"", ""\t\t\tif (a->fd >= 0)"", ""\t\t\t\te = extattr_set_fd(a->fd, namespace, name, value, size);"", ""\t\t\t\te = extattr_set_fd(a->fd, namespace, name,"", ""\t\t\t\t    value, size);"", ""\t\t\telse"", ""#endif"", ""\t\t\t/* TODO: should we use extattr_set_link() instead? */"", ""\t\t\t{"", ""\t\t\t\te = extattr_set_file(archive_entry_pathname(entry),"", ""\t\t\t\t    namespace, name, value, size);"", ""\t\t\t\te = extattr_set_file("", ""\t\t\t\t    archive_entry_pathname(entry), namespace,"", ""\t\t\t\t    name, value, size);"", ""\t\t\t}"", ""\t\t\tif (e != (int)size) {"", ""\t\t\t\tif (errno == ENOTSUP || errno == ENOSYS) {"", ""\t\t\t\t\tif (!warning_done) {"", ""\t\t\t\t\t\twarning_done = 1;"", ""\t\t\t\t\t\tarchive_set_error(&a->archive, errno,"", ""\t\t\t\t\t\tarchive_set_error(&a->archive,"", ""\t\t\t\t\t\t    errno,"", ""\t\t\t\t\t\t    \""Cannot restore extended \"""", ""\t\t\t\t\t\t    \""attributes on this file \"""", ""\t\t\t\t\t\t    \""system\"");""]","[0, 0, 0, -1, 1, 1, 0, 0, 0, 0, -1, -1, 1, 1, 1, 0, 0, 0, 0, 0, -2, 2, 1, 0, 0, 0]","[[20, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""-"", ""archive_set_error(&a->archive, errno,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""], [21, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_disk_posix.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_57_new.cpp""]]",3808,4108
"[""\treturn (ARCHIVE_OK);"", ""}"", """", ""/* Add ACL to pax header */"", ""static int"", ""add_pax_acl(struct archive_write *a,"", ""    struct archive_entry *entry, struct pax *pax, int flags)"", ""{"", ""\tchar *p;"", ""\tconst char *attr;"", ""\tint acl_types;"", """", ""\tacl_types = archive_entry_acl_types(entry);"", """", ""\tif ((acl_types & ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0)"", ""\t\tattr = \""SCHILY.acl.ace\"";"", ""\telse if ((flags & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0)"", ""\t\tattr = \""SCHILY.acl.access\"";"", ""\telse if ((flags & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)"", ""\t\tattr = \""SCHILY.acl.default\"";"", ""\telse"", ""\t\treturn (ARCHIVE_FATAL);"", """", ""\tp = archive_entry_acl_to_text_l(entry, NULL, flags, pax->sconv_utf8);"", ""\tif (p == NULL) {"", ""\t\tif (errno == ENOMEM) {"", ""\t\t\tarchive_set_error(&a->archive, ENOMEM, \""%s %s\"","", ""\t\t\t    \""Can't allocate memory for \"", attr);"", ""\t\t\treturn (ARCHIVE_FATAL);"", ""\t\t}"", ""\t\tarchive_set_error(&a->archive,"", ""\t\t    ARCHIVE_ERRNO_FILE_FORMAT, \""%s %s %s\"","", ""\t\t    \""Can't translate \"", attr, \"" to UTF-8\"");"", ""\t\treturn(ARCHIVE_WARN);"", ""\t} else if (*p != '\\0') {"", ""\t\tadd_pax_attr(&(pax->pax_header),"", ""\t\t    attr, p);"", ""\t\tfree(p);"", ""\t}"", ""\treturn(ARCHIVE_OK);"", ""}"", """", ""/*"", "" * TODO: Consider adding 'comment' and 'charset' fields to"", "" * archive_entry so that clients can specify them.  Also, consider""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[26, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_set_format_pax.c"", ""+"", ""archive_set_error(&a->archive, ENOMEM, \""%s %s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_58_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_58_new.cpp""], [30, ""c206211af647dd1f7039da91c34c9c72e50aefdf"", ""LibArchive 2017-02-19 (100ee75a)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0)."", ""libarchive/archive_write_set_format_pax.c"", ""+"", ""archive_set_error(&a->archive,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_58_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_58_new.cpp""]]",450,491
"[""  if(!do_trace)"", ""    return;"", """", ""  va_start (args, fmt);"", ""  vfprintf (stderr, fmt, args);"", ""  va_end (args);"", ""  va_start(args, fmt);"", ""  vfprintf(stderr, fmt, args);"", ""  va_end(args);"", ""}"", ""#endif"", """"]","[0, 0, 0, -1, -1, -1, 1, 2, 1, 0, 0, 0]","[[7, ""bb72fff2f09ef307b74de35ab00dfc08e6da83ee"", ""Merge topic 'update-curl'\n\nd4da4755 Help: Add notes for topic 'update-curl'\n14c77153 Tests: Fix `file://` URLs given to curl\n73ae6700 curl: Fix passing _WINSOCKAPI_ macro to compiler\n1df9d5f9 Merge branch 'upstream-curl' into update-curl\n4cc2908f curl 2016-12-22 (44b9b4d4)\nf4a3290a curl: Update script to get curl 7.52.1"", ""Utilities/cmcurl/lib/ldap.c"", ""+"", ""vfprintf(stderr, fmt, args);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_59_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_59_new.cpp""]]",694,694
"[""    else {"", ""      CURLcode result;"", ""      ssl_sessionid ="", ""        aprintf(\""%s:%d:%d:%s:%hu\"", data->set.str[STRING_SSL_CAFILE],"", ""                data->set.ssl.verifypeer, data->set.ssl.verifyhost,"", ""                conn->host.name, conn->remote_port);"", ""        aprintf(\""%s:%d:%d:%s:%hu\"", ssl_cafile,"", ""                verifypeer, SSL_CONN_CONFIG(verifyhost), hostname, port);"", ""      ssl_sessionid_len = strlen(ssl_sessionid);"", """", ""      err = SSLSetPeerID(connssl->ssl_ctx, ssl_sessionid, ssl_sessionid_len);""]","[0, 0, 0, -2, -1, -1, 2, 1, 0, 0, 0]","[[3, ""bb72fff2f09ef307b74de35ab00dfc08e6da83ee"", ""Merge topic 'update-curl'\n\nd4da4755 Help: Add notes for topic 'update-curl'\n14c77153 Tests: Fix `file://` URLs given to curl\n73ae6700 curl: Fix passing _WINSOCKAPI_ macro to compiler\n1df9d5f9 Merge branch 'upstream-curl' into update-curl\n4cc2908f curl 2016-12-22 (44b9b4d4)\nf4a3290a curl: Update script to get curl 7.52.1"", ""Utilities/cmcurl/lib/vtls/darwinssl.c"", ""-"", ""aprintf(\""%s:%d:%d:%s:%hu\"", data->set.str[STRING_SSL_CAFILE],"", 0, ""/data/download/CMake/CMake/Kitware_CMake_60_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_60_new.cpp""], [6, ""bb72fff2f09ef307b74de35ab00dfc08e6da83ee"", ""Merge topic 'update-curl'\n\nd4da4755 Help: Add notes for topic 'update-curl'\n14c77153 Tests: Fix `file://` URLs given to curl\n73ae6700 curl: Fix passing _WINSOCKAPI_ macro to compiler\n1df9d5f9 Merge branch 'upstream-curl' into update-curl\n4cc2908f curl 2016-12-22 (44b9b4d4)\nf4a3290a curl: Update script to get curl 7.52.1"", ""Utilities/cmcurl/lib/vtls/darwinssl.c"", ""+"", ""aprintf(\""%s:%d:%d:%s:%hu\"", ssl_cafile,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_60_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_60_new.cpp""]]",1504,1563
"[""  return strdup(*beg? \""TRUE\"": \""FALSE\"");"", ""}"", """", ""static const char * octet2str(const char * beg, const char * end)"", ""static const char *octet2str(const char *beg, const char *end)"", ""{"", ""  size_t n = end - beg;"", ""  char * buf;"", ""  char *buf = NULL;"", """", ""  /* Convert an ASN.1 octet string to a printable string."", ""     Return the dynamically allocated string, or NULL if an error occurs. */"", """", ""  buf = malloc(3 * n + 1);"", ""  if(buf)"", ""    for(n = 0; beg < end; n += 3)"", ""      snprintf(buf + n, 4, \""%02x:\"", *(const unsigned char *) beg++);"", ""  if(n <= (CURL_SIZE_T_MAX - 1) / 3) {"", ""    buf = malloc(3 * n + 1);"", ""    if(buf)"", ""      for(n = 0; beg < end; n += 3)"", ""        snprintf(buf + n, 4, \""%02x:\"", *(const unsigned char *) beg++);"", ""  }"", ""  return buf;"", ""}"", """", ""static const char * bit2str(const char * beg, const char * end)"", ""static const char *bit2str(const char *beg, const char *end)"", ""{"", ""  /* Convert an ASN.1 bit string to a printable string."", ""     Return the dynamically allocated string, or NULL if an error occurs. */""]","[0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, -1, -1, -1, -2, 1, 1, 1, 1, 2, 1, 0, 0, 0, -1, 1, 0, 0, 0]","[[16, ""bb72fff2f09ef307b74de35ab00dfc08e6da83ee"", ""Merge topic 'update-curl'\n\nd4da4755 Help: Add notes for topic 'update-curl'\n14c77153 Tests: Fix `file://` URLs given to curl\n73ae6700 curl: Fix passing _WINSOCKAPI_ macro to compiler\n1df9d5f9 Merge branch 'upstream-curl' into update-curl\n4cc2908f curl 2016-12-22 (44b9b4d4)\nf4a3290a curl: Update script to get curl 7.52.1"", ""Utilities/cmcurl/lib/x509asn1.c"", ""-"", ""snprintf(buf + n, 4, \""%02x:\"", *(const unsigned char *) beg++);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_61_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_61_new.cpp""], [21, ""bb72fff2f09ef307b74de35ab00dfc08e6da83ee"", ""Merge topic 'update-curl'\n\nd4da4755 Help: Add notes for topic 'update-curl'\n14c77153 Tests: Fix `file://` URLs given to curl\n73ae6700 curl: Fix passing _WINSOCKAPI_ macro to compiler\n1df9d5f9 Merge branch 'upstream-curl' into update-curl\n4cc2908f curl 2016-12-22 (44b9b4d4)\nf4a3290a curl: Update script to get curl 7.52.1"", ""Utilities/cmcurl/lib/x509asn1.c"", ""+"", ""snprintf(buf + n, 4, \""%02x:\"", *(const unsigned char *) beg++);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_61_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_61_new.cpp""]]",195,198
"[""  if(!do_trace)"", ""    return;"", """", ""  va_start (args, fmt);"", ""  vfprintf (stderr, fmt, args);"", ""  va_end (args);"", ""  va_start(args, fmt);"", ""  vfprintf(stderr, fmt, args);"", ""  va_end(args);"", ""}"", ""#endif"", """"]","[0, 0, 0, -1, -1, -1, 1, 2, 1, 0, 0, 0]","[[7, ""1df9d5f91944e0b5ba00815d55bb7dc545053b4c"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-12-22 (44b9b4d4)"", ""Utilities/cmcurl/lib/ldap.c"", ""+"", ""vfprintf(stderr, fmt, args);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_62_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_62_new.cpp""]]",694,694
"[""    else {"", ""      CURLcode result;"", ""      ssl_sessionid ="", ""        aprintf(\""%s:%d:%d:%s:%hu\"", data->set.str[STRING_SSL_CAFILE],"", ""                data->set.ssl.verifypeer, data->set.ssl.verifyhost,"", ""                conn->host.name, conn->remote_port);"", ""        aprintf(\""%s:%d:%d:%s:%hu\"", ssl_cafile,"", ""                verifypeer, SSL_CONN_CONFIG(verifyhost), hostname, port);"", ""      ssl_sessionid_len = strlen(ssl_sessionid);"", """", ""      err = SSLSetPeerID(connssl->ssl_ctx, ssl_sessionid, ssl_sessionid_len);""]","[0, 0, 0, -2, -1, -1, 2, 1, 0, 0, 0]","[[3, ""1df9d5f91944e0b5ba00815d55bb7dc545053b4c"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-12-22 (44b9b4d4)"", ""Utilities/cmcurl/lib/vtls/darwinssl.c"", ""-"", ""aprintf(\""%s:%d:%d:%s:%hu\"", data->set.str[STRING_SSL_CAFILE],"", 0, ""/data/download/CMake/CMake/Kitware_CMake_63_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_63_new.cpp""], [6, ""1df9d5f91944e0b5ba00815d55bb7dc545053b4c"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-12-22 (44b9b4d4)"", ""Utilities/cmcurl/lib/vtls/darwinssl.c"", ""+"", ""aprintf(\""%s:%d:%d:%s:%hu\"", ssl_cafile,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_63_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_63_new.cpp""]]",1504,1563
"[""  return strdup(*beg? \""TRUE\"": \""FALSE\"");"", ""}"", """", ""static const char * octet2str(const char * beg, const char * end)"", ""static const char *octet2str(const char *beg, const char *end)"", ""{"", ""  size_t n = end - beg;"", ""  char * buf;"", ""  char *buf = NULL;"", """", ""  /* Convert an ASN.1 octet string to a printable string."", ""     Return the dynamically allocated string, or NULL if an error occurs. */"", """", ""  buf = malloc(3 * n + 1);"", ""  if(buf)"", ""    for(n = 0; beg < end; n += 3)"", ""      snprintf(buf + n, 4, \""%02x:\"", *(const unsigned char *) beg++);"", ""  if(n <= (CURL_SIZE_T_MAX - 1) / 3) {"", ""    buf = malloc(3 * n + 1);"", ""    if(buf)"", ""      for(n = 0; beg < end; n += 3)"", ""        snprintf(buf + n, 4, \""%02x:\"", *(const unsigned char *) beg++);"", ""  }"", ""  return buf;"", ""}"", """", ""static const char * bit2str(const char * beg, const char * end)"", ""static const char *bit2str(const char *beg, const char *end)"", ""{"", ""  /* Convert an ASN.1 bit string to a printable string."", ""     Return the dynamically allocated string, or NULL if an error occurs. */""]","[0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, -1, -1, -1, -2, 1, 1, 1, 1, 2, 1, 0, 0, 0, -1, 1, 0, 0, 0]","[[16, ""1df9d5f91944e0b5ba00815d55bb7dc545053b4c"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-12-22 (44b9b4d4)"", ""Utilities/cmcurl/lib/x509asn1.c"", ""-"", ""snprintf(buf + n, 4, \""%02x:\"", *(const unsigned char *) beg++);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_64_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_64_new.cpp""], [21, ""1df9d5f91944e0b5ba00815d55bb7dc545053b4c"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-12-22 (44b9b4d4)"", ""Utilities/cmcurl/lib/x509asn1.c"", ""+"", ""snprintf(buf + n, 4, \""%02x:\"", *(const unsigned char *) beg++);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_64_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_64_new.cpp""]]",195,198
"[""  if(!do_trace)"", ""    return;"", """", ""  va_start (args, fmt);"", ""  vfprintf (stderr, fmt, args);"", ""  va_end (args);"", ""  va_start(args, fmt);"", ""  vfprintf(stderr, fmt, args);"", ""  va_end(args);"", ""}"", ""#endif"", """"]","[0, 0, 0, -1, -1, -1, 1, 2, 1, 0, 0, 0]","[[7, ""4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab"", ""curl 2016-12-22 (44b9b4d4)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1)."", ""lib/ldap.c"", ""+"", ""vfprintf(stderr, fmt, args);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_65_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_65_new.cpp""]]",694,694
"[""    else {"", ""      CURLcode result;"", ""      ssl_sessionid ="", ""        aprintf(\""%s:%d:%d:%s:%hu\"", data->set.str[STRING_SSL_CAFILE],"", ""                data->set.ssl.verifypeer, data->set.ssl.verifyhost,"", ""                conn->host.name, conn->remote_port);"", ""        aprintf(\""%s:%d:%d:%s:%hu\"", ssl_cafile,"", ""                verifypeer, SSL_CONN_CONFIG(verifyhost), hostname, port);"", ""      ssl_sessionid_len = strlen(ssl_sessionid);"", """", ""      err = SSLSetPeerID(connssl->ssl_ctx, ssl_sessionid, ssl_sessionid_len);""]","[0, 0, 0, -2, -1, -1, 2, 1, 0, 0, 0]","[[3, ""4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab"", ""curl 2016-12-22 (44b9b4d4)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1)."", ""lib/vtls/darwinssl.c"", ""-"", ""aprintf(\""%s:%d:%d:%s:%hu\"", data->set.str[STRING_SSL_CAFILE],"", 0, ""/data/download/CMake/CMake/Kitware_CMake_66_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_66_new.cpp""], [6, ""4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab"", ""curl 2016-12-22 (44b9b4d4)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1)."", ""lib/vtls/darwinssl.c"", ""+"", ""aprintf(\""%s:%d:%d:%s:%hu\"", ssl_cafile,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_66_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_66_new.cpp""]]",1504,1563
"[""  return strdup(*beg? \""TRUE\"": \""FALSE\"");"", ""}"", """", ""static const char * octet2str(const char * beg, const char * end)"", ""static const char *octet2str(const char *beg, const char *end)"", ""{"", ""  size_t n = end - beg;"", ""  char * buf;"", ""  char *buf = NULL;"", """", ""  /* Convert an ASN.1 octet string to a printable string."", ""     Return the dynamically allocated string, or NULL if an error occurs. */"", """", ""  buf = malloc(3 * n + 1);"", ""  if(buf)"", ""    for(n = 0; beg < end; n += 3)"", ""      snprintf(buf + n, 4, \""%02x:\"", *(const unsigned char *) beg++);"", ""  if(n <= (CURL_SIZE_T_MAX - 1) / 3) {"", ""    buf = malloc(3 * n + 1);"", ""    if(buf)"", ""      for(n = 0; beg < end; n += 3)"", ""        snprintf(buf + n, 4, \""%02x:\"", *(const unsigned char *) beg++);"", ""  }"", ""  return buf;"", ""}"", """", ""static const char * bit2str(const char * beg, const char * end)"", ""static const char *bit2str(const char *beg, const char *end)"", ""{"", ""  /* Convert an ASN.1 bit string to a printable string."", ""     Return the dynamically allocated string, or NULL if an error occurs. */""]","[0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, -1, -1, -1, -2, 1, 1, 1, 1, 2, 1, 0, 0, 0, -1, 1, 0, 0, 0]","[[16, ""4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab"", ""curl 2016-12-22 (44b9b4d4)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1)."", ""lib/x509asn1.c"", ""-"", ""snprintf(buf + n, 4, \""%02x:\"", *(const unsigned char *) beg++);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_67_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_67_new.cpp""], [21, ""4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab"", ""curl 2016-12-22 (44b9b4d4)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1)."", ""lib/x509asn1.c"", ""+"", ""snprintf(buf + n, 4, \""%02x:\"", *(const unsigned char *) beg++);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_67_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_67_new.cpp""]]",195,198
"["""", ""/* Amount of stuff to slurp up with each read. */"", ""#ifndef YY_READ_BUF_SIZE"", ""#ifdef __ia64__"", ""/* On IA-64, the buffer size is 16k, not 8k */"", ""#define YY_READ_BUF_SIZE 16384"", ""#else"", ""#define YY_READ_BUF_SIZE 8192"", ""#endif /* __ia64__ */"", ""#endif"", """", ""/* Copy whatever the last rule matched to the standard output. */"", ""#ifndef ECHO"", ""/* This used to be an fputs(), but since the string might contain NUL's,"", "" * we now use fwrite()."", "" */"", ""#define ECHO fwrite( yytext, yyleng, 1, yyout )"", ""#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)"", ""#endif"", """", ""/* Gets input and stuffs it into \""buf\"".  number of characters read, or YY_NULL,"", "" * is returned in \""result\""."", "" */"", ""#ifndef YY_INPUT"", ""#define YY_INPUT(buf,result,max_size) \\"", ""        if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\"", ""                { \\"", ""                int c = '*'; \\"", ""                size_t n; \\"", ""                for ( n = 0; n < max_size && \\"", ""                             (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\"", ""                        buf[n] = (char) c; \\"", ""                if ( c == '\\n' ) \\"", ""                        buf[n++] = (char) c; \\"", ""                if ( c == EOF && ferror( yyin ) ) \\"", ""                        YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""                result = n; \\"", ""                } \\"", ""        else \\"", ""                { \\"", ""                errno=0; \\"", ""                while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\"", ""                        { \\"", ""                        if( errno != EINTR) \\"", ""                                { \\"", ""                                YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""                                break; \\"", ""                                } \\"", ""                        errno=0; \\"", ""                        clearerr(yyin); \\"", ""                        } \\"", ""                }\\"", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\"", ""\t\t{ \\"", ""\t\tint c = '*'; \\"", ""\t\tsize_t n; \\"", ""\t\tfor ( n = 0; n < max_size && \\"", ""\t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\"", ""\t\t\tbuf[n] = (char) c; \\"", ""\t\tif ( c == '\\n' ) \\"", ""\t\t\tbuf[n++] = (char) c; \\"", ""\t\tif ( c == EOF && ferror( yyin ) ) \\"", ""\t\t\tYY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""\t\tresult = n; \\"", ""\t\t} \\"", ""\telse \\"", ""\t\t{ \\"", ""\t\terrno=0; \\"", ""\t\twhile ( (result = (int) fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\"", ""\t\t\t{ \\"", ""\t\t\tif( errno != EINTR) \\"", ""\t\t\t\t{ \\"", ""\t\t\t\tYY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""\t\t\t\tbreak; \\"", ""\t\t\t\t} \\"", ""\t\t\terrno=0; \\"", ""\t\t\tclearerr(yyin); \\"", ""\t\t\t} \\"", ""\t\t}\\"", ""\\"", """", ""#endif""]","[0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[35, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [45, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [62, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [72, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""]]",615,600
"["""", ""/* Code executed at the end of each rule. */"", ""#ifndef YY_BREAK"", ""#define YY_BREAK break;"", ""#define YY_BREAK /*LINTED*/break;"", ""#endif"", """", ""#define YY_RULE_SETUP \\"", ""        YY_USER_ACTION"", ""\tYY_USER_ACTION"", """", ""/** The main scanner function which does all the work."", "" */"", ""YY_DECL"", ""{"", ""        yy_state_type yy_current_state;"", ""        char *yy_cp, *yy_bp;"", ""        int yy_act;"", ""\tyy_state_type yy_current_state;"", ""\tchar *yy_cp, *yy_bp;"", ""\tint yy_act;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""#line 64 \""cmCommandArgumentLexer.in.l\"""", ""\tif ( !yyg->yy_init )"", ""\t\t{"", ""\t\tyyg->yy_init = 1;"", """", ""#ifdef YY_USER_INIT"", ""\t\tYY_USER_INIT;"", ""#endif"", """", ""#line 732 \""cmCommandArgumentLexer.cxx\"""", ""\t\tif ( ! yyg->yy_start )"", ""\t\t\tyyg->yy_start = 1;\t/* first start state */"", """", ""        if ( !yyg->yy_init )"", ""                {"", ""                yyg->yy_init = 1;"", ""\t\tif ( ! yyin )"", ""\t\t\tyyin = stdin;"", """", ""#ifdef YY_USER_INIT"", ""                YY_USER_INIT;"", ""#endif"", ""\t\tif ( ! yyout )"", ""\t\t\tyyout = stdout;"", """", ""                if ( ! yyg->yy_start )"", ""                        yyg->yy_start = 1;      /* first start state */"", ""\t\tif ( ! YY_CURRENT_BUFFER ) {"", ""\t\t\tcmCommandArgument_yyensure_buffer_stack (yyscanner);"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE ="", ""\t\t\t\tcmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);"", ""\t\t}"", """", ""                if ( ! yyin )"", ""                        yyin = stdin;"", ""\t\tcmCommandArgument_yy_load_buffer_state(yyscanner );"", ""\t\t}"", """", ""                if ( ! yyout )"", ""                        yyout = stdout;"", ""\t{"", ""#line 42 \""cmCommandArgumentLexer.in.l\"""", """", ""                if ( ! YY_CURRENT_BUFFER ) {"", ""                        cmCommandArgument_yyensure_buffer_stack (yyscanner);"", ""                        YY_CURRENT_BUFFER_LVALUE ="", ""                                cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);"", ""                }"", """", ""                cmCommandArgument_yy_load_buffer_state(yyscanner );"", ""                }"", ""#line 740 \""cmCommandArgumentLexer.cxx\"""", """", ""        for(;;)             /* loops until end-of-file is reached */"", ""                {"", ""                yy_cp = yyg->yy_c_buf_p;"", ""\twhile ( /*CONSTCOND*/1 )\t\t/* loops until end-of-file is reached */"", ""\t\t{"", ""\t\tyy_cp = yyg->yy_c_buf_p;"", """", ""                /* Support of yytext. */"", ""                *yy_cp = yyg->yy_hold_char;"", ""\t\t/* Support of yytext. */"", ""\t\t*yy_cp = yyg->yy_hold_char;"", """", ""                /* yy_bp points to the position in yy_ch_buf of the start of"", ""                 * the current run."", ""                 */"", ""                yy_bp = yy_cp;"", ""\t\t/* yy_bp points to the position in yy_ch_buf of the start of"", ""\t\t * the current run."", ""\t\t */"", ""\t\tyy_bp = yy_cp;"", """", ""                yy_current_state = yyg->yy_start;"", ""\t\tyy_current_state = yyg->yy_start;"", ""yy_match:"", ""                do"", ""                        {"", ""                        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];"", ""                        if ( yy_accept[yy_current_state] )"", ""                                {"", ""                                yyg->yy_last_accepting_state = yy_current_state;"", ""                                yyg->yy_last_accepting_cpos = yy_cp;"", ""                                }"", ""                        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""                                {"", ""                                yy_current_state = (int) yy_def[yy_current_state];"", ""                                if ( yy_current_state >= 30 )"", ""                                        yy_c = yy_meta[(unsigned int) yy_c];"", ""                                }"", ""                        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""                        ++yy_cp;"", ""                        }"", ""                while ( yy_base[yy_current_state] != 41 );"", ""\t\tdo"", ""\t\t\t{"", ""\t\t\tYY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;"", ""\t\t\tif ( yy_accept[yy_current_state] )"", ""\t\t\t\t{"", ""\t\t\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\t\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t\t\t}"", ""\t\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t\t\t{"", ""\t\t\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\t\t\tif ( yy_current_state >= 30 )"", ""\t\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t\t\t}"", ""\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];"", ""\t\t\t++yy_cp;"", ""\t\t\t}"", ""\t\twhile ( yy_base[yy_current_state] != 41 );"", """", ""yy_find_action:"", ""                yy_act = yy_accept[yy_current_state];"", ""                if ( yy_act == 0 )"", ""                        { /* have to back up */"", ""                        yy_cp = yyg->yy_last_accepting_cpos;"", ""                        yy_current_state = yyg->yy_last_accepting_state;"", ""                        yy_act = yy_accept[yy_current_state];"", ""                        }"", """", ""                YY_DO_BEFORE_ACTION;"", """", ""do_action:      /* This label is used only to access EOF actions. */"", """", ""                switch ( yy_act )"", ""        { /* beginning of action switch */"", ""                        case 0: /* must back up */"", ""                        /* undo the effects of YY_DO_BEFORE_ACTION */"", ""                        *yy_cp = yyg->yy_hold_char;"", ""                        yy_cp = yyg->yy_last_accepting_cpos;"", ""                        yy_current_state = yyg->yy_last_accepting_state;"", ""                        goto yy_find_action;"", ""\t\tyy_act = yy_accept[yy_current_state];"", ""\t\tif ( yy_act == 0 )"", ""\t\t\t{ /* have to back up */"", ""\t\t\tyy_cp = yyg->yy_last_accepting_cpos;"", ""\t\t\tyy_current_state = yyg->yy_last_accepting_state;"", ""\t\t\tyy_act = yy_accept[yy_current_state];"", ""\t\t\t}"", """", ""\t\tYY_DO_BEFORE_ACTION;"", """", ""do_action:\t/* This label is used only to access EOF actions. */"", """", ""\t\tswitch ( yy_act )"", ""\t{ /* beginning of action switch */"", ""\t\t\tcase 0: /* must back up */"", ""\t\t\t/* undo the effects of YY_DO_BEFORE_ACTION */"", ""\t\t\t*yy_cp = yyg->yy_hold_char;"", ""\t\t\tyy_cp = yyg->yy_last_accepting_cpos;"", ""\t\t\tyy_current_state = yyg->yy_last_accepting_state;"", ""\t\t\tgoto yy_find_action;"", """", ""case 1:"", ""YY_RULE_SETUP"", ""#line 66 \""cmCommandArgumentLexer.in.l\"""", ""#line 44 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //std::cerr << __LINE__ << \"" here: [\"" << yytext << \""]\"" << std::endl;"", ""  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);"", ""  return cal_ENVCURLY;"", ""}"", ""\tYY_BREAK"", ""case 2:"", ""YY_RULE_SETUP"", ""#line 72 \""cmCommandArgumentLexer.in.l\"""", ""#line 50 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //std::cerr << __LINE__ << \"" here: [\"" << yytext << \""]\"" << std::endl;"", ""  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);"", ""  return cal_NCURLY;"", ""}"", ""\tYY_BREAK"", ""case 3:"", ""YY_RULE_SETUP"", ""#line 78 \""cmCommandArgumentLexer.in.l\"""", ""#line 56 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //std::cerr << __LINE__ << \"" here: [\"" << yytext << \""]\"" << std::endl;"", ""  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);"", ""  return cal_ATNAME;"", ""}"", ""\tYY_BREAK"", ""case 4:"", ""YY_RULE_SETUP"", ""#line 84 \""cmCommandArgumentLexer.in.l\"""", ""#line 62 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //std::cerr << __LINE__ << \"" here: [\"" << yytext << \""]\"" << std::endl;"", ""  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));"", ""  yylvalp->str = yyextra->DCURLYVariable;"", ""  return cal_DCURLY;"", ""}"", ""\tYY_BREAK"", ""case 5:"", ""YY_RULE_SETUP"", ""#line 91 \""cmCommandArgumentLexer.in.l\"""", ""#line 69 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //std::cerr << __LINE__ << \"" here: [\"" << yytext << \""]\"" << std::endl;"", ""  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));"", ""  yylvalp->str = yyextra->RCURLYVariable;"", ""  return cal_RCURLY;"", ""}"", ""\tYY_BREAK"", ""case 6:"", ""YY_RULE_SETUP"", ""#line 98 \""cmCommandArgumentLexer.in.l\"""", ""#line 76 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //std::cerr << __LINE__ << \"" here: [\"" << yytext << \""]\"" << std::endl;"", ""  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));"", ""  yylvalp->str = yyextra->ATVariable;"", ""  return cal_AT;"", ""}"", ""\tYY_BREAK"", ""case 7:"", ""YY_RULE_SETUP"", ""#line 105 \""cmCommandArgumentLexer.in.l\"""", ""#line 83 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //std::cerr << __LINE__ << \"" here: [\"" << yytext << \""]\"" << std::endl;"", ""  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));"", ""  return cal_NAME;"", ""}"", ""\tYY_BREAK"", ""case 8:"", ""YY_RULE_SETUP"", ""#line 111 \""cmCommandArgumentLexer.in.l\"""", ""#line 89 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytext+1)) )"", ""    {"", ""    return cal_ERROR;"", ""    }"", ""  return cal_SYMBOL;"", ""}"", ""\tYY_BREAK"", ""case 9:"", ""/* rule 9 can match eol */"", ""YY_RULE_SETUP"", ""#line 119 \""cmCommandArgumentLexer.in.l\"""", ""#line 97 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //std::cerr << __LINE__ << \"" here: [\"" << yytext << \""]\"" << std::endl;"", ""  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));"", ""  return cal_SYMBOL;"", ""}"", ""\tYY_BREAK"", ""case 10:"", ""YY_RULE_SETUP"", ""#line 125 \""cmCommandArgumentLexer.in.l\"""", ""#line 103 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));"", ""  yylvalp->str = yyextra->DOLLARVariable;"", ""  return cal_DOLLAR;"", ""}"", ""\tYY_BREAK"", ""case 11:"", ""YY_RULE_SETUP"", ""#line 131 \""cmCommandArgumentLexer.in.l\"""", ""#line 109 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));"", ""  yylvalp->str = yyextra->LCURLYVariable;"", ""  return cal_LCURLY;"", ""}"", ""\tYY_BREAK"", ""case 12:"", ""YY_RULE_SETUP"", ""#line 137 \""cmCommandArgumentLexer.in.l\"""", ""#line 115 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));"", ""  yylvalp->str = yyextra->BSLASHVariable;"", ""  return cal_BSLASH;"", ""}"", ""\tYY_BREAK"", ""case 13:"", ""YY_RULE_SETUP"", ""#line 143 \""cmCommandArgumentLexer.in.l\"""", ""#line 121 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));"", ""  yylvalp->str = yyextra->BSLASHVariable;"", ""  return cal_SYMBOL;"", ""}"", ""\tYY_BREAK"", ""case 14:"", ""YY_RULE_SETUP"", ""#line 149 \""cmCommandArgumentLexer.in.l\"""", ""#line 127 \""cmCommandArgumentLexer.in.l\"""", ""ECHO;"", ""        YY_BREAK"", ""#line 943 \""cmCommandArgumentLexer.cxx\"""", ""\tYY_BREAK"", ""#line 925 \""cmCommandArgumentLexer.cxx\"""", ""case YY_STATE_EOF(INITIAL):"", ""case YY_STATE_EOF(ESCAPES):"", ""case YY_STATE_EOF(NOESCAPES):"", ""        yyterminate();"", """", ""        case YY_END_OF_BUFFER:"", ""                {"", ""                /* Amount of text matched not including the EOB char. */"", ""                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;"", """", ""                /* Undo the effects of YY_DO_BEFORE_ACTION. */"", ""                *yy_cp = yyg->yy_hold_char;"", ""                YY_RESTORE_YY_MORE_OFFSET"", """", ""                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )"", ""                        {"", ""                        /* We're scanning a new file or input source.  It's"", ""                         * possible that this happened because the user"", ""                         * just pointed yyin at a new source and called"", ""                         * cmCommandArgument_yylex().  If so, then we have to assure"", ""                         * consistency between YY_CURRENT_BUFFER and our"", ""                         * globals.  Here is the right place to do so, because"", ""                         * this is the first action (other than possibly a"", ""                         * back-up) that will match for the new input source."", ""                         */"", ""                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;"", ""                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;"", ""                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;"", ""                        }"", """", ""                /* Note that here we test for yy_c_buf_p \""<=\"" to the position"", ""                 * of the first EOB in the buffer, since yy_c_buf_p will"", ""                 * already have been incremented past the NUL character"", ""                 * (since all states make transitions on EOB to the"", ""                 * end-of-buffer state).  Contrast this with the test"", ""                 * in input()."", ""                 */"", ""                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )"", ""                        { /* This was really a NUL. */"", ""                        yy_state_type yy_next_state;"", """", ""                        yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""                        yy_current_state = yy_get_previous_state( yyscanner );"", """", ""                        /* Okay, we're now positioned to make the NUL"", ""                         * transition.  We couldn't have"", ""                         * yy_get_previous_state() go ahead and do it"", ""                         * for us because it doesn't know how to deal"", ""                         * with the possibility of jamming (and we don't"", ""                         * want to build jamming into it because then it"", ""                         * will run more slowly)."", ""                         */"", """", ""                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);"", """", ""                        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""                        if ( yy_next_state )"", ""                                {"", ""                                /* Consume the NUL. */"", ""                                yy_cp = ++yyg->yy_c_buf_p;"", ""                                yy_current_state = yy_next_state;"", ""                                goto yy_match;"", ""                                }"", """", ""                        else"", ""                                {"", ""                                yy_cp = yyg->yy_c_buf_p;"", ""                                goto yy_find_action;"", ""                                }"", ""                        }"", """", ""                else switch ( yy_get_next_buffer( yyscanner ) )"", ""                        {"", ""                        case EOB_ACT_END_OF_FILE:"", ""                                {"", ""                                yyg->yy_did_buffer_switch_on_eof = 0;"", """", ""                                if ( cmCommandArgument_yywrap(yyscanner ) )"", ""                                        {"", ""                                        /* Note: because we've taken care in"", ""                                         * yy_get_next_buffer() to have set up"", ""                                         * yytext, we can now set up"", ""                                         * yy_c_buf_p so that if some total"", ""                                         * hoser (like flex itself) wants to"", ""                                         * call the scanner after we return the"", ""                                         * YY_NULL, it'll still work - another"", ""                                         * YY_NULL will get returned."", ""                                         */"", ""                                        yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""                                        yy_act = YY_STATE_EOF(YY_START);"", ""                                        goto do_action;"", ""                                        }"", """", ""                                else"", ""                                        {"", ""                                        if ( ! yyg->yy_did_buffer_switch_on_eof )"", ""                                                YY_NEW_FILE;"", ""                                        }"", ""                                break;"", ""                                }"", """", ""                        case EOB_ACT_CONTINUE_SCAN:"", ""                                yyg->yy_c_buf_p ="", ""                                        yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""                                yy_current_state = yy_get_previous_state( yyscanner );"", """", ""                                yy_cp = yyg->yy_c_buf_p;"", ""                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""                                goto yy_match;"", """", ""                        case EOB_ACT_LAST_MATCH:"", ""                                yyg->yy_c_buf_p ="", ""                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];"", """", ""                                yy_current_state = yy_get_previous_state( yyscanner );"", """", ""                                yy_cp = yyg->yy_c_buf_p;"", ""                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""                                goto yy_find_action;"", ""                        }"", ""                break;"", ""                }"", """", ""        default:"", ""                YY_FATAL_ERROR("", ""                        \""fatal flex scanner internal error--no action found\"" );"", ""        } /* end of action switch */"", ""                } /* end of scanning one token */"", ""return 0; /* this should not happen but it quiets some compilers */"", ""\tyyterminate();"", """", ""\tcase YY_END_OF_BUFFER:"", ""\t\t{"", ""\t\t/* Amount of text matched not including the EOB char. */"", ""\t\tint yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;"", """", ""\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */"", ""\t\t*yy_cp = yyg->yy_hold_char;"", ""\t\tYY_RESTORE_YY_MORE_OFFSET"", """", ""\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )"", ""\t\t\t{"", ""\t\t\t/* We're scanning a new file or input source.  It's"", ""\t\t\t * possible that this happened because the user"", ""\t\t\t * just pointed yyin at a new source and called"", ""\t\t\t * cmCommandArgument_yylex().  If so, then we have to assure"", ""\t\t\t * consistency between YY_CURRENT_BUFFER and our"", ""\t\t\t * globals.  Here is the right place to do so, because"", ""\t\t\t * this is the first action (other than possibly a"", ""\t\t\t * back-up) that will match for the new input source."", ""\t\t\t */"", ""\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;"", ""\t\t\t}"", """", ""\t\t/* Note that here we test for yy_c_buf_p \""<=\"" to the position"", ""\t\t * of the first EOB in the buffer, since yy_c_buf_p will"", ""\t\t * already have been incremented past the NUL character"", ""\t\t * (since all states make transitions on EOB to the"", ""\t\t * end-of-buffer state).  Contrast this with the test"", ""\t\t * in input()."", ""\t\t */"", ""\t\tif ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )"", ""\t\t\t{ /* This was really a NUL. */"", ""\t\t\tyy_state_type yy_next_state;"", """", ""\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t/* Okay, we're now positioned to make the NUL"", ""\t\t\t * transition.  We couldn't have"", ""\t\t\t * yy_get_previous_state() go ahead and do it"", ""\t\t\t * for us because it doesn't know how to deal"", ""\t\t\t * with the possibility of jamming (and we don't"", ""\t\t\t * want to build jamming into it because then it"", ""\t\t\t * will run more slowly)."", ""\t\t\t */"", """", ""\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);"", """", ""\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""\t\t\tif ( yy_next_state )"", ""\t\t\t\t{"", ""\t\t\t\t/* Consume the NUL. */"", ""\t\t\t\tyy_cp = ++yyg->yy_c_buf_p;"", ""\t\t\t\tyy_current_state = yy_next_state;"", ""\t\t\t\tgoto yy_match;"", ""\t\t\t\t}"", """", ""\t\t\telse"", ""\t\t\t\t{"", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tgoto yy_find_action;"", ""\t\t\t\t}"", ""\t\t\t}"", """", ""\t\telse switch ( yy_get_next_buffer( yyscanner ) )"", ""\t\t\t{"", ""\t\t\tcase EOB_ACT_END_OF_FILE:"", ""\t\t\t\t{"", ""\t\t\t\tyyg->yy_did_buffer_switch_on_eof = 0;"", """", ""\t\t\t\tif ( cmCommandArgument_yywrap(yyscanner ) )"", ""\t\t\t\t\t{"", ""\t\t\t\t\t/* Note: because we've taken care in"", ""\t\t\t\t\t * yy_get_next_buffer() to have set up"", ""\t\t\t\t\t * yytext, we can now set up"", ""\t\t\t\t\t * yy_c_buf_p so that if some total"", ""\t\t\t\t\t * hoser (like flex itself) wants to"", ""\t\t\t\t\t * call the scanner after we return the"", ""\t\t\t\t\t * YY_NULL, it'll still work - another"", ""\t\t\t\t\t * YY_NULL will get returned."", ""\t\t\t\t\t */"", ""\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);"", ""\t\t\t\t\tgoto do_action;"", ""\t\t\t\t\t}"", """", ""\t\t\t\telse"", ""\t\t\t\t\t{"", ""\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )"", ""\t\t\t\t\t\tYY_NEW_FILE;"", ""\t\t\t\t\t}"", ""\t\t\t\tbreak;"", ""\t\t\t\t}"", """", ""\t\t\tcase EOB_ACT_CONTINUE_SCAN:"", ""\t\t\t\tyyg->yy_c_buf_p ="", ""\t\t\t\t\tyyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""\t\t\t\tgoto yy_match;"", """", ""\t\t\tcase EOB_ACT_LAST_MATCH:"", ""\t\t\t\tyyg->yy_c_buf_p ="", ""\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];"", """", ""\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""\t\t\t\tgoto yy_find_action;"", ""\t\t\t}"", ""\t\tbreak;"", ""\t\t}"", """", ""\tdefault:"", ""\t\tYY_FATAL_ERROR("", ""\t\t\t\""fatal flex scanner internal error--no action found\"" );"", ""\t} /* end of action switch */"", ""\t\t} /* end of scanning one token */"", ""\t} /* end of user's declarations */"", ""} /* end of cmCommandArgument_yylex */"", """", ""/* yy_get_next_buffer - try to read in a new buffer"", "" *"", "" * Returns a code representing an action:"", "" *      EOB_ACT_LAST_MATCH -"", "" *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position"", "" *      EOB_ACT_END_OF_FILE - end of file"", "" *\tEOB_ACT_LAST_MATCH -"", "" *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position"", "" *\tEOB_ACT_END_OF_FILE - end of file"", "" */"", ""static int yy_get_next_buffer (yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;"", ""        char *source = yyg->yytext_ptr;"", ""        int number_to_move, i;"", ""        int ret_val;"", """", ""        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )"", ""                YY_FATAL_ERROR("", ""                \""fatal flex scanner internal error--end of buffer missed\"" );"", """", ""        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )"", ""                { /* Don't try to fill the buffer, so this is an EOF. */"", ""                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )"", ""                        {"", ""                        /* We matched a single character, the EOB, so"", ""                         * treat this as a final EOF."", ""                         */"", ""                        return EOB_ACT_END_OF_FILE;"", ""                        }"", """", ""                else"", ""                        {"", ""                        /* We matched some text prior to the EOB, first"", ""                         * process it."", ""                         */"", ""                        return EOB_ACT_LAST_MATCH;"", ""                        }"", ""                }"", """", ""        /* Try to read more data. */"", """", ""        /* First move last chars to start of buffer. */"", ""        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;"", """", ""        for ( i = 0; i < number_to_move; ++i )"", ""                *(dest++) = *(source++);"", """", ""        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )"", ""                /* don't do the read, it's not guaranteed to return an EOF,"", ""                 * just force an EOF"", ""                 */"", ""                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;"", """", ""        else"", ""                {"", ""                        int num_to_read ="", ""                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;"", """", ""                while ( num_to_read <= 0 )"", ""                        { /* Not enough room in the buffer - grow it. */"", """", ""                        /* just a shorter name for the current buffer */"", ""                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;"", """", ""                        int yy_c_buf_p_offset ="", ""                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);"", """", ""                        if ( b->yy_is_our_buffer )"", ""                                {"", ""                                int new_size = b->yy_buf_size * 2;"", """", ""                                if ( new_size <= 0 )"", ""                                        b->yy_buf_size += b->yy_buf_size / 8;"", ""                                else"", ""                                        b->yy_buf_size *= 2;"", """", ""                                b->yy_ch_buf = (char *)"", ""                                        /* Include room in for 2 EOB chars. */"", ""                                        cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );"", ""                                }"", ""                        else"", ""                                /* Can't grow it, we don't own it. */"", ""                                b->yy_ch_buf = 0;"", """", ""                        if ( ! b->yy_ch_buf )"", ""                                YY_FATAL_ERROR("", ""                                \""fatal error - scanner input buffer overflow\"" );"", """", ""                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];"", """", ""                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -"", ""                                                number_to_move - 1;"", """", ""                        }"", """", ""                if ( num_to_read > YY_READ_BUF_SIZE )"", ""                        num_to_read = YY_READ_BUF_SIZE;"", """", ""                /* Read in more data. */"", ""                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),"", ""                        yyg->yy_n_chars, (size_t) num_to_read );"", """", ""                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;"", ""                }"", """", ""        if ( yyg->yy_n_chars == 0 )"", ""                {"", ""                if ( number_to_move == YY_MORE_ADJ )"", ""                        {"", ""                        ret_val = EOB_ACT_END_OF_FILE;"", ""                        cmCommandArgument_yyrestart(yyin  ,yyscanner);"", ""                        }"", """", ""                else"", ""                        {"", ""                        ret_val = EOB_ACT_LAST_MATCH;"", ""                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status ="", ""                                YY_BUFFER_EOF_PENDING;"", ""                        }"", ""                }"", """", ""        else"", ""                ret_val = EOB_ACT_CONTINUE_SCAN;"", """", ""        if ((yy_size_t) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {"", ""                /* Extend the array by 50%, plus the number we really need. */"", ""                yy_size_t new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);"", ""                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );"", ""                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""                        YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", ""        }"", """", ""        yyg->yy_n_chars += number_to_move;"", ""        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;"", ""        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;"", """", ""        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];"", ""\tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;"", ""\tchar *source = yyg->yytext_ptr;"", ""\tyy_size_t number_to_move, i;"", ""\tint ret_val;"", """", ""\tif ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )"", ""\t\tYY_FATAL_ERROR("", ""\t\t\""fatal flex scanner internal error--end of buffer missed\"" );"", """", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )"", ""\t\t{ /* Don't try to fill the buffer, so this is an EOF. */"", ""\t\tif ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )"", ""\t\t\t{"", ""\t\t\t/* We matched a single character, the EOB, so"", ""\t\t\t * treat this as a final EOF."", ""\t\t\t */"", ""\t\t\treturn EOB_ACT_END_OF_FILE;"", ""\t\t\t}"", """", ""\t\telse"", ""\t\t\t{"", ""\t\t\t/* We matched some text prior to the EOB, first"", ""\t\t\t * process it."", ""\t\t\t */"", ""\t\t\treturn EOB_ACT_LAST_MATCH;"", ""\t\t\t}"", ""\t\t}"", """", ""\t/* Try to read more data. */"", """", ""\t/* First move last chars to start of buffer. */"", ""\tnumber_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;"", """", ""\tfor ( i = 0; i < number_to_move; ++i )"", ""\t\t*(dest++) = *(source++);"", """", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )"", ""\t\t/* don't do the read, it's not guaranteed to return an EOF,"", ""\t\t * just force an EOF"", ""\t\t */"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;"", """", ""\telse"", ""\t\t{"", ""\t\t\tint num_to_read ="", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;"", """", ""\t\twhile ( num_to_read <= 0 )"", ""\t\t\t{ /* Not enough room in the buffer - grow it. */"", """", ""\t\t\t/* just a shorter name for the current buffer */"", ""\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;"", """", ""\t\t\tint yy_c_buf_p_offset ="", ""\t\t\t\t(int) (yyg->yy_c_buf_p - b->yy_ch_buf);"", """", ""\t\t\tif ( b->yy_is_our_buffer )"", ""\t\t\t\t{"", ""\t\t\t\tint new_size = b->yy_buf_size * 2;"", """", ""\t\t\t\tif ( new_size <= 0 )"", ""\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;"", ""\t\t\t\telse"", ""\t\t\t\t\tb->yy_buf_size *= 2;"", """", ""\t\t\t\tb->yy_ch_buf = (char *)"", ""\t\t\t\t\t/* Include room in for 2 EOB chars. */"", ""\t\t\t\t\tcmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );"", ""\t\t\t\t}"", ""\t\t\telse"", ""\t\t\t\t/* Can't grow it, we don't own it. */"", ""\t\t\t\tb->yy_ch_buf = NULL;"", """", ""\t\t\tif ( ! b->yy_ch_buf )"", ""\t\t\t\tYY_FATAL_ERROR("", ""\t\t\t\t\""fatal error - scanner input buffer overflow\"" );"", """", ""\t\t\tyyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];"", """", ""\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -"", ""\t\t\t\t\t\tnumber_to_move - 1;"", """", ""\t\t\t}"", """", ""\t\tif ( num_to_read > YY_READ_BUF_SIZE )"", ""\t\t\tnum_to_read = YY_READ_BUF_SIZE;"", """", ""\t\t/* Read in more data. */"", ""\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),"", ""\t\t\tyyg->yy_n_chars, num_to_read );"", """", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;"", ""\t\t}"", """", ""\tif ( yyg->yy_n_chars == 0 )"", ""\t\t{"", ""\t\tif ( number_to_move == YY_MORE_ADJ )"", ""\t\t\t{"", ""\t\t\tret_val = EOB_ACT_END_OF_FILE;"", ""\t\t\tcmCommandArgument_yyrestart(yyin  ,yyscanner);"", ""\t\t\t}"", """", ""\t\telse"", ""\t\t\t{"", ""\t\t\tret_val = EOB_ACT_LAST_MATCH;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status ="", ""\t\t\t\tYY_BUFFER_EOF_PENDING;"", ""\t\t\t}"", ""\t\t}"", """", ""\telse"", ""\t\tret_val = EOB_ACT_CONTINUE_SCAN;"", """", ""\tif ((int) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {"", ""\t\t/* Extend the array by 50%, plus the number we really need. */"", ""\t\tint new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );"", ""\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", ""\t}"", """", ""\tyyg->yy_n_chars += number_to_move;"", ""\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;"", ""\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;"", """", ""\tyyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];"", """", ""        return ret_val;"", ""\treturn ret_val;"", ""}"", """", ""/* yy_get_previous_state - get the state just before the EOB char was reached */"", """", ""    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)"", ""{"", ""        yy_state_type yy_current_state;"", ""        char *yy_cp;"", ""\tyy_state_type yy_current_state;"", ""\tchar *yy_cp;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        yy_current_state = yyg->yy_start;"", """", ""        for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )"", ""                {"", ""                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);"", ""                if ( yy_accept[yy_current_state] )"", ""                        {"", ""                        yyg->yy_last_accepting_state = yy_current_state;"", ""                        yyg->yy_last_accepting_cpos = yy_cp;"", ""                        }"", ""                while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""                        {"", ""                        yy_current_state = (int) yy_def[yy_current_state];"", ""                        if ( yy_current_state >= 30 )"", ""                                yy_c = yy_meta[(unsigned int) yy_c];"", ""                        }"", ""                yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""                }"", """", ""        return yy_current_state;"", ""\tyy_current_state = yyg->yy_start;"", """", ""\tfor ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )"", ""\t\t{"", ""\t\tYY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);"", ""\t\tif ( yy_accept[yy_current_state] )"", ""\t\t\t{"", ""\t\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t\t}"", ""\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t\t{"", ""\t\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\t\tif ( yy_current_state >= 30 )"", ""\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t\t}"", ""\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];"", ""\t\t}"", """", ""\treturn yy_current_state;"", ""}"", """", ""/* yy_try_NUL_trans - try to make a transition on the NUL character"", "" *"", "" * synopsis"", "" *      next_state = yy_try_NUL_trans( current_state );"", "" *\tnext_state = yy_try_NUL_trans( current_state );"", "" */"", ""    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)"", ""{"", ""        int yy_is_jam;"", ""\tint yy_is_jam;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */"", ""        char *yy_cp = yyg->yy_c_buf_p;"", """", ""        YY_CHAR yy_c = 1;"", ""        if ( yy_accept[yy_current_state] )"", ""                {"", ""                yyg->yy_last_accepting_state = yy_current_state;"", ""                yyg->yy_last_accepting_cpos = yy_cp;"", ""                }"", ""        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""                {"", ""                yy_current_state = (int) yy_def[yy_current_state];"", ""                if ( yy_current_state >= 30 )"", ""                        yy_c = yy_meta[(unsigned int) yy_c];"", ""                }"", ""        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""        yy_is_jam = (yy_current_state == 29);"", """", ""        return yy_is_jam ? 0 : yy_current_state;"", ""\tchar *yy_cp = yyg->yy_c_buf_p;"", """", ""\tYY_CHAR yy_c = 1;"", ""\tif ( yy_accept[yy_current_state] )"", ""\t\t{"", ""\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t}"", ""\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t{"", ""\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\tif ( yy_current_state >= 30 )"", ""\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t}"", ""\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];"", ""\tyy_is_jam = (yy_current_state == 29);"", """", ""\t(void)yyg;"", ""\treturn yy_is_jam ? 0 : yy_current_state;"", ""}"", """", ""#ifndef YY_NO_UNPUT"", """", ""#endif"", """", ""#ifndef YY_NO_INPUT"", ""#ifdef __cplusplus"", ""    static int yyinput (yyscan_t yyscanner)""]","[0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, -1, 1, 1, 1, 0, 1, 1, 1, 0, -1, 1, 1, 0, -1, -1, -1, 1, 1, 0, -1, -1, -1, 1, 1, 0, -1, -1, 1, 1, 1, 1, 1, 0, -1, -1, 1, 1, 0, -1, -1, 1, 1, 0, -1, -1, -1, -1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, -1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, -1, -1, 1, 1, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0]","[[452, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [582, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [608, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [676, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [720, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [734, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [802, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [846, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""]]",702,692
"["" */"", ""    YY_BUFFER_STATE cmCommandArgument_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)"", ""{"", ""        YY_BUFFER_STATE b;"", ""\tYY_BUFFER_STATE b;"", """", ""        b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""        if ( ! b )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_create_buffer()\"" );"", ""\tb = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_create_buffer()\"" );"", """", ""        b->yy_buf_size = size;"", ""\tb->yy_buf_size = (yy_size_t)size;"", """", ""        /* yy_ch_buf has to be 2 characters longer than the size given because"", ""         * we need to put in 2 end-of-buffer characters."", ""         */"", ""        b->yy_ch_buf = (char *) cmCommandArgument_yyalloc(b->yy_buf_size + 2 ,yyscanner );"", ""        if ( ! b->yy_ch_buf )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_create_buffer()\"" );"", ""\t/* yy_ch_buf has to be 2 characters longer than the size given because"", ""\t * we need to put in 2 end-of-buffer characters."", ""\t */"", ""\tb->yy_ch_buf = (char *) cmCommandArgument_yyalloc(b->yy_buf_size + 2 ,yyscanner );"", ""\tif ( ! b->yy_ch_buf )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_create_buffer()\"" );"", """", ""        b->yy_is_our_buffer = 1;"", ""\tb->yy_is_our_buffer = 1;"", """", ""        cmCommandArgument_yy_init_buffer(b,file ,yyscanner);"", ""\tcmCommandArgument_yy_init_buffer(b,file ,yyscanner);"", """", ""        return b;"", ""\treturn b;"", ""}"", """", ""/** Destroy the buffer.""]","[0, 0, 0, -1, 1, 0, -1, -1, -2, 1, 1, 2, 0, -1, 1, 0, -1, -1, -1, -1, -1, -2, 1, 1, 1, 1, 1, 2, 0, -1, 1, 0, -1, 1, 0, -1, 1, 0, 0, 0]","[[8, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [11, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [21, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [27, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""]]",1400,1409
"[""void cmCommandArgument_yypop_buffer_state (yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""        if (!YY_CURRENT_BUFFER)"", ""                return;"", """", ""        cmCommandArgument_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);"", ""        YY_CURRENT_BUFFER_LVALUE = NULL;"", ""        if (yyg->yy_buffer_stack_top > 0)"", ""                --yyg->yy_buffer_stack_top;"", """", ""        if (YY_CURRENT_BUFFER) {"", ""                cmCommandArgument_yy_load_buffer_state(yyscanner );"", ""                yyg->yy_did_buffer_switch_on_eof = 1;"", ""        }"", ""\tif (!YY_CURRENT_BUFFER)"", ""\t\treturn;"", """", ""\tcmCommandArgument_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);"", ""\tYY_CURRENT_BUFFER_LVALUE = NULL;"", ""\tif (yyg->yy_buffer_stack_top > 0)"", ""\t\t--yyg->yy_buffer_stack_top;"", """", ""\tif (YY_CURRENT_BUFFER) {"", ""\t\tcmCommandArgument_yy_load_buffer_state(yyscanner );"", ""\t\tyyg->yy_did_buffer_switch_on_eof = 1;"", ""\t}"", ""}"", """", ""/* Allocates the stack if it does not exist."", "" *  Guarantees space for at least one push."", "" */"", ""static void cmCommandArgument_yyensure_buffer_stack (yyscan_t yyscanner)"", ""{"", ""        int num_to_alloc;"", ""\tint num_to_alloc;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        if (!yyg->yy_buffer_stack) {"", ""\tif (!yyg->yy_buffer_stack) {"", """", ""                /* First allocation is just for 2 elements, since we don't know if this"", ""                 * scanner will even need a stack. We use 2 instead of 1 to avoid an"", ""                 * immediate realloc on the next call."", ""\t\t/* First allocation is just for 2 elements, since we don't know if this"", ""\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an"", ""\t\t * immediate realloc on the next call."", ""         */"", ""                num_to_alloc = 1;"", ""                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyalloc"", ""                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)"", ""                                                                , yyscanner);"", ""                if ( ! yyg->yy_buffer_stack )"", ""                        YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()\"" );"", """", ""                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));"", """", ""                yyg->yy_buffer_stack_max = num_to_alloc;"", ""                yyg->yy_buffer_stack_top = 0;"", ""                return;"", ""        }"", """", ""        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){"", """", ""                /* Increase the buffer to prepare for a possible push. */"", ""                int grow_size = 8 /* arbitrary grow size */;"", """", ""                num_to_alloc = yyg->yy_buffer_stack_max + grow_size;"", ""                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyrealloc"", ""                                                                (yyg->yy_buffer_stack,"", ""                                                                num_to_alloc * sizeof(struct yy_buffer_state*)"", ""                                                                , yyscanner);"", ""                if ( ! yyg->yy_buffer_stack )"", ""                        YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()\"" );"", """", ""                /* zero only the new slots.*/"", ""                memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));"", ""                yyg->yy_buffer_stack_max = num_to_alloc;"", ""        }"", ""      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */"", ""\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyalloc"", ""\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)"", ""\t\t\t\t\t\t\t\t, yyscanner);"", ""\t\tif ( ! yyg->yy_buffer_stack )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()\"" );"", """", ""\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));"", """", ""\t\tyyg->yy_buffer_stack_max = num_to_alloc;"", ""\t\tyyg->yy_buffer_stack_top = 0;"", ""\t\treturn;"", ""\t}"", """", ""\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){"", """", ""\t\t/* Increase the buffer to prepare for a possible push. */"", ""\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;"", """", ""\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;"", ""\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyrealloc"", ""\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,"", ""\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)"", ""\t\t\t\t\t\t\t\t, yyscanner);"", ""\t\tif ( ! yyg->yy_buffer_stack )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()\"" );"", """", ""\t\t/* zero only the new slots.*/"", ""\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));"", ""\t\tyyg->yy_buffer_stack_max = num_to_alloc;"", ""\t}"", ""}"", """", ""/** Setup the input buffer state to scan directly from a user-specified character buffer.""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 0, 0]","[[53, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [73, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [84, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [104, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""]]",1543,1548
"["" */"", ""YY_BUFFER_STATE cmCommandArgument_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)"", ""{"", ""        YY_BUFFER_STATE b;"", """", ""        if ( size < 2 ||"", ""             base[size-2] != YY_END_OF_BUFFER_CHAR ||"", ""             base[size-1] != YY_END_OF_BUFFER_CHAR )"", ""                /* They forgot to leave room for the EOB's. */"", ""                return 0;"", """", ""        b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""        if ( ! b )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_scan_buffer()\"" );"", """", ""        b->yy_buf_size = size - 2;      /* \""- 2\"" to take care of EOB's */"", ""        b->yy_buf_pos = b->yy_ch_buf = base;"", ""        b->yy_is_our_buffer = 0;"", ""        b->yy_input_file = 0;"", ""        b->yy_n_chars = b->yy_buf_size;"", ""        b->yy_is_interactive = 0;"", ""        b->yy_at_bol = 1;"", ""        b->yy_fill_buffer = 0;"", ""        b->yy_buffer_status = YY_BUFFER_NEW;"", """", ""        cmCommandArgument_yy_switch_to_buffer(b ,yyscanner );"", """", ""        return b;"", ""\tYY_BUFFER_STATE b;"", """", ""\tif ( size < 2 ||"", ""\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||"", ""\t     base[size-1] != YY_END_OF_BUFFER_CHAR )"", ""\t\t/* They forgot to leave room for the EOB's. */"", ""\t\treturn NULL;"", """", ""\tb = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_scan_buffer()\"" );"", """", ""\tb->yy_buf_size = size - 2;\t/* \""- 2\"" to take care of EOB's */"", ""\tb->yy_buf_pos = b->yy_ch_buf = base;"", ""\tb->yy_is_our_buffer = 0;"", ""\tb->yy_input_file = NULL;"", ""\tb->yy_n_chars = b->yy_buf_size;"", ""\tb->yy_is_interactive = 0;"", ""\tb->yy_at_bol = 1;"", ""\tb->yy_fill_buffer = 0;"", ""\tb->yy_buffer_status = YY_BUFFER_NEW;"", """", ""\tcmCommandArgument_yy_switch_to_buffer(b ,yyscanner );"", """", ""\treturn b;"", ""}"", """", ""/** Setup the input buffer state to scan a string. The next call to cmCommandArgument_yylex() will""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[13, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_scan_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [38, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_scan_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""]]",1612,1617
"[""YY_BUFFER_STATE cmCommandArgument_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)"", ""{"", """", ""        return cmCommandArgument_yy_scan_bytes(yystr,strlen(yystr) ,yyscanner);"", ""\treturn cmCommandArgument_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);"", ""}"", """", ""/** Setup the input buffer state to scan the given bytes. The next call to cmCommandArgument_yylex() will"", "" * scan from a @e copy of @a yybytes."", "" * scan from a @e copy of @a bytes."", "" * @param yybytes the byte buffer to scan"", "" * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes."", "" * @param yyscanner The scanner object."", "" * @return the newly allocated buffer state object."", "" */"", ""YY_BUFFER_STATE cmCommandArgument_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)"", ""{"", ""        YY_BUFFER_STATE b;"", ""        char *buf;"", ""        yy_size_t n;"", ""        int i;"", ""\tYY_BUFFER_STATE b;"", ""\tchar *buf;"", ""\tyy_size_t n;"", ""\tyy_size_t i;"", """", ""        /* Get memory for full buffer, including space for trailing EOB's. */"", ""        n = _yybytes_len + 2;"", ""        buf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );"", ""        if ( ! buf )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_scan_bytes()\"" );"", ""\t/* Get memory for full buffer, including space for trailing EOB's. */"", ""\tn = (yy_size_t) _yybytes_len + 2;"", ""\tbuf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );"", ""\tif ( ! buf )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_scan_bytes()\"" );"", """", ""        for ( i = 0; i < _yybytes_len; ++i )"", ""                buf[i] = yybytes[i];"", ""\tfor ( i = 0; i < (size_t)_yybytes_len; ++i )"", ""\t\tbuf[i] = yybytes[i];"", """", ""        buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;"", ""\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;"", """", ""        b = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);"", ""        if ( ! b )"", ""                YY_FATAL_ERROR( \""bad buffer in cmCommandArgument_yy_scan_bytes()\"" );"", ""\tb = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""bad buffer in cmCommandArgument_yy_scan_bytes()\"" );"", """", ""        /* It's okay to grow etc. this buffer, and we should throw it"", ""         * away when we're done."", ""         */"", ""        b->yy_is_our_buffer = 1;"", ""\t/* It's okay to grow etc. this buffer, and we should throw it"", ""\t * away when we're done."", ""\t */"", ""\tb->yy_is_our_buffer = 1;"", """", ""        return b;"", ""\treturn b;"", ""}"", """", ""#ifndef YY_EXIT_FAILURE"", ""#define YY_EXIT_FAILURE 2"", ""#endif"", """", ""static void yy_fatal_error (yyconst char* msg , yyscan_t)"", ""static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)"", ""{"", ""        (void) fprintf( stderr, \""%s\\n\"", msg );"", ""        exit( YY_EXIT_FAILURE );"", ""\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""\t(void)yyg;"", ""\t(void) fprintf( stderr, \""%s\\n\"", msg );"", ""\texit( YY_EXIT_FAILURE );"", ""}"", """", ""/* Redefine yyless() so it works in section 3 code. */"", """", ""#undef yyless"", ""#define yyless(n) \\"", ""        do \\"", ""                { \\"", ""                /* Undo effects of setting up yytext. */ \\"", ""\tdo \\"", ""\t\t{ \\"", ""\t\t/* Undo effects of setting up yytext. */ \\"", ""        int yyless_macro_arg = (n); \\"", ""        YY_LESS_LINENO(yyless_macro_arg);\\"", ""                yytext[yyleng] = yyg->yy_hold_char; \\"", ""                yyg->yy_c_buf_p = yytext + yyless_macro_arg; \\"", ""                yyg->yy_hold_char = *yyg->yy_c_buf_p; \\"", ""                *yyg->yy_c_buf_p = '\\0'; \\"", ""                yyleng = yyless_macro_arg; \\"", ""                } \\"", ""        while ( 0 )"", ""\t\tyytext[yyleng] = yyg->yy_hold_char; \\"", ""\t\tyyg->yy_c_buf_p = yytext + yyless_macro_arg; \\"", ""\t\tyyg->yy_hold_char = *yyg->yy_c_buf_p; \\"", ""\t\t*yyg->yy_c_buf_p = '\\0'; \\"", ""\t\tyyleng = yyless_macro_arg; \\"", ""\t\t} \\"", ""\twhile ( 0 )"", """", ""/* Accessor  methods (get/set functions) to struct members. */"", """"]","[0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -2, 1, 1, 1, 1, 2, 0, -1, -1, 1, 1, 0, -1, 1, 0, -1, -1, -2, 1, 1, 2, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, -2, -1, 1, 1, 2, 1, 0, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[30, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [35, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [47, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""bad buffer in cmCommandArgument_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [50, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""bad buffer in cmCommandArgument_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [72, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""(void) fprintf( stderr, \""%s\\n\"", msg );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [76, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""(void) fprintf( stderr, \""%s\\n\"", msg );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""]]",1650,1655
"[""}"", """", ""/** Set the current line number."", "" * @param line_number The line number to set."", "" * @param _line_number line number"", "" * @param yyscanner The scanner object."", "" */"", ""void cmCommandArgument_yyset_lineno (int  line_number , yyscan_t yyscanner)"", ""void cmCommandArgument_yyset_lineno (int  _line_number , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        /* lineno is only valid if an input buffer exists. */"", ""        if (! YY_CURRENT_BUFFER )"", ""           yy_fatal_error( \""cmCommandArgument_yyset_lineno called with no buffer\"" , yyscanner);"", ""           YY_FATAL_ERROR( \""cmCommandArgument_yyset_lineno called with no buffer\"" );"", """", ""    yylineno = line_number;"", ""    yylineno = _line_number;"", ""}"", """", ""/** Set the current column."", "" * @param column_no The column number to set."", "" * @param _column_no column number"", "" * @param yyscanner The scanner object."", "" */"", ""void cmCommandArgument_yyset_column (int  column_no , yyscan_t yyscanner)"", ""void cmCommandArgument_yyset_column (int  _column_no , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        /* column is only valid if an input buffer exists. */"", ""        if (! YY_CURRENT_BUFFER )"", ""           yy_fatal_error( \""cmCommandArgument_yyset_column called with no buffer\"" , yyscanner);"", ""           YY_FATAL_ERROR( \""cmCommandArgument_yyset_column called with no buffer\"" );"", """", ""    yycolumn = column_no;"", ""    yycolumn = _column_no;"", ""}"", """", ""/** Set the input stream. This does not discard the current"", "" * input buffer."", "" * @param in_str A readable stream."", "" * @param _in_str A readable stream."", "" * @param yyscanner The scanner object."", "" * @see cmCommandArgument_yy_switch_to_buffer"", "" */"", ""void cmCommandArgument_yyset_in (FILE *  in_str , yyscan_t yyscanner)"", ""void cmCommandArgument_yyset_in (FILE *  _in_str , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""    yyin = in_str ;"", ""    yyin = _in_str ;"", ""}"", """", ""void cmCommandArgument_yyset_out (FILE *  out_str , yyscan_t yyscanner)"", ""void cmCommandArgument_yyset_out (FILE *  _out_str , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""    yyout = out_str ;"", ""    yyout = _out_str ;"", ""}"", """", ""int cmCommandArgument_yyget_debug  (yyscan_t yyscanner)""]","[0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, -2, 2, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, -2, 2, 0, -1, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0]","[[14, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""yy_fatal_error( \""cmCommandArgument_yyset_lineno called with no buffer\"" , yyscanner);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [15, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""cmCommandArgument_yyset_lineno called with no buffer\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [33, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""yy_fatal_error( \""cmCommandArgument_yyset_column called with no buffer\"" , yyscanner);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""], [34, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""cmCommandArgument_yyset_column called with no buffer\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_68_new.cpp""]]",1802,1809
"["""", ""/* Amount of stuff to slurp up with each read. */"", ""#ifndef YY_READ_BUF_SIZE"", ""#ifdef __ia64__"", ""/* On IA-64, the buffer size is 16k, not 8k */"", ""#define YY_READ_BUF_SIZE 16384"", ""#else"", ""#define YY_READ_BUF_SIZE 8192"", ""#endif /* __ia64__ */"", ""#endif"", """", ""/* Copy whatever the last rule matched to the standard output. */"", ""#ifndef ECHO"", ""/* This used to be an fputs(), but since the string might contain NUL's,"", "" * we now use fwrite()."", "" */"", ""#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )"", ""#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)"", ""#endif"", """", ""/* Gets input and stuffs it into \""buf\"".  number of characters read, or YY_NULL,"", "" * is returned in \""result\""."", "" */"", ""#ifndef YY_INPUT"", ""#define YY_INPUT(buf,result,max_size) \\"", ""  if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\"", ""    { \\"", ""    int c = '*'; \\"", ""    size_t n; \\"", ""    for ( n = 0; n < max_size && \\"", ""           (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\"", ""      buf[n] = (char) c; \\"", ""    if ( c == '\\n' ) \\"", ""      buf[n++] = (char) c; \\"", ""    if ( c == EOF && ferror( yyin ) ) \\"", ""      YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""    result = n; \\"", ""    } \\"", ""  else \\"", ""    { \\"", ""    errno=0; \\"", ""    while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\"", ""      { \\"", ""      if( errno != EINTR) \\"", ""        { \\"", ""        YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""        break; \\"", ""        } \\"", ""      errno=0; \\"", ""      clearerr(yyin); \\"", ""      } \\"", ""    }\\"", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\"", ""\t\t{ \\"", ""\t\tint c = '*'; \\"", ""\t\tsize_t n; \\"", ""\t\tfor ( n = 0; n < max_size && \\"", ""\t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\"", ""\t\t\tbuf[n] = (char) c; \\"", ""\t\tif ( c == '\\n' ) \\"", ""\t\t\tbuf[n++] = (char) c; \\"", ""\t\tif ( c == EOF && ferror( yyin ) ) \\"", ""\t\t\tYY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""\t\tresult = n; \\"", ""\t\t} \\"", ""\telse \\"", ""\t\t{ \\"", ""\t\terrno=0; \\"", ""\t\twhile ( (result = (int) fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\"", ""\t\t\t{ \\"", ""\t\t\tif( errno != EINTR) \\"", ""\t\t\t\t{ \\"", ""\t\t\t\tYY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""\t\t\t\tbreak; \\"", ""\t\t\t\t} \\"", ""\t\t\terrno=0; \\"", ""\t\t\tclearerr(yyin); \\"", ""\t\t\t} \\"", ""\t\t}\\"", ""\\"", """", ""#endif""]","[0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[35, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [45, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [62, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [72, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""]]",589,592
"["""", ""/* Code executed at the end of each rule. */"", ""#ifndef YY_BREAK"", ""#define YY_BREAK break;"", ""#define YY_BREAK /*LINTED*/break;"", ""#endif"", """", ""#define YY_RULE_SETUP \\"", ""  YY_USER_ACTION"", ""\tYY_USER_ACTION"", """", ""/** The main scanner function which does all the work."", "" */"", ""YY_DECL"", ""{"", ""  yy_state_type yy_current_state;"", ""  char *yy_cp, *yy_bp;"", ""  int yy_act;"", ""\tyy_state_type yy_current_state;"", ""\tchar *yy_cp, *yy_bp;"", ""\tint yy_act;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""#line 86 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""\tif ( !yyg->yy_init )"", ""\t\t{"", ""\t\tyyg->yy_init = 1;"", """", ""#ifdef YY_USER_INIT"", ""\t\tYY_USER_INIT;"", ""#endif"", """", ""#line 736 \""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx\"""", ""\t\tif ( ! yyg->yy_start )"", ""\t\t\tyyg->yy_start = 1;\t/* first start state */"", """", ""  if ( yyg->yy_init )"", ""    {"", ""    yyg->yy_init = 0;"", ""\t\tif ( ! yyin )"", ""\t\t\tyyin = stdin;"", """", ""#ifdef YY_USER_INIT"", ""    YY_USER_INIT;"", ""#endif"", ""\t\tif ( ! yyout )"", ""\t\t\tyyout = stdout;"", """", ""    if ( ! yyg->yy_start )"", ""      yyg->yy_start = 1;  /* first start state */"", ""\t\tif ( ! YY_CURRENT_BUFFER ) {"", ""\t\t\tcmExpr_yyensure_buffer_stack (yyscanner);"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE ="", ""\t\t\t\tcmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);"", ""\t\t}"", """", ""    if ( ! yyin )"", ""      yyin = stdin;"", ""\t\tcmExpr_yy_load_buffer_state(yyscanner );"", ""\t\t}"", """", ""    if ( ! yyout )"", ""      yyout = stdout;"", ""\t{"", ""#line 39 \""cmExprLexer.in.l\"""", """", ""    if ( ! YY_CURRENT_BUFFER ) {"", ""      cmExpr_yyensure_buffer_stack (yyscanner);"", ""      YY_CURRENT_BUFFER_LVALUE ="", ""        cmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);"", ""    }"", """", ""    cmExpr_yy_load_buffer_state(yyscanner );"", ""    }"", ""#line 732 \""cmExprLexer.cxx\"""", """", ""  for(;;)    /* loops until end-of-file is reached */"", ""    {"", ""    yy_cp = yyg->yy_c_buf_p;"", ""\twhile ( /*CONSTCOND*/1 )\t\t/* loops until end-of-file is reached */"", ""\t\t{"", ""\t\tyy_cp = yyg->yy_c_buf_p;"", """", ""    /* Support of yytext. */"", ""    *yy_cp = yyg->yy_hold_char;"", ""\t\t/* Support of yytext. */"", ""\t\t*yy_cp = yyg->yy_hold_char;"", """", ""    /* yy_bp points to the position in yy_ch_buf of the start of"", ""     * the current run."", ""     */"", ""    yy_bp = yy_cp;"", ""\t\t/* yy_bp points to the position in yy_ch_buf of the start of"", ""\t\t * the current run."", ""\t\t */"", ""\t\tyy_bp = yy_cp;"", """", ""    yy_current_state = yyg->yy_start;"", ""\t\tyy_current_state = yyg->yy_start;"", ""yy_match:"", ""    do"", ""      {"", ""      YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];"", ""      if ( yy_accept[yy_current_state] )"", ""        {"", ""        yyg->yy_last_accepting_state = yy_current_state;"", ""        yyg->yy_last_accepting_cpos = yy_cp;"", ""        }"", ""      while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""        {"", ""        yy_current_state = (int) yy_def[yy_current_state];"", ""        if ( yy_current_state >= 23 )"", ""          yy_c = yy_meta[(unsigned int) yy_c];"", ""        }"", ""      yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""      ++yy_cp;"", ""      }"", ""    while ( yy_base[yy_current_state] != 21 );"", ""\t\tdo"", ""\t\t\t{"", ""\t\t\tYY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;"", ""\t\t\tif ( yy_accept[yy_current_state] )"", ""\t\t\t\t{"", ""\t\t\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\t\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t\t\t}"", ""\t\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t\t\t{"", ""\t\t\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\t\t\tif ( yy_current_state >= 23 )"", ""\t\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t\t\t}"", ""\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];"", ""\t\t\t++yy_cp;"", ""\t\t\t}"", ""\t\twhile ( yy_base[yy_current_state] != 21 );"", """", ""yy_find_action:"", ""    yy_act = yy_accept[yy_current_state];"", ""    if ( yy_act == 0 )"", ""      { /* have to back up */"", ""      yy_cp = yyg->yy_last_accepting_cpos;"", ""      yy_current_state = yyg->yy_last_accepting_state;"", ""      yy_act = yy_accept[yy_current_state];"", ""      }"", """", ""    YY_DO_BEFORE_ACTION;"", """", ""do_action:  /* This label is used only to access EOF actions. */"", """", ""    switch ( yy_act )"", ""  { /* beginning of action switch */"", ""      case 0: /* must back up */"", ""      /* undo the effects of YY_DO_BEFORE_ACTION */"", ""      *yy_cp = yyg->yy_hold_char;"", ""      yy_cp = yyg->yy_last_accepting_cpos;"", ""      yy_current_state = yyg->yy_last_accepting_state;"", ""      goto yy_find_action;"", ""\t\tyy_act = yy_accept[yy_current_state];"", ""\t\tif ( yy_act == 0 )"", ""\t\t\t{ /* have to back up */"", ""\t\t\tyy_cp = yyg->yy_last_accepting_cpos;"", ""\t\t\tyy_current_state = yyg->yy_last_accepting_state;"", ""\t\t\tyy_act = yy_accept[yy_current_state];"", ""\t\t\t}"", """", ""\t\tYY_DO_BEFORE_ACTION;"", """", ""do_action:\t/* This label is used only to access EOF actions. */"", """", ""\t\tswitch ( yy_act )"", ""\t{ /* beginning of action switch */"", ""\t\t\tcase 0: /* must back up */"", ""\t\t\t/* undo the effects of YY_DO_BEFORE_ACTION */"", ""\t\t\t*yy_cp = yyg->yy_hold_char;"", ""\t\t\tyy_cp = yyg->yy_last_accepting_cpos;"", ""\t\t\tyy_current_state = yyg->yy_last_accepting_state;"", ""\t\t\tgoto yy_find_action;"", """", ""case 1:"", ""YY_RULE_SETUP"", ""#line 88 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 41 \""cmExprLexer.in.l\"""", ""{ yylvalp->Number = atoi(yytext); return exp_NUMBER; }"", ""\tYY_BREAK"", ""case 2:"", ""YY_RULE_SETUP"", ""#line 90 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 43 \""cmExprLexer.in.l\"""", ""{ return exp_PLUS; }"", ""\tYY_BREAK"", ""case 3:"", ""YY_RULE_SETUP"", ""#line 91 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 44 \""cmExprLexer.in.l\"""", ""{ return exp_MINUS; }"", ""\tYY_BREAK"", ""case 4:"", ""YY_RULE_SETUP"", ""#line 92 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 45 \""cmExprLexer.in.l\"""", ""{ return exp_TIMES; }"", ""\tYY_BREAK"", ""case 5:"", ""YY_RULE_SETUP"", ""#line 93 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 46 \""cmExprLexer.in.l\"""", ""{ return exp_DIVIDE; }"", ""\tYY_BREAK"", ""case 6:"", ""YY_RULE_SETUP"", ""#line 94 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 47 \""cmExprLexer.in.l\"""", ""{ return exp_MOD; }"", ""\tYY_BREAK"", ""case 7:"", ""YY_RULE_SETUP"", ""#line 95 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 48 \""cmExprLexer.in.l\"""", ""{ return exp_OR; }"", ""\tYY_BREAK"", ""case 8:"", ""YY_RULE_SETUP"", ""#line 96 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 49 \""cmExprLexer.in.l\"""", ""{ return exp_AND; }"", ""\tYY_BREAK"", ""case 9:"", ""YY_RULE_SETUP"", ""#line 97 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 50 \""cmExprLexer.in.l\"""", ""{ return exp_XOR; }"", ""\tYY_BREAK"", ""case 10:"", ""YY_RULE_SETUP"", ""#line 98 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 51 \""cmExprLexer.in.l\"""", ""{ return exp_NOT; }"", ""\tYY_BREAK"", ""case 11:"", ""YY_RULE_SETUP"", ""#line 99 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 52 \""cmExprLexer.in.l\"""", ""{ return exp_SHIFTLEFT; }"", ""\tYY_BREAK"", ""case 12:"", ""YY_RULE_SETUP"", ""#line 100 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 53 \""cmExprLexer.in.l\"""", ""{ return exp_SHIFTRIGHT; }"", ""\tYY_BREAK"", ""case 13:"", ""YY_RULE_SETUP"", ""#line 101 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 54 \""cmExprLexer.in.l\"""", ""{ return exp_OPENPARENT; }"", ""\tYY_BREAK"", ""case 14:"", ""YY_RULE_SETUP"", ""#line 102 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 55 \""cmExprLexer.in.l\"""", ""{ return exp_CLOSEPARENT; }"", ""\tYY_BREAK"", ""case 15:"", ""YY_RULE_SETUP"", ""#line 104 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 57 \""cmExprLexer.in.l\"""", ""ECHO;"", ""  YY_BREAK"", ""#line 894 \""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx\"""", ""\tYY_BREAK"", ""#line 864 \""cmExprLexer.cxx\"""", ""case YY_STATE_EOF(INITIAL):"", ""  yyterminate();"", """", ""  case YY_END_OF_BUFFER:"", ""    {"", ""    /* Amount of text matched not including the EOB char. */"", ""    int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;"", """", ""    /* Undo the effects of YY_DO_BEFORE_ACTION. */"", ""    *yy_cp = yyg->yy_hold_char;"", ""    YY_RESTORE_YY_MORE_OFFSET"", """", ""    if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )"", ""      {"", ""      /* We're scanning a new file or input source.  It's"", ""       * possible that this happened because the user"", ""       * just pointed yyin at a new source and called"", ""       * cmExpr_yylex().  If so, then we have to assure"", ""       * consistency between YY_CURRENT_BUFFER and our"", ""       * globals.  Here is the right place to do so, because"", ""       * this is the first action (other than possibly a"", ""       * back-up) that will match for the new input source."", ""       */"", ""      yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;"", ""      YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;"", ""      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;"", ""      }"", """", ""    /* Note that here we test for yy_c_buf_p \""<=\"" to the position"", ""     * of the first EOB in the buffer, since yy_c_buf_p will"", ""     * already have been incremented past the NUL character"", ""     * (since all states make transitions on EOB to the"", ""     * end-of-buffer state).  Contrast this with the test"", ""     * in input()."", ""     */"", ""    if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )"", ""      { /* This was really a NUL. */"", ""      yy_state_type yy_next_state;"", """", ""      yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""      yy_current_state = yy_get_previous_state( yyscanner );"", """", ""      /* Okay, we're now positioned to make the NUL"", ""       * transition.  We couldn't have"", ""       * yy_get_previous_state() go ahead and do it"", ""       * for us because it doesn't know how to deal"", ""       * with the possibility of jamming (and we don't"", ""       * want to build jamming into it because then it"", ""       * will run more slowly)."", ""       */"", """", ""      yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);"", """", ""      yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""      if ( yy_next_state )"", ""        {"", ""        /* Consume the NUL. */"", ""        yy_cp = ++yyg->yy_c_buf_p;"", ""        yy_current_state = yy_next_state;"", ""        goto yy_match;"", ""        }"", """", ""      else"", ""        {"", ""        yy_cp = yyg->yy_c_buf_p;"", ""        goto yy_find_action;"", ""        }"", ""      }"", """", ""    else switch ( yy_get_next_buffer( yyscanner ) )"", ""      {"", ""      case EOB_ACT_END_OF_FILE:"", ""        {"", ""        yyg->yy_did_buffer_switch_on_eof = 0;"", """", ""        if ( cmExpr_yywrap(yyscanner ) )"", ""          {"", ""          /* Note: because we've taken care in"", ""           * yy_get_next_buffer() to have set up"", ""           * yytext, we can now set up"", ""           * yy_c_buf_p so that if some total"", ""           * hoser (like flex itself) wants to"", ""           * call the scanner after we return the"", ""           * YY_NULL, it'll still work - another"", ""           * YY_NULL will get returned."", ""           */"", ""          yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""          yy_act = YY_STATE_EOF(YY_START);"", ""          goto do_action;"", ""          }"", """", ""        else"", ""          {"", ""          if ( ! yyg->yy_did_buffer_switch_on_eof )"", ""            YY_NEW_FILE;"", ""          }"", ""        break;"", ""        }"", """", ""      case EOB_ACT_CONTINUE_SCAN:"", ""        yyg->yy_c_buf_p ="", ""          yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""        yy_current_state = yy_get_previous_state( yyscanner );"", """", ""        yy_cp = yyg->yy_c_buf_p;"", ""        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""        goto yy_match;"", """", ""      case EOB_ACT_LAST_MATCH:"", ""        yyg->yy_c_buf_p ="", ""        &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];"", """", ""        yy_current_state = yy_get_previous_state( yyscanner );"", """", ""        yy_cp = yyg->yy_c_buf_p;"", ""        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""        goto yy_find_action;"", ""      }"", ""    break;"", ""    }"", """", ""  default:"", ""    YY_FATAL_ERROR("", ""      \""fatal flex scanner internal error--no action found\"" );"", ""  } /* end of action switch */"", ""    } /* end of scanning one token */"", ""return 0; /* this should not happen but it quiets some compilers */"", ""\tyyterminate();"", """", ""\tcase YY_END_OF_BUFFER:"", ""\t\t{"", ""\t\t/* Amount of text matched not including the EOB char. */"", ""\t\tint yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;"", """", ""\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */"", ""\t\t*yy_cp = yyg->yy_hold_char;"", ""\t\tYY_RESTORE_YY_MORE_OFFSET"", """", ""\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )"", ""\t\t\t{"", ""\t\t\t/* We're scanning a new file or input source.  It's"", ""\t\t\t * possible that this happened because the user"", ""\t\t\t * just pointed yyin at a new source and called"", ""\t\t\t * cmExpr_yylex().  If so, then we have to assure"", ""\t\t\t * consistency between YY_CURRENT_BUFFER and our"", ""\t\t\t * globals.  Here is the right place to do so, because"", ""\t\t\t * this is the first action (other than possibly a"", ""\t\t\t * back-up) that will match for the new input source."", ""\t\t\t */"", ""\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;"", ""\t\t\t}"", """", ""\t\t/* Note that here we test for yy_c_buf_p \""<=\"" to the position"", ""\t\t * of the first EOB in the buffer, since yy_c_buf_p will"", ""\t\t * already have been incremented past the NUL character"", ""\t\t * (since all states make transitions on EOB to the"", ""\t\t * end-of-buffer state).  Contrast this with the test"", ""\t\t * in input()."", ""\t\t */"", ""\t\tif ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )"", ""\t\t\t{ /* This was really a NUL. */"", ""\t\t\tyy_state_type yy_next_state;"", """", ""\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t/* Okay, we're now positioned to make the NUL"", ""\t\t\t * transition.  We couldn't have"", ""\t\t\t * yy_get_previous_state() go ahead and do it"", ""\t\t\t * for us because it doesn't know how to deal"", ""\t\t\t * with the possibility of jamming (and we don't"", ""\t\t\t * want to build jamming into it because then it"", ""\t\t\t * will run more slowly)."", ""\t\t\t */"", """", ""\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);"", """", ""\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""\t\t\tif ( yy_next_state )"", ""\t\t\t\t{"", ""\t\t\t\t/* Consume the NUL. */"", ""\t\t\t\tyy_cp = ++yyg->yy_c_buf_p;"", ""\t\t\t\tyy_current_state = yy_next_state;"", ""\t\t\t\tgoto yy_match;"", ""\t\t\t\t}"", """", ""\t\t\telse"", ""\t\t\t\t{"", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tgoto yy_find_action;"", ""\t\t\t\t}"", ""\t\t\t}"", """", ""\t\telse switch ( yy_get_next_buffer( yyscanner ) )"", ""\t\t\t{"", ""\t\t\tcase EOB_ACT_END_OF_FILE:"", ""\t\t\t\t{"", ""\t\t\t\tyyg->yy_did_buffer_switch_on_eof = 0;"", """", ""\t\t\t\tif ( cmExpr_yywrap(yyscanner ) )"", ""\t\t\t\t\t{"", ""\t\t\t\t\t/* Note: because we've taken care in"", ""\t\t\t\t\t * yy_get_next_buffer() to have set up"", ""\t\t\t\t\t * yytext, we can now set up"", ""\t\t\t\t\t * yy_c_buf_p so that if some total"", ""\t\t\t\t\t * hoser (like flex itself) wants to"", ""\t\t\t\t\t * call the scanner after we return the"", ""\t\t\t\t\t * YY_NULL, it'll still work - another"", ""\t\t\t\t\t * YY_NULL will get returned."", ""\t\t\t\t\t */"", ""\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);"", ""\t\t\t\t\tgoto do_action;"", ""\t\t\t\t\t}"", """", ""\t\t\t\telse"", ""\t\t\t\t\t{"", ""\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )"", ""\t\t\t\t\t\tYY_NEW_FILE;"", ""\t\t\t\t\t}"", ""\t\t\t\tbreak;"", ""\t\t\t\t}"", """", ""\t\t\tcase EOB_ACT_CONTINUE_SCAN:"", ""\t\t\t\tyyg->yy_c_buf_p ="", ""\t\t\t\t\tyyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""\t\t\t\tgoto yy_match;"", """", ""\t\t\tcase EOB_ACT_LAST_MATCH:"", ""\t\t\t\tyyg->yy_c_buf_p ="", ""\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];"", """", ""\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""\t\t\t\tgoto yy_find_action;"", ""\t\t\t}"", ""\t\tbreak;"", ""\t\t}"", """", ""\tdefault:"", ""\t\tYY_FATAL_ERROR("", ""\t\t\t\""fatal flex scanner internal error--no action found\"" );"", ""\t} /* end of action switch */"", ""\t\t} /* end of scanning one token */"", ""\t} /* end of user's declarations */"", ""} /* end of cmExpr_yylex */"", """", ""/* yy_get_next_buffer - try to read in a new buffer"", "" *"", "" * Returns a code representing an action:"", "" *  EOB_ACT_LAST_MATCH -"", "" *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position"", "" *  EOB_ACT_END_OF_FILE - end of file"", "" *\tEOB_ACT_LAST_MATCH -"", "" *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position"", "" *\tEOB_ACT_END_OF_FILE - end of file"", "" */"", ""static int yy_get_next_buffer (yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""  char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;"", ""  char *source = yyg->yytext_ptr;"", ""  int number_to_move, i;"", ""  int ret_val;"", """", ""  if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )"", ""    YY_FATAL_ERROR("", ""    \""fatal flex scanner internal error--end of buffer missed\"" );"", """", ""  if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )"", ""    { /* Don't try to fill the buffer, so this is an EOF. */"", ""    if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )"", ""      {"", ""      /* We matched a single character, the EOB, so"", ""       * treat this as a final EOF."", ""       */"", ""      return EOB_ACT_END_OF_FILE;"", ""      }"", """", ""    else"", ""      {"", ""      /* We matched some text prior to the EOB, first"", ""       * process it."", ""       */"", ""      return EOB_ACT_LAST_MATCH;"", ""      }"", ""    }"", """", ""  /* Try to read more data. */"", """", ""  /* First move last chars to start of buffer. */"", ""  number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;"", """", ""  for ( i = 0; i < number_to_move; ++i )"", ""    *(dest++) = *(source++);"", """", ""  if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )"", ""    /* don't do the read, it's not guaranteed to return an EOF,"", ""     * just force an EOF"", ""     */"", ""    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;"", """", ""  else"", ""    {"", ""      size_t nuto_read ="", ""      YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;"", """", ""    while ( nuto_read <= 0 )"", ""      { /* Not enough room in the buffer - grow it. */"", """", ""      /* just a shorter name for the current buffer */"", ""      YY_BUFFER_STATE b = YY_CURRENT_BUFFER;"", """", ""      int yy_c_buf_p_offset ="", ""        (int) (yyg->yy_c_buf_p - b->yy_ch_buf);"", """", ""      if ( b->yy_is_our_buffer )"", ""        {"", ""        int new_size = b->yy_buf_size * 2;"", """", ""        if ( new_size <= 0 )"", ""          b->yy_buf_size += b->yy_buf_size / 8;"", ""        else"", ""          b->yy_buf_size *= 2;"", """", ""        b->yy_ch_buf = (char *)"", ""          /* Include room in for 2 EOB chars. */"", ""          cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );"", ""        }"", ""      else"", ""        /* Can't grow it, we don't own it. */"", ""        b->yy_ch_buf = 0;"", """", ""      if ( ! b->yy_ch_buf )"", ""        YY_FATAL_ERROR("", ""        \""fatal error - scanner input buffer overflow\"" );"", """", ""      yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];"", """", ""      nuto_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -"", ""            number_to_move - 1;"", """", ""      }"", """", ""    if ( nuto_read > YY_READ_BUF_SIZE )"", ""      nuto_read = YY_READ_BUF_SIZE;"", """", ""    /* Read in more data. */"", ""    YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),"", ""      yyg->yy_n_chars, nuto_read );"", """", ""    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;"", ""    }"", ""\tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;"", ""\tchar *source = yyg->yytext_ptr;"", ""\tyy_size_t number_to_move, i;"", ""\tint ret_val;"", """", ""\tif ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )"", ""\t\tYY_FATAL_ERROR("", ""\t\t\""fatal flex scanner internal error--end of buffer missed\"" );"", """", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )"", ""\t\t{ /* Don't try to fill the buffer, so this is an EOF. */"", ""\t\tif ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )"", ""\t\t\t{"", ""\t\t\t/* We matched a single character, the EOB, so"", ""\t\t\t * treat this as a final EOF."", ""\t\t\t */"", ""\t\t\treturn EOB_ACT_END_OF_FILE;"", ""\t\t\t}"", """", ""\t\telse"", ""\t\t\t{"", ""\t\t\t/* We matched some text prior to the EOB, first"", ""\t\t\t * process it."", ""\t\t\t */"", ""\t\t\treturn EOB_ACT_LAST_MATCH;"", ""\t\t\t}"", ""\t\t}"", """", ""\t/* Try to read more data. */"", """", ""\t/* First move last chars to start of buffer. */"", ""\tnumber_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;"", """", ""\tfor ( i = 0; i < number_to_move; ++i )"", ""\t\t*(dest++) = *(source++);"", """", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )"", ""\t\t/* don't do the read, it's not guaranteed to return an EOF,"", ""\t\t * just force an EOF"", ""\t\t */"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;"", """", ""\telse"", ""\t\t{"", ""\t\t\tint num_to_read ="", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;"", """", ""\t\twhile ( num_to_read <= 0 )"", ""\t\t\t{ /* Not enough room in the buffer - grow it. */"", """", ""\t\t\t/* just a shorter name for the current buffer */"", ""\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;"", """", ""\t\t\tint yy_c_buf_p_offset ="", ""\t\t\t\t(int) (yyg->yy_c_buf_p - b->yy_ch_buf);"", """", ""\t\t\tif ( b->yy_is_our_buffer )"", ""\t\t\t\t{"", ""\t\t\t\tint new_size = b->yy_buf_size * 2;"", """", ""\t\t\t\tif ( new_size <= 0 )"", ""\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;"", ""\t\t\t\telse"", ""\t\t\t\t\tb->yy_buf_size *= 2;"", """", ""\t\t\t\tb->yy_ch_buf = (char *)"", ""\t\t\t\t\t/* Include room in for 2 EOB chars. */"", ""\t\t\t\t\tcmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );"", ""\t\t\t\t}"", ""\t\t\telse"", ""\t\t\t\t/* Can't grow it, we don't own it. */"", ""\t\t\t\tb->yy_ch_buf = NULL;"", """", ""\t\t\tif ( ! b->yy_ch_buf )"", ""\t\t\t\tYY_FATAL_ERROR("", ""\t\t\t\t\""fatal error - scanner input buffer overflow\"" );"", """", ""\t\t\tyyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];"", """", ""\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -"", ""\t\t\t\t\t\tnumber_to_move - 1;"", """", ""\t\t\t}"", """", ""\t\tif ( num_to_read > YY_READ_BUF_SIZE )"", ""\t\t\tnum_to_read = YY_READ_BUF_SIZE;"", """", ""\t\t/* Read in more data. */"", ""\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),"", ""\t\t\tyyg->yy_n_chars, num_to_read );"", """", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;"", ""\t\t}"", """", ""\tif ( yyg->yy_n_chars == 0 )"", ""\t\t{"", ""\t\tif ( number_to_move == YY_MORE_ADJ )"", ""\t\t\t{"", ""\t\t\tret_val = EOB_ACT_END_OF_FILE;"", ""\t\t\tcmExpr_yyrestart(yyin  ,yyscanner);"", ""\t\t\t}"", """", ""\t\telse"", ""\t\t\t{"", ""\t\t\tret_val = EOB_ACT_LAST_MATCH;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status ="", ""\t\t\t\tYY_BUFFER_EOF_PENDING;"", ""\t\t\t}"", ""\t\t}"", """", ""\telse"", ""\t\tret_val = EOB_ACT_CONTINUE_SCAN;"", """", ""\tif ((int) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {"", ""\t\t/* Extend the array by 50%, plus the number we really need. */"", ""\t\tint new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmExpr_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );"", ""\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", ""\t}"", """", ""\tyyg->yy_n_chars += number_to_move;"", ""\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;"", ""\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;"", """", ""\tyyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];"", """", ""  if ( yyg->yy_n_chars == 0 )"", ""    {"", ""    if ( number_to_move == YY_MORE_ADJ )"", ""      {"", ""      ret_val = EOB_ACT_END_OF_FILE;"", ""      cmExpr_yyrestart(yyin  ,yyscanner);"", ""      }"", """", ""    else"", ""      {"", ""      ret_val = EOB_ACT_LAST_MATCH;"", ""      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status ="", ""        YY_BUFFER_EOF_PENDING;"", ""      }"", ""    }"", """", ""  else"", ""    ret_val = EOB_ACT_CONTINUE_SCAN;"", """", ""  yyg->yy_n_chars += number_to_move;"", ""  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;"", ""  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;"", """", ""  yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];"", """", ""  return ret_val;"", ""\treturn ret_val;"", ""}"", """", ""/* yy_get_previous_state - get the state just before the EOB char was"", ""   reached */"", ""/* yy_get_previous_state - get the state just before the EOB char was reached */"", """", ""    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)"", ""{"", ""  yy_state_type yy_current_state;"", ""  char *yy_cp;"", ""\tyy_state_type yy_current_state;"", ""\tchar *yy_cp;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""  yy_current_state = yyg->yy_start;"", """", ""  for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )"", ""    {"", ""    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);"", ""    if ( yy_accept[yy_current_state] )"", ""      {"", ""      yyg->yy_last_accepting_state = yy_current_state;"", ""      yyg->yy_last_accepting_cpos = yy_cp;"", ""      }"", ""    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""      {"", ""      yy_current_state = (int) yy_def[yy_current_state];"", ""      if ( yy_current_state >= 23 )"", ""        yy_c = yy_meta[(unsigned int) yy_c];"", ""      }"", ""    yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""    }"", """", ""  return yy_current_state;"", ""\tyy_current_state = yyg->yy_start;"", """", ""\tfor ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )"", ""\t\t{"", ""\t\tYY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);"", ""\t\tif ( yy_accept[yy_current_state] )"", ""\t\t\t{"", ""\t\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t\t}"", ""\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t\t{"", ""\t\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\t\tif ( yy_current_state >= 23 )"", ""\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t\t}"", ""\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];"", ""\t\t}"", """", ""\treturn yy_current_state;"", ""}"", """", ""/* yy_try_NUL_trans - try to make a transition on the NUL character"", "" *"", "" * synopsis"", "" *  next_state = yy_try_NUL_trans( current_state );"", "" *\tnext_state = yy_try_NUL_trans( current_state );"", "" */"", ""    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)"", ""{"", ""  int yy_is_jam;"", ""\tint yy_is_jam;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */"", ""\tchar *yy_cp = yyg->yy_c_buf_p;"", """", ""\tYY_CHAR yy_c = 1;"", ""\tif ( yy_accept[yy_current_state] )"", ""\t\t{"", ""\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t}"", ""\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t{"", ""\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\tif ( yy_current_state >= 23 )"", ""\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t}"", ""\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];"", ""\tyy_is_jam = (yy_current_state == 22);"", """", ""\t(void)yyg;"", ""\treturn yy_is_jam ? 0 : yy_current_state;"", ""}"", """", ""#ifndef YY_NO_UNPUT"", """", ""    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)"", ""{"", ""\tchar *yy_cp;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""  char *yy_cp = yyg->yy_c_buf_p;"", """", ""  YY_CHAR yy_c = 1;"", ""  if ( yy_accept[yy_current_state] )"", ""    {"", ""    yyg->yy_last_accepting_state = yy_current_state;"", ""    yyg->yy_last_accepting_cpos = yy_cp;"", ""    }"", ""  while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""    {"", ""    yy_current_state = (int) yy_def[yy_current_state];"", ""    if ( yy_current_state >= 23 )"", ""      yy_c = yy_meta[(unsigned int) yy_c];"", ""    }"", ""  yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""  yy_is_jam = (yy_current_state == 22);"", ""    yy_cp = yyg->yy_c_buf_p;"", """", ""\t/* undo effects of setting up yytext */"", ""\t*yy_cp = yyg->yy_hold_char;"", """", ""\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )"", ""\t\t{ /* need to shift things up to make room */"", ""\t\t/* +2 for EOB chars. */"", ""\t\tint number_to_move = yyg->yy_n_chars + 2;"", ""\t\tchar *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf["", ""\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];"", ""\t\tchar *source ="", ""\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];"", """", ""  return yy_is_jam ? 0 : yy_current_state;"", ""\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""\t\t\t*--dest = *--source;"", """", ""\t\tyy_cp += (int) (dest - source);"", ""\t\tyy_bp += (int) (dest - source);"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars ="", ""\t\t\tyyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;"", """", ""\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )"", ""\t\t\tYY_FATAL_ERROR( \""flex scanner push-back overflow\"" );"", ""\t\t}"", """", ""\t*--yy_cp = (char) c;"", """", ""\tyyg->yytext_ptr = yy_bp;"", ""\tyyg->yy_hold_char = *yy_cp;"", ""\tyyg->yy_c_buf_p = yy_cp;"", ""}"", """", ""#endif"", """", ""#ifndef YY_NO_INPUT"", ""#ifdef __cplusplus"", ""    static int yyinput (yyscan_t yyscanner)""]","[0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, -1, 1, 1, 1, 0, 1, 1, 1, 0, -1, 1, 1, 0, -1, -1, -1, 1, 1, 0, -1, -1, -1, 1, 1, 0, -1, -1, 1, 1, 1, 1, 1, 0, -1, -1, 1, 1, 0, -1, -1, 1, 1, 0, -1, -1, -1, -1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, -1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, -1, -1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, 0, -1, -1, 1, 0, 0, 0, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0]","[[398, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [528, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [554, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [622, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [647, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [715, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [759, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [929, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""flex scanner push-back overflow\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""]]",676,684
"["" */"", ""    YY_BUFFER_STATE cmExpr_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)"", ""{"", ""  YY_BUFFER_STATE b;"", ""\tYY_BUFFER_STATE b;"", """", ""  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""  if ( ! b )"", ""    YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_create_buffer()\"" );"", ""\tb = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_create_buffer()\"" );"", """", ""  b->yy_buf_size = size;"", ""\tb->yy_buf_size = (yy_size_t)size;"", """", ""  /* yy_ch_buf has to be 2 characters longer than the size given because"", ""   * we need to put in 2 end-of-buffer characters."", ""   */"", ""  b->yy_ch_buf = (char *) cmExpr_yyalloc(b->yy_buf_size + 2 ,yyscanner );"", ""  if ( ! b->yy_ch_buf )"", ""    YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_create_buffer()\"" );"", ""\t/* yy_ch_buf has to be 2 characters longer than the size given because"", ""\t * we need to put in 2 end-of-buffer characters."", ""\t */"", ""\tb->yy_ch_buf = (char *) cmExpr_yyalloc(b->yy_buf_size + 2 ,yyscanner );"", ""\tif ( ! b->yy_ch_buf )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_create_buffer()\"" );"", """", ""  b->yy_is_our_buffer = 1;"", ""\tb->yy_is_our_buffer = 1;"", """", ""  cmExpr_yy_init_buffer(b,file ,yyscanner);"", ""\tcmExpr_yy_init_buffer(b,file ,yyscanner);"", """", ""  return b;"", ""\treturn b;"", ""}"", """", ""/** Destroy the buffer.""]","[0, 0, 0, -1, 1, 0, -1, -1, -2, 1, 1, 2, 0, -1, 1, 0, -1, -1, -1, -1, -1, -2, 1, 1, 1, 1, 1, 2, 0, -1, 1, 0, -1, 1, 0, -1, 1, 0, 0, 0]","[[8, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [11, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [21, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [27, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""]]",1311,1384
"[""void cmExpr_yypop_buffer_state (yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""  if (!YY_CURRENT_BUFFER)"", ""    return;"", """", ""  cmExpr_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);"", ""  YY_CURRENT_BUFFER_LVALUE = NULL;"", ""  if (yyg->yy_buffer_stack_top > 0)"", ""    --yyg->yy_buffer_stack_top;"", """", ""  if (YY_CURRENT_BUFFER) {"", ""    cmExpr_yy_load_buffer_state(yyscanner );"", ""    yyg->yy_did_buffer_switch_on_eof = 1;"", ""  }"", ""\tif (!YY_CURRENT_BUFFER)"", ""\t\treturn;"", """", ""\tcmExpr_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);"", ""\tYY_CURRENT_BUFFER_LVALUE = NULL;"", ""\tif (yyg->yy_buffer_stack_top > 0)"", ""\t\t--yyg->yy_buffer_stack_top;"", """", ""\tif (YY_CURRENT_BUFFER) {"", ""\t\tcmExpr_yy_load_buffer_state(yyscanner );"", ""\t\tyyg->yy_did_buffer_switch_on_eof = 1;"", ""\t}"", ""}"", """", ""/* Allocates the stack if it does not exist."", "" *  Guarantees space for at least one push."", "" */"", ""static void cmExpr_yyensure_buffer_stack (yyscan_t yyscanner)"", ""{"", ""  int nuto_alloc;"", ""\tint num_to_alloc;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""  if (!yyg->yy_buffer_stack) {"", ""\tif (!yyg->yy_buffer_stack) {"", """", ""    /* First allocation is just for 2 elements, since we don't know if this"", ""     * scanner will even need a stack. We use 2 instead of 1 to avoid an"", ""     * immediate realloc on the next call."", ""\t\t/* First allocation is just for 2 elements, since we don't know if this"", ""\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an"", ""\t\t * immediate realloc on the next call."", ""         */"", ""    nuto_alloc = 1;"", ""    yyg->yy_buffer_stack = (struct yy_buffer_state**)cmExpr_yyalloc"", ""                (nuto_alloc * sizeof(struct yy_buffer_state*)"", ""                , yyscanner);"", """", ""    memset(yyg->yy_buffer_stack, 0, nuto_alloc * sizeof(struct yy_buffer_state*));"", """", ""    yyg->yy_buffer_stack_max = nuto_alloc;"", ""    yyg->yy_buffer_stack_top = 0;"", ""    return;"", ""  }"", """", ""  if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){"", """", ""    /* Increase the buffer to prepare for a possible push. */"", ""    int grow_size = 8 /* arbitrary grow size */;"", """", ""    nuto_alloc = yyg->yy_buffer_stack_max + grow_size;"", ""    yyg->yy_buffer_stack = (struct yy_buffer_state**)cmExpr_yyrealloc"", ""                (yyg->yy_buffer_stack,"", ""                nuto_alloc * sizeof(struct yy_buffer_state*)"", ""                , yyscanner);"", """", ""    /* zero only the new slots.*/"", ""    memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));"", ""    yyg->yy_buffer_stack_max = nuto_alloc;"", ""  }"", ""      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */"", ""\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)cmExpr_yyalloc"", ""\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)"", ""\t\t\t\t\t\t\t\t, yyscanner);"", ""\t\tif ( ! yyg->yy_buffer_stack )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yyensure_buffer_stack()\"" );"", """", ""\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));"", """", ""\t\tyyg->yy_buffer_stack_max = num_to_alloc;"", ""\t\tyyg->yy_buffer_stack_top = 0;"", ""\t\treturn;"", ""\t}"", """", ""\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){"", """", ""\t\t/* Increase the buffer to prepare for a possible push. */"", ""\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;"", """", ""\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;"", ""\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)cmExpr_yyrealloc"", ""\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,"", ""\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)"", ""\t\t\t\t\t\t\t\t, yyscanner);"", ""\t\tif ( ! yyg->yy_buffer_stack )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yyensure_buffer_stack()\"" );"", """", ""\t\t/* zero only the new slots.*/"", ""\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));"", ""\t\tyyg->yy_buffer_stack_max = num_to_alloc;"", ""\t}"", ""}"", """", ""/** Setup the input buffer state to scan directly from a user-specified character buffer.""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 0, 0]","[[80, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [100, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""]]",1454,1523
"["" */"", ""YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)"", ""{"", ""  YY_BUFFER_STATE b;"", """", ""  if ( size < 2 ||"", ""       base[size-2] != YY_END_OF_BUFFER_CHAR ||"", ""       base[size-1] != YY_END_OF_BUFFER_CHAR )"", ""    /* They forgot to leave room for the EOB's. */"", ""    return 0;"", """", ""  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""  if ( ! b )"", ""    YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_scan_buffer()\"" );"", """", ""  b->yy_buf_size = size - 2;  /* \""- 2\"" to take care of EOB's */"", ""  b->yy_buf_pos = b->yy_ch_buf = base;"", ""  b->yy_is_our_buffer = 0;"", ""  b->yy_input_file = 0;"", ""  b->yy_n_chars = b->yy_buf_size;"", ""  b->yy_is_interactive = 0;"", ""  b->yy_at_bol = 1;"", ""  b->yy_fill_buffer = 0;"", ""  b->yy_buffer_status = YY_BUFFER_NEW;"", """", ""  cmExpr_yy_switch_to_buffer(b ,yyscanner );"", """", ""  return b;"", ""\tYY_BUFFER_STATE b;"", """", ""\tif ( size < 2 ||"", ""\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||"", ""\t     base[size-1] != YY_END_OF_BUFFER_CHAR )"", ""\t\t/* They forgot to leave room for the EOB's. */"", ""\t\treturn NULL;"", """", ""\tb = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_scan_buffer()\"" );"", """", ""\tb->yy_buf_size = size - 2;\t/* \""- 2\"" to take care of EOB's */"", ""\tb->yy_buf_pos = b->yy_ch_buf = base;"", ""\tb->yy_is_our_buffer = 0;"", ""\tb->yy_input_file = NULL;"", ""\tb->yy_n_chars = b->yy_buf_size;"", ""\tb->yy_is_interactive = 0;"", ""\tb->yy_at_bol = 1;"", ""\tb->yy_fill_buffer = 0;"", ""\tb->yy_buffer_status = YY_BUFFER_NEW;"", """", ""\tcmExpr_yy_switch_to_buffer(b ,yyscanner );"", """", ""\treturn b;"", ""}"", """", ""/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will"", "" * scan from a @e copy of @a yy_str."", "" * @param yy_str a NUL-terminated string to scan"", "" * scan from a @e copy of @a str."", "" * @param yystr a NUL-terminated string to scan"", "" * @param yyscanner The scanner object."", "" * @return the newly allocated buffer state object."", "" * @note If you want to scan bytes that may contain NUL values, then use"", "" *       cmExpr_yy_scan_bytes() instead."", "" */"", ""YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yy_str , yyscan_t yyscanner)"", ""YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)"", ""{"", """", ""  return cmExpr_yy_scan_bytes(yy_str,strlen(yy_str) ,yyscanner);"", ""\treturn cmExpr_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);"", ""}"", """", ""/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will"", "" * scan from a @e copy of @a bytes."", "" * @param bytes the byte buffer to scan"", "" * @param len the number of bytes in the buffer pointed to by @a bytes."", "" * @param yybytes the byte buffer to scan"", "" * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes."", "" * @param yyscanner The scanner object."", "" * @return the newly allocated buffer state object."", "" */"", ""YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * bytes, int  len , yyscan_t yyscanner)"", ""YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)"", ""{"", ""  YY_BUFFER_STATE b;"", ""  char *buf;"", ""  yy_size_t n;"", ""  int i;"", ""\tYY_BUFFER_STATE b;"", ""\tchar *buf;"", ""\tyy_size_t n;"", ""\tyy_size_t i;"", """", ""  /* Get memory for full buffer, including space for trailing EOB's. */"", ""  n = len + 2;"", ""  buf = (char *) cmExpr_yyalloc(n ,yyscanner );"", ""  if ( ! buf )"", ""    YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_scan_bytes()\"" );"", ""\t/* Get memory for full buffer, including space for trailing EOB's. */"", ""\tn = (yy_size_t) _yybytes_len + 2;"", ""\tbuf = (char *) cmExpr_yyalloc(n ,yyscanner );"", ""\tif ( ! buf )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_scan_bytes()\"" );"", """", ""  for ( i = 0; i < len; ++i )"", ""    buf[i] = bytes[i];"", ""\tfor ( i = 0; i < (size_t)_yybytes_len; ++i )"", ""\t\tbuf[i] = yybytes[i];"", """", ""  buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;"", ""\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;"", """", ""  b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);"", ""  if ( ! b )"", ""    YY_FATAL_ERROR( \""bad buffer in cmExpr_yy_scan_bytes()\"" );"", ""\tb = cmExpr_yy_scan_buffer(buf,n ,yyscanner);"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""bad buffer in cmExpr_yy_scan_bytes()\"" );"", """", ""  /* It's okay to grow etc. this buffer, and we should throw it"", ""   * away when we're done."", ""   */"", ""  b->yy_is_our_buffer = 1;"", ""\t/* It's okay to grow etc. this buffer, and we should throw it"", ""\t * away when we're done."", ""\t */"", ""\tb->yy_is_our_buffer = 1;"", """", ""  return b;"", ""\treturn b;"", ""}"", """", ""#ifndef YY_EXIT_FAILURE"", ""#define YY_EXIT_FAILURE 2"", ""#endif"", """", ""static void yy_fatal_error (yyconst char* msg , yyscan_t)"", ""static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)"", ""{"", ""      (void) fprintf( stderr, \""%s\\n\"", msg );"", ""  exit( YY_EXIT_FAILURE );"", ""\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""\t(void)yyg;"", ""\t(void) fprintf( stderr, \""%s\\n\"", msg );"", ""\texit( YY_EXIT_FAILURE );"", ""}"", """", ""/* Redefine yyless() so it works in section 3 code. */"", """", ""#undef yyless"", ""#define yyless(n) \\"", ""  do \\"", ""    { \\"", ""    /* Undo effects of setting up yytext. */ \\"", ""\tdo \\"", ""\t\t{ \\"", ""\t\t/* Undo effects of setting up yytext. */ \\"", ""        int yyless_macro_arg = (n); \\"", ""        YY_LESS_LINENO(yyless_macro_arg);\\"", ""    yytext[yyleng] = yyg->yy_hold_char; \\"", ""    yyg->yy_c_buf_p = yytext + yyless_macro_arg; \\"", ""    yyg->yy_hold_char = *yyg->yy_c_buf_p; \\"", ""    *yyg->yy_c_buf_p = '\\0'; \\"", ""    yyleng = yyless_macro_arg; \\"", ""    } \\"", ""  while ( 0 )"", ""\t\tyytext[yyleng] = yyg->yy_hold_char; \\"", ""\t\tyyg->yy_c_buf_p = yytext + yyless_macro_arg; \\"", ""\t\tyyg->yy_hold_char = *yyg->yy_c_buf_p; \\"", ""\t\t*yyg->yy_c_buf_p = '\\0'; \\"", ""\t\tyyleng = yyless_macro_arg; \\"", ""\t\t} \\"", ""\twhile ( 0 )"", """", ""/* Accessor  methods (get/set functions) to struct members. */"", """"]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, -1, -1, 1, 1, 0, 0, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, -1, -1, 1, 1, 0, 0, 0, -1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -2, 1, 1, 1, 1, 2, 0, -1, -1, 1, 1, 0, -1, 1, 0, -1, -1, -2, 1, 1, 2, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, -2, -1, 1, 1, 2, 1, 0, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[13, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_scan_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [38, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_scan_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [98, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [103, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [115, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""bad buffer in cmExpr_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [118, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""bad buffer in cmExpr_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [140, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""-"", ""(void) fprintf( stderr, \""%s\\n\"", msg );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [144, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""+"", ""(void) fprintf( stderr, \""%s\\n\"", msg );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""]]",1519,1592
"[""}"", """", ""/** Set the current line number."", "" * @param line_number The line number to set."", "" * @param _line_number line number"", "" * @param yyscanner The scanner object."", "" */"", ""void cmExpr_yyset_lineno (int  line_number , yyscan_t yyscanner)"", ""void cmExpr_yyset_lineno (int  _line_number , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        /* lineno is only valid if an input buffer exists. */"", ""        if (! YY_CURRENT_BUFFER )"", ""           yy_fatal_error( \""cmExpr_yyset_lineno called with no buffer\"" , yyscanner);"", ""           YY_FATAL_ERROR( \""cmExpr_yyset_lineno called with no buffer\"" );"", """", ""    yylineno = line_number;"", ""    yylineno = _line_number;"", ""}"", """", ""/** Set the current column."", "" * @param column_no The column number to set."", "" * @param _column_no column number"", "" * @param yyscanner The scanner object."", "" */"", ""void cmExpr_yyset_column (int  column_no , yyscan_t yyscanner)"", ""void cmExpr_yyset_column (int  _column_no , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        /* column is only valid if an input buffer exists. */"", ""        if (! YY_CURRENT_BUFFER )"", ""           yy_fatal_error( \""cmExpr_yyset_column called with no buffer\"" , yyscanner);"", ""           YY_FATAL_ERROR( \""cmExpr_yyset_column called with no buffer\"" );"", """", ""    yycolumn = column_no;"", ""    yycolumn = _column_no;"", ""}"", """", ""/** Set the input stream. This does not discard the current"", "" * input buffer."", "" * @param in_str A readable stream."", "" * @param _in_str A readable stream."", "" * @param yyscanner The scanner object."", "" * @see cmExpr_yy_switch_to_buffer"", "" */"", ""void cmExpr_yyset_in (FILE *  in_str , yyscan_t yyscanner)"", ""void cmExpr_yyset_in (FILE *  _in_str , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""    yyin = in_str ;"", ""    yyin = _in_str ;"", ""}"", """", ""void cmExpr_yyset_out (FILE *  out_str , yyscan_t yyscanner)"", ""void cmExpr_yyset_out (FILE *  _out_str , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""    yyout = out_str ;"", ""    yyout = _out_str ;"", ""}"", """", ""int cmExpr_yyget_debug  (yyscan_t yyscanner)""]","[0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, -2, 2, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, -2, 2, 0, -1, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0]","[[14, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""-"", ""yy_fatal_error( \""cmExpr_yyset_lineno called with no buffer\"" , yyscanner);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [15, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""cmExpr_yyset_lineno called with no buffer\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [33, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""-"", ""yy_fatal_error( \""cmExpr_yyset_column called with no buffer\"" , yyscanner);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""], [34, ""788581883fef05820f3f83ec5d1456490bc2397f"", ""Merge topic 'rebuild-lexers'\n\nc5df1f16 Regenerate lexer source code"", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""cmExpr_yyset_column called with no buffer\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_69_new.cpp""]]",1709,1784
"["""", ""/* Amount of stuff to slurp up with each read. */"", ""#ifndef YY_READ_BUF_SIZE"", ""#ifdef __ia64__"", ""/* On IA-64, the buffer size is 16k, not 8k */"", ""#define YY_READ_BUF_SIZE 16384"", ""#else"", ""#define YY_READ_BUF_SIZE 8192"", ""#endif /* __ia64__ */"", ""#endif"", """", ""/* Copy whatever the last rule matched to the standard output. */"", ""#ifndef ECHO"", ""/* This used to be an fputs(), but since the string might contain NUL's,"", "" * we now use fwrite()."", "" */"", ""#define ECHO fwrite( yytext, yyleng, 1, yyout )"", ""#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)"", ""#endif"", """", ""/* Gets input and stuffs it into \""buf\"".  number of characters read, or YY_NULL,"", "" * is returned in \""result\""."", "" */"", ""#ifndef YY_INPUT"", ""#define YY_INPUT(buf,result,max_size) \\"", ""        if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\"", ""                { \\"", ""                int c = '*'; \\"", ""                size_t n; \\"", ""                for ( n = 0; n < max_size && \\"", ""                             (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\"", ""                        buf[n] = (char) c; \\"", ""                if ( c == '\\n' ) \\"", ""                        buf[n++] = (char) c; \\"", ""                if ( c == EOF && ferror( yyin ) ) \\"", ""                        YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""                result = n; \\"", ""                } \\"", ""        else \\"", ""                { \\"", ""                errno=0; \\"", ""                while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\"", ""                        { \\"", ""                        if( errno != EINTR) \\"", ""                                { \\"", ""                                YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""                                break; \\"", ""                                } \\"", ""                        errno=0; \\"", ""                        clearerr(yyin); \\"", ""                        } \\"", ""                }\\"", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\"", ""\t\t{ \\"", ""\t\tint c = '*'; \\"", ""\t\tsize_t n; \\"", ""\t\tfor ( n = 0; n < max_size && \\"", ""\t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\"", ""\t\t\tbuf[n] = (char) c; \\"", ""\t\tif ( c == '\\n' ) \\"", ""\t\t\tbuf[n++] = (char) c; \\"", ""\t\tif ( c == EOF && ferror( yyin ) ) \\"", ""\t\t\tYY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""\t\tresult = n; \\"", ""\t\t} \\"", ""\telse \\"", ""\t\t{ \\"", ""\t\terrno=0; \\"", ""\t\twhile ( (result = (int) fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\"", ""\t\t\t{ \\"", ""\t\t\tif( errno != EINTR) \\"", ""\t\t\t\t{ \\"", ""\t\t\t\tYY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""\t\t\t\tbreak; \\"", ""\t\t\t\t} \\"", ""\t\t\terrno=0; \\"", ""\t\t\tclearerr(yyin); \\"", ""\t\t\t} \\"", ""\t\t}\\"", ""\\"", """", ""#endif""]","[0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[35, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [45, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [62, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [72, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""]]",615,600
"["""", ""/* Code executed at the end of each rule. */"", ""#ifndef YY_BREAK"", ""#define YY_BREAK break;"", ""#define YY_BREAK /*LINTED*/break;"", ""#endif"", """", ""#define YY_RULE_SETUP \\"", ""        YY_USER_ACTION"", ""\tYY_USER_ACTION"", """", ""/** The main scanner function which does all the work."", "" */"", ""YY_DECL"", ""{"", ""        yy_state_type yy_current_state;"", ""        char *yy_cp, *yy_bp;"", ""        int yy_act;"", ""\tyy_state_type yy_current_state;"", ""\tchar *yy_cp, *yy_bp;"", ""\tint yy_act;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""#line 64 \""cmCommandArgumentLexer.in.l\"""", ""\tif ( !yyg->yy_init )"", ""\t\t{"", ""\t\tyyg->yy_init = 1;"", """", ""#ifdef YY_USER_INIT"", ""\t\tYY_USER_INIT;"", ""#endif"", """", ""#line 732 \""cmCommandArgumentLexer.cxx\"""", ""\t\tif ( ! yyg->yy_start )"", ""\t\t\tyyg->yy_start = 1;\t/* first start state */"", """", ""        if ( !yyg->yy_init )"", ""                {"", ""                yyg->yy_init = 1;"", ""\t\tif ( ! yyin )"", ""\t\t\tyyin = stdin;"", """", ""#ifdef YY_USER_INIT"", ""                YY_USER_INIT;"", ""#endif"", ""\t\tif ( ! yyout )"", ""\t\t\tyyout = stdout;"", """", ""                if ( ! yyg->yy_start )"", ""                        yyg->yy_start = 1;      /* first start state */"", ""\t\tif ( ! YY_CURRENT_BUFFER ) {"", ""\t\t\tcmCommandArgument_yyensure_buffer_stack (yyscanner);"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE ="", ""\t\t\t\tcmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);"", ""\t\t}"", """", ""                if ( ! yyin )"", ""                        yyin = stdin;"", ""\t\tcmCommandArgument_yy_load_buffer_state(yyscanner );"", ""\t\t}"", """", ""                if ( ! yyout )"", ""                        yyout = stdout;"", ""\t{"", ""#line 42 \""cmCommandArgumentLexer.in.l\"""", """", ""                if ( ! YY_CURRENT_BUFFER ) {"", ""                        cmCommandArgument_yyensure_buffer_stack (yyscanner);"", ""                        YY_CURRENT_BUFFER_LVALUE ="", ""                                cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);"", ""                }"", """", ""                cmCommandArgument_yy_load_buffer_state(yyscanner );"", ""                }"", ""#line 740 \""cmCommandArgumentLexer.cxx\"""", """", ""        for(;;)             /* loops until end-of-file is reached */"", ""                {"", ""                yy_cp = yyg->yy_c_buf_p;"", ""\twhile ( /*CONSTCOND*/1 )\t\t/* loops until end-of-file is reached */"", ""\t\t{"", ""\t\tyy_cp = yyg->yy_c_buf_p;"", """", ""                /* Support of yytext. */"", ""                *yy_cp = yyg->yy_hold_char;"", ""\t\t/* Support of yytext. */"", ""\t\t*yy_cp = yyg->yy_hold_char;"", """", ""                /* yy_bp points to the position in yy_ch_buf of the start of"", ""                 * the current run."", ""                 */"", ""                yy_bp = yy_cp;"", ""\t\t/* yy_bp points to the position in yy_ch_buf of the start of"", ""\t\t * the current run."", ""\t\t */"", ""\t\tyy_bp = yy_cp;"", """", ""                yy_current_state = yyg->yy_start;"", ""\t\tyy_current_state = yyg->yy_start;"", ""yy_match:"", ""                do"", ""                        {"", ""                        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];"", ""                        if ( yy_accept[yy_current_state] )"", ""                                {"", ""                                yyg->yy_last_accepting_state = yy_current_state;"", ""                                yyg->yy_last_accepting_cpos = yy_cp;"", ""                                }"", ""                        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""                                {"", ""                                yy_current_state = (int) yy_def[yy_current_state];"", ""                                if ( yy_current_state >= 30 )"", ""                                        yy_c = yy_meta[(unsigned int) yy_c];"", ""                                }"", ""                        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""                        ++yy_cp;"", ""                        }"", ""                while ( yy_base[yy_current_state] != 41 );"", ""\t\tdo"", ""\t\t\t{"", ""\t\t\tYY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;"", ""\t\t\tif ( yy_accept[yy_current_state] )"", ""\t\t\t\t{"", ""\t\t\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\t\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t\t\t}"", ""\t\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t\t\t{"", ""\t\t\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\t\t\tif ( yy_current_state >= 30 )"", ""\t\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t\t\t}"", ""\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];"", ""\t\t\t++yy_cp;"", ""\t\t\t}"", ""\t\twhile ( yy_base[yy_current_state] != 41 );"", """", ""yy_find_action:"", ""                yy_act = yy_accept[yy_current_state];"", ""                if ( yy_act == 0 )"", ""                        { /* have to back up */"", ""                        yy_cp = yyg->yy_last_accepting_cpos;"", ""                        yy_current_state = yyg->yy_last_accepting_state;"", ""                        yy_act = yy_accept[yy_current_state];"", ""                        }"", """", ""                YY_DO_BEFORE_ACTION;"", """", ""do_action:      /* This label is used only to access EOF actions. */"", """", ""                switch ( yy_act )"", ""        { /* beginning of action switch */"", ""                        case 0: /* must back up */"", ""                        /* undo the effects of YY_DO_BEFORE_ACTION */"", ""                        *yy_cp = yyg->yy_hold_char;"", ""                        yy_cp = yyg->yy_last_accepting_cpos;"", ""                        yy_current_state = yyg->yy_last_accepting_state;"", ""                        goto yy_find_action;"", ""\t\tyy_act = yy_accept[yy_current_state];"", ""\t\tif ( yy_act == 0 )"", ""\t\t\t{ /* have to back up */"", ""\t\t\tyy_cp = yyg->yy_last_accepting_cpos;"", ""\t\t\tyy_current_state = yyg->yy_last_accepting_state;"", ""\t\t\tyy_act = yy_accept[yy_current_state];"", ""\t\t\t}"", """", ""\t\tYY_DO_BEFORE_ACTION;"", """", ""do_action:\t/* This label is used only to access EOF actions. */"", """", ""\t\tswitch ( yy_act )"", ""\t{ /* beginning of action switch */"", ""\t\t\tcase 0: /* must back up */"", ""\t\t\t/* undo the effects of YY_DO_BEFORE_ACTION */"", ""\t\t\t*yy_cp = yyg->yy_hold_char;"", ""\t\t\tyy_cp = yyg->yy_last_accepting_cpos;"", ""\t\t\tyy_current_state = yyg->yy_last_accepting_state;"", ""\t\t\tgoto yy_find_action;"", """", ""case 1:"", ""YY_RULE_SETUP"", ""#line 66 \""cmCommandArgumentLexer.in.l\"""", ""#line 44 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //std::cerr << __LINE__ << \"" here: [\"" << yytext << \""]\"" << std::endl;"", ""  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);"", ""  return cal_ENVCURLY;"", ""}"", ""\tYY_BREAK"", ""case 2:"", ""YY_RULE_SETUP"", ""#line 72 \""cmCommandArgumentLexer.in.l\"""", ""#line 50 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //std::cerr << __LINE__ << \"" here: [\"" << yytext << \""]\"" << std::endl;"", ""  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);"", ""  return cal_NCURLY;"", ""}"", ""\tYY_BREAK"", ""case 3:"", ""YY_RULE_SETUP"", ""#line 78 \""cmCommandArgumentLexer.in.l\"""", ""#line 56 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //std::cerr << __LINE__ << \"" here: [\"" << yytext << \""]\"" << std::endl;"", ""  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);"", ""  return cal_ATNAME;"", ""}"", ""\tYY_BREAK"", ""case 4:"", ""YY_RULE_SETUP"", ""#line 84 \""cmCommandArgumentLexer.in.l\"""", ""#line 62 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //std::cerr << __LINE__ << \"" here: [\"" << yytext << \""]\"" << std::endl;"", ""  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));"", ""  yylvalp->str = yyextra->DCURLYVariable;"", ""  return cal_DCURLY;"", ""}"", ""\tYY_BREAK"", ""case 5:"", ""YY_RULE_SETUP"", ""#line 91 \""cmCommandArgumentLexer.in.l\"""", ""#line 69 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //std::cerr << __LINE__ << \"" here: [\"" << yytext << \""]\"" << std::endl;"", ""  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));"", ""  yylvalp->str = yyextra->RCURLYVariable;"", ""  return cal_RCURLY;"", ""}"", ""\tYY_BREAK"", ""case 6:"", ""YY_RULE_SETUP"", ""#line 98 \""cmCommandArgumentLexer.in.l\"""", ""#line 76 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //std::cerr << __LINE__ << \"" here: [\"" << yytext << \""]\"" << std::endl;"", ""  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));"", ""  yylvalp->str = yyextra->ATVariable;"", ""  return cal_AT;"", ""}"", ""\tYY_BREAK"", ""case 7:"", ""YY_RULE_SETUP"", ""#line 105 \""cmCommandArgumentLexer.in.l\"""", ""#line 83 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //std::cerr << __LINE__ << \"" here: [\"" << yytext << \""]\"" << std::endl;"", ""  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));"", ""  return cal_NAME;"", ""}"", ""\tYY_BREAK"", ""case 8:"", ""YY_RULE_SETUP"", ""#line 111 \""cmCommandArgumentLexer.in.l\"""", ""#line 89 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytext+1)) )"", ""    {"", ""    return cal_ERROR;"", ""    }"", ""  return cal_SYMBOL;"", ""}"", ""\tYY_BREAK"", ""case 9:"", ""/* rule 9 can match eol */"", ""YY_RULE_SETUP"", ""#line 119 \""cmCommandArgumentLexer.in.l\"""", ""#line 97 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //std::cerr << __LINE__ << \"" here: [\"" << yytext << \""]\"" << std::endl;"", ""  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));"", ""  return cal_SYMBOL;"", ""}"", ""\tYY_BREAK"", ""case 10:"", ""YY_RULE_SETUP"", ""#line 125 \""cmCommandArgumentLexer.in.l\"""", ""#line 103 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));"", ""  yylvalp->str = yyextra->DOLLARVariable;"", ""  return cal_DOLLAR;"", ""}"", ""\tYY_BREAK"", ""case 11:"", ""YY_RULE_SETUP"", ""#line 131 \""cmCommandArgumentLexer.in.l\"""", ""#line 109 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));"", ""  yylvalp->str = yyextra->LCURLYVariable;"", ""  return cal_LCURLY;"", ""}"", ""\tYY_BREAK"", ""case 12:"", ""YY_RULE_SETUP"", ""#line 137 \""cmCommandArgumentLexer.in.l\"""", ""#line 115 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));"", ""  yylvalp->str = yyextra->BSLASHVariable;"", ""  return cal_BSLASH;"", ""}"", ""\tYY_BREAK"", ""case 13:"", ""YY_RULE_SETUP"", ""#line 143 \""cmCommandArgumentLexer.in.l\"""", ""#line 121 \""cmCommandArgumentLexer.in.l\"""", ""{"", ""  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));"", ""  yylvalp->str = yyextra->BSLASHVariable;"", ""  return cal_SYMBOL;"", ""}"", ""\tYY_BREAK"", ""case 14:"", ""YY_RULE_SETUP"", ""#line 149 \""cmCommandArgumentLexer.in.l\"""", ""#line 127 \""cmCommandArgumentLexer.in.l\"""", ""ECHO;"", ""        YY_BREAK"", ""#line 943 \""cmCommandArgumentLexer.cxx\"""", ""\tYY_BREAK"", ""#line 925 \""cmCommandArgumentLexer.cxx\"""", ""case YY_STATE_EOF(INITIAL):"", ""case YY_STATE_EOF(ESCAPES):"", ""case YY_STATE_EOF(NOESCAPES):"", ""        yyterminate();"", """", ""        case YY_END_OF_BUFFER:"", ""                {"", ""                /* Amount of text matched not including the EOB char. */"", ""                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;"", """", ""                /* Undo the effects of YY_DO_BEFORE_ACTION. */"", ""                *yy_cp = yyg->yy_hold_char;"", ""                YY_RESTORE_YY_MORE_OFFSET"", """", ""                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )"", ""                        {"", ""                        /* We're scanning a new file or input source.  It's"", ""                         * possible that this happened because the user"", ""                         * just pointed yyin at a new source and called"", ""                         * cmCommandArgument_yylex().  If so, then we have to assure"", ""                         * consistency between YY_CURRENT_BUFFER and our"", ""                         * globals.  Here is the right place to do so, because"", ""                         * this is the first action (other than possibly a"", ""                         * back-up) that will match for the new input source."", ""                         */"", ""                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;"", ""                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;"", ""                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;"", ""                        }"", """", ""                /* Note that here we test for yy_c_buf_p \""<=\"" to the position"", ""                 * of the first EOB in the buffer, since yy_c_buf_p will"", ""                 * already have been incremented past the NUL character"", ""                 * (since all states make transitions on EOB to the"", ""                 * end-of-buffer state).  Contrast this with the test"", ""                 * in input()."", ""                 */"", ""                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )"", ""                        { /* This was really a NUL. */"", ""                        yy_state_type yy_next_state;"", """", ""                        yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""                        yy_current_state = yy_get_previous_state( yyscanner );"", """", ""                        /* Okay, we're now positioned to make the NUL"", ""                         * transition.  We couldn't have"", ""                         * yy_get_previous_state() go ahead and do it"", ""                         * for us because it doesn't know how to deal"", ""                         * with the possibility of jamming (and we don't"", ""                         * want to build jamming into it because then it"", ""                         * will run more slowly)."", ""                         */"", """", ""                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);"", """", ""                        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""                        if ( yy_next_state )"", ""                                {"", ""                                /* Consume the NUL. */"", ""                                yy_cp = ++yyg->yy_c_buf_p;"", ""                                yy_current_state = yy_next_state;"", ""                                goto yy_match;"", ""                                }"", """", ""                        else"", ""                                {"", ""                                yy_cp = yyg->yy_c_buf_p;"", ""                                goto yy_find_action;"", ""                                }"", ""                        }"", """", ""                else switch ( yy_get_next_buffer( yyscanner ) )"", ""                        {"", ""                        case EOB_ACT_END_OF_FILE:"", ""                                {"", ""                                yyg->yy_did_buffer_switch_on_eof = 0;"", """", ""                                if ( cmCommandArgument_yywrap(yyscanner ) )"", ""                                        {"", ""                                        /* Note: because we've taken care in"", ""                                         * yy_get_next_buffer() to have set up"", ""                                         * yytext, we can now set up"", ""                                         * yy_c_buf_p so that if some total"", ""                                         * hoser (like flex itself) wants to"", ""                                         * call the scanner after we return the"", ""                                         * YY_NULL, it'll still work - another"", ""                                         * YY_NULL will get returned."", ""                                         */"", ""                                        yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""                                        yy_act = YY_STATE_EOF(YY_START);"", ""                                        goto do_action;"", ""                                        }"", """", ""                                else"", ""                                        {"", ""                                        if ( ! yyg->yy_did_buffer_switch_on_eof )"", ""                                                YY_NEW_FILE;"", ""                                        }"", ""                                break;"", ""                                }"", """", ""                        case EOB_ACT_CONTINUE_SCAN:"", ""                                yyg->yy_c_buf_p ="", ""                                        yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""                                yy_current_state = yy_get_previous_state( yyscanner );"", """", ""                                yy_cp = yyg->yy_c_buf_p;"", ""                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""                                goto yy_match;"", """", ""                        case EOB_ACT_LAST_MATCH:"", ""                                yyg->yy_c_buf_p ="", ""                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];"", """", ""                                yy_current_state = yy_get_previous_state( yyscanner );"", """", ""                                yy_cp = yyg->yy_c_buf_p;"", ""                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""                                goto yy_find_action;"", ""                        }"", ""                break;"", ""                }"", """", ""        default:"", ""                YY_FATAL_ERROR("", ""                        \""fatal flex scanner internal error--no action found\"" );"", ""        } /* end of action switch */"", ""                } /* end of scanning one token */"", ""return 0; /* this should not happen but it quiets some compilers */"", ""\tyyterminate();"", """", ""\tcase YY_END_OF_BUFFER:"", ""\t\t{"", ""\t\t/* Amount of text matched not including the EOB char. */"", ""\t\tint yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;"", """", ""\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */"", ""\t\t*yy_cp = yyg->yy_hold_char;"", ""\t\tYY_RESTORE_YY_MORE_OFFSET"", """", ""\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )"", ""\t\t\t{"", ""\t\t\t/* We're scanning a new file or input source.  It's"", ""\t\t\t * possible that this happened because the user"", ""\t\t\t * just pointed yyin at a new source and called"", ""\t\t\t * cmCommandArgument_yylex().  If so, then we have to assure"", ""\t\t\t * consistency between YY_CURRENT_BUFFER and our"", ""\t\t\t * globals.  Here is the right place to do so, because"", ""\t\t\t * this is the first action (other than possibly a"", ""\t\t\t * back-up) that will match for the new input source."", ""\t\t\t */"", ""\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;"", ""\t\t\t}"", """", ""\t\t/* Note that here we test for yy_c_buf_p \""<=\"" to the position"", ""\t\t * of the first EOB in the buffer, since yy_c_buf_p will"", ""\t\t * already have been incremented past the NUL character"", ""\t\t * (since all states make transitions on EOB to the"", ""\t\t * end-of-buffer state).  Contrast this with the test"", ""\t\t * in input()."", ""\t\t */"", ""\t\tif ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )"", ""\t\t\t{ /* This was really a NUL. */"", ""\t\t\tyy_state_type yy_next_state;"", """", ""\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t/* Okay, we're now positioned to make the NUL"", ""\t\t\t * transition.  We couldn't have"", ""\t\t\t * yy_get_previous_state() go ahead and do it"", ""\t\t\t * for us because it doesn't know how to deal"", ""\t\t\t * with the possibility of jamming (and we don't"", ""\t\t\t * want to build jamming into it because then it"", ""\t\t\t * will run more slowly)."", ""\t\t\t */"", """", ""\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);"", """", ""\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""\t\t\tif ( yy_next_state )"", ""\t\t\t\t{"", ""\t\t\t\t/* Consume the NUL. */"", ""\t\t\t\tyy_cp = ++yyg->yy_c_buf_p;"", ""\t\t\t\tyy_current_state = yy_next_state;"", ""\t\t\t\tgoto yy_match;"", ""\t\t\t\t}"", """", ""\t\t\telse"", ""\t\t\t\t{"", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tgoto yy_find_action;"", ""\t\t\t\t}"", ""\t\t\t}"", """", ""\t\telse switch ( yy_get_next_buffer( yyscanner ) )"", ""\t\t\t{"", ""\t\t\tcase EOB_ACT_END_OF_FILE:"", ""\t\t\t\t{"", ""\t\t\t\tyyg->yy_did_buffer_switch_on_eof = 0;"", """", ""\t\t\t\tif ( cmCommandArgument_yywrap(yyscanner ) )"", ""\t\t\t\t\t{"", ""\t\t\t\t\t/* Note: because we've taken care in"", ""\t\t\t\t\t * yy_get_next_buffer() to have set up"", ""\t\t\t\t\t * yytext, we can now set up"", ""\t\t\t\t\t * yy_c_buf_p so that if some total"", ""\t\t\t\t\t * hoser (like flex itself) wants to"", ""\t\t\t\t\t * call the scanner after we return the"", ""\t\t\t\t\t * YY_NULL, it'll still work - another"", ""\t\t\t\t\t * YY_NULL will get returned."", ""\t\t\t\t\t */"", ""\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);"", ""\t\t\t\t\tgoto do_action;"", ""\t\t\t\t\t}"", """", ""\t\t\t\telse"", ""\t\t\t\t\t{"", ""\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )"", ""\t\t\t\t\t\tYY_NEW_FILE;"", ""\t\t\t\t\t}"", ""\t\t\t\tbreak;"", ""\t\t\t\t}"", """", ""\t\t\tcase EOB_ACT_CONTINUE_SCAN:"", ""\t\t\t\tyyg->yy_c_buf_p ="", ""\t\t\t\t\tyyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""\t\t\t\tgoto yy_match;"", """", ""\t\t\tcase EOB_ACT_LAST_MATCH:"", ""\t\t\t\tyyg->yy_c_buf_p ="", ""\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];"", """", ""\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""\t\t\t\tgoto yy_find_action;"", ""\t\t\t}"", ""\t\tbreak;"", ""\t\t}"", """", ""\tdefault:"", ""\t\tYY_FATAL_ERROR("", ""\t\t\t\""fatal flex scanner internal error--no action found\"" );"", ""\t} /* end of action switch */"", ""\t\t} /* end of scanning one token */"", ""\t} /* end of user's declarations */"", ""} /* end of cmCommandArgument_yylex */"", """", ""/* yy_get_next_buffer - try to read in a new buffer"", "" *"", "" * Returns a code representing an action:"", "" *      EOB_ACT_LAST_MATCH -"", "" *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position"", "" *      EOB_ACT_END_OF_FILE - end of file"", "" *\tEOB_ACT_LAST_MATCH -"", "" *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position"", "" *\tEOB_ACT_END_OF_FILE - end of file"", "" */"", ""static int yy_get_next_buffer (yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;"", ""        char *source = yyg->yytext_ptr;"", ""        int number_to_move, i;"", ""        int ret_val;"", """", ""        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )"", ""                YY_FATAL_ERROR("", ""                \""fatal flex scanner internal error--end of buffer missed\"" );"", """", ""        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )"", ""                { /* Don't try to fill the buffer, so this is an EOF. */"", ""                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )"", ""                        {"", ""                        /* We matched a single character, the EOB, so"", ""                         * treat this as a final EOF."", ""                         */"", ""                        return EOB_ACT_END_OF_FILE;"", ""                        }"", """", ""                else"", ""                        {"", ""                        /* We matched some text prior to the EOB, first"", ""                         * process it."", ""                         */"", ""                        return EOB_ACT_LAST_MATCH;"", ""                        }"", ""                }"", """", ""        /* Try to read more data. */"", """", ""        /* First move last chars to start of buffer. */"", ""        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;"", """", ""        for ( i = 0; i < number_to_move; ++i )"", ""                *(dest++) = *(source++);"", """", ""        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )"", ""                /* don't do the read, it's not guaranteed to return an EOF,"", ""                 * just force an EOF"", ""                 */"", ""                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;"", """", ""        else"", ""                {"", ""                        int num_to_read ="", ""                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;"", """", ""                while ( num_to_read <= 0 )"", ""                        { /* Not enough room in the buffer - grow it. */"", """", ""                        /* just a shorter name for the current buffer */"", ""                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;"", """", ""                        int yy_c_buf_p_offset ="", ""                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);"", """", ""                        if ( b->yy_is_our_buffer )"", ""                                {"", ""                                int new_size = b->yy_buf_size * 2;"", """", ""                                if ( new_size <= 0 )"", ""                                        b->yy_buf_size += b->yy_buf_size / 8;"", ""                                else"", ""                                        b->yy_buf_size *= 2;"", """", ""                                b->yy_ch_buf = (char *)"", ""                                        /* Include room in for 2 EOB chars. */"", ""                                        cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );"", ""                                }"", ""                        else"", ""                                /* Can't grow it, we don't own it. */"", ""                                b->yy_ch_buf = 0;"", """", ""                        if ( ! b->yy_ch_buf )"", ""                                YY_FATAL_ERROR("", ""                                \""fatal error - scanner input buffer overflow\"" );"", """", ""                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];"", """", ""                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -"", ""                                                number_to_move - 1;"", """", ""                        }"", """", ""                if ( num_to_read > YY_READ_BUF_SIZE )"", ""                        num_to_read = YY_READ_BUF_SIZE;"", """", ""                /* Read in more data. */"", ""                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),"", ""                        yyg->yy_n_chars, (size_t) num_to_read );"", """", ""                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;"", ""                }"", """", ""        if ( yyg->yy_n_chars == 0 )"", ""                {"", ""                if ( number_to_move == YY_MORE_ADJ )"", ""                        {"", ""                        ret_val = EOB_ACT_END_OF_FILE;"", ""                        cmCommandArgument_yyrestart(yyin  ,yyscanner);"", ""                        }"", """", ""                else"", ""                        {"", ""                        ret_val = EOB_ACT_LAST_MATCH;"", ""                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status ="", ""                                YY_BUFFER_EOF_PENDING;"", ""                        }"", ""                }"", """", ""        else"", ""                ret_val = EOB_ACT_CONTINUE_SCAN;"", """", ""        if ((yy_size_t) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {"", ""                /* Extend the array by 50%, plus the number we really need. */"", ""                yy_size_t new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);"", ""                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );"", ""                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""                        YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", ""        }"", """", ""        yyg->yy_n_chars += number_to_move;"", ""        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;"", ""        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;"", """", ""        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];"", ""\tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;"", ""\tchar *source = yyg->yytext_ptr;"", ""\tyy_size_t number_to_move, i;"", ""\tint ret_val;"", """", ""\tif ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )"", ""\t\tYY_FATAL_ERROR("", ""\t\t\""fatal flex scanner internal error--end of buffer missed\"" );"", """", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )"", ""\t\t{ /* Don't try to fill the buffer, so this is an EOF. */"", ""\t\tif ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )"", ""\t\t\t{"", ""\t\t\t/* We matched a single character, the EOB, so"", ""\t\t\t * treat this as a final EOF."", ""\t\t\t */"", ""\t\t\treturn EOB_ACT_END_OF_FILE;"", ""\t\t\t}"", """", ""\t\telse"", ""\t\t\t{"", ""\t\t\t/* We matched some text prior to the EOB, first"", ""\t\t\t * process it."", ""\t\t\t */"", ""\t\t\treturn EOB_ACT_LAST_MATCH;"", ""\t\t\t}"", ""\t\t}"", """", ""\t/* Try to read more data. */"", """", ""\t/* First move last chars to start of buffer. */"", ""\tnumber_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;"", """", ""\tfor ( i = 0; i < number_to_move; ++i )"", ""\t\t*(dest++) = *(source++);"", """", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )"", ""\t\t/* don't do the read, it's not guaranteed to return an EOF,"", ""\t\t * just force an EOF"", ""\t\t */"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;"", """", ""\telse"", ""\t\t{"", ""\t\t\tint num_to_read ="", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;"", """", ""\t\twhile ( num_to_read <= 0 )"", ""\t\t\t{ /* Not enough room in the buffer - grow it. */"", """", ""\t\t\t/* just a shorter name for the current buffer */"", ""\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;"", """", ""\t\t\tint yy_c_buf_p_offset ="", ""\t\t\t\t(int) (yyg->yy_c_buf_p - b->yy_ch_buf);"", """", ""\t\t\tif ( b->yy_is_our_buffer )"", ""\t\t\t\t{"", ""\t\t\t\tint new_size = b->yy_buf_size * 2;"", """", ""\t\t\t\tif ( new_size <= 0 )"", ""\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;"", ""\t\t\t\telse"", ""\t\t\t\t\tb->yy_buf_size *= 2;"", """", ""\t\t\t\tb->yy_ch_buf = (char *)"", ""\t\t\t\t\t/* Include room in for 2 EOB chars. */"", ""\t\t\t\t\tcmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );"", ""\t\t\t\t}"", ""\t\t\telse"", ""\t\t\t\t/* Can't grow it, we don't own it. */"", ""\t\t\t\tb->yy_ch_buf = NULL;"", """", ""\t\t\tif ( ! b->yy_ch_buf )"", ""\t\t\t\tYY_FATAL_ERROR("", ""\t\t\t\t\""fatal error - scanner input buffer overflow\"" );"", """", ""\t\t\tyyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];"", """", ""\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -"", ""\t\t\t\t\t\tnumber_to_move - 1;"", """", ""\t\t\t}"", """", ""\t\tif ( num_to_read > YY_READ_BUF_SIZE )"", ""\t\t\tnum_to_read = YY_READ_BUF_SIZE;"", """", ""\t\t/* Read in more data. */"", ""\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),"", ""\t\t\tyyg->yy_n_chars, num_to_read );"", """", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;"", ""\t\t}"", """", ""\tif ( yyg->yy_n_chars == 0 )"", ""\t\t{"", ""\t\tif ( number_to_move == YY_MORE_ADJ )"", ""\t\t\t{"", ""\t\t\tret_val = EOB_ACT_END_OF_FILE;"", ""\t\t\tcmCommandArgument_yyrestart(yyin  ,yyscanner);"", ""\t\t\t}"", """", ""\t\telse"", ""\t\t\t{"", ""\t\t\tret_val = EOB_ACT_LAST_MATCH;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status ="", ""\t\t\t\tYY_BUFFER_EOF_PENDING;"", ""\t\t\t}"", ""\t\t}"", """", ""\telse"", ""\t\tret_val = EOB_ACT_CONTINUE_SCAN;"", """", ""\tif ((int) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {"", ""\t\t/* Extend the array by 50%, plus the number we really need. */"", ""\t\tint new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );"", ""\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", ""\t}"", """", ""\tyyg->yy_n_chars += number_to_move;"", ""\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;"", ""\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;"", """", ""\tyyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];"", """", ""        return ret_val;"", ""\treturn ret_val;"", ""}"", """", ""/* yy_get_previous_state - get the state just before the EOB char was reached */"", """", ""    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)"", ""{"", ""        yy_state_type yy_current_state;"", ""        char *yy_cp;"", ""\tyy_state_type yy_current_state;"", ""\tchar *yy_cp;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        yy_current_state = yyg->yy_start;"", """", ""        for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )"", ""                {"", ""                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);"", ""                if ( yy_accept[yy_current_state] )"", ""                        {"", ""                        yyg->yy_last_accepting_state = yy_current_state;"", ""                        yyg->yy_last_accepting_cpos = yy_cp;"", ""                        }"", ""                while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""                        {"", ""                        yy_current_state = (int) yy_def[yy_current_state];"", ""                        if ( yy_current_state >= 30 )"", ""                                yy_c = yy_meta[(unsigned int) yy_c];"", ""                        }"", ""                yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""                }"", """", ""        return yy_current_state;"", ""\tyy_current_state = yyg->yy_start;"", """", ""\tfor ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )"", ""\t\t{"", ""\t\tYY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);"", ""\t\tif ( yy_accept[yy_current_state] )"", ""\t\t\t{"", ""\t\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t\t}"", ""\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t\t{"", ""\t\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\t\tif ( yy_current_state >= 30 )"", ""\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t\t}"", ""\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];"", ""\t\t}"", """", ""\treturn yy_current_state;"", ""}"", """", ""/* yy_try_NUL_trans - try to make a transition on the NUL character"", "" *"", "" * synopsis"", "" *      next_state = yy_try_NUL_trans( current_state );"", "" *\tnext_state = yy_try_NUL_trans( current_state );"", "" */"", ""    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)"", ""{"", ""        int yy_is_jam;"", ""\tint yy_is_jam;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */"", ""        char *yy_cp = yyg->yy_c_buf_p;"", """", ""        YY_CHAR yy_c = 1;"", ""        if ( yy_accept[yy_current_state] )"", ""                {"", ""                yyg->yy_last_accepting_state = yy_current_state;"", ""                yyg->yy_last_accepting_cpos = yy_cp;"", ""                }"", ""        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""                {"", ""                yy_current_state = (int) yy_def[yy_current_state];"", ""                if ( yy_current_state >= 30 )"", ""                        yy_c = yy_meta[(unsigned int) yy_c];"", ""                }"", ""        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""        yy_is_jam = (yy_current_state == 29);"", """", ""        return yy_is_jam ? 0 : yy_current_state;"", ""\tchar *yy_cp = yyg->yy_c_buf_p;"", """", ""\tYY_CHAR yy_c = 1;"", ""\tif ( yy_accept[yy_current_state] )"", ""\t\t{"", ""\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t}"", ""\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t{"", ""\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\tif ( yy_current_state >= 30 )"", ""\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t}"", ""\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];"", ""\tyy_is_jam = (yy_current_state == 29);"", """", ""\t(void)yyg;"", ""\treturn yy_is_jam ? 0 : yy_current_state;"", ""}"", """", ""#ifndef YY_NO_UNPUT"", """", ""#endif"", """", ""#ifndef YY_NO_INPUT"", ""#ifdef __cplusplus"", ""    static int yyinput (yyscan_t yyscanner)""]","[0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, -1, 1, 1, 1, 0, 1, 1, 1, 0, -1, 1, 1, 0, -1, -1, -1, 1, 1, 0, -1, -1, -1, 1, 1, 0, -1, -1, 1, 1, 1, 1, 1, 0, -1, -1, 1, 1, 0, -1, -1, 1, 1, 0, -1, -1, -1, -1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, -1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1, 0, -1, -1, 1, 1, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0]","[[452, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [582, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [608, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [676, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [720, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [734, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [802, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [846, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""]]",702,692
"["" */"", ""    YY_BUFFER_STATE cmCommandArgument_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)"", ""{"", ""        YY_BUFFER_STATE b;"", ""\tYY_BUFFER_STATE b;"", """", ""        b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""        if ( ! b )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_create_buffer()\"" );"", ""\tb = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_create_buffer()\"" );"", """", ""        b->yy_buf_size = size;"", ""\tb->yy_buf_size = (yy_size_t)size;"", """", ""        /* yy_ch_buf has to be 2 characters longer than the size given because"", ""         * we need to put in 2 end-of-buffer characters."", ""         */"", ""        b->yy_ch_buf = (char *) cmCommandArgument_yyalloc(b->yy_buf_size + 2 ,yyscanner );"", ""        if ( ! b->yy_ch_buf )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_create_buffer()\"" );"", ""\t/* yy_ch_buf has to be 2 characters longer than the size given because"", ""\t * we need to put in 2 end-of-buffer characters."", ""\t */"", ""\tb->yy_ch_buf = (char *) cmCommandArgument_yyalloc(b->yy_buf_size + 2 ,yyscanner );"", ""\tif ( ! b->yy_ch_buf )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_create_buffer()\"" );"", """", ""        b->yy_is_our_buffer = 1;"", ""\tb->yy_is_our_buffer = 1;"", """", ""        cmCommandArgument_yy_init_buffer(b,file ,yyscanner);"", ""\tcmCommandArgument_yy_init_buffer(b,file ,yyscanner);"", """", ""        return b;"", ""\treturn b;"", ""}"", """", ""/** Destroy the buffer.""]","[0, 0, 0, -1, 1, 0, -1, -1, -2, 1, 1, 2, 0, -1, 1, 0, -1, -1, -1, -1, -1, -2, 1, 1, 1, 1, 1, 2, 0, -1, 1, 0, -1, 1, 0, -1, 1, 0, 0, 0]","[[8, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [11, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [21, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [27, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""]]",1400,1409
"[""void cmCommandArgument_yypop_buffer_state (yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""        if (!YY_CURRENT_BUFFER)"", ""                return;"", """", ""        cmCommandArgument_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);"", ""        YY_CURRENT_BUFFER_LVALUE = NULL;"", ""        if (yyg->yy_buffer_stack_top > 0)"", ""                --yyg->yy_buffer_stack_top;"", """", ""        if (YY_CURRENT_BUFFER) {"", ""                cmCommandArgument_yy_load_buffer_state(yyscanner );"", ""                yyg->yy_did_buffer_switch_on_eof = 1;"", ""        }"", ""\tif (!YY_CURRENT_BUFFER)"", ""\t\treturn;"", """", ""\tcmCommandArgument_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);"", ""\tYY_CURRENT_BUFFER_LVALUE = NULL;"", ""\tif (yyg->yy_buffer_stack_top > 0)"", ""\t\t--yyg->yy_buffer_stack_top;"", """", ""\tif (YY_CURRENT_BUFFER) {"", ""\t\tcmCommandArgument_yy_load_buffer_state(yyscanner );"", ""\t\tyyg->yy_did_buffer_switch_on_eof = 1;"", ""\t}"", ""}"", """", ""/* Allocates the stack if it does not exist."", "" *  Guarantees space for at least one push."", "" */"", ""static void cmCommandArgument_yyensure_buffer_stack (yyscan_t yyscanner)"", ""{"", ""        int num_to_alloc;"", ""\tint num_to_alloc;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        if (!yyg->yy_buffer_stack) {"", ""\tif (!yyg->yy_buffer_stack) {"", """", ""                /* First allocation is just for 2 elements, since we don't know if this"", ""                 * scanner will even need a stack. We use 2 instead of 1 to avoid an"", ""                 * immediate realloc on the next call."", ""\t\t/* First allocation is just for 2 elements, since we don't know if this"", ""\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an"", ""\t\t * immediate realloc on the next call."", ""         */"", ""                num_to_alloc = 1;"", ""                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyalloc"", ""                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)"", ""                                                                , yyscanner);"", ""                if ( ! yyg->yy_buffer_stack )"", ""                        YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()\"" );"", """", ""                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));"", """", ""                yyg->yy_buffer_stack_max = num_to_alloc;"", ""                yyg->yy_buffer_stack_top = 0;"", ""                return;"", ""        }"", """", ""        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){"", """", ""                /* Increase the buffer to prepare for a possible push. */"", ""                int grow_size = 8 /* arbitrary grow size */;"", """", ""                num_to_alloc = yyg->yy_buffer_stack_max + grow_size;"", ""                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyrealloc"", ""                                                                (yyg->yy_buffer_stack,"", ""                                                                num_to_alloc * sizeof(struct yy_buffer_state*)"", ""                                                                , yyscanner);"", ""                if ( ! yyg->yy_buffer_stack )"", ""                        YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()\"" );"", """", ""                /* zero only the new slots.*/"", ""                memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));"", ""                yyg->yy_buffer_stack_max = num_to_alloc;"", ""        }"", ""      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */"", ""\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyalloc"", ""\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)"", ""\t\t\t\t\t\t\t\t, yyscanner);"", ""\t\tif ( ! yyg->yy_buffer_stack )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()\"" );"", """", ""\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));"", """", ""\t\tyyg->yy_buffer_stack_max = num_to_alloc;"", ""\t\tyyg->yy_buffer_stack_top = 0;"", ""\t\treturn;"", ""\t}"", """", ""\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){"", """", ""\t\t/* Increase the buffer to prepare for a possible push. */"", ""\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;"", """", ""\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;"", ""\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyrealloc"", ""\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,"", ""\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)"", ""\t\t\t\t\t\t\t\t, yyscanner);"", ""\t\tif ( ! yyg->yy_buffer_stack )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()\"" );"", """", ""\t\t/* zero only the new slots.*/"", ""\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));"", ""\t\tyyg->yy_buffer_stack_max = num_to_alloc;"", ""\t}"", ""}"", """", ""/** Setup the input buffer state to scan directly from a user-specified character buffer.""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 0, 0]","[[53, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [73, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [84, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [104, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""]]",1543,1548
"["" */"", ""YY_BUFFER_STATE cmCommandArgument_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)"", ""{"", ""        YY_BUFFER_STATE b;"", """", ""        if ( size < 2 ||"", ""             base[size-2] != YY_END_OF_BUFFER_CHAR ||"", ""             base[size-1] != YY_END_OF_BUFFER_CHAR )"", ""                /* They forgot to leave room for the EOB's. */"", ""                return 0;"", """", ""        b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""        if ( ! b )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_scan_buffer()\"" );"", """", ""        b->yy_buf_size = size - 2;      /* \""- 2\"" to take care of EOB's */"", ""        b->yy_buf_pos = b->yy_ch_buf = base;"", ""        b->yy_is_our_buffer = 0;"", ""        b->yy_input_file = 0;"", ""        b->yy_n_chars = b->yy_buf_size;"", ""        b->yy_is_interactive = 0;"", ""        b->yy_at_bol = 1;"", ""        b->yy_fill_buffer = 0;"", ""        b->yy_buffer_status = YY_BUFFER_NEW;"", """", ""        cmCommandArgument_yy_switch_to_buffer(b ,yyscanner );"", """", ""        return b;"", ""\tYY_BUFFER_STATE b;"", """", ""\tif ( size < 2 ||"", ""\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||"", ""\t     base[size-1] != YY_END_OF_BUFFER_CHAR )"", ""\t\t/* They forgot to leave room for the EOB's. */"", ""\t\treturn NULL;"", """", ""\tb = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_scan_buffer()\"" );"", """", ""\tb->yy_buf_size = size - 2;\t/* \""- 2\"" to take care of EOB's */"", ""\tb->yy_buf_pos = b->yy_ch_buf = base;"", ""\tb->yy_is_our_buffer = 0;"", ""\tb->yy_input_file = NULL;"", ""\tb->yy_n_chars = b->yy_buf_size;"", ""\tb->yy_is_interactive = 0;"", ""\tb->yy_at_bol = 1;"", ""\tb->yy_fill_buffer = 0;"", ""\tb->yy_buffer_status = YY_BUFFER_NEW;"", """", ""\tcmCommandArgument_yy_switch_to_buffer(b ,yyscanner );"", """", ""\treturn b;"", ""}"", """", ""/** Setup the input buffer state to scan a string. The next call to cmCommandArgument_yylex() will""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[13, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_scan_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [38, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_scan_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""]]",1612,1617
"[""YY_BUFFER_STATE cmCommandArgument_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)"", ""{"", """", ""        return cmCommandArgument_yy_scan_bytes(yystr,strlen(yystr) ,yyscanner);"", ""\treturn cmCommandArgument_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);"", ""}"", """", ""/** Setup the input buffer state to scan the given bytes. The next call to cmCommandArgument_yylex() will"", "" * scan from a @e copy of @a yybytes."", "" * scan from a @e copy of @a bytes."", "" * @param yybytes the byte buffer to scan"", "" * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes."", "" * @param yyscanner The scanner object."", "" * @return the newly allocated buffer state object."", "" */"", ""YY_BUFFER_STATE cmCommandArgument_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)"", ""{"", ""        YY_BUFFER_STATE b;"", ""        char *buf;"", ""        yy_size_t n;"", ""        int i;"", ""\tYY_BUFFER_STATE b;"", ""\tchar *buf;"", ""\tyy_size_t n;"", ""\tyy_size_t i;"", """", ""        /* Get memory for full buffer, including space for trailing EOB's. */"", ""        n = _yybytes_len + 2;"", ""        buf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );"", ""        if ( ! buf )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_scan_bytes()\"" );"", ""\t/* Get memory for full buffer, including space for trailing EOB's. */"", ""\tn = (yy_size_t) _yybytes_len + 2;"", ""\tbuf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );"", ""\tif ( ! buf )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_scan_bytes()\"" );"", """", ""        for ( i = 0; i < _yybytes_len; ++i )"", ""                buf[i] = yybytes[i];"", ""\tfor ( i = 0; i < (size_t)_yybytes_len; ++i )"", ""\t\tbuf[i] = yybytes[i];"", """", ""        buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;"", ""\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;"", """", ""        b = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);"", ""        if ( ! b )"", ""                YY_FATAL_ERROR( \""bad buffer in cmCommandArgument_yy_scan_bytes()\"" );"", ""\tb = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""bad buffer in cmCommandArgument_yy_scan_bytes()\"" );"", """", ""        /* It's okay to grow etc. this buffer, and we should throw it"", ""         * away when we're done."", ""         */"", ""        b->yy_is_our_buffer = 1;"", ""\t/* It's okay to grow etc. this buffer, and we should throw it"", ""\t * away when we're done."", ""\t */"", ""\tb->yy_is_our_buffer = 1;"", """", ""        return b;"", ""\treturn b;"", ""}"", """", ""#ifndef YY_EXIT_FAILURE"", ""#define YY_EXIT_FAILURE 2"", ""#endif"", """", ""static void yy_fatal_error (yyconst char* msg , yyscan_t)"", ""static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)"", ""{"", ""        (void) fprintf( stderr, \""%s\\n\"", msg );"", ""        exit( YY_EXIT_FAILURE );"", ""\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""\t(void)yyg;"", ""\t(void) fprintf( stderr, \""%s\\n\"", msg );"", ""\texit( YY_EXIT_FAILURE );"", ""}"", """", ""/* Redefine yyless() so it works in section 3 code. */"", """", ""#undef yyless"", ""#define yyless(n) \\"", ""        do \\"", ""                { \\"", ""                /* Undo effects of setting up yytext. */ \\"", ""\tdo \\"", ""\t\t{ \\"", ""\t\t/* Undo effects of setting up yytext. */ \\"", ""        int yyless_macro_arg = (n); \\"", ""        YY_LESS_LINENO(yyless_macro_arg);\\"", ""                yytext[yyleng] = yyg->yy_hold_char; \\"", ""                yyg->yy_c_buf_p = yytext + yyless_macro_arg; \\"", ""                yyg->yy_hold_char = *yyg->yy_c_buf_p; \\"", ""                *yyg->yy_c_buf_p = '\\0'; \\"", ""                yyleng = yyless_macro_arg; \\"", ""                } \\"", ""        while ( 0 )"", ""\t\tyytext[yyleng] = yyg->yy_hold_char; \\"", ""\t\tyyg->yy_c_buf_p = yytext + yyless_macro_arg; \\"", ""\t\tyyg->yy_hold_char = *yyg->yy_c_buf_p; \\"", ""\t\t*yyg->yy_c_buf_p = '\\0'; \\"", ""\t\tyyleng = yyless_macro_arg; \\"", ""\t\t} \\"", ""\twhile ( 0 )"", """", ""/* Accessor  methods (get/set functions) to struct members. */"", """"]","[0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -2, 1, 1, 1, 1, 2, 0, -1, -1, 1, 1, 0, -1, 1, 0, -1, -1, -2, 1, 1, 2, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, -2, -1, 1, 1, 2, 1, 0, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[30, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [35, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmCommandArgument_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [47, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""bad buffer in cmCommandArgument_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [50, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""bad buffer in cmCommandArgument_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [72, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""(void) fprintf( stderr, \""%s\\n\"", msg );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [76, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""(void) fprintf( stderr, \""%s\\n\"", msg );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""]]",1650,1655
"[""}"", """", ""/** Set the current line number."", "" * @param line_number The line number to set."", "" * @param _line_number line number"", "" * @param yyscanner The scanner object."", "" */"", ""void cmCommandArgument_yyset_lineno (int  line_number , yyscan_t yyscanner)"", ""void cmCommandArgument_yyset_lineno (int  _line_number , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        /* lineno is only valid if an input buffer exists. */"", ""        if (! YY_CURRENT_BUFFER )"", ""           yy_fatal_error( \""cmCommandArgument_yyset_lineno called with no buffer\"" , yyscanner);"", ""           YY_FATAL_ERROR( \""cmCommandArgument_yyset_lineno called with no buffer\"" );"", """", ""    yylineno = line_number;"", ""    yylineno = _line_number;"", ""}"", """", ""/** Set the current column."", "" * @param column_no The column number to set."", "" * @param _column_no column number"", "" * @param yyscanner The scanner object."", "" */"", ""void cmCommandArgument_yyset_column (int  column_no , yyscan_t yyscanner)"", ""void cmCommandArgument_yyset_column (int  _column_no , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        /* column is only valid if an input buffer exists. */"", ""        if (! YY_CURRENT_BUFFER )"", ""           yy_fatal_error( \""cmCommandArgument_yyset_column called with no buffer\"" , yyscanner);"", ""           YY_FATAL_ERROR( \""cmCommandArgument_yyset_column called with no buffer\"" );"", """", ""    yycolumn = column_no;"", ""    yycolumn = _column_no;"", ""}"", """", ""/** Set the input stream. This does not discard the current"", "" * input buffer."", "" * @param in_str A readable stream."", "" * @param _in_str A readable stream."", "" * @param yyscanner The scanner object."", "" * @see cmCommandArgument_yy_switch_to_buffer"", "" */"", ""void cmCommandArgument_yyset_in (FILE *  in_str , yyscan_t yyscanner)"", ""void cmCommandArgument_yyset_in (FILE *  _in_str , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""    yyin = in_str ;"", ""    yyin = _in_str ;"", ""}"", """", ""void cmCommandArgument_yyset_out (FILE *  out_str , yyscan_t yyscanner)"", ""void cmCommandArgument_yyset_out (FILE *  _out_str , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""    yyout = out_str ;"", ""    yyout = _out_str ;"", ""}"", """", ""int cmCommandArgument_yyget_debug  (yyscan_t yyscanner)""]","[0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, -2, 2, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, -2, 2, 0, -1, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0]","[[14, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""yy_fatal_error( \""cmCommandArgument_yyset_lineno called with no buffer\"" , yyscanner);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [15, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""cmCommandArgument_yyset_lineno called with no buffer\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [33, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""-"", ""yy_fatal_error( \""cmCommandArgument_yyset_column called with no buffer\"" , yyscanner);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""], [34, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmCommandArgumentLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""cmCommandArgument_yyset_column called with no buffer\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_70_new.cpp""]]",1802,1809
"["""", ""/* Amount of stuff to slurp up with each read. */"", ""#ifndef YY_READ_BUF_SIZE"", ""#ifdef __ia64__"", ""/* On IA-64, the buffer size is 16k, not 8k */"", ""#define YY_READ_BUF_SIZE 16384"", ""#else"", ""#define YY_READ_BUF_SIZE 8192"", ""#endif /* __ia64__ */"", ""#endif"", """", ""/* Copy whatever the last rule matched to the standard output. */"", ""#ifndef ECHO"", ""/* This used to be an fputs(), but since the string might contain NUL's,"", "" * we now use fwrite()."", "" */"", ""#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )"", ""#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)"", ""#endif"", """", ""/* Gets input and stuffs it into \""buf\"".  number of characters read, or YY_NULL,"", "" * is returned in \""result\""."", "" */"", ""#ifndef YY_INPUT"", ""#define YY_INPUT(buf,result,max_size) \\"", ""  if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\"", ""    { \\"", ""    int c = '*'; \\"", ""    size_t n; \\"", ""    for ( n = 0; n < max_size && \\"", ""           (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\"", ""      buf[n] = (char) c; \\"", ""    if ( c == '\\n' ) \\"", ""      buf[n++] = (char) c; \\"", ""    if ( c == EOF && ferror( yyin ) ) \\"", ""      YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""    result = n; \\"", ""    } \\"", ""  else \\"", ""    { \\"", ""    errno=0; \\"", ""    while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\"", ""      { \\"", ""      if( errno != EINTR) \\"", ""        { \\"", ""        YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""        break; \\"", ""        } \\"", ""      errno=0; \\"", ""      clearerr(yyin); \\"", ""      } \\"", ""    }\\"", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\"", ""\t\t{ \\"", ""\t\tint c = '*'; \\"", ""\t\tsize_t n; \\"", ""\t\tfor ( n = 0; n < max_size && \\"", ""\t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\"", ""\t\t\tbuf[n] = (char) c; \\"", ""\t\tif ( c == '\\n' ) \\"", ""\t\t\tbuf[n++] = (char) c; \\"", ""\t\tif ( c == EOF && ferror( yyin ) ) \\"", ""\t\t\tYY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""\t\tresult = n; \\"", ""\t\t} \\"", ""\telse \\"", ""\t\t{ \\"", ""\t\terrno=0; \\"", ""\t\twhile ( (result = (int) fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\"", ""\t\t\t{ \\"", ""\t\t\tif( errno != EINTR) \\"", ""\t\t\t\t{ \\"", ""\t\t\t\tYY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""\t\t\t\tbreak; \\"", ""\t\t\t\t} \\"", ""\t\t\terrno=0; \\"", ""\t\t\tclearerr(yyin); \\"", ""\t\t\t} \\"", ""\t\t}\\"", ""\\"", """", ""#endif""]","[0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[35, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [45, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [62, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [72, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""]]",589,592
"["""", ""/* Code executed at the end of each rule. */"", ""#ifndef YY_BREAK"", ""#define YY_BREAK break;"", ""#define YY_BREAK /*LINTED*/break;"", ""#endif"", """", ""#define YY_RULE_SETUP \\"", ""  YY_USER_ACTION"", ""\tYY_USER_ACTION"", """", ""/** The main scanner function which does all the work."", "" */"", ""YY_DECL"", ""{"", ""  yy_state_type yy_current_state;"", ""  char *yy_cp, *yy_bp;"", ""  int yy_act;"", ""\tyy_state_type yy_current_state;"", ""\tchar *yy_cp, *yy_bp;"", ""\tint yy_act;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""#line 86 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""\tif ( !yyg->yy_init )"", ""\t\t{"", ""\t\tyyg->yy_init = 1;"", """", ""#ifdef YY_USER_INIT"", ""\t\tYY_USER_INIT;"", ""#endif"", """", ""#line 736 \""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx\"""", ""\t\tif ( ! yyg->yy_start )"", ""\t\t\tyyg->yy_start = 1;\t/* first start state */"", """", ""  if ( yyg->yy_init )"", ""    {"", ""    yyg->yy_init = 0;"", ""\t\tif ( ! yyin )"", ""\t\t\tyyin = stdin;"", """", ""#ifdef YY_USER_INIT"", ""    YY_USER_INIT;"", ""#endif"", ""\t\tif ( ! yyout )"", ""\t\t\tyyout = stdout;"", """", ""    if ( ! yyg->yy_start )"", ""      yyg->yy_start = 1;  /* first start state */"", ""\t\tif ( ! YY_CURRENT_BUFFER ) {"", ""\t\t\tcmExpr_yyensure_buffer_stack (yyscanner);"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE ="", ""\t\t\t\tcmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);"", ""\t\t}"", """", ""    if ( ! yyin )"", ""      yyin = stdin;"", ""\t\tcmExpr_yy_load_buffer_state(yyscanner );"", ""\t\t}"", """", ""    if ( ! yyout )"", ""      yyout = stdout;"", ""\t{"", ""#line 39 \""cmExprLexer.in.l\"""", """", ""    if ( ! YY_CURRENT_BUFFER ) {"", ""      cmExpr_yyensure_buffer_stack (yyscanner);"", ""      YY_CURRENT_BUFFER_LVALUE ="", ""        cmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);"", ""    }"", """", ""    cmExpr_yy_load_buffer_state(yyscanner );"", ""    }"", ""#line 732 \""cmExprLexer.cxx\"""", """", ""  for(;;)    /* loops until end-of-file is reached */"", ""    {"", ""    yy_cp = yyg->yy_c_buf_p;"", ""\twhile ( /*CONSTCOND*/1 )\t\t/* loops until end-of-file is reached */"", ""\t\t{"", ""\t\tyy_cp = yyg->yy_c_buf_p;"", """", ""    /* Support of yytext. */"", ""    *yy_cp = yyg->yy_hold_char;"", ""\t\t/* Support of yytext. */"", ""\t\t*yy_cp = yyg->yy_hold_char;"", """", ""    /* yy_bp points to the position in yy_ch_buf of the start of"", ""     * the current run."", ""     */"", ""    yy_bp = yy_cp;"", ""\t\t/* yy_bp points to the position in yy_ch_buf of the start of"", ""\t\t * the current run."", ""\t\t */"", ""\t\tyy_bp = yy_cp;"", """", ""    yy_current_state = yyg->yy_start;"", ""\t\tyy_current_state = yyg->yy_start;"", ""yy_match:"", ""    do"", ""      {"", ""      YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];"", ""      if ( yy_accept[yy_current_state] )"", ""        {"", ""        yyg->yy_last_accepting_state = yy_current_state;"", ""        yyg->yy_last_accepting_cpos = yy_cp;"", ""        }"", ""      while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""        {"", ""        yy_current_state = (int) yy_def[yy_current_state];"", ""        if ( yy_current_state >= 23 )"", ""          yy_c = yy_meta[(unsigned int) yy_c];"", ""        }"", ""      yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""      ++yy_cp;"", ""      }"", ""    while ( yy_base[yy_current_state] != 21 );"", ""\t\tdo"", ""\t\t\t{"", ""\t\t\tYY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;"", ""\t\t\tif ( yy_accept[yy_current_state] )"", ""\t\t\t\t{"", ""\t\t\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\t\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t\t\t}"", ""\t\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t\t\t{"", ""\t\t\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\t\t\tif ( yy_current_state >= 23 )"", ""\t\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t\t\t}"", ""\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];"", ""\t\t\t++yy_cp;"", ""\t\t\t}"", ""\t\twhile ( yy_base[yy_current_state] != 21 );"", """", ""yy_find_action:"", ""    yy_act = yy_accept[yy_current_state];"", ""    if ( yy_act == 0 )"", ""      { /* have to back up */"", ""      yy_cp = yyg->yy_last_accepting_cpos;"", ""      yy_current_state = yyg->yy_last_accepting_state;"", ""      yy_act = yy_accept[yy_current_state];"", ""      }"", """", ""    YY_DO_BEFORE_ACTION;"", """", ""do_action:  /* This label is used only to access EOF actions. */"", """", ""    switch ( yy_act )"", ""  { /* beginning of action switch */"", ""      case 0: /* must back up */"", ""      /* undo the effects of YY_DO_BEFORE_ACTION */"", ""      *yy_cp = yyg->yy_hold_char;"", ""      yy_cp = yyg->yy_last_accepting_cpos;"", ""      yy_current_state = yyg->yy_last_accepting_state;"", ""      goto yy_find_action;"", ""\t\tyy_act = yy_accept[yy_current_state];"", ""\t\tif ( yy_act == 0 )"", ""\t\t\t{ /* have to back up */"", ""\t\t\tyy_cp = yyg->yy_last_accepting_cpos;"", ""\t\t\tyy_current_state = yyg->yy_last_accepting_state;"", ""\t\t\tyy_act = yy_accept[yy_current_state];"", ""\t\t\t}"", """", ""\t\tYY_DO_BEFORE_ACTION;"", """", ""do_action:\t/* This label is used only to access EOF actions. */"", """", ""\t\tswitch ( yy_act )"", ""\t{ /* beginning of action switch */"", ""\t\t\tcase 0: /* must back up */"", ""\t\t\t/* undo the effects of YY_DO_BEFORE_ACTION */"", ""\t\t\t*yy_cp = yyg->yy_hold_char;"", ""\t\t\tyy_cp = yyg->yy_last_accepting_cpos;"", ""\t\t\tyy_current_state = yyg->yy_last_accepting_state;"", ""\t\t\tgoto yy_find_action;"", """", ""case 1:"", ""YY_RULE_SETUP"", ""#line 88 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 41 \""cmExprLexer.in.l\"""", ""{ yylvalp->Number = atoi(yytext); return exp_NUMBER; }"", ""\tYY_BREAK"", ""case 2:"", ""YY_RULE_SETUP"", ""#line 90 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 43 \""cmExprLexer.in.l\"""", ""{ return exp_PLUS; }"", ""\tYY_BREAK"", ""case 3:"", ""YY_RULE_SETUP"", ""#line 91 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 44 \""cmExprLexer.in.l\"""", ""{ return exp_MINUS; }"", ""\tYY_BREAK"", ""case 4:"", ""YY_RULE_SETUP"", ""#line 92 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 45 \""cmExprLexer.in.l\"""", ""{ return exp_TIMES; }"", ""\tYY_BREAK"", ""case 5:"", ""YY_RULE_SETUP"", ""#line 93 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 46 \""cmExprLexer.in.l\"""", ""{ return exp_DIVIDE; }"", ""\tYY_BREAK"", ""case 6:"", ""YY_RULE_SETUP"", ""#line 94 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 47 \""cmExprLexer.in.l\"""", ""{ return exp_MOD; }"", ""\tYY_BREAK"", ""case 7:"", ""YY_RULE_SETUP"", ""#line 95 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 48 \""cmExprLexer.in.l\"""", ""{ return exp_OR; }"", ""\tYY_BREAK"", ""case 8:"", ""YY_RULE_SETUP"", ""#line 96 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 49 \""cmExprLexer.in.l\"""", ""{ return exp_AND; }"", ""\tYY_BREAK"", ""case 9:"", ""YY_RULE_SETUP"", ""#line 97 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 50 \""cmExprLexer.in.l\"""", ""{ return exp_XOR; }"", ""\tYY_BREAK"", ""case 10:"", ""YY_RULE_SETUP"", ""#line 98 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 51 \""cmExprLexer.in.l\"""", ""{ return exp_NOT; }"", ""\tYY_BREAK"", ""case 11:"", ""YY_RULE_SETUP"", ""#line 99 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 52 \""cmExprLexer.in.l\"""", ""{ return exp_SHIFTLEFT; }"", ""\tYY_BREAK"", ""case 12:"", ""YY_RULE_SETUP"", ""#line 100 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 53 \""cmExprLexer.in.l\"""", ""{ return exp_SHIFTRIGHT; }"", ""\tYY_BREAK"", ""case 13:"", ""YY_RULE_SETUP"", ""#line 101 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 54 \""cmExprLexer.in.l\"""", ""{ return exp_OPENPARENT; }"", ""\tYY_BREAK"", ""case 14:"", ""YY_RULE_SETUP"", ""#line 102 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 55 \""cmExprLexer.in.l\"""", ""{ return exp_CLOSEPARENT; }"", ""\tYY_BREAK"", ""case 15:"", ""YY_RULE_SETUP"", ""#line 104 \""/home/andy/vtk/CMake/Source/cmExprLexer.in.l\"""", ""#line 57 \""cmExprLexer.in.l\"""", ""ECHO;"", ""  YY_BREAK"", ""#line 894 \""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx\"""", ""\tYY_BREAK"", ""#line 864 \""cmExprLexer.cxx\"""", ""case YY_STATE_EOF(INITIAL):"", ""  yyterminate();"", """", ""  case YY_END_OF_BUFFER:"", ""    {"", ""    /* Amount of text matched not including the EOB char. */"", ""    int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;"", """", ""    /* Undo the effects of YY_DO_BEFORE_ACTION. */"", ""    *yy_cp = yyg->yy_hold_char;"", ""    YY_RESTORE_YY_MORE_OFFSET"", """", ""    if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )"", ""      {"", ""      /* We're scanning a new file or input source.  It's"", ""       * possible that this happened because the user"", ""       * just pointed yyin at a new source and called"", ""       * cmExpr_yylex().  If so, then we have to assure"", ""       * consistency between YY_CURRENT_BUFFER and our"", ""       * globals.  Here is the right place to do so, because"", ""       * this is the first action (other than possibly a"", ""       * back-up) that will match for the new input source."", ""       */"", ""      yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;"", ""      YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;"", ""      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;"", ""      }"", """", ""    /* Note that here we test for yy_c_buf_p \""<=\"" to the position"", ""     * of the first EOB in the buffer, since yy_c_buf_p will"", ""     * already have been incremented past the NUL character"", ""     * (since all states make transitions on EOB to the"", ""     * end-of-buffer state).  Contrast this with the test"", ""     * in input()."", ""     */"", ""    if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )"", ""      { /* This was really a NUL. */"", ""      yy_state_type yy_next_state;"", """", ""      yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""      yy_current_state = yy_get_previous_state( yyscanner );"", """", ""      /* Okay, we're now positioned to make the NUL"", ""       * transition.  We couldn't have"", ""       * yy_get_previous_state() go ahead and do it"", ""       * for us because it doesn't know how to deal"", ""       * with the possibility of jamming (and we don't"", ""       * want to build jamming into it because then it"", ""       * will run more slowly)."", ""       */"", """", ""      yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);"", """", ""      yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""      if ( yy_next_state )"", ""        {"", ""        /* Consume the NUL. */"", ""        yy_cp = ++yyg->yy_c_buf_p;"", ""        yy_current_state = yy_next_state;"", ""        goto yy_match;"", ""        }"", """", ""      else"", ""        {"", ""        yy_cp = yyg->yy_c_buf_p;"", ""        goto yy_find_action;"", ""        }"", ""      }"", """", ""    else switch ( yy_get_next_buffer( yyscanner ) )"", ""      {"", ""      case EOB_ACT_END_OF_FILE:"", ""        {"", ""        yyg->yy_did_buffer_switch_on_eof = 0;"", """", ""        if ( cmExpr_yywrap(yyscanner ) )"", ""          {"", ""          /* Note: because we've taken care in"", ""           * yy_get_next_buffer() to have set up"", ""           * yytext, we can now set up"", ""           * yy_c_buf_p so that if some total"", ""           * hoser (like flex itself) wants to"", ""           * call the scanner after we return the"", ""           * YY_NULL, it'll still work - another"", ""           * YY_NULL will get returned."", ""           */"", ""          yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""          yy_act = YY_STATE_EOF(YY_START);"", ""          goto do_action;"", ""          }"", """", ""        else"", ""          {"", ""          if ( ! yyg->yy_did_buffer_switch_on_eof )"", ""            YY_NEW_FILE;"", ""          }"", ""        break;"", ""        }"", """", ""      case EOB_ACT_CONTINUE_SCAN:"", ""        yyg->yy_c_buf_p ="", ""          yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""        yy_current_state = yy_get_previous_state( yyscanner );"", """", ""        yy_cp = yyg->yy_c_buf_p;"", ""        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""        goto yy_match;"", """", ""      case EOB_ACT_LAST_MATCH:"", ""        yyg->yy_c_buf_p ="", ""        &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];"", """", ""        yy_current_state = yy_get_previous_state( yyscanner );"", """", ""        yy_cp = yyg->yy_c_buf_p;"", ""        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""        goto yy_find_action;"", ""      }"", ""    break;"", ""    }"", """", ""  default:"", ""    YY_FATAL_ERROR("", ""      \""fatal flex scanner internal error--no action found\"" );"", ""  } /* end of action switch */"", ""    } /* end of scanning one token */"", ""return 0; /* this should not happen but it quiets some compilers */"", ""\tyyterminate();"", """", ""\tcase YY_END_OF_BUFFER:"", ""\t\t{"", ""\t\t/* Amount of text matched not including the EOB char. */"", ""\t\tint yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;"", """", ""\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */"", ""\t\t*yy_cp = yyg->yy_hold_char;"", ""\t\tYY_RESTORE_YY_MORE_OFFSET"", """", ""\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )"", ""\t\t\t{"", ""\t\t\t/* We're scanning a new file or input source.  It's"", ""\t\t\t * possible that this happened because the user"", ""\t\t\t * just pointed yyin at a new source and called"", ""\t\t\t * cmExpr_yylex().  If so, then we have to assure"", ""\t\t\t * consistency between YY_CURRENT_BUFFER and our"", ""\t\t\t * globals.  Here is the right place to do so, because"", ""\t\t\t * this is the first action (other than possibly a"", ""\t\t\t * back-up) that will match for the new input source."", ""\t\t\t */"", ""\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;"", ""\t\t\t}"", """", ""\t\t/* Note that here we test for yy_c_buf_p \""<=\"" to the position"", ""\t\t * of the first EOB in the buffer, since yy_c_buf_p will"", ""\t\t * already have been incremented past the NUL character"", ""\t\t * (since all states make transitions on EOB to the"", ""\t\t * end-of-buffer state).  Contrast this with the test"", ""\t\t * in input()."", ""\t\t */"", ""\t\tif ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )"", ""\t\t\t{ /* This was really a NUL. */"", ""\t\t\tyy_state_type yy_next_state;"", """", ""\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t/* Okay, we're now positioned to make the NUL"", ""\t\t\t * transition.  We couldn't have"", ""\t\t\t * yy_get_previous_state() go ahead and do it"", ""\t\t\t * for us because it doesn't know how to deal"", ""\t\t\t * with the possibility of jamming (and we don't"", ""\t\t\t * want to build jamming into it because then it"", ""\t\t\t * will run more slowly)."", ""\t\t\t */"", """", ""\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);"", """", ""\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""\t\t\tif ( yy_next_state )"", ""\t\t\t\t{"", ""\t\t\t\t/* Consume the NUL. */"", ""\t\t\t\tyy_cp = ++yyg->yy_c_buf_p;"", ""\t\t\t\tyy_current_state = yy_next_state;"", ""\t\t\t\tgoto yy_match;"", ""\t\t\t\t}"", """", ""\t\t\telse"", ""\t\t\t\t{"", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tgoto yy_find_action;"", ""\t\t\t\t}"", ""\t\t\t}"", """", ""\t\telse switch ( yy_get_next_buffer( yyscanner ) )"", ""\t\t\t{"", ""\t\t\tcase EOB_ACT_END_OF_FILE:"", ""\t\t\t\t{"", ""\t\t\t\tyyg->yy_did_buffer_switch_on_eof = 0;"", """", ""\t\t\t\tif ( cmExpr_yywrap(yyscanner ) )"", ""\t\t\t\t\t{"", ""\t\t\t\t\t/* Note: because we've taken care in"", ""\t\t\t\t\t * yy_get_next_buffer() to have set up"", ""\t\t\t\t\t * yytext, we can now set up"", ""\t\t\t\t\t * yy_c_buf_p so that if some total"", ""\t\t\t\t\t * hoser (like flex itself) wants to"", ""\t\t\t\t\t * call the scanner after we return the"", ""\t\t\t\t\t * YY_NULL, it'll still work - another"", ""\t\t\t\t\t * YY_NULL will get returned."", ""\t\t\t\t\t */"", ""\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);"", ""\t\t\t\t\tgoto do_action;"", ""\t\t\t\t\t}"", """", ""\t\t\t\telse"", ""\t\t\t\t\t{"", ""\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )"", ""\t\t\t\t\t\tYY_NEW_FILE;"", ""\t\t\t\t\t}"", ""\t\t\t\tbreak;"", ""\t\t\t\t}"", """", ""\t\t\tcase EOB_ACT_CONTINUE_SCAN:"", ""\t\t\t\tyyg->yy_c_buf_p ="", ""\t\t\t\t\tyyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""\t\t\t\tgoto yy_match;"", """", ""\t\t\tcase EOB_ACT_LAST_MATCH:"", ""\t\t\t\tyyg->yy_c_buf_p ="", ""\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];"", """", ""\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""\t\t\t\tgoto yy_find_action;"", ""\t\t\t}"", ""\t\tbreak;"", ""\t\t}"", """", ""\tdefault:"", ""\t\tYY_FATAL_ERROR("", ""\t\t\t\""fatal flex scanner internal error--no action found\"" );"", ""\t} /* end of action switch */"", ""\t\t} /* end of scanning one token */"", ""\t} /* end of user's declarations */"", ""} /* end of cmExpr_yylex */"", """", ""/* yy_get_next_buffer - try to read in a new buffer"", "" *"", "" * Returns a code representing an action:"", "" *  EOB_ACT_LAST_MATCH -"", "" *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position"", "" *  EOB_ACT_END_OF_FILE - end of file"", "" *\tEOB_ACT_LAST_MATCH -"", "" *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position"", "" *\tEOB_ACT_END_OF_FILE - end of file"", "" */"", ""static int yy_get_next_buffer (yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""  char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;"", ""  char *source = yyg->yytext_ptr;"", ""  int number_to_move, i;"", ""  int ret_val;"", """", ""  if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )"", ""    YY_FATAL_ERROR("", ""    \""fatal flex scanner internal error--end of buffer missed\"" );"", """", ""  if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )"", ""    { /* Don't try to fill the buffer, so this is an EOF. */"", ""    if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )"", ""      {"", ""      /* We matched a single character, the EOB, so"", ""       * treat this as a final EOF."", ""       */"", ""      return EOB_ACT_END_OF_FILE;"", ""      }"", """", ""    else"", ""      {"", ""      /* We matched some text prior to the EOB, first"", ""       * process it."", ""       */"", ""      return EOB_ACT_LAST_MATCH;"", ""      }"", ""    }"", """", ""  /* Try to read more data. */"", """", ""  /* First move last chars to start of buffer. */"", ""  number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;"", """", ""  for ( i = 0; i < number_to_move; ++i )"", ""    *(dest++) = *(source++);"", """", ""  if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )"", ""    /* don't do the read, it's not guaranteed to return an EOF,"", ""     * just force an EOF"", ""     */"", ""    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;"", """", ""  else"", ""    {"", ""      size_t nuto_read ="", ""      YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;"", """", ""    while ( nuto_read <= 0 )"", ""      { /* Not enough room in the buffer - grow it. */"", """", ""      /* just a shorter name for the current buffer */"", ""      YY_BUFFER_STATE b = YY_CURRENT_BUFFER;"", """", ""      int yy_c_buf_p_offset ="", ""        (int) (yyg->yy_c_buf_p - b->yy_ch_buf);"", """", ""      if ( b->yy_is_our_buffer )"", ""        {"", ""        int new_size = b->yy_buf_size * 2;"", """", ""        if ( new_size <= 0 )"", ""          b->yy_buf_size += b->yy_buf_size / 8;"", ""        else"", ""          b->yy_buf_size *= 2;"", """", ""        b->yy_ch_buf = (char *)"", ""          /* Include room in for 2 EOB chars. */"", ""          cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );"", ""        }"", ""      else"", ""        /* Can't grow it, we don't own it. */"", ""        b->yy_ch_buf = 0;"", """", ""      if ( ! b->yy_ch_buf )"", ""        YY_FATAL_ERROR("", ""        \""fatal error - scanner input buffer overflow\"" );"", """", ""      yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];"", """", ""      nuto_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -"", ""            number_to_move - 1;"", """", ""      }"", """", ""    if ( nuto_read > YY_READ_BUF_SIZE )"", ""      nuto_read = YY_READ_BUF_SIZE;"", """", ""    /* Read in more data. */"", ""    YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),"", ""      yyg->yy_n_chars, nuto_read );"", """", ""    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;"", ""    }"", ""\tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;"", ""\tchar *source = yyg->yytext_ptr;"", ""\tyy_size_t number_to_move, i;"", ""\tint ret_val;"", """", ""\tif ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )"", ""\t\tYY_FATAL_ERROR("", ""\t\t\""fatal flex scanner internal error--end of buffer missed\"" );"", """", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )"", ""\t\t{ /* Don't try to fill the buffer, so this is an EOF. */"", ""\t\tif ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )"", ""\t\t\t{"", ""\t\t\t/* We matched a single character, the EOB, so"", ""\t\t\t * treat this as a final EOF."", ""\t\t\t */"", ""\t\t\treturn EOB_ACT_END_OF_FILE;"", ""\t\t\t}"", """", ""\t\telse"", ""\t\t\t{"", ""\t\t\t/* We matched some text prior to the EOB, first"", ""\t\t\t * process it."", ""\t\t\t */"", ""\t\t\treturn EOB_ACT_LAST_MATCH;"", ""\t\t\t}"", ""\t\t}"", """", ""\t/* Try to read more data. */"", """", ""\t/* First move last chars to start of buffer. */"", ""\tnumber_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;"", """", ""\tfor ( i = 0; i < number_to_move; ++i )"", ""\t\t*(dest++) = *(source++);"", """", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )"", ""\t\t/* don't do the read, it's not guaranteed to return an EOF,"", ""\t\t * just force an EOF"", ""\t\t */"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;"", """", ""\telse"", ""\t\t{"", ""\t\t\tint num_to_read ="", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;"", """", ""\t\twhile ( num_to_read <= 0 )"", ""\t\t\t{ /* Not enough room in the buffer - grow it. */"", """", ""\t\t\t/* just a shorter name for the current buffer */"", ""\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;"", """", ""\t\t\tint yy_c_buf_p_offset ="", ""\t\t\t\t(int) (yyg->yy_c_buf_p - b->yy_ch_buf);"", """", ""\t\t\tif ( b->yy_is_our_buffer )"", ""\t\t\t\t{"", ""\t\t\t\tint new_size = b->yy_buf_size * 2;"", """", ""\t\t\t\tif ( new_size <= 0 )"", ""\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;"", ""\t\t\t\telse"", ""\t\t\t\t\tb->yy_buf_size *= 2;"", """", ""\t\t\t\tb->yy_ch_buf = (char *)"", ""\t\t\t\t\t/* Include room in for 2 EOB chars. */"", ""\t\t\t\t\tcmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );"", ""\t\t\t\t}"", ""\t\t\telse"", ""\t\t\t\t/* Can't grow it, we don't own it. */"", ""\t\t\t\tb->yy_ch_buf = NULL;"", """", ""\t\t\tif ( ! b->yy_ch_buf )"", ""\t\t\t\tYY_FATAL_ERROR("", ""\t\t\t\t\""fatal error - scanner input buffer overflow\"" );"", """", ""\t\t\tyyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];"", """", ""\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -"", ""\t\t\t\t\t\tnumber_to_move - 1;"", """", ""\t\t\t}"", """", ""\t\tif ( num_to_read > YY_READ_BUF_SIZE )"", ""\t\t\tnum_to_read = YY_READ_BUF_SIZE;"", """", ""\t\t/* Read in more data. */"", ""\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),"", ""\t\t\tyyg->yy_n_chars, num_to_read );"", """", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;"", ""\t\t}"", """", ""\tif ( yyg->yy_n_chars == 0 )"", ""\t\t{"", ""\t\tif ( number_to_move == YY_MORE_ADJ )"", ""\t\t\t{"", ""\t\t\tret_val = EOB_ACT_END_OF_FILE;"", ""\t\t\tcmExpr_yyrestart(yyin  ,yyscanner);"", ""\t\t\t}"", """", ""\t\telse"", ""\t\t\t{"", ""\t\t\tret_val = EOB_ACT_LAST_MATCH;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status ="", ""\t\t\t\tYY_BUFFER_EOF_PENDING;"", ""\t\t\t}"", ""\t\t}"", """", ""\telse"", ""\t\tret_val = EOB_ACT_CONTINUE_SCAN;"", """", ""\tif ((int) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {"", ""\t\t/* Extend the array by 50%, plus the number we really need. */"", ""\t\tint new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmExpr_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );"", ""\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", ""\t}"", """", ""\tyyg->yy_n_chars += number_to_move;"", ""\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;"", ""\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;"", """", ""\tyyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];"", """", ""  if ( yyg->yy_n_chars == 0 )"", ""    {"", ""    if ( number_to_move == YY_MORE_ADJ )"", ""      {"", ""      ret_val = EOB_ACT_END_OF_FILE;"", ""      cmExpr_yyrestart(yyin  ,yyscanner);"", ""      }"", """", ""    else"", ""      {"", ""      ret_val = EOB_ACT_LAST_MATCH;"", ""      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status ="", ""        YY_BUFFER_EOF_PENDING;"", ""      }"", ""    }"", """", ""  else"", ""    ret_val = EOB_ACT_CONTINUE_SCAN;"", """", ""  yyg->yy_n_chars += number_to_move;"", ""  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;"", ""  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;"", """", ""  yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];"", """", ""  return ret_val;"", ""\treturn ret_val;"", ""}"", """", ""/* yy_get_previous_state - get the state just before the EOB char was"", ""   reached */"", ""/* yy_get_previous_state - get the state just before the EOB char was reached */"", """", ""    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)"", ""{"", ""  yy_state_type yy_current_state;"", ""  char *yy_cp;"", ""\tyy_state_type yy_current_state;"", ""\tchar *yy_cp;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""  yy_current_state = yyg->yy_start;"", """", ""  for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )"", ""    {"", ""    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);"", ""    if ( yy_accept[yy_current_state] )"", ""      {"", ""      yyg->yy_last_accepting_state = yy_current_state;"", ""      yyg->yy_last_accepting_cpos = yy_cp;"", ""      }"", ""    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""      {"", ""      yy_current_state = (int) yy_def[yy_current_state];"", ""      if ( yy_current_state >= 23 )"", ""        yy_c = yy_meta[(unsigned int) yy_c];"", ""      }"", ""    yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""    }"", """", ""  return yy_current_state;"", ""\tyy_current_state = yyg->yy_start;"", """", ""\tfor ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )"", ""\t\t{"", ""\t\tYY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);"", ""\t\tif ( yy_accept[yy_current_state] )"", ""\t\t\t{"", ""\t\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t\t}"", ""\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t\t{"", ""\t\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\t\tif ( yy_current_state >= 23 )"", ""\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t\t}"", ""\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];"", ""\t\t}"", """", ""\treturn yy_current_state;"", ""}"", """", ""/* yy_try_NUL_trans - try to make a transition on the NUL character"", "" *"", "" * synopsis"", "" *  next_state = yy_try_NUL_trans( current_state );"", "" *\tnext_state = yy_try_NUL_trans( current_state );"", "" */"", ""    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)"", ""{"", ""  int yy_is_jam;"", ""\tint yy_is_jam;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */"", ""\tchar *yy_cp = yyg->yy_c_buf_p;"", """", ""\tYY_CHAR yy_c = 1;"", ""\tif ( yy_accept[yy_current_state] )"", ""\t\t{"", ""\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t}"", ""\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t{"", ""\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\tif ( yy_current_state >= 23 )"", ""\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t}"", ""\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];"", ""\tyy_is_jam = (yy_current_state == 22);"", """", ""\t(void)yyg;"", ""\treturn yy_is_jam ? 0 : yy_current_state;"", ""}"", """", ""#ifndef YY_NO_UNPUT"", """", ""    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)"", ""{"", ""\tchar *yy_cp;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""  char *yy_cp = yyg->yy_c_buf_p;"", """", ""  YY_CHAR yy_c = 1;"", ""  if ( yy_accept[yy_current_state] )"", ""    {"", ""    yyg->yy_last_accepting_state = yy_current_state;"", ""    yyg->yy_last_accepting_cpos = yy_cp;"", ""    }"", ""  while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""    {"", ""    yy_current_state = (int) yy_def[yy_current_state];"", ""    if ( yy_current_state >= 23 )"", ""      yy_c = yy_meta[(unsigned int) yy_c];"", ""    }"", ""  yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""  yy_is_jam = (yy_current_state == 22);"", ""    yy_cp = yyg->yy_c_buf_p;"", """", ""\t/* undo effects of setting up yytext */"", ""\t*yy_cp = yyg->yy_hold_char;"", """", ""\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )"", ""\t\t{ /* need to shift things up to make room */"", ""\t\t/* +2 for EOB chars. */"", ""\t\tint number_to_move = yyg->yy_n_chars + 2;"", ""\t\tchar *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf["", ""\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];"", ""\t\tchar *source ="", ""\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];"", """", ""  return yy_is_jam ? 0 : yy_current_state;"", ""\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""\t\t\t*--dest = *--source;"", """", ""\t\tyy_cp += (int) (dest - source);"", ""\t\tyy_bp += (int) (dest - source);"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars ="", ""\t\t\tyyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;"", """", ""\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )"", ""\t\t\tYY_FATAL_ERROR( \""flex scanner push-back overflow\"" );"", ""\t\t}"", """", ""\t*--yy_cp = (char) c;"", """", ""\tyyg->yytext_ptr = yy_bp;"", ""\tyyg->yy_hold_char = *yy_cp;"", ""\tyyg->yy_c_buf_p = yy_cp;"", ""}"", """", ""#endif"", """", ""#ifndef YY_NO_INPUT"", ""#ifdef __cplusplus"", ""    static int yyinput (yyscan_t yyscanner)""]","[0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, -1, 1, 1, 1, 0, 1, 1, 1, 0, -1, 1, 1, 0, -1, -1, -1, 1, 1, 0, -1, -1, -1, 1, 1, 0, -1, -1, 1, 1, 1, 1, 1, 0, -1, -1, 1, 1, 0, -1, -1, 1, 1, 0, -1, -1, -1, -1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, -1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, 1, 0, 0, -1, 1, 0, -1, -1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, 0, -1, -1, 1, 0, 0, 0, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0]","[[398, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [528, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [554, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [622, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [647, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [715, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [759, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [929, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""flex scanner push-back overflow\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""]]",676,684
"["" */"", ""    YY_BUFFER_STATE cmExpr_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)"", ""{"", ""  YY_BUFFER_STATE b;"", ""\tYY_BUFFER_STATE b;"", """", ""  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""  if ( ! b )"", ""    YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_create_buffer()\"" );"", ""\tb = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_create_buffer()\"" );"", """", ""  b->yy_buf_size = size;"", ""\tb->yy_buf_size = (yy_size_t)size;"", """", ""  /* yy_ch_buf has to be 2 characters longer than the size given because"", ""   * we need to put in 2 end-of-buffer characters."", ""   */"", ""  b->yy_ch_buf = (char *) cmExpr_yyalloc(b->yy_buf_size + 2 ,yyscanner );"", ""  if ( ! b->yy_ch_buf )"", ""    YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_create_buffer()\"" );"", ""\t/* yy_ch_buf has to be 2 characters longer than the size given because"", ""\t * we need to put in 2 end-of-buffer characters."", ""\t */"", ""\tb->yy_ch_buf = (char *) cmExpr_yyalloc(b->yy_buf_size + 2 ,yyscanner );"", ""\tif ( ! b->yy_ch_buf )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_create_buffer()\"" );"", """", ""  b->yy_is_our_buffer = 1;"", ""\tb->yy_is_our_buffer = 1;"", """", ""  cmExpr_yy_init_buffer(b,file ,yyscanner);"", ""\tcmExpr_yy_init_buffer(b,file ,yyscanner);"", """", ""  return b;"", ""\treturn b;"", ""}"", """", ""/** Destroy the buffer.""]","[0, 0, 0, -1, 1, 0, -1, -1, -2, 1, 1, 2, 0, -1, 1, 0, -1, -1, -1, -1, -1, -2, 1, 1, 1, 1, 1, 2, 0, -1, 1, 0, -1, 1, 0, -1, 1, 0, 0, 0]","[[8, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [11, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [21, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [27, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""]]",1311,1384
"[""void cmExpr_yypop_buffer_state (yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""  if (!YY_CURRENT_BUFFER)"", ""    return;"", """", ""  cmExpr_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);"", ""  YY_CURRENT_BUFFER_LVALUE = NULL;"", ""  if (yyg->yy_buffer_stack_top > 0)"", ""    --yyg->yy_buffer_stack_top;"", """", ""  if (YY_CURRENT_BUFFER) {"", ""    cmExpr_yy_load_buffer_state(yyscanner );"", ""    yyg->yy_did_buffer_switch_on_eof = 1;"", ""  }"", ""\tif (!YY_CURRENT_BUFFER)"", ""\t\treturn;"", """", ""\tcmExpr_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);"", ""\tYY_CURRENT_BUFFER_LVALUE = NULL;"", ""\tif (yyg->yy_buffer_stack_top > 0)"", ""\t\t--yyg->yy_buffer_stack_top;"", """", ""\tif (YY_CURRENT_BUFFER) {"", ""\t\tcmExpr_yy_load_buffer_state(yyscanner );"", ""\t\tyyg->yy_did_buffer_switch_on_eof = 1;"", ""\t}"", ""}"", """", ""/* Allocates the stack if it does not exist."", "" *  Guarantees space for at least one push."", "" */"", ""static void cmExpr_yyensure_buffer_stack (yyscan_t yyscanner)"", ""{"", ""  int nuto_alloc;"", ""\tint num_to_alloc;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""  if (!yyg->yy_buffer_stack) {"", ""\tif (!yyg->yy_buffer_stack) {"", """", ""    /* First allocation is just for 2 elements, since we don't know if this"", ""     * scanner will even need a stack. We use 2 instead of 1 to avoid an"", ""     * immediate realloc on the next call."", ""\t\t/* First allocation is just for 2 elements, since we don't know if this"", ""\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an"", ""\t\t * immediate realloc on the next call."", ""         */"", ""    nuto_alloc = 1;"", ""    yyg->yy_buffer_stack = (struct yy_buffer_state**)cmExpr_yyalloc"", ""                (nuto_alloc * sizeof(struct yy_buffer_state*)"", ""                , yyscanner);"", """", ""    memset(yyg->yy_buffer_stack, 0, nuto_alloc * sizeof(struct yy_buffer_state*));"", """", ""    yyg->yy_buffer_stack_max = nuto_alloc;"", ""    yyg->yy_buffer_stack_top = 0;"", ""    return;"", ""  }"", """", ""  if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){"", """", ""    /* Increase the buffer to prepare for a possible push. */"", ""    int grow_size = 8 /* arbitrary grow size */;"", """", ""    nuto_alloc = yyg->yy_buffer_stack_max + grow_size;"", ""    yyg->yy_buffer_stack = (struct yy_buffer_state**)cmExpr_yyrealloc"", ""                (yyg->yy_buffer_stack,"", ""                nuto_alloc * sizeof(struct yy_buffer_state*)"", ""                , yyscanner);"", """", ""    /* zero only the new slots.*/"", ""    memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));"", ""    yyg->yy_buffer_stack_max = nuto_alloc;"", ""  }"", ""      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */"", ""\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)cmExpr_yyalloc"", ""\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)"", ""\t\t\t\t\t\t\t\t, yyscanner);"", ""\t\tif ( ! yyg->yy_buffer_stack )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yyensure_buffer_stack()\"" );"", """", ""\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));"", """", ""\t\tyyg->yy_buffer_stack_max = num_to_alloc;"", ""\t\tyyg->yy_buffer_stack_top = 0;"", ""\t\treturn;"", ""\t}"", """", ""\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){"", """", ""\t\t/* Increase the buffer to prepare for a possible push. */"", ""\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;"", """", ""\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;"", ""\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)cmExpr_yyrealloc"", ""\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,"", ""\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)"", ""\t\t\t\t\t\t\t\t, yyscanner);"", ""\t\tif ( ! yyg->yy_buffer_stack )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yyensure_buffer_stack()\"" );"", """", ""\t\t/* zero only the new slots.*/"", ""\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));"", ""\t\tyyg->yy_buffer_stack_max = num_to_alloc;"", ""\t}"", ""}"", """", ""/** Setup the input buffer state to scan directly from a user-specified character buffer.""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 0, 0]","[[80, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [100, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""]]",1454,1523
"["" */"", ""YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)"", ""{"", ""  YY_BUFFER_STATE b;"", """", ""  if ( size < 2 ||"", ""       base[size-2] != YY_END_OF_BUFFER_CHAR ||"", ""       base[size-1] != YY_END_OF_BUFFER_CHAR )"", ""    /* They forgot to leave room for the EOB's. */"", ""    return 0;"", """", ""  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""  if ( ! b )"", ""    YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_scan_buffer()\"" );"", """", ""  b->yy_buf_size = size - 2;  /* \""- 2\"" to take care of EOB's */"", ""  b->yy_buf_pos = b->yy_ch_buf = base;"", ""  b->yy_is_our_buffer = 0;"", ""  b->yy_input_file = 0;"", ""  b->yy_n_chars = b->yy_buf_size;"", ""  b->yy_is_interactive = 0;"", ""  b->yy_at_bol = 1;"", ""  b->yy_fill_buffer = 0;"", ""  b->yy_buffer_status = YY_BUFFER_NEW;"", """", ""  cmExpr_yy_switch_to_buffer(b ,yyscanner );"", """", ""  return b;"", ""\tYY_BUFFER_STATE b;"", """", ""\tif ( size < 2 ||"", ""\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||"", ""\t     base[size-1] != YY_END_OF_BUFFER_CHAR )"", ""\t\t/* They forgot to leave room for the EOB's. */"", ""\t\treturn NULL;"", """", ""\tb = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_scan_buffer()\"" );"", """", ""\tb->yy_buf_size = size - 2;\t/* \""- 2\"" to take care of EOB's */"", ""\tb->yy_buf_pos = b->yy_ch_buf = base;"", ""\tb->yy_is_our_buffer = 0;"", ""\tb->yy_input_file = NULL;"", ""\tb->yy_n_chars = b->yy_buf_size;"", ""\tb->yy_is_interactive = 0;"", ""\tb->yy_at_bol = 1;"", ""\tb->yy_fill_buffer = 0;"", ""\tb->yy_buffer_status = YY_BUFFER_NEW;"", """", ""\tcmExpr_yy_switch_to_buffer(b ,yyscanner );"", """", ""\treturn b;"", ""}"", """", ""/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will"", "" * scan from a @e copy of @a yy_str."", "" * @param yy_str a NUL-terminated string to scan"", "" * scan from a @e copy of @a str."", "" * @param yystr a NUL-terminated string to scan"", "" * @param yyscanner The scanner object."", "" * @return the newly allocated buffer state object."", "" * @note If you want to scan bytes that may contain NUL values, then use"", "" *       cmExpr_yy_scan_bytes() instead."", "" */"", ""YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yy_str , yyscan_t yyscanner)"", ""YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)"", ""{"", """", ""  return cmExpr_yy_scan_bytes(yy_str,strlen(yy_str) ,yyscanner);"", ""\treturn cmExpr_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);"", ""}"", """", ""/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will"", "" * scan from a @e copy of @a bytes."", "" * @param bytes the byte buffer to scan"", "" * @param len the number of bytes in the buffer pointed to by @a bytes."", "" * @param yybytes the byte buffer to scan"", "" * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes."", "" * @param yyscanner The scanner object."", "" * @return the newly allocated buffer state object."", "" */"", ""YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * bytes, int  len , yyscan_t yyscanner)"", ""YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)"", ""{"", ""  YY_BUFFER_STATE b;"", ""  char *buf;"", ""  yy_size_t n;"", ""  int i;"", ""\tYY_BUFFER_STATE b;"", ""\tchar *buf;"", ""\tyy_size_t n;"", ""\tyy_size_t i;"", """", ""  /* Get memory for full buffer, including space for trailing EOB's. */"", ""  n = len + 2;"", ""  buf = (char *) cmExpr_yyalloc(n ,yyscanner );"", ""  if ( ! buf )"", ""    YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_scan_bytes()\"" );"", ""\t/* Get memory for full buffer, including space for trailing EOB's. */"", ""\tn = (yy_size_t) _yybytes_len + 2;"", ""\tbuf = (char *) cmExpr_yyalloc(n ,yyscanner );"", ""\tif ( ! buf )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_scan_bytes()\"" );"", """", ""  for ( i = 0; i < len; ++i )"", ""    buf[i] = bytes[i];"", ""\tfor ( i = 0; i < (size_t)_yybytes_len; ++i )"", ""\t\tbuf[i] = yybytes[i];"", """", ""  buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;"", ""\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;"", """", ""  b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);"", ""  if ( ! b )"", ""    YY_FATAL_ERROR( \""bad buffer in cmExpr_yy_scan_bytes()\"" );"", ""\tb = cmExpr_yy_scan_buffer(buf,n ,yyscanner);"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""bad buffer in cmExpr_yy_scan_bytes()\"" );"", """", ""  /* It's okay to grow etc. this buffer, and we should throw it"", ""   * away when we're done."", ""   */"", ""  b->yy_is_our_buffer = 1;"", ""\t/* It's okay to grow etc. this buffer, and we should throw it"", ""\t * away when we're done."", ""\t */"", ""\tb->yy_is_our_buffer = 1;"", """", ""  return b;"", ""\treturn b;"", ""}"", """", ""#ifndef YY_EXIT_FAILURE"", ""#define YY_EXIT_FAILURE 2"", ""#endif"", """", ""static void yy_fatal_error (yyconst char* msg , yyscan_t)"", ""static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)"", ""{"", ""      (void) fprintf( stderr, \""%s\\n\"", msg );"", ""  exit( YY_EXIT_FAILURE );"", ""\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""\t(void)yyg;"", ""\t(void) fprintf( stderr, \""%s\\n\"", msg );"", ""\texit( YY_EXIT_FAILURE );"", ""}"", """", ""/* Redefine yyless() so it works in section 3 code. */"", """", ""#undef yyless"", ""#define yyless(n) \\"", ""  do \\"", ""    { \\"", ""    /* Undo effects of setting up yytext. */ \\"", ""\tdo \\"", ""\t\t{ \\"", ""\t\t/* Undo effects of setting up yytext. */ \\"", ""        int yyless_macro_arg = (n); \\"", ""        YY_LESS_LINENO(yyless_macro_arg);\\"", ""    yytext[yyleng] = yyg->yy_hold_char; \\"", ""    yyg->yy_c_buf_p = yytext + yyless_macro_arg; \\"", ""    yyg->yy_hold_char = *yyg->yy_c_buf_p; \\"", ""    *yyg->yy_c_buf_p = '\\0'; \\"", ""    yyleng = yyless_macro_arg; \\"", ""    } \\"", ""  while ( 0 )"", ""\t\tyytext[yyleng] = yyg->yy_hold_char; \\"", ""\t\tyyg->yy_c_buf_p = yytext + yyless_macro_arg; \\"", ""\t\tyyg->yy_hold_char = *yyg->yy_c_buf_p; \\"", ""\t\t*yyg->yy_c_buf_p = '\\0'; \\"", ""\t\tyyleng = yyless_macro_arg; \\"", ""\t\t} \\"", ""\twhile ( 0 )"", """", ""/* Accessor  methods (get/set functions) to struct members. */"", """"]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, -1, -1, 1, 1, 0, 0, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, -1, -1, 1, 1, 0, 0, 0, -1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -2, 1, 1, 1, 1, 2, 0, -1, -1, 1, 1, 0, -1, 1, 0, -1, -1, -2, 1, 1, 2, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, -2, -1, 1, 1, 2, 1, 0, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[13, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_scan_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [38, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_scan_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [98, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [103, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmExpr_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [115, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""bad buffer in cmExpr_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [118, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""bad buffer in cmExpr_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [140, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""-"", ""(void) fprintf( stderr, \""%s\\n\"", msg );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [144, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""+"", ""(void) fprintf( stderr, \""%s\\n\"", msg );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""]]",1519,1592
"[""}"", """", ""/** Set the current line number."", "" * @param line_number The line number to set."", "" * @param _line_number line number"", "" * @param yyscanner The scanner object."", "" */"", ""void cmExpr_yyset_lineno (int  line_number , yyscan_t yyscanner)"", ""void cmExpr_yyset_lineno (int  _line_number , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        /* lineno is only valid if an input buffer exists. */"", ""        if (! YY_CURRENT_BUFFER )"", ""           yy_fatal_error( \""cmExpr_yyset_lineno called with no buffer\"" , yyscanner);"", ""           YY_FATAL_ERROR( \""cmExpr_yyset_lineno called with no buffer\"" );"", """", ""    yylineno = line_number;"", ""    yylineno = _line_number;"", ""}"", """", ""/** Set the current column."", "" * @param column_no The column number to set."", "" * @param _column_no column number"", "" * @param yyscanner The scanner object."", "" */"", ""void cmExpr_yyset_column (int  column_no , yyscan_t yyscanner)"", ""void cmExpr_yyset_column (int  _column_no , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        /* column is only valid if an input buffer exists. */"", ""        if (! YY_CURRENT_BUFFER )"", ""           yy_fatal_error( \""cmExpr_yyset_column called with no buffer\"" , yyscanner);"", ""           YY_FATAL_ERROR( \""cmExpr_yyset_column called with no buffer\"" );"", """", ""    yycolumn = column_no;"", ""    yycolumn = _column_no;"", ""}"", """", ""/** Set the input stream. This does not discard the current"", "" * input buffer."", "" * @param in_str A readable stream."", "" * @param _in_str A readable stream."", "" * @param yyscanner The scanner object."", "" * @see cmExpr_yy_switch_to_buffer"", "" */"", ""void cmExpr_yyset_in (FILE *  in_str , yyscan_t yyscanner)"", ""void cmExpr_yyset_in (FILE *  _in_str , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""    yyin = in_str ;"", ""    yyin = _in_str ;"", ""}"", """", ""void cmExpr_yyset_out (FILE *  out_str , yyscan_t yyscanner)"", ""void cmExpr_yyset_out (FILE *  _out_str , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""    yyout = out_str ;"", ""    yyout = _out_str ;"", ""}"", """", ""int cmExpr_yyget_debug  (yyscan_t yyscanner)""]","[0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, -2, 2, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, -2, 2, 0, -1, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0]","[[14, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""-"", ""yy_fatal_error( \""cmExpr_yyset_lineno called with no buffer\"" , yyscanner);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [15, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""cmExpr_yyset_lineno called with no buffer\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [33, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""-"", ""yy_fatal_error( \""cmExpr_yyset_column called with no buffer\"" , yyscanner);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""], [34, ""c5df1f165c7f8f1e31e3144d326c6836af2e678d"", ""Regenerate lexer source code\n\nRevise the manual procedure in the `*Lexer.in.l` files.  Some of our\npost-processing steps are no longer necessary with the current set of\nsupported compilers.  Some steps changed with newer versions of flex.\n\nThen regenerate all lexers with flex version 2.6.1."", ""Source/cmExprLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""cmExpr_yyset_column called with no buffer\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_71_new.cpp""]]",1709,1784
"[""  \""CMAKE_TRY_COMPILE_PLATFORM_VARIABLES\"";"", ""static std::string const kCMAKE_WARN_DEPRECATED = \""CMAKE_WARN_DEPRECATED\"";"", """", ""static void writeProperty(FILE* fout, std::string const& targetName,"", ""                          std::string const& prop, std::string const& value)"", ""{"", ""  fprintf(fout, \""set_property(TARGET %s PROPERTY %s %s)\\n\"", targetName.c_str(),"", ""          cmOutputConverter::EscapeForCMake(prop).c_str(),"", ""          cmOutputConverter::EscapeForCMake(value).c_str());"", ""}"", """", ""std::string cmCoreTryCompile::LookupStdVar(std::string const& var,"", ""                                           bool warnCMP0067)"", ""{"", ""  std::string value = this->Makefile->GetSafeDefinition(var);"", ""  if (warnCMP0067 && !value.empty()) {"", ""    value.clear();"", ""    this->WarnCMP0067.push_back(var);"", ""  }"", ""  return value;"", ""}"", """", ""int cmCoreTryCompile::TryCompileCode(std::vector<std::string> const& argv,"", ""                                     bool isTryRun)"", ""{""]","[0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[6, ""a0d64ecf8b9eac29cbfeb7461cf3bcb1688f7aa7"", ""Merge topic 'try_compile-lang-std'\n\nf72ba42b try_compile: Add policy CMP0067 to honor language standards\n45aa03b9 try_compile: Add options to specify language standards\n3bb2051e try_compile: Stop processing when test build system fails to generate"", ""Source/cmCoreTryCompile.cxx"", ""+"", ""fprintf(fout, \""set_property(TARGET %s PROPERTY %s %s)\\n\"", targetName.c_str(),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_72_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_72_new.cpp""]]",46,46
"[""  return CURLE_OK;"", ""}"", """", ""#ifdef USE_LIBIDN"", ""/*"", "" * Initialise use of IDNA library."", "" * It falls back to ASCII if $CHARSET isn't defined. This doesn't work for"", "" * idna_to_ascii_lz()."", "" */"", ""static void idna_init (void)"", ""{"", ""#ifdef WIN32"", ""  char buf[60];"", ""  UINT cp = GetACP();"", """", ""  if(!getenv(\""CHARSET\"") && cp > 0) {"", ""    snprintf(buf, sizeof(buf), \""CHARSET=cp%u\"", cp);"", ""    putenv(buf);"", ""  }"", ""#else"", ""  /* to do? */"", ""#endif"", ""}"", ""#endif  /* USE_LIBIDN */"", """", ""/* true globals -- for curl_global_init() and curl_global_cleanup() */"", ""static unsigned int  initialized;"", ""static long          init_flags;""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0]","[[16, ""0290bfc35dee73fb534556700554536f1164caaf"", ""Merge topic 'update-curl'\n\ndf7fa47c curl: Disable symbol hiding logic in build for CMake\nf8a1ba20 Merge branch 'upstream-curl' into update-curl\n93cc249f curl 2016-11-02 (3c561c65)\n25d7b1ca curl: Update script to get curl 7.51.0"", ""Utilities/cmcurl/lib/easy.c"", ""-"", ""snprintf(buf, sizeof(buf), \""CHARSET=cp%u\"", cp);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_73_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_73_new.cpp""]]",144,143
"[""                             curl_off_t *size,"", ""                             const char *fmt, ...)"", ""{"", ""  char s[4096];"", ""  char *s;"", ""  CURLcode result;"", ""  va_list ap;"", ""  va_start(ap, fmt);"", ""  vsnprintf(s, sizeof(s), fmt, ap);"", ""  s = curl_mvaprintf(fmt, ap);"", ""  va_end(ap);"", """", ""  return AddFormData(formp, FORM_DATA, s, 0, size);"", ""  if(!s)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  result = AddFormData(formp, FORM_DATAMEM, s, 0, size);"", ""  if(result)"", ""    free(s);"", """", ""  return result;"", ""}"", """", ""/*""]","[0, 0, 0, -1, 1, 1, 0, 0, -2, 2, 0, 0, -1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[8, ""0290bfc35dee73fb534556700554536f1164caaf"", ""Merge topic 'update-curl'\n\ndf7fa47c curl: Disable symbol hiding logic in build for CMake\nf8a1ba20 Merge branch 'upstream-curl' into update-curl\n93cc249f curl 2016-11-02 (3c561c65)\n25d7b1ca curl: Update script to get curl 7.51.0"", ""Utilities/cmcurl/lib/formdata.c"", ""-"", ""vsnprintf(s, sizeof(s), fmt, ap);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_74_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_74_new.cpp""], [9, ""0290bfc35dee73fb534556700554536f1164caaf"", ""Merge topic 'update-curl'\n\ndf7fa47c curl: Disable symbol hiding logic in build for CMake\nf8a1ba20 Merge branch 'upstream-curl' into update-curl\n93cc249f curl 2016-11-02 (3c561c65)\n25d7b1ca curl: Update script to get curl 7.51.0"", ""Utilities/cmcurl/lib/formdata.c"", ""+"", ""s = curl_mvaprintf(fmt, ap);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_74_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_74_new.cpp""]]",906,914
"[""  enum protection_level data_sec = conn->data_prot;"", ""#endif"", """", ""  va_list ap;"", ""  va_start(ap, fmt);"", ""  write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);"", ""  va_end(ap);"", ""  write_len = strlen(cmd);"", ""  if(write_len > (sizeof(s) -3))"", ""    return CURLE_BAD_FUNCTION_ARGUMENT;"", """", ""  strcpy(&s[write_len], \""\\r\\n\""); /* append a trailing CRLF */"", ""  write_len +=2;""]","[0, 0, 0, -1, -1, -2, -1, 1, 1, 1, 0, 0, 0]","[[5, ""0290bfc35dee73fb534556700554536f1164caaf"", ""Merge topic 'update-curl'\n\ndf7fa47c curl: Disable symbol hiding logic in build for CMake\nf8a1ba20 Merge branch 'upstream-curl' into update-curl\n93cc249f curl 2016-11-02 (3c561c65)\n25d7b1ca curl: Update script to get curl 7.51.0"", ""Utilities/cmcurl/lib/ftp.c"", ""-"", ""write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_75_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_75_new.cpp""]]",4107,4103
"["" * Create an index with the type of each parameter entry and its"", "" * value (may vary in size)"", "" *"", "" * Returns zero on success."", "" *"", "" ******************************************************************/"", """", ""static long dprintf_Pass1(const char *format, va_stack_t *vto, char **endpos,"", ""                          va_list arglist)"", ""static int dprintf_Pass1(const char *format, va_stack_t *vto, char **endpos,"", ""                         va_list arglist)"", ""{"", ""  char *fmt = (char *)format;"", ""  int param_num = 0;""]","[0, 0, 0, 1, 1, 0, 0, -2, -1, 2, 1, 0, 0, 0]","[[7, ""0290bfc35dee73fb534556700554536f1164caaf"", ""Merge topic 'update-curl'\n\ndf7fa47c curl: Disable symbol hiding logic in build for CMake\nf8a1ba20 Merge branch 'upstream-curl' into update-curl\n93cc249f curl 2016-11-02 (3c561c65)\n25d7b1ca curl: Update script to get curl 7.51.0"", ""Utilities/cmcurl/lib/mprintf.c"", ""-"", ""static long dprintf_Pass1(const char *format, va_stack_t *vto, char **endpos,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_76_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_76_new.cpp""], [9, ""0290bfc35dee73fb534556700554536f1164caaf"", ""Merge topic 'update-curl'\n\ndf7fa47c curl: Disable symbol hiding logic in build for CMake\nf8a1ba20 Merge branch 'upstream-curl' into update-curl\n93cc249f curl 2016-11-02 (3c561c65)\n25d7b1ca curl: Update script to get curl 7.51.0"", ""Utilities/cmcurl/lib/mprintf.c"", ""+"", ""static int dprintf_Pass1(const char *format, va_stack_t *vto, char **endpos,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_76_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_76_new.cpp""]]",223,223
"[""  char *workend = &work[sizeof(work) - 2];"", """", ""  /* Do the actual %-code parsing */"", ""  dprintf_Pass1(format, vto, endpos, ap_save);"", ""  if(dprintf_Pass1(format, vto, endpos, ap_save))"", ""    return -1;"", """", ""  end = &endpos[0]; /* the initial end-position from the list dprintf_Pass1()"", ""                       created for us */""]","[0, 0, 0, -2, 2, 1, 0, 0, 0]","[[3, ""0290bfc35dee73fb534556700554536f1164caaf"", ""Merge topic 'update-curl'\n\ndf7fa47c curl: Disable symbol hiding logic in build for CMake\nf8a1ba20 Merge branch 'upstream-curl' into update-curl\n93cc249f curl 2016-11-02 (3c561c65)\n25d7b1ca curl: Update script to get curl 7.51.0"", ""Utilities/cmcurl/lib/mprintf.c"", ""-"", ""dprintf_Pass1(format, vto, endpos, ap_save);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_76_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_76_new.cpp""], [4, ""0290bfc35dee73fb534556700554536f1164caaf"", ""Merge topic 'update-curl'\n\ndf7fa47c curl: Disable symbol hiding logic in build for CMake\nf8a1ba20 Merge branch 'upstream-curl' into update-curl\n93cc249f curl 2016-11-02 (3c561c65)\n25d7b1ca curl: Update script to get curl 7.51.0"", ""Utilities/cmcurl/lib/mprintf.c"", ""+"", ""if(dprintf_Pass1(format, vto, endpos, ap_save))"", 0, ""/data/download/CMake/CMake/Kitware_CMake_76_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_76_new.cpp""]]",583,589
"[""  left -= len;"", ""  ptr += len;"", ""#endif"", ""#ifdef USE_LIBIDN"", ""  if(stringprep_check_version(LIBIDN_REQUIRED_VERSION)) {"", ""    len = snprintf(ptr, left, \"" libidn/%s\"", stringprep_check_version(NULL));"", ""#ifdef USE_LIBIDN2"", ""  if(idn2_check_version(IDN2_VERSION)) {"", ""    len = snprintf(ptr, left, \"" libidn2/%s\"", idn2_check_version(NULL));"", ""    left -= len;"", ""    ptr += len;"", ""  }""]","[0, 0, 0, -1, -1, -2, 1, 1, 2, 0, 0, 0]","[[5, ""0290bfc35dee73fb534556700554536f1164caaf"", ""Merge topic 'update-curl'\n\ndf7fa47c curl: Disable symbol hiding logic in build for CMake\nf8a1ba20 Merge branch 'upstream-curl' into update-curl\n93cc249f curl 2016-11-02 (3c561c65)\n25d7b1ca curl: Update script to get curl 7.51.0"", ""Utilities/cmcurl/lib/version.c"", ""-"", ""len = snprintf(ptr, left, \"" libidn/%s\"", stringprep_check_version(NULL));"", 0, ""/data/download/CMake/CMake/Kitware_CMake_77_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_77_new.cpp""], [8, ""0290bfc35dee73fb534556700554536f1164caaf"", ""Merge topic 'update-curl'\n\ndf7fa47c curl: Disable symbol hiding logic in build for CMake\nf8a1ba20 Merge branch 'upstream-curl' into update-curl\n93cc249f curl 2016-11-02 (3c561c65)\n25d7b1ca curl: Update script to get curl 7.51.0"", ""Utilities/cmcurl/lib/version.c"", ""+"", ""len = snprintf(ptr, left, \"" libidn2/%s\"", idn2_check_version(NULL));"", 0, ""/data/download/CMake/CMake/Kitware_CMake_77_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_77_new.cpp""]]",111,111
"[""  \""CMAKE_TRY_COMPILE_PLATFORM_VARIABLES\"";"", ""static std::string const kCMAKE_WARN_DEPRECATED = \""CMAKE_WARN_DEPRECATED\"";"", """", ""static void writeProperty(FILE* fout, std::string const& targetName,"", ""                          std::string const& prop, std::string const& value)"", ""{"", ""  fprintf(fout, \""set_property(TARGET %s PROPERTY %s %s)\\n\"", targetName.c_str(),"", ""          cmOutputConverter::EscapeForCMake(prop).c_str(),"", ""          cmOutputConverter::EscapeForCMake(value).c_str());"", ""}"", """", ""int cmCoreTryCompile::TryCompileCode(std::vector<std::string> const& argv,"", ""                                     bool isTryRun)"", ""{""]","[0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0]","[[6, ""45aa03b97aeeb512264ac2bfbb2028330be254d1"", ""try_compile: Add options to specify language standards\n\nGive `try_compile` callers a way to control the `CXX_STANDARD`,\n`CXX_STANDARD_REQUIRED`, and `CXX_EXTENSIONS` properties of the\ngenerated test target (or the `C` equivalents) in order to compile a\ntest source for a particular language standard.\n\nIssue: #16456"", ""Source/cmCoreTryCompile.cxx"", ""+"", ""fprintf(fout, \""set_property(TARGET %s PROPERTY %s %s)\\n\"", targetName.c_str(),"", 0, ""/data/download/CMake/CMake/Kitware_CMake_78_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_78_new.cpp""]]",46,46
"[""  return CURLE_OK;"", ""}"", """", ""#ifdef USE_LIBIDN"", ""/*"", "" * Initialise use of IDNA library."", "" * It falls back to ASCII if $CHARSET isn't defined. This doesn't work for"", "" * idna_to_ascii_lz()."", "" */"", ""static void idna_init (void)"", ""{"", ""#ifdef WIN32"", ""  char buf[60];"", ""  UINT cp = GetACP();"", """", ""  if(!getenv(\""CHARSET\"") && cp > 0) {"", ""    snprintf(buf, sizeof(buf), \""CHARSET=cp%u\"", cp);"", ""    putenv(buf);"", ""  }"", ""#else"", ""  /* to do? */"", ""#endif"", ""}"", ""#endif  /* USE_LIBIDN */"", """", ""/* true globals -- for curl_global_init() and curl_global_cleanup() */"", ""static unsigned int  initialized;"", ""static long          init_flags;""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0]","[[16, ""f8a1ba202f51e70510f12f46fe0633ea908d5144"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-11-02 (3c561c65)"", ""Utilities/cmcurl/lib/easy.c"", ""-"", ""snprintf(buf, sizeof(buf), \""CHARSET=cp%u\"", cp);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_79_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_79_new.cpp""]]",144,143
"[""                             curl_off_t *size,"", ""                             const char *fmt, ...)"", ""{"", ""  char s[4096];"", ""  char *s;"", ""  CURLcode result;"", ""  va_list ap;"", ""  va_start(ap, fmt);"", ""  vsnprintf(s, sizeof(s), fmt, ap);"", ""  s = curl_mvaprintf(fmt, ap);"", ""  va_end(ap);"", """", ""  return AddFormData(formp, FORM_DATA, s, 0, size);"", ""  if(!s)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  result = AddFormData(formp, FORM_DATAMEM, s, 0, size);"", ""  if(result)"", ""    free(s);"", """", ""  return result;"", ""}"", """", ""/*""]","[0, 0, 0, -1, 1, 1, 0, 0, -2, 2, 0, 0, -1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[8, ""f8a1ba202f51e70510f12f46fe0633ea908d5144"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-11-02 (3c561c65)"", ""Utilities/cmcurl/lib/formdata.c"", ""-"", ""vsnprintf(s, sizeof(s), fmt, ap);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_80_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_80_new.cpp""], [9, ""f8a1ba202f51e70510f12f46fe0633ea908d5144"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-11-02 (3c561c65)"", ""Utilities/cmcurl/lib/formdata.c"", ""+"", ""s = curl_mvaprintf(fmt, ap);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_80_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_80_new.cpp""]]",906,914
"[""  enum protection_level data_sec = conn->data_prot;"", ""#endif"", """", ""  va_list ap;"", ""  va_start(ap, fmt);"", ""  write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);"", ""  va_end(ap);"", ""  write_len = strlen(cmd);"", ""  if(write_len > (sizeof(s) -3))"", ""    return CURLE_BAD_FUNCTION_ARGUMENT;"", """", ""  strcpy(&s[write_len], \""\\r\\n\""); /* append a trailing CRLF */"", ""  write_len +=2;""]","[0, 0, 0, -1, -1, -2, -1, 1, 1, 1, 0, 0, 0]","[[5, ""f8a1ba202f51e70510f12f46fe0633ea908d5144"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-11-02 (3c561c65)"", ""Utilities/cmcurl/lib/ftp.c"", ""-"", ""write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_81_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_81_new.cpp""]]",4107,4103
"["" * Create an index with the type of each parameter entry and its"", "" * value (may vary in size)"", "" *"", "" * Returns zero on success."", "" *"", "" ******************************************************************/"", """", ""static long dprintf_Pass1(const char *format, va_stack_t *vto, char **endpos,"", ""                          va_list arglist)"", ""static int dprintf_Pass1(const char *format, va_stack_t *vto, char **endpos,"", ""                         va_list arglist)"", ""{"", ""  char *fmt = (char *)format;"", ""  int param_num = 0;""]","[0, 0, 0, 1, 1, 0, 0, -2, -1, 2, 1, 0, 0, 0]","[[7, ""f8a1ba202f51e70510f12f46fe0633ea908d5144"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-11-02 (3c561c65)"", ""Utilities/cmcurl/lib/mprintf.c"", ""-"", ""static long dprintf_Pass1(const char *format, va_stack_t *vto, char **endpos,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_82_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_82_new.cpp""], [9, ""f8a1ba202f51e70510f12f46fe0633ea908d5144"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-11-02 (3c561c65)"", ""Utilities/cmcurl/lib/mprintf.c"", ""+"", ""static int dprintf_Pass1(const char *format, va_stack_t *vto, char **endpos,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_82_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_82_new.cpp""]]",223,223
"[""  char *workend = &work[sizeof(work) - 2];"", """", ""  /* Do the actual %-code parsing */"", ""  dprintf_Pass1(format, vto, endpos, ap_save);"", ""  if(dprintf_Pass1(format, vto, endpos, ap_save))"", ""    return -1;"", """", ""  end = &endpos[0]; /* the initial end-position from the list dprintf_Pass1()"", ""                       created for us */""]","[0, 0, 0, -2, 2, 1, 0, 0, 0]","[[3, ""f8a1ba202f51e70510f12f46fe0633ea908d5144"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-11-02 (3c561c65)"", ""Utilities/cmcurl/lib/mprintf.c"", ""-"", ""dprintf_Pass1(format, vto, endpos, ap_save);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_82_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_82_new.cpp""], [4, ""f8a1ba202f51e70510f12f46fe0633ea908d5144"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-11-02 (3c561c65)"", ""Utilities/cmcurl/lib/mprintf.c"", ""+"", ""if(dprintf_Pass1(format, vto, endpos, ap_save))"", 0, ""/data/download/CMake/CMake/Kitware_CMake_82_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_82_new.cpp""]]",583,589
"[""  left -= len;"", ""  ptr += len;"", ""#endif"", ""#ifdef USE_LIBIDN"", ""  if(stringprep_check_version(LIBIDN_REQUIRED_VERSION)) {"", ""    len = snprintf(ptr, left, \"" libidn/%s\"", stringprep_check_version(NULL));"", ""#ifdef USE_LIBIDN2"", ""  if(idn2_check_version(IDN2_VERSION)) {"", ""    len = snprintf(ptr, left, \"" libidn2/%s\"", idn2_check_version(NULL));"", ""    left -= len;"", ""    ptr += len;"", ""  }""]","[0, 0, 0, -1, -1, -2, 1, 1, 2, 0, 0, 0]","[[5, ""f8a1ba202f51e70510f12f46fe0633ea908d5144"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-11-02 (3c561c65)"", ""Utilities/cmcurl/lib/version.c"", ""-"", ""len = snprintf(ptr, left, \"" libidn/%s\"", stringprep_check_version(NULL));"", 0, ""/data/download/CMake/CMake/Kitware_CMake_83_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_83_new.cpp""], [8, ""f8a1ba202f51e70510f12f46fe0633ea908d5144"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-11-02 (3c561c65)"", ""Utilities/cmcurl/lib/version.c"", ""+"", ""len = snprintf(ptr, left, \"" libidn2/%s\"", idn2_check_version(NULL));"", 0, ""/data/download/CMake/CMake/Kitware_CMake_83_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_83_new.cpp""]]",111,111
"[""  return CURLE_OK;"", ""}"", """", ""#ifdef USE_LIBIDN"", ""/*"", "" * Initialise use of IDNA library."", "" * It falls back to ASCII if $CHARSET isn't defined. This doesn't work for"", "" * idna_to_ascii_lz()."", "" */"", ""static void idna_init (void)"", ""{"", ""#ifdef WIN32"", ""  char buf[60];"", ""  UINT cp = GetACP();"", """", ""  if(!getenv(\""CHARSET\"") && cp > 0) {"", ""    snprintf(buf, sizeof(buf), \""CHARSET=cp%u\"", cp);"", ""    putenv(buf);"", ""  }"", ""#else"", ""  /* to do? */"", ""#endif"", ""}"", ""#endif  /* USE_LIBIDN */"", """", ""/* true globals -- for curl_global_init() and curl_global_cleanup() */"", ""static unsigned int  initialized;"", ""static long          init_flags;""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0]","[[16, ""93cc249f3dd7ecd621cd063e4c08bbdb54d971e8"", ""curl 2016-11-02 (3c561c65)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0)."", ""lib/easy.c"", ""-"", ""snprintf(buf, sizeof(buf), \""CHARSET=cp%u\"", cp);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_84_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_84_new.cpp""]]",144,143
"[""                             curl_off_t *size,"", ""                             const char *fmt, ...)"", ""{"", ""  char s[4096];"", ""  char *s;"", ""  CURLcode result;"", ""  va_list ap;"", ""  va_start(ap, fmt);"", ""  vsnprintf(s, sizeof(s), fmt, ap);"", ""  s = curl_mvaprintf(fmt, ap);"", ""  va_end(ap);"", """", ""  return AddFormData(formp, FORM_DATA, s, 0, size);"", ""  if(!s)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  result = AddFormData(formp, FORM_DATAMEM, s, 0, size);"", ""  if(result)"", ""    free(s);"", """", ""  return result;"", ""}"", """", ""/*""]","[0, 0, 0, -1, 1, 1, 0, 0, -2, 2, 0, 0, -1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[8, ""93cc249f3dd7ecd621cd063e4c08bbdb54d971e8"", ""curl 2016-11-02 (3c561c65)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0)."", ""lib/formdata.c"", ""-"", ""vsnprintf(s, sizeof(s), fmt, ap);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_85_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_85_new.cpp""], [9, ""93cc249f3dd7ecd621cd063e4c08bbdb54d971e8"", ""curl 2016-11-02 (3c561c65)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0)."", ""lib/formdata.c"", ""+"", ""s = curl_mvaprintf(fmt, ap);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_85_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_85_new.cpp""]]",906,914
"[""  enum protection_level data_sec = conn->data_prot;"", ""#endif"", """", ""  va_list ap;"", ""  va_start(ap, fmt);"", ""  write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);"", ""  va_end(ap);"", ""  write_len = strlen(cmd);"", ""  if(write_len > (sizeof(s) -3))"", ""    return CURLE_BAD_FUNCTION_ARGUMENT;"", """", ""  strcpy(&s[write_len], \""\\r\\n\""); /* append a trailing CRLF */"", ""  write_len +=2;""]","[0, 0, 0, -1, -1, -2, -1, 1, 1, 1, 0, 0, 0]","[[5, ""93cc249f3dd7ecd621cd063e4c08bbdb54d971e8"", ""curl 2016-11-02 (3c561c65)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0)."", ""lib/ftp.c"", ""-"", ""write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_86_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_86_new.cpp""]]",4106,4102
"["" * Create an index with the type of each parameter entry and its"", "" * value (may vary in size)"", "" *"", "" * Returns zero on success."", "" *"", "" ******************************************************************/"", """", ""static long dprintf_Pass1(const char *format, va_stack_t *vto, char **endpos,"", ""                          va_list arglist)"", ""static int dprintf_Pass1(const char *format, va_stack_t *vto, char **endpos,"", ""                         va_list arglist)"", ""{"", ""  char *fmt = (char *)format;"", ""  int param_num = 0;""]","[0, 0, 0, 1, 1, 0, 0, -2, -1, 2, 1, 0, 0, 0]","[[7, ""93cc249f3dd7ecd621cd063e4c08bbdb54d971e8"", ""curl 2016-11-02 (3c561c65)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0)."", ""lib/mprintf.c"", ""-"", ""static long dprintf_Pass1(const char *format, va_stack_t *vto, char **endpos,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_87_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_87_new.cpp""], [9, ""93cc249f3dd7ecd621cd063e4c08bbdb54d971e8"", ""curl 2016-11-02 (3c561c65)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0)."", ""lib/mprintf.c"", ""+"", ""static int dprintf_Pass1(const char *format, va_stack_t *vto, char **endpos,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_87_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_87_new.cpp""]]",227,227
"[""  char *workend = &work[sizeof(work) - 2];"", """", ""  /* Do the actual %-code parsing */"", ""  dprintf_Pass1(format, vto, endpos, ap_save);"", ""  if(dprintf_Pass1(format, vto, endpos, ap_save))"", ""    return -1;"", """", ""  end = &endpos[0]; /* the initial end-position from the list dprintf_Pass1()"", ""                       created for us */""]","[0, 0, 0, -2, 2, 1, 0, 0, 0]","[[3, ""93cc249f3dd7ecd621cd063e4c08bbdb54d971e8"", ""curl 2016-11-02 (3c561c65)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0)."", ""lib/mprintf.c"", ""-"", ""dprintf_Pass1(format, vto, endpos, ap_save);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_87_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_87_new.cpp""], [4, ""93cc249f3dd7ecd621cd063e4c08bbdb54d971e8"", ""curl 2016-11-02 (3c561c65)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0)."", ""lib/mprintf.c"", ""+"", ""if(dprintf_Pass1(format, vto, endpos, ap_save))"", 0, ""/data/download/CMake/CMake/Kitware_CMake_87_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_87_new.cpp""]]",587,593
"[""  left -= len;"", ""  ptr += len;"", ""#endif"", ""#ifdef USE_LIBIDN"", ""  if(stringprep_check_version(LIBIDN_REQUIRED_VERSION)) {"", ""    len = snprintf(ptr, left, \"" libidn/%s\"", stringprep_check_version(NULL));"", ""#ifdef USE_LIBIDN2"", ""  if(idn2_check_version(IDN2_VERSION)) {"", ""    len = snprintf(ptr, left, \"" libidn2/%s\"", idn2_check_version(NULL));"", ""    left -= len;"", ""    ptr += len;"", ""  }""]","[0, 0, 0, -1, -1, -2, 1, 1, 2, 0, 0, 0]","[[5, ""93cc249f3dd7ecd621cd063e4c08bbdb54d971e8"", ""curl 2016-11-02 (3c561c65)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0)."", ""lib/version.c"", ""-"", ""len = snprintf(ptr, left, \"" libidn/%s\"", stringprep_check_version(NULL));"", 0, ""/data/download/CMake/CMake/Kitware_CMake_88_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_88_new.cpp""], [8, ""93cc249f3dd7ecd621cd063e4c08bbdb54d971e8"", ""curl 2016-11-02 (3c561c65)\n\nCode extracted from:\n\n    https://github.com/curl/curl.git\n\nat commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0)."", ""lib/version.c"", ""+"", ""len = snprintf(ptr, left, \"" libidn2/%s\"", idn2_check_version(NULL));"", 0, ""/data/download/CMake/CMake/Kitware_CMake_88_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_88_new.cpp""]]",111,111
"["""", ""// Read an integer value from an input stream."", ""template <class T>"", ""std::istream&"", ""IOStreamScanTemplate(std::istream& is, T& value, char type)"", ""std::istream& IOStreamScanTemplate(std::istream& is, T& value, char type)"", ""{"", ""  int state = std::ios_base::goodbit;"", """", ""  // Skip leading whitespace."", ""  std::istream::sentry okay(is);"", """", ""  if(okay)"", ""    {"", ""  if (okay) {"", ""    try {"", ""    // Copy the string to a buffer and construct the format string."", ""    char buffer[KWSYS_IOS_INT64_MAX_DIG];"", ""#   if defined(_MSC_VER)"", ""    char format[] = \""%I64_\"";"", ""    const int typeIndex = 4;"", ""#   else"", ""    char format[] = \""%ll_\"";"", ""    const int typeIndex = 3;"", ""#   endif"", ""    switch(IOStreamScanStream(is, buffer))"", ""      {"", ""      case 8: format[typeIndex] = 'o'; break;"", ""      case 0: // Default to decimal if not told otherwise."", ""      case 10: format[typeIndex] = type; break;"", ""      case 16: format[typeIndex] = 'x'; break;"", ""      // Copy the string to a buffer and construct the format string."", ""      char buffer[KWSYS_IOS_INT64_MAX_DIG];"", ""#if defined(_MSC_VER)"", ""      char format[] = \""%I64_\"";"", ""      const int typeIndex = 4;"", ""#else"", ""      char format[] = \""%ll_\"";"", ""      const int typeIndex = 3;"", ""#endif"", ""      switch (IOStreamScanStream(is, buffer)) {"", ""        case 8:"", ""          format[typeIndex] = 'o';"", ""          break;"", ""        case 0: // Default to decimal if not told otherwise."", ""        case 10:"", ""          format[typeIndex] = type;"", ""          break;"", ""        case 16:"", ""          format[typeIndex] = 'x';"", ""          break;"", ""      };"", """", ""    // Use sscanf to parse the number from the buffer."", ""    T result;"", ""    int success = (sscanf(buffer, format, &result) == 1)?1:0;"", ""      // Use sscanf to parse the number from the buffer."", ""      T result;"", ""      int success = (sscanf(buffer, format, &result) == 1) ? 1 : 0;"", """", ""    // Set flags for resulting state."", ""    if(is.peek() == EOF) { state |= std::ios_base::eofbit; }"", ""    if(!success) { state |= std::ios_base::failbit; }"", ""    else { value = result; }"", ""    } catch(...) { state |= std::ios_base::badbit; }"", ""      // Set flags for resulting state."", ""      if (is.peek() == EOF) {"", ""        state |= std::ios_base::eofbit;"", ""      }"", ""      if (!success) {"", ""        state |= std::ios_base::failbit;"", ""      } else {"", ""        value = result;"", ""      }"", ""    } catch (...) {"", ""      state |= std::ios_base::badbit;"", ""    }"", ""  }"", """", ""  is.setstate(std::ios_base::iostate(state));"", ""  return is;"", ""}"", """", ""// Print an integer value to an output stream."", ""template <class T>"", ""std::ostream&"", ""IOStreamPrintTemplate(std::ostream& os, T value, char type)"", ""std::ostream& IOStreamPrintTemplate(std::ostream& os, T value, char type)"", ""{"", ""  std::ostream::sentry okay(os);"", ""  if(okay)"", ""    {"", ""  if (okay) {"", ""    try {"", ""    // Construct the format string."", ""    char format[8];"", ""    char* f = format;"", ""    *f++ = '%';"", ""    if(os.flags() & std::ios_base::showpos) { *f++ = '+'; }"", ""    if(os.flags() & std::ios_base::showbase) { *f++ = '#'; }"", ""#   if defined(_MSC_VER)"", ""    *f++ = 'I'; *f++ = '6'; *f++ = '4';"", ""#   else"", ""    *f++ = 'l'; *f++ = 'l';"", ""#   endif"", ""    long bflags = os.flags() & std::ios_base::basefield;"", ""    if(bflags == std::ios_base::oct) { *f++ = 'o'; }"", ""    else if(bflags != std::ios_base::hex) { *f++ = type; }"", ""    else if(os.flags() & std::ios_base::uppercase) { *f++ = 'X'; }"", ""    else { *f++ = 'x'; }"", ""    *f = '\\0';"", """", ""    // Use sprintf to print to a buffer and then write the"", ""    // buffer to the stream."", ""    char buffer[2*KWSYS_IOS_INT64_MAX_DIG];"", ""    sprintf(buffer, format, value);"", ""    os << buffer;"", ""    } catch(...) { os.clear(os.rdstate() | std::ios_base::badbit); }"", ""      // Construct the format string."", ""      char format[8];"", ""      char* f = format;"", ""      *f++ = '%';"", ""      if (os.flags() & std::ios_base::showpos) {"", ""        *f++ = '+';"", ""      }"", ""      if (os.flags() & std::ios_base::showbase) {"", ""        *f++ = '#';"", ""      }"", ""#if defined(_MSC_VER)"", ""      *f++ = 'I';"", ""      *f++ = '6';"", ""      *f++ = '4';"", ""#else"", ""      *f++ = 'l';"", ""      *f++ = 'l';"", ""#endif"", ""      long bflags = os.flags() & std::ios_base::basefield;"", ""      if (bflags == std::ios_base::oct) {"", ""        *f++ = 'o';"", ""      } else if (bflags != std::ios_base::hex) {"", ""        *f++ = type;"", ""      } else if (os.flags() & std::ios_base::uppercase) {"", ""        *f++ = 'X';"", ""      } else {"", ""        *f++ = 'x';"", ""      }"", ""      *f = '\\0';"", """", ""      // Use sprintf to print to a buffer and then write the"", ""      // buffer to the stream."", ""      char buffer[2 * KWSYS_IOS_INT64_MAX_DIG];"", ""      sprintf(buffer, format, value);"", ""      os << buffer;"", ""    } catch (...) {"", ""      os.clear(os.rdstate() | std::ios_base::badbit);"", ""    }"", ""  }"", ""  return os;"", ""}"", """", ""# if !KWSYS_IOS_HAS_ISTREAM_LONG_LONG"", ""#if !KWSYS_IOS_HAS_ISTREAM_LONG_LONG"", ""// Implement input stream operator for IOStreamSLL."", ""std::istream& IOStreamScan(std::istream& is, IOStreamSLL& value)"", ""{""]","[0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, 1, 0, 0, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0]","[[115, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/IOStream.cxx"", ""-"", ""sprintf(buffer, format, value);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_89_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_89_new.cpp""], [151, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/IOStream.cxx"", ""+"", ""sprintf(buffer, format, value);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_89_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_89_new.cpp""]]",123,107
"["" * of the structure of the compiled regexp."", "" */"", """", """", ""// compile -- compile a regular expression into internal code"", ""// for later pattern matching."", """", ""bool RegularExpression::compile (const char* exp) {"", ""    const char* scan;"", ""    const char* longest;"", ""    size_t      len;"", ""    int         flags;"", ""bool RegularExpression::compile(const char* exp)"", ""{"", ""  const char* scan;"", ""  const char* longest;"", ""  size_t len;"", ""  int flags;"", """", ""  if (exp == 0) {"", ""    // RAISE Error, SYM(RegularExpression), SYM(No_Expr),"", ""    printf(\""RegularExpression::compile(): No expression supplied.\\n\"");"", ""    return false;"", ""  }"", """", ""    if (exp == 0) {"", ""      //RAISE Error, SYM(RegularExpression), SYM(No_Expr),"", ""      printf (\""RegularExpression::compile(): No expression supplied.\\n\"");"", ""      return false;"", ""    }"", ""  // First pass: determine size, legality."", ""  regparse = exp;"", ""  regnpar = 1;"", ""  regsize = 0L;"", ""  regcode = &regdummy;"", ""  regc(static_cast<char>(MAGIC));"", ""  if (!reg(0, &flags)) {"", ""    printf(\""RegularExpression::compile(): Error in compile.\\n\"");"", ""    return false;"", ""  }"", ""  this->startp[0] = this->endp[0] = this->searchstring = 0;"", """", ""    // First pass: determine size, legality."", ""    regparse = exp;"", ""    regnpar = 1;"", ""    regsize = 0L;"", ""    regcode = &regdummy;"", ""    regc(static_cast<char>(MAGIC));"", ""    if(!reg(0, &flags))"", ""      {"", ""        printf (\""RegularExpression::compile(): Error in compile.\\n\"");"", ""        return false;"", ""      }"", ""    this->startp[0] = this->endp[0] = this->searchstring = 0;"", ""  // Small enough for pointer-storage convention?"", ""  if (regsize >= 32767L) { // Probably could be 65535L."", ""    // RAISE Error, SYM(RegularExpression), SYM(Expr_Too_Big),"", ""    printf(\""RegularExpression::compile(): Expression too big.\\n\"");"", ""    return false;"", ""  }"", """", ""    // Small enough for pointer-storage convention?"", ""    if (regsize >= 32767L) {    // Probably could be 65535L."", ""      //RAISE Error, SYM(RegularExpression), SYM(Expr_Too_Big),"", ""      printf (\""RegularExpression::compile(): Expression too big.\\n\"");"", ""      return false;"", ""    }"", ""  // Allocate space."", ""  //#ifndef _WIN32"", ""  if (this->program != 0)"", ""    delete[] this->program;"", ""  //#endif"", ""  this->program = new char[regsize];"", ""  this->progsize = static_cast<int>(regsize);"", """", ""  if (this->program == 0) {"", ""    // RAISE Error, SYM(RegularExpression), SYM(Out_Of_Memory),"", ""    printf(\""RegularExpression::compile(): Out of memory.\\n\"");"", ""    return false;"", ""  }"", """", ""    // Allocate space."", ""//#ifndef _WIN32"", ""    if (this->program != 0) delete [] this->program;"", ""//#endif"", ""    this->program = new char[regsize];"", ""    this->progsize = static_cast<int>(regsize);"", """", ""    if (this->program == 0) {"", ""      //RAISE Error, SYM(RegularExpression), SYM(Out_Of_Memory),"", ""      printf (\""RegularExpression::compile(): Out of memory.\\n\"");"", ""      return false;"", ""    }"", ""  // Second pass: emit code."", ""  regparse = exp;"", ""  regnpar = 1;"", ""  regcode = this->program;"", ""  regc(static_cast<char>(MAGIC));"", ""  reg(0, &flags);"", """", ""  // Dig out information for optimizations."", ""  this->regstart = '\\0'; // Worst-case defaults."", ""  this->reganch = 0;"", ""  this->regmust = 0;"", ""  this->regmlen = 0;"", ""  scan = this->program + 1;       // First BRANCH."", ""  if (OP(regnext(scan)) == END) { // Only one top-level choice."", ""    scan = OPERAND(scan);"", """", ""    // Starting-point info."", ""    if (OP(scan) == EXACTLY)"", ""      this->regstart = *OPERAND(scan);"", ""    else if (OP(scan) == BOL)"", ""      this->reganch++;"", """", ""    // Second pass: emit code."", ""    regparse = exp;"", ""    regnpar = 1;"", ""    regcode = this->program;"", ""    regc(static_cast<char>(MAGIC));"", ""    reg(0, &flags);"", """", ""    // Dig out information for optimizations."", ""    this->regstart = '\\0';              // Worst-case defaults."", ""    this->reganch = 0;"", ""    this->regmust = 0;"", ""    this->regmlen = 0;"", ""    scan = this->program + 1;   // First BRANCH."", ""    if (OP(regnext(scan)) == END) {     // Only one top-level choice."", ""        scan = OPERAND(scan);"", """", ""        // Starting-point info."", ""        if (OP(scan) == EXACTLY)"", ""            this->regstart = *OPERAND(scan);"", ""        else if (OP(scan) == BOL)"", ""            this->reganch++;"", """", ""         //"", ""         // If there's something expensive in the r.e., find the longest"", ""         // literal string that must appear and make it the regmust.  Resolve"", ""         // ties in favor of later strings, since the regstart check works"", ""         // with the beginning of the r.e. and avoiding duplication"", ""         // strengthens checking.  Not a strong reason, but sufficient in the"", ""         // absence of others."", ""         //"", ""        if (flags & SPSTART) {"", ""            longest = 0;"", ""            len = 0;"", ""            for (; scan != 0; scan = regnext(scan))"", ""                if (OP(scan) == EXACTLY && strlen(OPERAND(scan)) >= len) {"", ""                    longest = OPERAND(scan);"", ""                    len = strlen(OPERAND(scan));"", ""                }"", ""            this->regmust = longest;"", ""            this->regmlen = len;"", ""    //"", ""    // If there's something expensive in the r.e., find the longest"", ""    // literal string that must appear and make it the regmust.  Resolve"", ""    // ties in favor of later strings, since the regstart check works"", ""    // with the beginning of the r.e. and avoiding duplication"", ""    // strengthens checking.  Not a strong reason, but sufficient in the"", ""    // absence of others."", ""    //"", ""    if (flags & SPSTART) {"", ""      longest = 0;"", ""      len = 0;"", ""      for (; scan != 0; scan = regnext(scan))"", ""        if (OP(scan) == EXACTLY && strlen(OPERAND(scan)) >= len) {"", ""          longest = OPERAND(scan);"", ""          len = strlen(OPERAND(scan));"", ""        }"", ""      this->regmust = longest;"", ""      this->regmlen = len;"", ""    }"", ""    return true;"", ""  }"", ""  return true;"", ""}"", """", """", ""/*"", "" - reg - regular expression, i.e. main body or parenthesized thing"", "" *""]","[0, 0, 0, -1, 0, 0, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 2, 1, 1, 0, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, -1, 1, 1, 0, 0, -1, 0, 0, 0]","[[21, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): No expression supplied.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_new.cpp""], [37, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Error in compile.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_new.cpp""], [57, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Expression too big.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_new.cpp""], [77, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Out of memory.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_new.cpp""]]",339,325
"["" * is a trifle forced, but the need to tie the tails of the branches to what"", "" * follows makes it hard to avoid."", "" */"", ""static char* reg (int paren, int *flagp) {"", ""    char* ret;"", ""    char* br;"", ""    char* ender;"", ""    int   parno =0;"", ""    int   flags;"", """", ""    *flagp = HASWIDTH;          // Tentatively."", """", ""    // Make an OPEN node, if parenthesized."", ""    if (paren) {"", ""        if (regnpar >=  RegularExpression::NSUBEXP) {"", ""          //RAISE Error, SYM(RegularExpression), SYM(Too_Many_Parens),"", ""          printf (\""RegularExpression::compile(): Too many parentheses.\\n\"");"", ""          return 0;"", ""        }"", ""        parno = regnpar;"", ""        regnpar++;"", ""        ret = regnode(static_cast<char>(OPEN + parno));"", ""static char* reg(int paren, int* flagp)"", ""{"", ""  char* ret;"", ""  char* br;"", ""  char* ender;"", ""  int parno = 0;"", ""  int flags;"", """", ""  *flagp = HASWIDTH; // Tentatively."", """", ""  // Make an OPEN node, if parenthesized."", ""  if (paren) {"", ""    if (regnpar >= RegularExpression::NSUBEXP) {"", ""      // RAISE Error, SYM(RegularExpression), SYM(Too_Many_Parens),"", ""      printf(\""RegularExpression::compile(): Too many parentheses.\\n\"");"", ""      return 0;"", ""    }"", ""    else"", ""        ret = 0;"", """", ""    // Pick up the branches, linking them together."", ""    parno = regnpar;"", ""    regnpar++;"", ""    ret = regnode(static_cast<char>(OPEN + parno));"", ""  } else"", ""    ret = 0;"", """", ""  // Pick up the branches, linking them together."", ""  br = regbranch(&flags);"", ""  if (br == 0)"", ""    return (0);"", ""  if (ret != 0)"", ""    regtail(ret, br); // OPEN -> first."", ""  else"", ""    ret = br;"", ""  if (!(flags & HASWIDTH))"", ""    *flagp &= ~HASWIDTH;"", ""  *flagp |= flags & SPSTART;"", ""  while (*regparse == '|') {"", ""    regparse++;"", ""    br = regbranch(&flags);"", ""    if (br == 0)"", ""        return (0);"", ""    if (ret != 0)"", ""        regtail(ret, br);       // OPEN -> first."", ""    else"", ""        ret = br;"", ""      return (0);"", ""    regtail(ret, br); // BRANCH -> BRANCH."", ""    if (!(flags & HASWIDTH))"", ""        *flagp &= ~HASWIDTH;"", ""      *flagp &= ~HASWIDTH;"", ""    *flagp |= flags & SPSTART;"", ""    while (*regparse == '|') {"", ""        regparse++;"", ""        br = regbranch(&flags);"", ""        if (br == 0)"", ""            return (0);"", ""        regtail(ret, br);       // BRANCH -> BRANCH."", ""        if (!(flags & HASWIDTH))"", ""            *flagp &= ~HASWIDTH;"", ""        *flagp |= flags & SPSTART;"", ""      }"", """", ""    // Make a closing node, and hook it on the end."", ""    ender = regnode(static_cast<char>((paren) ? CLOSE + parno : END));"", ""    regtail(ret, ender);"", """", ""    // Hook the tails of the branches to the closing node."", ""    for (br = ret; br != 0; br = regnext(br))"", ""        regoptail(br, ender);"", ""  }"", """", ""    // Check for proper termination."", ""    if (paren && *regparse++ != ')') {"", ""        //RAISE Error, SYM(RegularExpression), SYM(Unmatched_Parens),"", ""        printf (\""RegularExpression::compile(): Unmatched parentheses.\\n\"");"", ""        return 0;"", ""    }"", ""    else if (!paren && *regparse != '\\0') {"", ""        if (*regparse == ')') {"", ""            //RAISE Error, SYM(RegularExpression), SYM(Unmatched_Parens),"", ""            printf (\""RegularExpression::compile(): Unmatched parentheses.\\n\"");"", ""            return 0;"", ""        }"", ""        else {"", ""            //RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""            printf (\""RegularExpression::compile(): Internal error.\\n\"");"", ""            return 0;"", ""        }"", ""        // NOTREACHED"", ""  // Make a closing node, and hook it on the end."", ""  ender = regnode(static_cast<char>((paren) ? CLOSE + parno : END));"", ""  regtail(ret, ender);"", """", ""  // Hook the tails of the branches to the closing node."", ""  for (br = ret; br != 0; br = regnext(br))"", ""    regoptail(br, ender);"", """", ""  // Check for proper termination."", ""  if (paren && *regparse++ != ')') {"", ""    // RAISE Error, SYM(RegularExpression), SYM(Unmatched_Parens),"", ""    printf(\""RegularExpression::compile(): Unmatched parentheses.\\n\"");"", ""    return 0;"", ""  } else if (!paren && *regparse != '\\0') {"", ""    if (*regparse == ')') {"", ""      // RAISE Error, SYM(RegularExpression), SYM(Unmatched_Parens),"", ""      printf(\""RegularExpression::compile(): Unmatched parentheses.\\n\"");"", ""      return 0;"", ""    } else {"", ""      // RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""      printf(\""RegularExpression::compile(): Internal error.\\n\"");"", ""      return 0;"", ""    }"", ""    return (ret);"", ""    // NOTREACHED"", ""  }"", ""  return (ret);"", ""}"", """", """", ""/*"", "" - regbranch - one alternative of an | operator"", "" *"", "" * Implements the concatenation operator."", "" */"", ""static char* regbranch (int *flagp) {"", ""    char* ret;"", ""    char* chain;"", ""    char* latest;"", ""    int   flags;"", """", ""    *flagp = WORST;             // Tentatively."", """", ""    ret = regnode(BRANCH);"", ""    chain = 0;"", ""    while (*regparse != '\\0' && *regparse != '|' && *regparse != ')') {"", ""        latest = regpiece(&flags);"", ""        if (latest == 0)"", ""            return (0);"", ""        *flagp |= flags & HASWIDTH;"", ""        if (chain == 0) // First piece."", ""            *flagp |= flags & SPSTART;"", ""        else"", ""            regtail(chain, latest);"", ""        chain = latest;"", ""    }"", ""    if (chain == 0)             // Loop ran zero times."", ""        regnode(NOTHING);"", ""static char* regbranch(int* flagp)"", ""{"", ""  char* ret;"", ""  char* chain;"", ""  char* latest;"", ""  int flags;"", """", ""  *flagp = WORST; // Tentatively."", """", ""  ret = regnode(BRANCH);"", ""  chain = 0;"", ""  while (*regparse != '\\0' && *regparse != '|' && *regparse != ')') {"", ""    latest = regpiece(&flags);"", ""    if (latest == 0)"", ""      return (0);"", ""    *flagp |= flags & HASWIDTH;"", ""    if (chain == 0) // First piece."", ""      *flagp |= flags & SPSTART;"", ""    else"", ""      regtail(chain, latest);"", ""    chain = latest;"", ""  }"", ""  if (chain == 0) // Loop ran zero times."", ""    regnode(NOTHING);"", """", ""    return (ret);"", ""  return (ret);"", ""}"", """", """", ""/*"", "" - regpiece - something followed by possible [*+?]"", "" *""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, 1, 1, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 0, -1, 1, 1, 1, 0, 0, -1, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, 0, -1, 0, 0, 0]","[[36, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Too many parentheses.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_new.cpp""], [124, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Unmatched parentheses.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_new.cpp""], [129, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Unmatched parentheses.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_new.cpp""], [133, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Internal error.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_new.cpp""]]",443,428
"["" * It might seem that this node could be dispensed with entirely, but the"", "" * endmarker role is not redundant."", "" */"", ""static char* regpiece (int *flagp) {"", ""    char* ret;"", ""    char  op;"", ""    char* next;"", ""    int   flags;"", """", ""    ret = regatom(&flags);"", ""    if (ret == 0)"", ""        return (0);"", ""static char* regpiece(int* flagp)"", ""{"", ""  char* ret;"", ""  char op;"", ""  char* next;"", ""  int flags;"", """", ""    op = *regparse;"", ""    if (!ISMULT(op)) {"", ""        *flagp = flags;"", ""        return (ret);"", ""    }"", ""  ret = regatom(&flags);"", ""  if (ret == 0)"", ""    return (0);"", """", ""    if (!(flags & HASWIDTH) && op != '?') {"", ""        //RAISE Error, SYM(RegularExpression), SYM(Empty_Operand),"", ""        printf (\""RegularExpression::compile() : *+ operand could be empty.\\n\"");"", ""        return 0;"", ""    }"", ""    *flagp = (op != '+') ? (WORST | SPSTART) : (WORST | HASWIDTH);"", """", ""    if (op == '*' && (flags & SIMPLE))"", ""        reginsert(STAR, ret);"", ""    else if (op == '*') {"", ""        // Emit x* as (x&|), where & means \""self\""."", ""        reginsert(BRANCH, ret); // Either x"", ""        regoptail(ret, regnode(BACK));  // and loop"", ""        regoptail(ret, ret);    // back"", ""        regtail(ret, regnode(BRANCH));  // or"", ""        regtail(ret, regnode(NOTHING)); // null."", ""    }"", ""    else if (op == '+' && (flags & SIMPLE))"", ""        reginsert(PLUS, ret);"", ""    else if (op == '+') {"", ""        // Emit x+ as x(&|), where & means \""self\""."", ""        next = regnode(BRANCH); // Either"", ""        regtail(ret, next);"", ""        regtail(regnode(BACK), ret);    // loop back"", ""        regtail(next, regnode(BRANCH)); // or"", ""        regtail(ret, regnode(NOTHING)); // null."", ""    }"", ""    else if (op == '?') {"", ""        // Emit x? as (x|)"", ""        reginsert(BRANCH, ret); // Either x"", ""        regtail(ret, regnode(BRANCH));  // or"", ""        next = regnode(NOTHING);// null."", ""        regtail(ret, next);"", ""        regoptail(ret, next);"", ""    }"", ""    regparse++;"", ""    if (ISMULT(*regparse)) {"", ""        //RAISE Error, SYM(RegularExpression), SYM(Nested_Operand),"", ""        printf (\""RegularExpression::compile(): Nested *?+.\\n\"");"", ""        return 0;"", ""    }"", ""  op = *regparse;"", ""  if (!ISMULT(op)) {"", ""    *flagp = flags;"", ""    return (ret);"", ""}"", ""  }"", """", ""  if (!(flags & HASWIDTH) && op != '?') {"", ""    // RAISE Error, SYM(RegularExpression), SYM(Empty_Operand),"", ""    printf(\""RegularExpression::compile() : *+ operand could be empty.\\n\"");"", ""    return 0;"", ""  }"", ""  *flagp = (op != '+') ? (WORST | SPSTART) : (WORST | HASWIDTH);"", """", ""  if (op == '*' && (flags & SIMPLE))"", ""    reginsert(STAR, ret);"", ""  else if (op == '*') {"", ""    // Emit x* as (x&|), where & means \""self\""."", ""    reginsert(BRANCH, ret);         // Either x"", ""    regoptail(ret, regnode(BACK));  // and loop"", ""    regoptail(ret, ret);            // back"", ""    regtail(ret, regnode(BRANCH));  // or"", ""    regtail(ret, regnode(NOTHING)); // null."", ""  } else if (op == '+' && (flags & SIMPLE))"", ""    reginsert(PLUS, ret);"", ""  else if (op == '+') {"", ""    // Emit x+ as x(&|), where & means \""self\""."", ""    next = regnode(BRANCH); // Either"", ""    regtail(ret, next);"", ""    regtail(regnode(BACK), ret);    // loop back"", ""    regtail(next, regnode(BRANCH)); // or"", ""    regtail(ret, regnode(NOTHING)); // null."", ""  } else if (op == '?') {"", ""    // Emit x? as (x|)"", ""    reginsert(BRANCH, ret);        // Either x"", ""    regtail(ret, regnode(BRANCH)); // or"", ""    next = regnode(NOTHING);       // null."", ""    regtail(ret, next);"", ""    regoptail(ret, next);"", ""  }"", ""  regparse++;"", ""  if (ISMULT(*regparse)) {"", ""    // RAISE Error, SYM(RegularExpression), SYM(Nested_Operand),"", ""    printf(\""RegularExpression::compile(): Nested *?+.\\n\"");"", ""    return 0;"", ""  }"", ""  return (ret);"", ""}"", """", ""/*"", "" - regatom - the lowest level""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 0, -1, 1, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0]","[[78, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile() : *+ operand could be empty.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_new.cpp""], [112, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Nested *?+.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_new.cpp""]]",561,543
"["" * faster to run.  Backslashed characters are exceptions, each becoming a"", "" * separate node; the code is simpler that way and it's not worth fixing."", "" */"", ""static char* regatom (int *flagp) {"", ""    char* ret;"", ""    int   flags;"", """", ""    *flagp = WORST;             // Tentatively."", """", ""    switch (*regparse++) {"", ""        case '^':"", ""            ret = regnode(BOL);"", ""            break;"", ""        case '$':"", ""            ret = regnode(EOL);"", ""            break;"", ""        case '.':"", ""            ret = regnode(ANY);"", ""            *flagp |= HASWIDTH | SIMPLE;"", ""            break;"", ""        case '[':{"", ""                int    rxpclass;"", ""                int    rxpclassend;"", """", ""                if (*regparse == '^') { // Complement of range."", ""                    ret = regnode(ANYBUT);"", ""                    regparse++;"", ""                }"", ""                else"", ""                    ret = regnode(ANYOF);"", ""                if (*regparse == ']' || *regparse == '-')"", ""                    regc(*regparse++);"", ""                while (*regparse != '\\0' && *regparse != ']') {"", ""                    if (*regparse == '-') {"", ""                        regparse++;"", ""                        if (*regparse == ']' || *regparse == '\\0')"", ""                            regc('-');"", ""                        else {"", ""                            rxpclass = UCHARAT(regparse - 2) + 1;"", ""                            rxpclassend = UCHARAT(regparse);"", ""                            if (rxpclass > rxpclassend + 1) {"", ""                               //RAISE Error, SYM(RegularExpression), SYM(Invalid_Range),"", ""                               printf (\""RegularExpression::compile(): Invalid range in [].\\n\"");"", ""                               return 0;"", ""                            }"", ""                            for (; rxpclass <= rxpclassend; rxpclass++)"", ""                              regc(static_cast<char>(rxpclass));"", ""                            regparse++;"", ""                        }"", ""                    }"", ""                    else"", ""                        regc(*regparse++);"", ""                }"", ""                regc('\\0');"", ""                if (*regparse != ']') {"", ""                    //RAISE Error, SYM(RegularExpression), SYM(Unmatched_Bracket),"", ""                    printf (\""RegularExpression::compile(): Unmatched [].\\n\"");"", ""                    return 0;"", ""                }"", ""                regparse++;"", ""                *flagp |= HASWIDTH | SIMPLE;"", ""            }"", ""            break;"", ""        case '(':"", ""            ret = reg(1, &flags);"", ""            if (ret == 0)"", ""                return (0);"", ""            *flagp |= flags & (HASWIDTH | SPSTART);"", ""            break;"", ""        case '\\0':"", ""        case '|':"", ""        case ')':"", ""            //RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""            printf (\""RegularExpression::compile(): Internal error.\\n\""); // Never here"", ""            return 0;"", ""        case '?':"", ""        case '+':"", ""        case '*':"", ""            //RAISE Error, SYM(RegularExpression), SYM(No_Operand),"", ""            printf (\""RegularExpression::compile(): ?+* follows nothing.\\n\"");"", ""            return 0;"", ""        case '\\\\':"", ""            if (*regparse == '\\0') {"", ""                //RAISE Error, SYM(RegularExpression), SYM(Trailing_Backslash),"", ""                printf (\""RegularExpression::compile(): Trailing backslash.\\n\"");"", ""                return 0;"", ""            }"", ""            ret = regnode(EXACTLY);"", ""            regc(*regparse++);"", ""            regc('\\0');"", ""            *flagp |= HASWIDTH | SIMPLE;"", ""            break;"", ""        default:{"", ""                int    len;"", ""                char   ender;"", """", ""                regparse--;"", ""                len = int(strcspn(regparse, META));"", ""                if (len <= 0) {"", ""                    //RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""                    printf (\""RegularExpression::compile(): Internal error.\\n\"");"", ""                    return 0;"", ""                }"", ""                ender = *(regparse + len);"", ""                if (len > 1 && ISMULT(ender))"", ""                    len--;      // Back off clear of ?+* operand."", ""                *flagp |= HASWIDTH;"", ""                if (len == 1)"", ""                    *flagp |= SIMPLE;"", ""                ret = regnode(EXACTLY);"", ""                while (len > 0) {"", ""                    regc(*regparse++);"", ""                    len--;"", ""                }"", ""                regc('\\0');"", ""static char* regatom(int* flagp)"", ""{"", ""  char* ret;"", ""  int flags;"", """", ""  *flagp = WORST; // Tentatively."", """", ""  switch (*regparse++) {"", ""    case '^':"", ""      ret = regnode(BOL);"", ""      break;"", ""    case '$':"", ""      ret = regnode(EOL);"", ""      break;"", ""    case '.':"", ""      ret = regnode(ANY);"", ""      *flagp |= HASWIDTH | SIMPLE;"", ""      break;"", ""    case '[': {"", ""      int rxpclass;"", ""      int rxpclassend;"", """", ""      if (*regparse == '^') { // Complement of range."", ""        ret = regnode(ANYBUT);"", ""        regparse++;"", ""      } else"", ""        ret = regnode(ANYOF);"", ""      if (*regparse == ']' || *regparse == '-')"", ""        regc(*regparse++);"", ""      while (*regparse != '\\0' && *regparse != ']') {"", ""        if (*regparse == '-') {"", ""          regparse++;"", ""          if (*regparse == ']' || *regparse == '\\0')"", ""            regc('-');"", ""          else {"", ""            rxpclass = UCHARAT(regparse - 2) + 1;"", ""            rxpclassend = UCHARAT(regparse);"", ""            if (rxpclass > rxpclassend + 1) {"", ""              // RAISE Error, SYM(RegularExpression), SYM(Invalid_Range),"", ""              printf(\""RegularExpression::compile(): Invalid range in [].\\n\"");"", ""              return 0;"", ""            }"", ""            break;"", ""    }"", ""    return (ret);"", ""            for (; rxpclass <= rxpclassend; rxpclass++)"", ""              regc(static_cast<char>(rxpclass));"", ""            regparse++;"", ""          }"", ""        } else"", ""          regc(*regparse++);"", ""      }"", ""      regc('\\0');"", ""      if (*regparse != ']') {"", ""        // RAISE Error, SYM(RegularExpression), SYM(Unmatched_Bracket),"", ""        printf(\""RegularExpression::compile(): Unmatched [].\\n\"");"", ""        return 0;"", ""      }"", ""      regparse++;"", ""      *flagp |= HASWIDTH | SIMPLE;"", ""    } break;"", ""    case '(':"", ""      ret = reg(1, &flags);"", ""      if (ret == 0)"", ""        return (0);"", ""      *flagp |= flags & (HASWIDTH | SPSTART);"", ""      break;"", ""    case '\\0':"", ""    case '|':"", ""    case ')':"", ""      // RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""      printf(\""RegularExpression::compile(): Internal error.\\n\""); // Never here"", ""      return 0;"", ""    case '?':"", ""    case '+':"", ""    case '*':"", ""      // RAISE Error, SYM(RegularExpression), SYM(No_Operand),"", ""      printf(\""RegularExpression::compile(): ?+* follows nothing.\\n\"");"", ""      return 0;"", ""    case '\\\\':"", ""      if (*regparse == '\\0') {"", ""        // RAISE Error, SYM(RegularExpression), SYM(Trailing_Backslash),"", ""        printf(\""RegularExpression::compile(): Trailing backslash.\\n\"");"", ""        return 0;"", ""      }"", ""      ret = regnode(EXACTLY);"", ""      regc(*regparse++);"", ""      regc('\\0');"", ""      *flagp |= HASWIDTH | SIMPLE;"", ""      break;"", ""    default: {"", ""      int len;"", ""      char ender;"", """", ""      regparse--;"", ""      len = int(strcspn(regparse, META));"", ""      if (len <= 0) {"", ""        // RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""        printf(\""RegularExpression::compile(): Internal error.\\n\"");"", ""        return 0;"", ""      }"", ""      ender = *(regparse + len);"", ""      if (len > 1 && ISMULT(ender))"", ""        len--; // Back off clear of ?+* operand."", ""      *flagp |= HASWIDTH;"", ""      if (len == 1)"", ""        *flagp |= SIMPLE;"", ""      ret = regnode(EXACTLY);"", ""      while (len > 0) {"", ""        regc(*regparse++);"", ""        len--;"", ""      }"", ""      regc('\\0');"", ""    } break;"", ""  }"", ""  return (ret);"", ""}"", """", """", ""/*"", "" - regnode - emit a node"", ""   Location."", "" */"", ""static char* regnode (char op) {"", ""    char* ret;"", ""    char* ptr;"", """", ""    ret = regcode;"", ""    if (ret == &regdummy) {"", ""        regsize += 3;"", ""        return (ret);"", ""    }"", """", ""    ptr = ret;"", ""    *ptr++ = op;"", ""    *ptr++ = '\\0';              // Null \""next\"" pointer."", ""    *ptr++ = '\\0';"", ""    regcode = ptr;"", ""static char* regnode(char op)"", ""{"", ""  char* ret;"", ""  char* ptr;"", """", ""  ret = regcode;"", ""  if (ret == &regdummy) {"", ""    regsize += 3;"", ""    return (ret);"", ""}"", ""  }"", """", ""  ptr = ret;"", ""  *ptr++ = op;"", ""  *ptr++ = '\\0'; // Null \""next\"" pointer."", ""  *ptr++ = '\\0';"", ""  regcode = ptr;"", """", ""  return (ret);"", ""}"", """", ""/*"", "" - regc - emit (if appropriate) a byte of code"", "" */"", ""static void regc (char b) {"", ""    if (regcode != &regdummy)"", ""        *regcode++ = b;"", ""    else"", ""        regsize++;"", ""static void regc(char b)"", ""{"", ""  if (regcode != &regdummy)"", ""    *regcode++ = b;"", ""  else"", ""    regsize++;"", ""}"", """", """", ""/*"", "" - reginsert - insert an operator in front of already-emitted operand"", "" *"", "" * Means relocating the operand."", "" */"", ""static void reginsert (char op, char* opnd) {"", ""    char* src;"", ""    char* dst;"", ""    char* place;"", """", ""    if (regcode == &regdummy) {"", ""        regsize += 3;"", ""        return;"", ""    }"", ""static void reginsert(char op, char* opnd)"", ""{"", ""  char* src;"", ""  char* dst;"", ""  char* place;"", """", ""  if (regcode == &regdummy) {"", ""    regsize += 3;"", ""    return;"", ""  }"", """", ""    src = regcode;"", ""    regcode += 3;"", ""    dst = regcode;"", ""    while (src > opnd)"", ""        *--dst = *--src;"", ""  src = regcode;"", ""  regcode += 3;"", ""  dst = regcode;"", ""  while (src > opnd)"", ""    *--dst = *--src;"", """", ""    place = opnd;               // Op node, where operand used to be."", ""    *place++ = op;"", ""    *place++ = '\\0';"", ""    *place = '\\0';"", ""  place = opnd; // Op node, where operand used to be."", ""  *place++ = op;"", ""  *place++ = '\\0';"", ""  *place = '\\0';"", ""}"", """", """", ""/*"", "" - regtail - set the next-pointer at the end of a node chain"", "" */"", ""static void regtail (char* p, const char* val) {"", ""    char* scan;"", ""    char* temp;"", ""    int   offset;"", """", ""    if (p == &regdummy)"", ""        return;"", """", ""    // Find last node."", ""    scan = p;"", ""    for (;;) {"", ""        temp = regnext(scan);"", ""        if (temp == 0)"", ""            break;"", ""        scan = temp;"", ""    }"", ""static void regtail(char* p, const char* val)"", ""{"", ""  char* scan;"", ""  char* temp;"", ""  int offset;"", """", ""    if (OP(scan) == BACK)"", ""        offset = int(scan - val);"", ""    else"", ""        offset = int(val - scan);"", ""    *(scan + 1) = static_cast<char>((offset >> 8) & 0377);"", ""    *(scan + 2) = static_cast<char>(offset & 0377);"", ""}"", ""  if (p == &regdummy)"", ""    return;"", """", ""  // Find last node."", ""  scan = p;"", ""  for (;;) {"", ""    temp = regnext(scan);"", ""    if (temp == 0)"", ""      break;"", ""    scan = temp;"", ""  }"", """", ""  if (OP(scan) == BACK)"", ""    offset = int(scan - val);"", ""  else"", ""    offset = int(val - scan);"", ""  *(scan + 1) = static_cast<char>((offset >> 8) & 0377);"", ""  *(scan + 2) = static_cast<char>(offset & 0377);"", ""}"", """", ""/*"", "" - regoptail - regtail on operand of first argument; nop if operandless"", "" */"", ""static void regoptail (char* p, const char* val) {"", ""    // \""Operandless\"" and \""op != BRANCH\"" are synonymous in practice."", ""    if (p == 0 || p == &regdummy || OP(p) != BRANCH)"", ""        return;"", ""    regtail(OPERAND(p), val);"", ""static void regoptail(char* p, const char* val)"", ""{"", ""  // \""Operandless\"" and \""op != BRANCH\"" are synonymous in practice."", ""  if (p == 0 || p == &regdummy || OP(p) != BRANCH)"", ""    return;"", ""  regtail(OPERAND(p), val);"", ""}"", """", """", """", ""////////////////////////////////////////////////////////////////////////"", ""// "", ""//"", ""//  find and friends"", ""// "", ""//"", ""////////////////////////////////////////////////////////////////////////"", """", """", ""/*"", "" * Global work variables for find()."", "" */"", ""static const char*  reginput;   // String-input pointer."", ""static const char*  regbol;     // Beginning of input, for ^ check."", ""static const char* *regstartp;  // Pointer to startp array."", ""static const char* *regendp;    // Ditto for endp."", ""static const char* reginput;   // String-input pointer."", ""static const char* regbol;     // Beginning of input, for ^ check."", ""static const char** regstartp; // Pointer to startp array."", ""static const char** regendp;   // Ditto for endp."", """", ""/*"", "" * Forwards."", "" */"", ""static int regtry (const char*, const char* *,"", ""                   const char* *, const char*);"", ""static int regmatch (const char*);"", ""static int regrepeat (const char*);"", ""static int regtry(const char*, const char**, const char**, const char*);"", ""static int regmatch(const char*);"", ""static int regrepeat(const char*);"", """", ""#ifdef DEBUG"", ""int          regnarrate = 0;"", ""void         regdump ();"", ""static char* regprop ();"", ""int regnarrate = 0;"", ""void regdump();"", ""static char* regprop();"", ""#endif"", """", ""// find -- Matches the regular expression to the given string."", ""// Returns true if found, and sets start and end indexes accordingly."", """", ""bool RegularExpression::find (const char* string) {"", ""    const char* s;"", ""bool RegularExpression::find(const char* string)"", ""{"", ""  const char* s;"", """", ""    this->searchstring = string;"", ""  this->searchstring = string;"", """", ""    if (!this->program)"", ""      {"", ""      return false;"", ""      }"", ""  if (!this->program) {"", ""    return false;"", ""  }"", """", ""    // Check validity of program."", ""    if (UCHARAT(this->program) != MAGIC) {"", ""        //RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""        printf (\""RegularExpression::find(): Compiled regular expression corrupted.\\n\"");"", ""        return 0;"", ""    }"", ""  // Check validity of program."", ""  if (UCHARAT(this->program) != MAGIC) {"", ""    // RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""    printf("", ""      \""RegularExpression::find(): Compiled regular expression corrupted.\\n\"");"", ""    return 0;"", ""  }"", """", ""    // If there is a \""must appear\"" string, look for it."", ""    if (this->regmust != 0) {"", ""        s = string;"", ""        while ((s = strchr(s, this->regmust[0])) != 0) {"", ""            if (strncmp(s, this->regmust, this->regmlen) == 0)"", ""                break;          // Found it."", ""            s++;"", ""        }"", ""        if (s == 0)             // Not present."", ""            return (0);"", ""  // If there is a \""must appear\"" string, look for it."", ""  if (this->regmust != 0) {"", ""    s = string;"", ""    while ((s = strchr(s, this->regmust[0])) != 0) {"", ""      if (strncmp(s, this->regmust, this->regmlen) == 0)"", ""        break; // Found it."", ""      s++;"", ""    }"", ""    if (s == 0) // Not present."", ""      return (0);"", ""  }"", """", ""    // Mark beginning of line for ^ ."", ""    regbol = string;"", """", ""    // Simplest case:  anchored match need be tried only once."", ""    if (this->reganch)"", ""        return (regtry(string, this->startp, this->endp, this->program) != 0);"", ""  // Mark beginning of line for ^ ."", ""  regbol = string;"", """", ""    // Messy cases:  unanchored match."", ""    s = string;"", ""    if (this->regstart != '\\0')"", ""        // We know what char it must start with."", ""        while ((s = strchr(s, this->regstart)) != 0) {"", ""            if (regtry(s, this->startp, this->endp, this->program))"", ""                return (1);"", ""            s++;"", ""  // Simplest case:  anchored match need be tried only once."", ""  if (this->reganch)"", ""    return (regtry(string, this->startp, this->endp, this->program) != 0);"", """", ""        }"", ""    else"", ""        // We don't -- general case."", ""        do {"", ""            if (regtry(s, this->startp, this->endp, this->program))"", ""                return (1);"", ""        } while (*s++ != '\\0');"", ""  // Messy cases:  unanchored match."", ""  s = string;"", ""  if (this->regstart != '\\0')"", ""    // We know what char it must start with."", ""    while ((s = strchr(s, this->regstart)) != 0) {"", ""      if (regtry(s, this->startp, this->endp, this->program))"", ""        return (1);"", ""      s++;"", ""    }"", ""  else"", ""    // We don't -- general case."", ""    do {"", ""      if (regtry(s, this->startp, this->endp, this->program))"", ""        return (1);"", ""    } while (*s++ != '\\0');"", """", ""    // Failure."", ""    return (0);"", ""  // Failure."", ""  return (0);"", ""}"", """", """", ""/*"", "" - regtry - try match at specific point"", ""   0 failure, 1 success"", "" */"", ""static int regtry (const char* string, const char* *start,"", ""                   const char* *end, const char* prog) {"", ""                   int    i;"", ""                   const char* *sp1;"", ""                   const char* *ep;"", """", ""    reginput = string;"", ""    regstartp = start;"", ""    regendp = end;"", """", ""    sp1 = start;"", ""    ep = end;"", ""    for (i = RegularExpression::NSUBEXP; i > 0; i--) {"", ""        *sp1++ = 0;"", ""        *ep++ = 0;"", ""    }"", ""    if (regmatch(prog + 1)) {"", ""        start[0] = string;"", ""        end[0] = reginput;"", ""        return (1);"", ""    }"", ""    else"", ""        return (0);"", ""static int regtry(const char* string, const char** start, const char** end,"", ""                  const char* prog)"", ""{"", ""  int i;"", ""  const char** sp1;"", ""  const char** ep;"", """", ""  reginput = string;"", ""  regstartp = start;"", ""  regendp = end;"", """", ""  sp1 = start;"", ""  ep = end;"", ""  for (i = RegularExpression::NSUBEXP; i > 0; i--) {"", ""    *sp1++ = 0;"", ""    *ep++ = 0;"", ""  }"", ""  if (regmatch(prog + 1)) {"", ""    start[0] = string;"", ""    end[0] = reginput;"", ""    return (1);"", ""  } else"", ""    return (0);"", ""}"", """", """", ""/*"", "" - regmatch - main matching routine"", "" *""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 0, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 0, 1, 1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 0, 0, -1, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, 0, -1, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, 0, -1, 1, 0, -1, 1, 0, 0, -1, 0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, 0, 0, 0, -1, -1, 1, 1, 1, 0, -1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, 1, 1, 1, 2, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, 1, 1, 0, 0, -1, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, 0, 0, 0]","[[154, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Invalid range in [].\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_new.cpp""], [170, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Unmatched [].\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_new.cpp""], [186, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Internal error.\\n\""); // Never here"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_new.cpp""], [192, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): ?+* follows nothing.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_new.cpp""], [197, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Trailing backslash.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_new.cpp""], [213, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Internal error.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_new.cpp""], [478, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf("", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_90_new.cpp""]]",630,610
"[""#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)"", ""  CONSOLE_SCREEN_BUFFER_INFO hOutInfo;"", ""  HANDLE hOut = kwsysTerminalGetStreamHandle(stream);"", ""  if(GetConsoleScreenBufferInfo(hOut, &hOutInfo))"", ""    {"", ""  if (GetConsoleScreenBufferInfo(hOut, &hOutInfo)) {"", ""    pipeIsConsole = 1;"", ""    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream, color);"", ""    }"", ""  }"", ""#endif"", ""  if(!pipeIsConsole && kwsysTerminalStreamIsVT100(stream,"", ""                                                  default_vt100, default_tty))"", ""    {"", ""  if (!pipeIsConsole &&"", ""      kwsysTerminalStreamIsVT100(stream, default_vt100, default_tty)) {"", ""    pipeIsVT100 = 1;"", ""    kwsysTerminalSetVT100Color(stream, color);"", ""    }"", ""  }"", """", ""  /* Format the text into the stream.  */"", ""  {"", ""  va_list var_args;"", ""  va_start(var_args, format);"", ""  vfprintf(stream, format, var_args);"", ""  va_end(var_args);"", ""    va_list var_args;"", ""    va_start(var_args, format);"", ""    vfprintf(stream, format, var_args);"", ""    va_end(var_args);"", ""  }"", """", ""  /* Restore the normal color state for the stream.  */"", ""/* Restore the normal color state for the stream.  */"", ""#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)"", ""  if(pipeIsConsole)"", ""    {"", ""  if (pipeIsConsole) {"", ""    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream,"", ""                                 kwsysTerminal_Color_Normal);"", ""    }"", ""  }"", ""#endif"", ""  if(pipeIsVT100)"", ""    {"", ""  if (pipeIsVT100) {"", ""    kwsysTerminalSetVT100Color(stream, kwsysTerminal_Color_Normal);"", ""    }"", ""  }"", ""}"", """", ""/*--------------------------------------------------------------------------*/""]","[0, 0, 0, -1, -1, 1, 0, 0, -1, 1, 0, -1, -1, -1, 1, 1, 0, 0, -1, 1, 0, 0, 0, -1, -1, -2, -1, 1, 1, 2, 1, 0, 0, -1, 1, 0, -1, -1, 1, 0, 0, -1, 1, 0, -1, -1, 1, 0, -1, 1, 0, 0, 0]","[[25, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/Terminal.c"", ""-"", ""vfprintf(stream, format, var_args);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_91_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_91_new.cpp""], [29, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/Terminal.c"", ""+"", ""vfprintf(stream, format, var_args);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_91_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_91_new.cpp""]]",68,58
"[""  return 0;"", ""}"", """", ""static int runChild2(kwsysProcess* kp,"", ""              const char* cmd[], int state, int exception, int value,"", ""              int share, int output, int delay, double timeout,"", ""              int poll, int disown, int createNewGroup,"", ""              unsigned int interruptDelay)"", ""static int runChild2(kwsysProcess* kp, const char* cmd[], int state,"", ""                     int exception, int value, int share, int output,"", ""                     int delay, double timeout, int poll, int disown,"", ""                     int createNewGroup, unsigned int interruptDelay)"", ""{"", ""  int result = 0;"", ""  char* data = 0;"", ""  int length = 0;"", ""  double userTimeout = 0;"", ""  double* pUserTimeout = 0;"", ""  kwsysProcess_SetCommand(kp, cmd);"", ""  if(timeout >= 0)"", ""    {"", ""  if (timeout >= 0) {"", ""    kwsysProcess_SetTimeout(kp, timeout);"", ""    }"", ""  if(share)"", ""    {"", ""  }"", ""  if (share) {"", ""    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);"", ""    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);"", ""    }"", ""  if(disown)"", ""    {"", ""  }"", ""  if (disown) {"", ""    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);"", ""    }"", ""  if(createNewGroup)"", ""    {"", ""  }"", ""  if (createNewGroup) {"", ""    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);"", ""    }"", ""  }"", ""  kwsysProcess_Execute(kp);"", """", ""  if(poll)"", ""    {"", ""  if (poll) {"", ""    pUserTimeout = &userTimeout;"", ""    }"", ""  }"", """", ""  if(interruptDelay)"", ""    {"", ""  if (interruptDelay) {"", ""    testProcess_sleep(interruptDelay);"", ""    kwsysProcess_Interrupt(kp);"", ""    }"", ""  }"", """", ""  if(!share && !disown)"", ""    {"", ""  if (!share && !disown) {"", ""    int p;"", ""    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))"", ""      {"", ""      if(output)"", ""        {"", ""        if(poll && p == kwsysProcess_Pipe_Timeout)"", ""          {"", ""    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {"", ""      if (output) {"", ""        if (poll && p == kwsysProcess_Pipe_Timeout) {"", ""          fprintf(stdout, \""WaitForData timeout reached.\\n\"");"", ""          fflush(stdout);"", """", ""          /* Count the number of times we polled without getting data."", ""             If it is excessive then kill the child and fail.  */"", ""          if(++poll >= MAXPOLL)"", ""            {"", ""            fprintf(stdout, \""Poll count reached limit %d.\\n\"","", ""                    MAXPOLL);"", ""          if (++poll >= MAXPOLL) {"", ""            fprintf(stdout, \""Poll count reached limit %d.\\n\"", MAXPOLL);"", ""            kwsysProcess_Kill(kp);"", ""            }"", ""          }"", ""        else"", ""          {"", ""          fwrite(data, 1, (size_t) length, stdout);"", ""        } else {"", ""          fwrite(data, 1, (size_t)length, stdout);"", ""          fflush(stdout);"", ""          }"", ""        }"", ""      if(poll)"", ""        {"", ""      }"", ""      if (poll) {"", ""        /* Delay to avoid busy loop during polling.  */"", ""        testProcess_usleep(100000);"", ""        }"", ""      if(delay)"", ""        {"", ""        /* Purposely sleeping only on Win32 to let pipe fill up.  */"", ""      }"", ""      if (delay) {"", ""/* Purposely sleeping only on Win32 to let pipe fill up.  */"", ""#if defined(_WIN32)"", ""        testProcess_usleep(100000);"", ""#endif"", ""        }"", ""      }"", ""    }"", ""  }"", """", ""  if(disown)"", ""    {"", ""  if (disown) {"", ""    kwsysProcess_Disown(kp);"", ""    }"", ""  else"", ""    {"", ""  } else {"", ""    kwsysProcess_WaitForExit(kp, 0);"", ""    }"", ""  }"", """", ""  switch (kwsysProcess_GetState(kp))"", ""    {"", ""  switch (kwsysProcess_GetState(kp)) {"", ""    case kwsysProcess_State_Starting:"", ""      printf(\""No process has been executed.\\n\""); break;"", ""      printf(\""No process has been executed.\\n\"");"", ""      break;"", ""    case kwsysProcess_State_Executing:"", ""      printf(\""The process is still executing.\\n\""); break;"", ""      printf(\""The process is still executing.\\n\"");"", ""      break;"", ""    case kwsysProcess_State_Expired:"", ""      printf(\""Child was killed when timeout expired.\\n\""); break;"", ""      printf(\""Child was killed when timeout expired.\\n\"");"", ""      break;"", ""    case kwsysProcess_State_Exited:"", ""      printf(\""Child exited with value = %d\\n\"","", ""             kwsysProcess_GetExitValue(kp));"", ""      printf(\""Child exited with value = %d\\n\"", kwsysProcess_GetExitValue(kp));"", ""      result = ((exception != kwsysProcess_GetExitException(kp)) ||"", ""                (value != kwsysProcess_GetExitValue(kp))); break;"", ""                (value != kwsysProcess_GetExitValue(kp)));"", ""      break;"", ""    case kwsysProcess_State_Killed:"", ""      printf(\""Child was killed by parent.\\n\""); break;"", ""      printf(\""Child was killed by parent.\\n\"");"", ""      break;"", ""    case kwsysProcess_State_Exception:"", ""      printf(\""Child terminated abnormally: %s\\n\"","", ""             kwsysProcess_GetExceptionString(kp));"", ""      result = ((exception != kwsysProcess_GetExitException(kp)) ||"", ""                (value != kwsysProcess_GetExitValue(kp))); break;"", ""                (value != kwsysProcess_GetExitValue(kp)));"", ""      break;"", ""    case kwsysProcess_State_Disowned:"", ""      printf(\""Child was disowned.\\n\""); break;"", ""      printf(\""Child was disowned.\\n\"");"", ""      break;"", ""    case kwsysProcess_State_Error:"", ""      printf(\""Error in administrating child process: [%s]\\n\"","", ""             kwsysProcess_GetErrorString(kp)); break;"", ""    };"", ""             kwsysProcess_GetErrorString(kp));"", ""      break;"", ""  };"", """", ""  if(result)"", ""    {"", ""    if(exception != kwsysProcess_GetExitException(kp))"", ""      {"", ""  if (result) {"", ""    if (exception != kwsysProcess_GetExitException(kp)) {"", ""      fprintf(stderr, \""Mismatch in exit exception.  \"""", ""              \""Should have been %d, was %d.\\n\"","", ""                      \""Should have been %d, was %d.\\n\"","", ""              exception, kwsysProcess_GetExitException(kp));"", ""      }"", ""    if(value != kwsysProcess_GetExitValue(kp))"", ""      {"", ""    }"", ""    if (value != kwsysProcess_GetExitValue(kp)) {"", ""      fprintf(stderr, \""Mismatch in exit value.  \"""", ""              \""Should have been %d, was %d.\\n\"","", ""                      \""Should have been %d, was %d.\\n\"","", ""              value, kwsysProcess_GetExitValue(kp));"", ""      }"", ""    }"", ""  }"", """", ""  if(kwsysProcess_GetState(kp) != state)"", ""    {"", ""  if (kwsysProcess_GetState(kp) != state) {"", ""    fprintf(stderr, \""Mismatch in state.  \"""", ""            \""Should have been %d, was %d.\\n\"","", ""                    \""Should have been %d, was %d.\\n\"","", ""            state, kwsysProcess_GetState(kp));"", ""    result = 1;"", ""    }"", ""  }"", """", ""  /* We should have polled more times than there were data if polling"", ""     was enabled.  */"", ""  if(poll && poll < MINPOLL)"", ""    {"", ""    fprintf(stderr, \""Poll count is %d, which is less than %d.\\n\"","", ""            poll, MINPOLL);"", ""  if (poll && poll < MINPOLL) {"", ""    fprintf(stderr, \""Poll count is %d, which is less than %d.\\n\"", poll,"", ""            MINPOLL);"", ""    result = 1;"", ""    }"", ""  }"", """", ""  return result;"", ""}""]","[0, 0, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, 1, 0, -1, -1, -1, 1, 1, 0, 0, -1, -1, -1, 1, 1, 0, -1, -1, -1, 1, 1, 0, -1, 1, 0, 0, -1, -1, 1, 0, -1, 1, 0, -1, -1, 1, 0, 0, -1, 1, 0, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, 1, 1, 1, 0, 0, 0, 0, 0, -1, -1, -2, -1, 1, 2, 0, -1, 0, -1, -1, -1, 1, 1, 0, -1, 0, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, 1, 1, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, -1, 1, 0, -1, -1, -1, 1, 0, -1, 1, 0, -1, -1, 1, 0, -2, 2, 1, 0, -2, 2, 1, 0, -2, 2, 1, 0, -2, -1, 2, 0, -1, 1, 1, 0, -2, 2, 1, 0, 0, 0, 0, -1, 1, 1, 0, -2, 2, 1, 0, 0, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 0, -1, 1, 0, -1, -1, -1, 1, 1, 0, -1, 1, 0, -1, 0, 1, 0, -1, -1, 1, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, -1, -1, -2, -1, 1, 2, 1, 0, -1, 1, 0, 0, 0]","[[81, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""-"", ""fprintf(stdout, \""Poll count reached limit %d.\\n\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_new.cpp""], [84, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""+"", ""fprintf(stdout, \""Poll count reached limit %d.\\n\"", MAXPOLL);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_new.cpp""], [133, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""-"", ""printf(\""No process has been executed.\\n\""); break;"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_new.cpp""], [134, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""+"", ""printf(\""No process has been executed.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_new.cpp""], [137, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""-"", ""printf(\""The process is still executing.\\n\""); break;"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_new.cpp""], [138, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""+"", ""printf(\""The process is still executing.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_new.cpp""], [141, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""-"", ""printf(\""Child was killed when timeout expired.\\n\""); break;"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_new.cpp""], [142, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""+"", ""printf(\""Child was killed when timeout expired.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_new.cpp""], [145, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""-"", ""printf(\""Child exited with value = %d\\n\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_new.cpp""], [147, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""+"", ""printf(\""Child exited with value = %d\\n\"", kwsysProcess_GetExitValue(kp));"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_new.cpp""], [153, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""-"", ""printf(\""Child was killed by parent.\\n\""); break;"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_new.cpp""], [154, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""+"", ""printf(\""Child was killed by parent.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_new.cpp""], [164, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""-"", ""printf(\""Child was disowned.\\n\""); break;"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_new.cpp""], [165, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""+"", ""printf(\""Child was disowned.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_new.cpp""], [213, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""-"", ""fprintf(stderr, \""Poll count is %d, which is less than %d.\\n\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_new.cpp""], [216, ""88f38a2bb42599561e685dfba956866d857fe518"", ""Merge topic 'update-kwsys'\n\n95a97a40 Merge branch 'upstream-KWSys' into update-kwsys\n773b36e5 KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""+"", ""fprintf(stderr, \""Poll count is %d, which is less than %d.\\n\"", poll,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_92_new.cpp""]]",368,362
"["""", ""// Read an integer value from an input stream."", ""template <class T>"", ""std::istream&"", ""IOStreamScanTemplate(std::istream& is, T& value, char type)"", ""std::istream& IOStreamScanTemplate(std::istream& is, T& value, char type)"", ""{"", ""  int state = std::ios_base::goodbit;"", """", ""  // Skip leading whitespace."", ""  std::istream::sentry okay(is);"", """", ""  if(okay)"", ""    {"", ""  if (okay) {"", ""    try {"", ""    // Copy the string to a buffer and construct the format string."", ""    char buffer[KWSYS_IOS_INT64_MAX_DIG];"", ""#   if defined(_MSC_VER)"", ""    char format[] = \""%I64_\"";"", ""    const int typeIndex = 4;"", ""#   else"", ""    char format[] = \""%ll_\"";"", ""    const int typeIndex = 3;"", ""#   endif"", ""    switch(IOStreamScanStream(is, buffer))"", ""      {"", ""      case 8: format[typeIndex] = 'o'; break;"", ""      case 0: // Default to decimal if not told otherwise."", ""      case 10: format[typeIndex] = type; break;"", ""      case 16: format[typeIndex] = 'x'; break;"", ""      // Copy the string to a buffer and construct the format string."", ""      char buffer[KWSYS_IOS_INT64_MAX_DIG];"", ""#if defined(_MSC_VER)"", ""      char format[] = \""%I64_\"";"", ""      const int typeIndex = 4;"", ""#else"", ""      char format[] = \""%ll_\"";"", ""      const int typeIndex = 3;"", ""#endif"", ""      switch (IOStreamScanStream(is, buffer)) {"", ""        case 8:"", ""          format[typeIndex] = 'o';"", ""          break;"", ""        case 0: // Default to decimal if not told otherwise."", ""        case 10:"", ""          format[typeIndex] = type;"", ""          break;"", ""        case 16:"", ""          format[typeIndex] = 'x';"", ""          break;"", ""      };"", """", ""    // Use sscanf to parse the number from the buffer."", ""    T result;"", ""    int success = (sscanf(buffer, format, &result) == 1)?1:0;"", ""      // Use sscanf to parse the number from the buffer."", ""      T result;"", ""      int success = (sscanf(buffer, format, &result) == 1) ? 1 : 0;"", """", ""    // Set flags for resulting state."", ""    if(is.peek() == EOF) { state |= std::ios_base::eofbit; }"", ""    if(!success) { state |= std::ios_base::failbit; }"", ""    else { value = result; }"", ""    } catch(...) { state |= std::ios_base::badbit; }"", ""      // Set flags for resulting state."", ""      if (is.peek() == EOF) {"", ""        state |= std::ios_base::eofbit;"", ""      }"", ""      if (!success) {"", ""        state |= std::ios_base::failbit;"", ""      } else {"", ""        value = result;"", ""      }"", ""    } catch (...) {"", ""      state |= std::ios_base::badbit;"", ""    }"", ""  }"", """", ""  is.setstate(std::ios_base::iostate(state));"", ""  return is;"", ""}"", """", ""// Print an integer value to an output stream."", ""template <class T>"", ""std::ostream&"", ""IOStreamPrintTemplate(std::ostream& os, T value, char type)"", ""std::ostream& IOStreamPrintTemplate(std::ostream& os, T value, char type)"", ""{"", ""  std::ostream::sentry okay(os);"", ""  if(okay)"", ""    {"", ""  if (okay) {"", ""    try {"", ""    // Construct the format string."", ""    char format[8];"", ""    char* f = format;"", ""    *f++ = '%';"", ""    if(os.flags() & std::ios_base::showpos) { *f++ = '+'; }"", ""    if(os.flags() & std::ios_base::showbase) { *f++ = '#'; }"", ""#   if defined(_MSC_VER)"", ""    *f++ = 'I'; *f++ = '6'; *f++ = '4';"", ""#   else"", ""    *f++ = 'l'; *f++ = 'l';"", ""#   endif"", ""    long bflags = os.flags() & std::ios_base::basefield;"", ""    if(bflags == std::ios_base::oct) { *f++ = 'o'; }"", ""    else if(bflags != std::ios_base::hex) { *f++ = type; }"", ""    else if(os.flags() & std::ios_base::uppercase) { *f++ = 'X'; }"", ""    else { *f++ = 'x'; }"", ""    *f = '\\0';"", """", ""    // Use sprintf to print to a buffer and then write the"", ""    // buffer to the stream."", ""    char buffer[2*KWSYS_IOS_INT64_MAX_DIG];"", ""    sprintf(buffer, format, value);"", ""    os << buffer;"", ""    } catch(...) { os.clear(os.rdstate() | std::ios_base::badbit); }"", ""      // Construct the format string."", ""      char format[8];"", ""      char* f = format;"", ""      *f++ = '%';"", ""      if (os.flags() & std::ios_base::showpos) {"", ""        *f++ = '+';"", ""      }"", ""      if (os.flags() & std::ios_base::showbase) {"", ""        *f++ = '#';"", ""      }"", ""#if defined(_MSC_VER)"", ""      *f++ = 'I';"", ""      *f++ = '6';"", ""      *f++ = '4';"", ""#else"", ""      *f++ = 'l';"", ""      *f++ = 'l';"", ""#endif"", ""      long bflags = os.flags() & std::ios_base::basefield;"", ""      if (bflags == std::ios_base::oct) {"", ""        *f++ = 'o';"", ""      } else if (bflags != std::ios_base::hex) {"", ""        *f++ = type;"", ""      } else if (os.flags() & std::ios_base::uppercase) {"", ""        *f++ = 'X';"", ""      } else {"", ""        *f++ = 'x';"", ""      }"", ""      *f = '\\0';"", """", ""      // Use sprintf to print to a buffer and then write the"", ""      // buffer to the stream."", ""      char buffer[2 * KWSYS_IOS_INT64_MAX_DIG];"", ""      sprintf(buffer, format, value);"", ""      os << buffer;"", ""    } catch (...) {"", ""      os.clear(os.rdstate() | std::ios_base::badbit);"", ""    }"", ""  }"", ""  return os;"", ""}"", """", ""# if !KWSYS_IOS_HAS_ISTREAM_LONG_LONG"", ""#if !KWSYS_IOS_HAS_ISTREAM_LONG_LONG"", ""// Implement input stream operator for IOStreamSLL."", ""std::istream& IOStreamScan(std::istream& is, IOStreamSLL& value)"", ""{""]","[0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, 1, 0, 0, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0]","[[115, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/IOStream.cxx"", ""-"", ""sprintf(buffer, format, value);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_93_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_93_new.cpp""], [151, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/IOStream.cxx"", ""+"", ""sprintf(buffer, format, value);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_93_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_93_new.cpp""]]",123,107
"["" * of the structure of the compiled regexp."", "" */"", """", """", ""// compile -- compile a regular expression into internal code"", ""// for later pattern matching."", """", ""bool RegularExpression::compile (const char* exp) {"", ""    const char* scan;"", ""    const char* longest;"", ""    size_t      len;"", ""    int         flags;"", ""bool RegularExpression::compile(const char* exp)"", ""{"", ""  const char* scan;"", ""  const char* longest;"", ""  size_t len;"", ""  int flags;"", """", ""  if (exp == 0) {"", ""    // RAISE Error, SYM(RegularExpression), SYM(No_Expr),"", ""    printf(\""RegularExpression::compile(): No expression supplied.\\n\"");"", ""    return false;"", ""  }"", """", ""    if (exp == 0) {"", ""      //RAISE Error, SYM(RegularExpression), SYM(No_Expr),"", ""      printf (\""RegularExpression::compile(): No expression supplied.\\n\"");"", ""      return false;"", ""    }"", ""  // First pass: determine size, legality."", ""  regparse = exp;"", ""  regnpar = 1;"", ""  regsize = 0L;"", ""  regcode = &regdummy;"", ""  regc(static_cast<char>(MAGIC));"", ""  if (!reg(0, &flags)) {"", ""    printf(\""RegularExpression::compile(): Error in compile.\\n\"");"", ""    return false;"", ""  }"", ""  this->startp[0] = this->endp[0] = this->searchstring = 0;"", """", ""    // First pass: determine size, legality."", ""    regparse = exp;"", ""    regnpar = 1;"", ""    regsize = 0L;"", ""    regcode = &regdummy;"", ""    regc(static_cast<char>(MAGIC));"", ""    if(!reg(0, &flags))"", ""      {"", ""        printf (\""RegularExpression::compile(): Error in compile.\\n\"");"", ""        return false;"", ""      }"", ""    this->startp[0] = this->endp[0] = this->searchstring = 0;"", ""  // Small enough for pointer-storage convention?"", ""  if (regsize >= 32767L) { // Probably could be 65535L."", ""    // RAISE Error, SYM(RegularExpression), SYM(Expr_Too_Big),"", ""    printf(\""RegularExpression::compile(): Expression too big.\\n\"");"", ""    return false;"", ""  }"", """", ""    // Small enough for pointer-storage convention?"", ""    if (regsize >= 32767L) {    // Probably could be 65535L."", ""      //RAISE Error, SYM(RegularExpression), SYM(Expr_Too_Big),"", ""      printf (\""RegularExpression::compile(): Expression too big.\\n\"");"", ""      return false;"", ""    }"", ""  // Allocate space."", ""  //#ifndef _WIN32"", ""  if (this->program != 0)"", ""    delete[] this->program;"", ""  //#endif"", ""  this->program = new char[regsize];"", ""  this->progsize = static_cast<int>(regsize);"", """", ""  if (this->program == 0) {"", ""    // RAISE Error, SYM(RegularExpression), SYM(Out_Of_Memory),"", ""    printf(\""RegularExpression::compile(): Out of memory.\\n\"");"", ""    return false;"", ""  }"", """", ""    // Allocate space."", ""//#ifndef _WIN32"", ""    if (this->program != 0) delete [] this->program;"", ""//#endif"", ""    this->program = new char[regsize];"", ""    this->progsize = static_cast<int>(regsize);"", """", ""    if (this->program == 0) {"", ""      //RAISE Error, SYM(RegularExpression), SYM(Out_Of_Memory),"", ""      printf (\""RegularExpression::compile(): Out of memory.\\n\"");"", ""      return false;"", ""    }"", ""  // Second pass: emit code."", ""  regparse = exp;"", ""  regnpar = 1;"", ""  regcode = this->program;"", ""  regc(static_cast<char>(MAGIC));"", ""  reg(0, &flags);"", """", ""  // Dig out information for optimizations."", ""  this->regstart = '\\0'; // Worst-case defaults."", ""  this->reganch = 0;"", ""  this->regmust = 0;"", ""  this->regmlen = 0;"", ""  scan = this->program + 1;       // First BRANCH."", ""  if (OP(regnext(scan)) == END) { // Only one top-level choice."", ""    scan = OPERAND(scan);"", """", ""    // Starting-point info."", ""    if (OP(scan) == EXACTLY)"", ""      this->regstart = *OPERAND(scan);"", ""    else if (OP(scan) == BOL)"", ""      this->reganch++;"", """", ""    // Second pass: emit code."", ""    regparse = exp;"", ""    regnpar = 1;"", ""    regcode = this->program;"", ""    regc(static_cast<char>(MAGIC));"", ""    reg(0, &flags);"", """", ""    // Dig out information for optimizations."", ""    this->regstart = '\\0';              // Worst-case defaults."", ""    this->reganch = 0;"", ""    this->regmust = 0;"", ""    this->regmlen = 0;"", ""    scan = this->program + 1;   // First BRANCH."", ""    if (OP(regnext(scan)) == END) {     // Only one top-level choice."", ""        scan = OPERAND(scan);"", """", ""        // Starting-point info."", ""        if (OP(scan) == EXACTLY)"", ""            this->regstart = *OPERAND(scan);"", ""        else if (OP(scan) == BOL)"", ""            this->reganch++;"", """", ""         //"", ""         // If there's something expensive in the r.e., find the longest"", ""         // literal string that must appear and make it the regmust.  Resolve"", ""         // ties in favor of later strings, since the regstart check works"", ""         // with the beginning of the r.e. and avoiding duplication"", ""         // strengthens checking.  Not a strong reason, but sufficient in the"", ""         // absence of others."", ""         //"", ""        if (flags & SPSTART) {"", ""            longest = 0;"", ""            len = 0;"", ""            for (; scan != 0; scan = regnext(scan))"", ""                if (OP(scan) == EXACTLY && strlen(OPERAND(scan)) >= len) {"", ""                    longest = OPERAND(scan);"", ""                    len = strlen(OPERAND(scan));"", ""                }"", ""            this->regmust = longest;"", ""            this->regmlen = len;"", ""    //"", ""    // If there's something expensive in the r.e., find the longest"", ""    // literal string that must appear and make it the regmust.  Resolve"", ""    // ties in favor of later strings, since the regstart check works"", ""    // with the beginning of the r.e. and avoiding duplication"", ""    // strengthens checking.  Not a strong reason, but sufficient in the"", ""    // absence of others."", ""    //"", ""    if (flags & SPSTART) {"", ""      longest = 0;"", ""      len = 0;"", ""      for (; scan != 0; scan = regnext(scan))"", ""        if (OP(scan) == EXACTLY && strlen(OPERAND(scan)) >= len) {"", ""          longest = OPERAND(scan);"", ""          len = strlen(OPERAND(scan));"", ""        }"", ""      this->regmust = longest;"", ""      this->regmlen = len;"", ""    }"", ""    return true;"", ""  }"", ""  return true;"", ""}"", """", """", ""/*"", "" - reg - regular expression, i.e. main body or parenthesized thing"", "" *""]","[0, 0, 0, -1, 0, 0, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 2, 1, 1, 0, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, -1, 1, 1, 0, 0, -1, 0, 0, 0]","[[21, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): No expression supplied.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_new.cpp""], [37, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Error in compile.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_new.cpp""], [57, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Expression too big.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_new.cpp""], [77, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Out of memory.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_new.cpp""]]",339,325
"["" * is a trifle forced, but the need to tie the tails of the branches to what"", "" * follows makes it hard to avoid."", "" */"", ""static char* reg (int paren, int *flagp) {"", ""    char* ret;"", ""    char* br;"", ""    char* ender;"", ""    int   parno =0;"", ""    int   flags;"", """", ""    *flagp = HASWIDTH;          // Tentatively."", """", ""    // Make an OPEN node, if parenthesized."", ""    if (paren) {"", ""        if (regnpar >=  RegularExpression::NSUBEXP) {"", ""          //RAISE Error, SYM(RegularExpression), SYM(Too_Many_Parens),"", ""          printf (\""RegularExpression::compile(): Too many parentheses.\\n\"");"", ""          return 0;"", ""        }"", ""        parno = regnpar;"", ""        regnpar++;"", ""        ret = regnode(static_cast<char>(OPEN + parno));"", ""static char* reg(int paren, int* flagp)"", ""{"", ""  char* ret;"", ""  char* br;"", ""  char* ender;"", ""  int parno = 0;"", ""  int flags;"", """", ""  *flagp = HASWIDTH; // Tentatively."", """", ""  // Make an OPEN node, if parenthesized."", ""  if (paren) {"", ""    if (regnpar >= RegularExpression::NSUBEXP) {"", ""      // RAISE Error, SYM(RegularExpression), SYM(Too_Many_Parens),"", ""      printf(\""RegularExpression::compile(): Too many parentheses.\\n\"");"", ""      return 0;"", ""    }"", ""    else"", ""        ret = 0;"", """", ""    // Pick up the branches, linking them together."", ""    parno = regnpar;"", ""    regnpar++;"", ""    ret = regnode(static_cast<char>(OPEN + parno));"", ""  } else"", ""    ret = 0;"", """", ""  // Pick up the branches, linking them together."", ""  br = regbranch(&flags);"", ""  if (br == 0)"", ""    return (0);"", ""  if (ret != 0)"", ""    regtail(ret, br); // OPEN -> first."", ""  else"", ""    ret = br;"", ""  if (!(flags & HASWIDTH))"", ""    *flagp &= ~HASWIDTH;"", ""  *flagp |= flags & SPSTART;"", ""  while (*regparse == '|') {"", ""    regparse++;"", ""    br = regbranch(&flags);"", ""    if (br == 0)"", ""        return (0);"", ""    if (ret != 0)"", ""        regtail(ret, br);       // OPEN -> first."", ""    else"", ""        ret = br;"", ""      return (0);"", ""    regtail(ret, br); // BRANCH -> BRANCH."", ""    if (!(flags & HASWIDTH))"", ""        *flagp &= ~HASWIDTH;"", ""      *flagp &= ~HASWIDTH;"", ""    *flagp |= flags & SPSTART;"", ""    while (*regparse == '|') {"", ""        regparse++;"", ""        br = regbranch(&flags);"", ""        if (br == 0)"", ""            return (0);"", ""        regtail(ret, br);       // BRANCH -> BRANCH."", ""        if (!(flags & HASWIDTH))"", ""            *flagp &= ~HASWIDTH;"", ""        *flagp |= flags & SPSTART;"", ""      }"", """", ""    // Make a closing node, and hook it on the end."", ""    ender = regnode(static_cast<char>((paren) ? CLOSE + parno : END));"", ""    regtail(ret, ender);"", """", ""    // Hook the tails of the branches to the closing node."", ""    for (br = ret; br != 0; br = regnext(br))"", ""        regoptail(br, ender);"", ""  }"", """", ""    // Check for proper termination."", ""    if (paren && *regparse++ != ')') {"", ""        //RAISE Error, SYM(RegularExpression), SYM(Unmatched_Parens),"", ""        printf (\""RegularExpression::compile(): Unmatched parentheses.\\n\"");"", ""        return 0;"", ""    }"", ""    else if (!paren && *regparse != '\\0') {"", ""        if (*regparse == ')') {"", ""            //RAISE Error, SYM(RegularExpression), SYM(Unmatched_Parens),"", ""            printf (\""RegularExpression::compile(): Unmatched parentheses.\\n\"");"", ""            return 0;"", ""        }"", ""        else {"", ""            //RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""            printf (\""RegularExpression::compile(): Internal error.\\n\"");"", ""            return 0;"", ""        }"", ""        // NOTREACHED"", ""  // Make a closing node, and hook it on the end."", ""  ender = regnode(static_cast<char>((paren) ? CLOSE + parno : END));"", ""  regtail(ret, ender);"", """", ""  // Hook the tails of the branches to the closing node."", ""  for (br = ret; br != 0; br = regnext(br))"", ""    regoptail(br, ender);"", """", ""  // Check for proper termination."", ""  if (paren && *regparse++ != ')') {"", ""    // RAISE Error, SYM(RegularExpression), SYM(Unmatched_Parens),"", ""    printf(\""RegularExpression::compile(): Unmatched parentheses.\\n\"");"", ""    return 0;"", ""  } else if (!paren && *regparse != '\\0') {"", ""    if (*regparse == ')') {"", ""      // RAISE Error, SYM(RegularExpression), SYM(Unmatched_Parens),"", ""      printf(\""RegularExpression::compile(): Unmatched parentheses.\\n\"");"", ""      return 0;"", ""    } else {"", ""      // RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""      printf(\""RegularExpression::compile(): Internal error.\\n\"");"", ""      return 0;"", ""    }"", ""    return (ret);"", ""    // NOTREACHED"", ""  }"", ""  return (ret);"", ""}"", """", """", ""/*"", "" - regbranch - one alternative of an | operator"", "" *"", "" * Implements the concatenation operator."", "" */"", ""static char* regbranch (int *flagp) {"", ""    char* ret;"", ""    char* chain;"", ""    char* latest;"", ""    int   flags;"", """", ""    *flagp = WORST;             // Tentatively."", """", ""    ret = regnode(BRANCH);"", ""    chain = 0;"", ""    while (*regparse != '\\0' && *regparse != '|' && *regparse != ')') {"", ""        latest = regpiece(&flags);"", ""        if (latest == 0)"", ""            return (0);"", ""        *flagp |= flags & HASWIDTH;"", ""        if (chain == 0) // First piece."", ""            *flagp |= flags & SPSTART;"", ""        else"", ""            regtail(chain, latest);"", ""        chain = latest;"", ""    }"", ""    if (chain == 0)             // Loop ran zero times."", ""        regnode(NOTHING);"", ""static char* regbranch(int* flagp)"", ""{"", ""  char* ret;"", ""  char* chain;"", ""  char* latest;"", ""  int flags;"", """", ""  *flagp = WORST; // Tentatively."", """", ""  ret = regnode(BRANCH);"", ""  chain = 0;"", ""  while (*regparse != '\\0' && *regparse != '|' && *regparse != ')') {"", ""    latest = regpiece(&flags);"", ""    if (latest == 0)"", ""      return (0);"", ""    *flagp |= flags & HASWIDTH;"", ""    if (chain == 0) // First piece."", ""      *flagp |= flags & SPSTART;"", ""    else"", ""      regtail(chain, latest);"", ""    chain = latest;"", ""  }"", ""  if (chain == 0) // Loop ran zero times."", ""    regnode(NOTHING);"", """", ""    return (ret);"", ""  return (ret);"", ""}"", """", """", ""/*"", "" - regpiece - something followed by possible [*+?]"", "" *""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, 1, 1, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 0, -1, 1, 1, 1, 0, 0, -1, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, 0, -1, 0, 0, 0]","[[36, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Too many parentheses.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_new.cpp""], [124, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Unmatched parentheses.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_new.cpp""], [129, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Unmatched parentheses.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_new.cpp""], [133, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Internal error.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_new.cpp""]]",443,428
"["" * It might seem that this node could be dispensed with entirely, but the"", "" * endmarker role is not redundant."", "" */"", ""static char* regpiece (int *flagp) {"", ""    char* ret;"", ""    char  op;"", ""    char* next;"", ""    int   flags;"", """", ""    ret = regatom(&flags);"", ""    if (ret == 0)"", ""        return (0);"", ""static char* regpiece(int* flagp)"", ""{"", ""  char* ret;"", ""  char op;"", ""  char* next;"", ""  int flags;"", """", ""    op = *regparse;"", ""    if (!ISMULT(op)) {"", ""        *flagp = flags;"", ""        return (ret);"", ""    }"", ""  ret = regatom(&flags);"", ""  if (ret == 0)"", ""    return (0);"", """", ""    if (!(flags & HASWIDTH) && op != '?') {"", ""        //RAISE Error, SYM(RegularExpression), SYM(Empty_Operand),"", ""        printf (\""RegularExpression::compile() : *+ operand could be empty.\\n\"");"", ""        return 0;"", ""    }"", ""    *flagp = (op != '+') ? (WORST | SPSTART) : (WORST | HASWIDTH);"", """", ""    if (op == '*' && (flags & SIMPLE))"", ""        reginsert(STAR, ret);"", ""    else if (op == '*') {"", ""        // Emit x* as (x&|), where & means \""self\""."", ""        reginsert(BRANCH, ret); // Either x"", ""        regoptail(ret, regnode(BACK));  // and loop"", ""        regoptail(ret, ret);    // back"", ""        regtail(ret, regnode(BRANCH));  // or"", ""        regtail(ret, regnode(NOTHING)); // null."", ""    }"", ""    else if (op == '+' && (flags & SIMPLE))"", ""        reginsert(PLUS, ret);"", ""    else if (op == '+') {"", ""        // Emit x+ as x(&|), where & means \""self\""."", ""        next = regnode(BRANCH); // Either"", ""        regtail(ret, next);"", ""        regtail(regnode(BACK), ret);    // loop back"", ""        regtail(next, regnode(BRANCH)); // or"", ""        regtail(ret, regnode(NOTHING)); // null."", ""    }"", ""    else if (op == '?') {"", ""        // Emit x? as (x|)"", ""        reginsert(BRANCH, ret); // Either x"", ""        regtail(ret, regnode(BRANCH));  // or"", ""        next = regnode(NOTHING);// null."", ""        regtail(ret, next);"", ""        regoptail(ret, next);"", ""    }"", ""    regparse++;"", ""    if (ISMULT(*regparse)) {"", ""        //RAISE Error, SYM(RegularExpression), SYM(Nested_Operand),"", ""        printf (\""RegularExpression::compile(): Nested *?+.\\n\"");"", ""        return 0;"", ""    }"", ""  op = *regparse;"", ""  if (!ISMULT(op)) {"", ""    *flagp = flags;"", ""    return (ret);"", ""}"", ""  }"", """", ""  if (!(flags & HASWIDTH) && op != '?') {"", ""    // RAISE Error, SYM(RegularExpression), SYM(Empty_Operand),"", ""    printf(\""RegularExpression::compile() : *+ operand could be empty.\\n\"");"", ""    return 0;"", ""  }"", ""  *flagp = (op != '+') ? (WORST | SPSTART) : (WORST | HASWIDTH);"", """", ""  if (op == '*' && (flags & SIMPLE))"", ""    reginsert(STAR, ret);"", ""  else if (op == '*') {"", ""    // Emit x* as (x&|), where & means \""self\""."", ""    reginsert(BRANCH, ret);         // Either x"", ""    regoptail(ret, regnode(BACK));  // and loop"", ""    regoptail(ret, ret);            // back"", ""    regtail(ret, regnode(BRANCH));  // or"", ""    regtail(ret, regnode(NOTHING)); // null."", ""  } else if (op == '+' && (flags & SIMPLE))"", ""    reginsert(PLUS, ret);"", ""  else if (op == '+') {"", ""    // Emit x+ as x(&|), where & means \""self\""."", ""    next = regnode(BRANCH); // Either"", ""    regtail(ret, next);"", ""    regtail(regnode(BACK), ret);    // loop back"", ""    regtail(next, regnode(BRANCH)); // or"", ""    regtail(ret, regnode(NOTHING)); // null."", ""  } else if (op == '?') {"", ""    // Emit x? as (x|)"", ""    reginsert(BRANCH, ret);        // Either x"", ""    regtail(ret, regnode(BRANCH)); // or"", ""    next = regnode(NOTHING);       // null."", ""    regtail(ret, next);"", ""    regoptail(ret, next);"", ""  }"", ""  regparse++;"", ""  if (ISMULT(*regparse)) {"", ""    // RAISE Error, SYM(RegularExpression), SYM(Nested_Operand),"", ""    printf(\""RegularExpression::compile(): Nested *?+.\\n\"");"", ""    return 0;"", ""  }"", ""  return (ret);"", ""}"", """", ""/*"", "" - regatom - the lowest level""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 0, -1, 1, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0]","[[78, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile() : *+ operand could be empty.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_new.cpp""], [112, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Nested *?+.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_new.cpp""]]",561,543
"["" * faster to run.  Backslashed characters are exceptions, each becoming a"", "" * separate node; the code is simpler that way and it's not worth fixing."", "" */"", ""static char* regatom (int *flagp) {"", ""    char* ret;"", ""    int   flags;"", """", ""    *flagp = WORST;             // Tentatively."", """", ""    switch (*regparse++) {"", ""        case '^':"", ""            ret = regnode(BOL);"", ""            break;"", ""        case '$':"", ""            ret = regnode(EOL);"", ""            break;"", ""        case '.':"", ""            ret = regnode(ANY);"", ""            *flagp |= HASWIDTH | SIMPLE;"", ""            break;"", ""        case '[':{"", ""                int    rxpclass;"", ""                int    rxpclassend;"", """", ""                if (*regparse == '^') { // Complement of range."", ""                    ret = regnode(ANYBUT);"", ""                    regparse++;"", ""                }"", ""                else"", ""                    ret = regnode(ANYOF);"", ""                if (*regparse == ']' || *regparse == '-')"", ""                    regc(*regparse++);"", ""                while (*regparse != '\\0' && *regparse != ']') {"", ""                    if (*regparse == '-') {"", ""                        regparse++;"", ""                        if (*regparse == ']' || *regparse == '\\0')"", ""                            regc('-');"", ""                        else {"", ""                            rxpclass = UCHARAT(regparse - 2) + 1;"", ""                            rxpclassend = UCHARAT(regparse);"", ""                            if (rxpclass > rxpclassend + 1) {"", ""                               //RAISE Error, SYM(RegularExpression), SYM(Invalid_Range),"", ""                               printf (\""RegularExpression::compile(): Invalid range in [].\\n\"");"", ""                               return 0;"", ""                            }"", ""                            for (; rxpclass <= rxpclassend; rxpclass++)"", ""                              regc(static_cast<char>(rxpclass));"", ""                            regparse++;"", ""                        }"", ""                    }"", ""                    else"", ""                        regc(*regparse++);"", ""                }"", ""                regc('\\0');"", ""                if (*regparse != ']') {"", ""                    //RAISE Error, SYM(RegularExpression), SYM(Unmatched_Bracket),"", ""                    printf (\""RegularExpression::compile(): Unmatched [].\\n\"");"", ""                    return 0;"", ""                }"", ""                regparse++;"", ""                *flagp |= HASWIDTH | SIMPLE;"", ""            }"", ""            break;"", ""        case '(':"", ""            ret = reg(1, &flags);"", ""            if (ret == 0)"", ""                return (0);"", ""            *flagp |= flags & (HASWIDTH | SPSTART);"", ""            break;"", ""        case '\\0':"", ""        case '|':"", ""        case ')':"", ""            //RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""            printf (\""RegularExpression::compile(): Internal error.\\n\""); // Never here"", ""            return 0;"", ""        case '?':"", ""        case '+':"", ""        case '*':"", ""            //RAISE Error, SYM(RegularExpression), SYM(No_Operand),"", ""            printf (\""RegularExpression::compile(): ?+* follows nothing.\\n\"");"", ""            return 0;"", ""        case '\\\\':"", ""            if (*regparse == '\\0') {"", ""                //RAISE Error, SYM(RegularExpression), SYM(Trailing_Backslash),"", ""                printf (\""RegularExpression::compile(): Trailing backslash.\\n\"");"", ""                return 0;"", ""            }"", ""            ret = regnode(EXACTLY);"", ""            regc(*regparse++);"", ""            regc('\\0');"", ""            *flagp |= HASWIDTH | SIMPLE;"", ""            break;"", ""        default:{"", ""                int    len;"", ""                char   ender;"", """", ""                regparse--;"", ""                len = int(strcspn(regparse, META));"", ""                if (len <= 0) {"", ""                    //RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""                    printf (\""RegularExpression::compile(): Internal error.\\n\"");"", ""                    return 0;"", ""                }"", ""                ender = *(regparse + len);"", ""                if (len > 1 && ISMULT(ender))"", ""                    len--;      // Back off clear of ?+* operand."", ""                *flagp |= HASWIDTH;"", ""                if (len == 1)"", ""                    *flagp |= SIMPLE;"", ""                ret = regnode(EXACTLY);"", ""                while (len > 0) {"", ""                    regc(*regparse++);"", ""                    len--;"", ""                }"", ""                regc('\\0');"", ""static char* regatom(int* flagp)"", ""{"", ""  char* ret;"", ""  int flags;"", """", ""  *flagp = WORST; // Tentatively."", """", ""  switch (*regparse++) {"", ""    case '^':"", ""      ret = regnode(BOL);"", ""      break;"", ""    case '$':"", ""      ret = regnode(EOL);"", ""      break;"", ""    case '.':"", ""      ret = regnode(ANY);"", ""      *flagp |= HASWIDTH | SIMPLE;"", ""      break;"", ""    case '[': {"", ""      int rxpclass;"", ""      int rxpclassend;"", """", ""      if (*regparse == '^') { // Complement of range."", ""        ret = regnode(ANYBUT);"", ""        regparse++;"", ""      } else"", ""        ret = regnode(ANYOF);"", ""      if (*regparse == ']' || *regparse == '-')"", ""        regc(*regparse++);"", ""      while (*regparse != '\\0' && *regparse != ']') {"", ""        if (*regparse == '-') {"", ""          regparse++;"", ""          if (*regparse == ']' || *regparse == '\\0')"", ""            regc('-');"", ""          else {"", ""            rxpclass = UCHARAT(regparse - 2) + 1;"", ""            rxpclassend = UCHARAT(regparse);"", ""            if (rxpclass > rxpclassend + 1) {"", ""              // RAISE Error, SYM(RegularExpression), SYM(Invalid_Range),"", ""              printf(\""RegularExpression::compile(): Invalid range in [].\\n\"");"", ""              return 0;"", ""            }"", ""            break;"", ""    }"", ""    return (ret);"", ""            for (; rxpclass <= rxpclassend; rxpclass++)"", ""              regc(static_cast<char>(rxpclass));"", ""            regparse++;"", ""          }"", ""        } else"", ""          regc(*regparse++);"", ""      }"", ""      regc('\\0');"", ""      if (*regparse != ']') {"", ""        // RAISE Error, SYM(RegularExpression), SYM(Unmatched_Bracket),"", ""        printf(\""RegularExpression::compile(): Unmatched [].\\n\"");"", ""        return 0;"", ""      }"", ""      regparse++;"", ""      *flagp |= HASWIDTH | SIMPLE;"", ""    } break;"", ""    case '(':"", ""      ret = reg(1, &flags);"", ""      if (ret == 0)"", ""        return (0);"", ""      *flagp |= flags & (HASWIDTH | SPSTART);"", ""      break;"", ""    case '\\0':"", ""    case '|':"", ""    case ')':"", ""      // RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""      printf(\""RegularExpression::compile(): Internal error.\\n\""); // Never here"", ""      return 0;"", ""    case '?':"", ""    case '+':"", ""    case '*':"", ""      // RAISE Error, SYM(RegularExpression), SYM(No_Operand),"", ""      printf(\""RegularExpression::compile(): ?+* follows nothing.\\n\"");"", ""      return 0;"", ""    case '\\\\':"", ""      if (*regparse == '\\0') {"", ""        // RAISE Error, SYM(RegularExpression), SYM(Trailing_Backslash),"", ""        printf(\""RegularExpression::compile(): Trailing backslash.\\n\"");"", ""        return 0;"", ""      }"", ""      ret = regnode(EXACTLY);"", ""      regc(*regparse++);"", ""      regc('\\0');"", ""      *flagp |= HASWIDTH | SIMPLE;"", ""      break;"", ""    default: {"", ""      int len;"", ""      char ender;"", """", ""      regparse--;"", ""      len = int(strcspn(regparse, META));"", ""      if (len <= 0) {"", ""        // RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""        printf(\""RegularExpression::compile(): Internal error.\\n\"");"", ""        return 0;"", ""      }"", ""      ender = *(regparse + len);"", ""      if (len > 1 && ISMULT(ender))"", ""        len--; // Back off clear of ?+* operand."", ""      *flagp |= HASWIDTH;"", ""      if (len == 1)"", ""        *flagp |= SIMPLE;"", ""      ret = regnode(EXACTLY);"", ""      while (len > 0) {"", ""        regc(*regparse++);"", ""        len--;"", ""      }"", ""      regc('\\0');"", ""    } break;"", ""  }"", ""  return (ret);"", ""}"", """", """", ""/*"", "" - regnode - emit a node"", ""   Location."", "" */"", ""static char* regnode (char op) {"", ""    char* ret;"", ""    char* ptr;"", """", ""    ret = regcode;"", ""    if (ret == &regdummy) {"", ""        regsize += 3;"", ""        return (ret);"", ""    }"", """", ""    ptr = ret;"", ""    *ptr++ = op;"", ""    *ptr++ = '\\0';              // Null \""next\"" pointer."", ""    *ptr++ = '\\0';"", ""    regcode = ptr;"", ""static char* regnode(char op)"", ""{"", ""  char* ret;"", ""  char* ptr;"", """", ""  ret = regcode;"", ""  if (ret == &regdummy) {"", ""    regsize += 3;"", ""    return (ret);"", ""}"", ""  }"", """", ""  ptr = ret;"", ""  *ptr++ = op;"", ""  *ptr++ = '\\0'; // Null \""next\"" pointer."", ""  *ptr++ = '\\0';"", ""  regcode = ptr;"", """", ""  return (ret);"", ""}"", """", ""/*"", "" - regc - emit (if appropriate) a byte of code"", "" */"", ""static void regc (char b) {"", ""    if (regcode != &regdummy)"", ""        *regcode++ = b;"", ""    else"", ""        regsize++;"", ""static void regc(char b)"", ""{"", ""  if (regcode != &regdummy)"", ""    *regcode++ = b;"", ""  else"", ""    regsize++;"", ""}"", """", """", ""/*"", "" - reginsert - insert an operator in front of already-emitted operand"", "" *"", "" * Means relocating the operand."", "" */"", ""static void reginsert (char op, char* opnd) {"", ""    char* src;"", ""    char* dst;"", ""    char* place;"", """", ""    if (regcode == &regdummy) {"", ""        regsize += 3;"", ""        return;"", ""    }"", ""static void reginsert(char op, char* opnd)"", ""{"", ""  char* src;"", ""  char* dst;"", ""  char* place;"", """", ""  if (regcode == &regdummy) {"", ""    regsize += 3;"", ""    return;"", ""  }"", """", ""    src = regcode;"", ""    regcode += 3;"", ""    dst = regcode;"", ""    while (src > opnd)"", ""        *--dst = *--src;"", ""  src = regcode;"", ""  regcode += 3;"", ""  dst = regcode;"", ""  while (src > opnd)"", ""    *--dst = *--src;"", """", ""    place = opnd;               // Op node, where operand used to be."", ""    *place++ = op;"", ""    *place++ = '\\0';"", ""    *place = '\\0';"", ""  place = opnd; // Op node, where operand used to be."", ""  *place++ = op;"", ""  *place++ = '\\0';"", ""  *place = '\\0';"", ""}"", """", """", ""/*"", "" - regtail - set the next-pointer at the end of a node chain"", "" */"", ""static void regtail (char* p, const char* val) {"", ""    char* scan;"", ""    char* temp;"", ""    int   offset;"", """", ""    if (p == &regdummy)"", ""        return;"", """", ""    // Find last node."", ""    scan = p;"", ""    for (;;) {"", ""        temp = regnext(scan);"", ""        if (temp == 0)"", ""            break;"", ""        scan = temp;"", ""    }"", ""static void regtail(char* p, const char* val)"", ""{"", ""  char* scan;"", ""  char* temp;"", ""  int offset;"", """", ""    if (OP(scan) == BACK)"", ""        offset = int(scan - val);"", ""    else"", ""        offset = int(val - scan);"", ""    *(scan + 1) = static_cast<char>((offset >> 8) & 0377);"", ""    *(scan + 2) = static_cast<char>(offset & 0377);"", ""}"", ""  if (p == &regdummy)"", ""    return;"", """", ""  // Find last node."", ""  scan = p;"", ""  for (;;) {"", ""    temp = regnext(scan);"", ""    if (temp == 0)"", ""      break;"", ""    scan = temp;"", ""  }"", """", ""  if (OP(scan) == BACK)"", ""    offset = int(scan - val);"", ""  else"", ""    offset = int(val - scan);"", ""  *(scan + 1) = static_cast<char>((offset >> 8) & 0377);"", ""  *(scan + 2) = static_cast<char>(offset & 0377);"", ""}"", """", ""/*"", "" - regoptail - regtail on operand of first argument; nop if operandless"", "" */"", ""static void regoptail (char* p, const char* val) {"", ""    // \""Operandless\"" and \""op != BRANCH\"" are synonymous in practice."", ""    if (p == 0 || p == &regdummy || OP(p) != BRANCH)"", ""        return;"", ""    regtail(OPERAND(p), val);"", ""static void regoptail(char* p, const char* val)"", ""{"", ""  // \""Operandless\"" and \""op != BRANCH\"" are synonymous in practice."", ""  if (p == 0 || p == &regdummy || OP(p) != BRANCH)"", ""    return;"", ""  regtail(OPERAND(p), val);"", ""}"", """", """", """", ""////////////////////////////////////////////////////////////////////////"", ""// "", ""//"", ""//  find and friends"", ""// "", ""//"", ""////////////////////////////////////////////////////////////////////////"", """", """", ""/*"", "" * Global work variables for find()."", "" */"", ""static const char*  reginput;   // String-input pointer."", ""static const char*  regbol;     // Beginning of input, for ^ check."", ""static const char* *regstartp;  // Pointer to startp array."", ""static const char* *regendp;    // Ditto for endp."", ""static const char* reginput;   // String-input pointer."", ""static const char* regbol;     // Beginning of input, for ^ check."", ""static const char** regstartp; // Pointer to startp array."", ""static const char** regendp;   // Ditto for endp."", """", ""/*"", "" * Forwards."", "" */"", ""static int regtry (const char*, const char* *,"", ""                   const char* *, const char*);"", ""static int regmatch (const char*);"", ""static int regrepeat (const char*);"", ""static int regtry(const char*, const char**, const char**, const char*);"", ""static int regmatch(const char*);"", ""static int regrepeat(const char*);"", """", ""#ifdef DEBUG"", ""int          regnarrate = 0;"", ""void         regdump ();"", ""static char* regprop ();"", ""int regnarrate = 0;"", ""void regdump();"", ""static char* regprop();"", ""#endif"", """", ""// find -- Matches the regular expression to the given string."", ""// Returns true if found, and sets start and end indexes accordingly."", """", ""bool RegularExpression::find (const char* string) {"", ""    const char* s;"", ""bool RegularExpression::find(const char* string)"", ""{"", ""  const char* s;"", """", ""    this->searchstring = string;"", ""  this->searchstring = string;"", """", ""    if (!this->program)"", ""      {"", ""      return false;"", ""      }"", ""  if (!this->program) {"", ""    return false;"", ""  }"", """", ""    // Check validity of program."", ""    if (UCHARAT(this->program) != MAGIC) {"", ""        //RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""        printf (\""RegularExpression::find(): Compiled regular expression corrupted.\\n\"");"", ""        return 0;"", ""    }"", ""  // Check validity of program."", ""  if (UCHARAT(this->program) != MAGIC) {"", ""    // RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""    printf("", ""      \""RegularExpression::find(): Compiled regular expression corrupted.\\n\"");"", ""    return 0;"", ""  }"", """", ""    // If there is a \""must appear\"" string, look for it."", ""    if (this->regmust != 0) {"", ""        s = string;"", ""        while ((s = strchr(s, this->regmust[0])) != 0) {"", ""            if (strncmp(s, this->regmust, this->regmlen) == 0)"", ""                break;          // Found it."", ""            s++;"", ""        }"", ""        if (s == 0)             // Not present."", ""            return (0);"", ""  // If there is a \""must appear\"" string, look for it."", ""  if (this->regmust != 0) {"", ""    s = string;"", ""    while ((s = strchr(s, this->regmust[0])) != 0) {"", ""      if (strncmp(s, this->regmust, this->regmlen) == 0)"", ""        break; // Found it."", ""      s++;"", ""    }"", ""    if (s == 0) // Not present."", ""      return (0);"", ""  }"", """", ""    // Mark beginning of line for ^ ."", ""    regbol = string;"", """", ""    // Simplest case:  anchored match need be tried only once."", ""    if (this->reganch)"", ""        return (regtry(string, this->startp, this->endp, this->program) != 0);"", ""  // Mark beginning of line for ^ ."", ""  regbol = string;"", """", ""    // Messy cases:  unanchored match."", ""    s = string;"", ""    if (this->regstart != '\\0')"", ""        // We know what char it must start with."", ""        while ((s = strchr(s, this->regstart)) != 0) {"", ""            if (regtry(s, this->startp, this->endp, this->program))"", ""                return (1);"", ""            s++;"", ""  // Simplest case:  anchored match need be tried only once."", ""  if (this->reganch)"", ""    return (regtry(string, this->startp, this->endp, this->program) != 0);"", """", ""        }"", ""    else"", ""        // We don't -- general case."", ""        do {"", ""            if (regtry(s, this->startp, this->endp, this->program))"", ""                return (1);"", ""        } while (*s++ != '\\0');"", ""  // Messy cases:  unanchored match."", ""  s = string;"", ""  if (this->regstart != '\\0')"", ""    // We know what char it must start with."", ""    while ((s = strchr(s, this->regstart)) != 0) {"", ""      if (regtry(s, this->startp, this->endp, this->program))"", ""        return (1);"", ""      s++;"", ""    }"", ""  else"", ""    // We don't -- general case."", ""    do {"", ""      if (regtry(s, this->startp, this->endp, this->program))"", ""        return (1);"", ""    } while (*s++ != '\\0');"", """", ""    // Failure."", ""    return (0);"", ""  // Failure."", ""  return (0);"", ""}"", """", """", ""/*"", "" - regtry - try match at specific point"", ""   0 failure, 1 success"", "" */"", ""static int regtry (const char* string, const char* *start,"", ""                   const char* *end, const char* prog) {"", ""                   int    i;"", ""                   const char* *sp1;"", ""                   const char* *ep;"", """", ""    reginput = string;"", ""    regstartp = start;"", ""    regendp = end;"", """", ""    sp1 = start;"", ""    ep = end;"", ""    for (i = RegularExpression::NSUBEXP; i > 0; i--) {"", ""        *sp1++ = 0;"", ""        *ep++ = 0;"", ""    }"", ""    if (regmatch(prog + 1)) {"", ""        start[0] = string;"", ""        end[0] = reginput;"", ""        return (1);"", ""    }"", ""    else"", ""        return (0);"", ""static int regtry(const char* string, const char** start, const char** end,"", ""                  const char* prog)"", ""{"", ""  int i;"", ""  const char** sp1;"", ""  const char** ep;"", """", ""  reginput = string;"", ""  regstartp = start;"", ""  regendp = end;"", """", ""  sp1 = start;"", ""  ep = end;"", ""  for (i = RegularExpression::NSUBEXP; i > 0; i--) {"", ""    *sp1++ = 0;"", ""    *ep++ = 0;"", ""  }"", ""  if (regmatch(prog + 1)) {"", ""    start[0] = string;"", ""    end[0] = reginput;"", ""    return (1);"", ""  } else"", ""    return (0);"", ""}"", """", """", ""/*"", "" - regmatch - main matching routine"", "" *""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 0, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 0, 1, 1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 0, 0, -1, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, 0, -1, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, 0, -1, 1, 0, -1, 1, 0, 0, -1, 0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, 0, 0, 0, -1, -1, 1, 1, 1, 0, -1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, 1, 1, 1, 2, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, 1, 1, 0, 0, -1, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, 0, 0, 0]","[[154, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Invalid range in [].\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_new.cpp""], [170, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Unmatched [].\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_new.cpp""], [186, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Internal error.\\n\""); // Never here"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_new.cpp""], [192, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): ?+* follows nothing.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_new.cpp""], [197, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Trailing backslash.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_new.cpp""], [213, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Internal error.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_new.cpp""], [478, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/RegularExpression.cxx"", ""+"", ""printf("", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_94_new.cpp""]]",630,610
"[""#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)"", ""  CONSOLE_SCREEN_BUFFER_INFO hOutInfo;"", ""  HANDLE hOut = kwsysTerminalGetStreamHandle(stream);"", ""  if(GetConsoleScreenBufferInfo(hOut, &hOutInfo))"", ""    {"", ""  if (GetConsoleScreenBufferInfo(hOut, &hOutInfo)) {"", ""    pipeIsConsole = 1;"", ""    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream, color);"", ""    }"", ""  }"", ""#endif"", ""  if(!pipeIsConsole && kwsysTerminalStreamIsVT100(stream,"", ""                                                  default_vt100, default_tty))"", ""    {"", ""  if (!pipeIsConsole &&"", ""      kwsysTerminalStreamIsVT100(stream, default_vt100, default_tty)) {"", ""    pipeIsVT100 = 1;"", ""    kwsysTerminalSetVT100Color(stream, color);"", ""    }"", ""  }"", """", ""  /* Format the text into the stream.  */"", ""  {"", ""  va_list var_args;"", ""  va_start(var_args, format);"", ""  vfprintf(stream, format, var_args);"", ""  va_end(var_args);"", ""    va_list var_args;"", ""    va_start(var_args, format);"", ""    vfprintf(stream, format, var_args);"", ""    va_end(var_args);"", ""  }"", """", ""  /* Restore the normal color state for the stream.  */"", ""/* Restore the normal color state for the stream.  */"", ""#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)"", ""  if(pipeIsConsole)"", ""    {"", ""  if (pipeIsConsole) {"", ""    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream,"", ""                                 kwsysTerminal_Color_Normal);"", ""    }"", ""  }"", ""#endif"", ""  if(pipeIsVT100)"", ""    {"", ""  if (pipeIsVT100) {"", ""    kwsysTerminalSetVT100Color(stream, kwsysTerminal_Color_Normal);"", ""    }"", ""  }"", ""}"", """", ""/*--------------------------------------------------------------------------*/""]","[0, 0, 0, -1, -1, 1, 0, 0, -1, 1, 0, -1, -1, -1, 1, 1, 0, 0, -1, 1, 0, 0, 0, -1, -1, -2, -1, 1, 1, 2, 1, 0, 0, -1, 1, 0, -1, -1, 1, 0, 0, -1, 1, 0, -1, -1, 1, 0, -1, 1, 0, 0, 0]","[[25, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/Terminal.c"", ""-"", ""vfprintf(stream, format, var_args);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_95_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_95_new.cpp""], [29, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/Terminal.c"", ""+"", ""vfprintf(stream, format, var_args);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_95_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_95_new.cpp""]]",68,58
"[""  return 0;"", ""}"", """", ""static int runChild2(kwsysProcess* kp,"", ""              const char* cmd[], int state, int exception, int value,"", ""              int share, int output, int delay, double timeout,"", ""              int poll, int disown, int createNewGroup,"", ""              unsigned int interruptDelay)"", ""static int runChild2(kwsysProcess* kp, const char* cmd[], int state,"", ""                     int exception, int value, int share, int output,"", ""                     int delay, double timeout, int poll, int disown,"", ""                     int createNewGroup, unsigned int interruptDelay)"", ""{"", ""  int result = 0;"", ""  char* data = 0;"", ""  int length = 0;"", ""  double userTimeout = 0;"", ""  double* pUserTimeout = 0;"", ""  kwsysProcess_SetCommand(kp, cmd);"", ""  if(timeout >= 0)"", ""    {"", ""  if (timeout >= 0) {"", ""    kwsysProcess_SetTimeout(kp, timeout);"", ""    }"", ""  if(share)"", ""    {"", ""  }"", ""  if (share) {"", ""    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);"", ""    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);"", ""    }"", ""  if(disown)"", ""    {"", ""  }"", ""  if (disown) {"", ""    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);"", ""    }"", ""  if(createNewGroup)"", ""    {"", ""  }"", ""  if (createNewGroup) {"", ""    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);"", ""    }"", ""  }"", ""  kwsysProcess_Execute(kp);"", """", ""  if(poll)"", ""    {"", ""  if (poll) {"", ""    pUserTimeout = &userTimeout;"", ""    }"", ""  }"", """", ""  if(interruptDelay)"", ""    {"", ""  if (interruptDelay) {"", ""    testProcess_sleep(interruptDelay);"", ""    kwsysProcess_Interrupt(kp);"", ""    }"", ""  }"", """", ""  if(!share && !disown)"", ""    {"", ""  if (!share && !disown) {"", ""    int p;"", ""    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))"", ""      {"", ""      if(output)"", ""        {"", ""        if(poll && p == kwsysProcess_Pipe_Timeout)"", ""          {"", ""    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {"", ""      if (output) {"", ""        if (poll && p == kwsysProcess_Pipe_Timeout) {"", ""          fprintf(stdout, \""WaitForData timeout reached.\\n\"");"", ""          fflush(stdout);"", """", ""          /* Count the number of times we polled without getting data."", ""             If it is excessive then kill the child and fail.  */"", ""          if(++poll >= MAXPOLL)"", ""            {"", ""            fprintf(stdout, \""Poll count reached limit %d.\\n\"","", ""                    MAXPOLL);"", ""          if (++poll >= MAXPOLL) {"", ""            fprintf(stdout, \""Poll count reached limit %d.\\n\"", MAXPOLL);"", ""            kwsysProcess_Kill(kp);"", ""            }"", ""          }"", ""        else"", ""          {"", ""          fwrite(data, 1, (size_t) length, stdout);"", ""        } else {"", ""          fwrite(data, 1, (size_t)length, stdout);"", ""          fflush(stdout);"", ""          }"", ""        }"", ""      if(poll)"", ""        {"", ""      }"", ""      if (poll) {"", ""        /* Delay to avoid busy loop during polling.  */"", ""        testProcess_usleep(100000);"", ""        }"", ""      if(delay)"", ""        {"", ""        /* Purposely sleeping only on Win32 to let pipe fill up.  */"", ""      }"", ""      if (delay) {"", ""/* Purposely sleeping only on Win32 to let pipe fill up.  */"", ""#if defined(_WIN32)"", ""        testProcess_usleep(100000);"", ""#endif"", ""        }"", ""      }"", ""    }"", ""  }"", """", ""  if(disown)"", ""    {"", ""  if (disown) {"", ""    kwsysProcess_Disown(kp);"", ""    }"", ""  else"", ""    {"", ""  } else {"", ""    kwsysProcess_WaitForExit(kp, 0);"", ""    }"", ""  }"", """", ""  switch (kwsysProcess_GetState(kp))"", ""    {"", ""  switch (kwsysProcess_GetState(kp)) {"", ""    case kwsysProcess_State_Starting:"", ""      printf(\""No process has been executed.\\n\""); break;"", ""      printf(\""No process has been executed.\\n\"");"", ""      break;"", ""    case kwsysProcess_State_Executing:"", ""      printf(\""The process is still executing.\\n\""); break;"", ""      printf(\""The process is still executing.\\n\"");"", ""      break;"", ""    case kwsysProcess_State_Expired:"", ""      printf(\""Child was killed when timeout expired.\\n\""); break;"", ""      printf(\""Child was killed when timeout expired.\\n\"");"", ""      break;"", ""    case kwsysProcess_State_Exited:"", ""      printf(\""Child exited with value = %d\\n\"","", ""             kwsysProcess_GetExitValue(kp));"", ""      printf(\""Child exited with value = %d\\n\"", kwsysProcess_GetExitValue(kp));"", ""      result = ((exception != kwsysProcess_GetExitException(kp)) ||"", ""                (value != kwsysProcess_GetExitValue(kp))); break;"", ""                (value != kwsysProcess_GetExitValue(kp)));"", ""      break;"", ""    case kwsysProcess_State_Killed:"", ""      printf(\""Child was killed by parent.\\n\""); break;"", ""      printf(\""Child was killed by parent.\\n\"");"", ""      break;"", ""    case kwsysProcess_State_Exception:"", ""      printf(\""Child terminated abnormally: %s\\n\"","", ""             kwsysProcess_GetExceptionString(kp));"", ""      result = ((exception != kwsysProcess_GetExitException(kp)) ||"", ""                (value != kwsysProcess_GetExitValue(kp))); break;"", ""                (value != kwsysProcess_GetExitValue(kp)));"", ""      break;"", ""    case kwsysProcess_State_Disowned:"", ""      printf(\""Child was disowned.\\n\""); break;"", ""      printf(\""Child was disowned.\\n\"");"", ""      break;"", ""    case kwsysProcess_State_Error:"", ""      printf(\""Error in administrating child process: [%s]\\n\"","", ""             kwsysProcess_GetErrorString(kp)); break;"", ""    };"", ""             kwsysProcess_GetErrorString(kp));"", ""      break;"", ""  };"", """", ""  if(result)"", ""    {"", ""    if(exception != kwsysProcess_GetExitException(kp))"", ""      {"", ""  if (result) {"", ""    if (exception != kwsysProcess_GetExitException(kp)) {"", ""      fprintf(stderr, \""Mismatch in exit exception.  \"""", ""              \""Should have been %d, was %d.\\n\"","", ""                      \""Should have been %d, was %d.\\n\"","", ""              exception, kwsysProcess_GetExitException(kp));"", ""      }"", ""    if(value != kwsysProcess_GetExitValue(kp))"", ""      {"", ""    }"", ""    if (value != kwsysProcess_GetExitValue(kp)) {"", ""      fprintf(stderr, \""Mismatch in exit value.  \"""", ""              \""Should have been %d, was %d.\\n\"","", ""                      \""Should have been %d, was %d.\\n\"","", ""              value, kwsysProcess_GetExitValue(kp));"", ""      }"", ""    }"", ""  }"", """", ""  if(kwsysProcess_GetState(kp) != state)"", ""    {"", ""  if (kwsysProcess_GetState(kp) != state) {"", ""    fprintf(stderr, \""Mismatch in state.  \"""", ""            \""Should have been %d, was %d.\\n\"","", ""                    \""Should have been %d, was %d.\\n\"","", ""            state, kwsysProcess_GetState(kp));"", ""    result = 1;"", ""    }"", ""  }"", """", ""  /* We should have polled more times than there were data if polling"", ""     was enabled.  */"", ""  if(poll && poll < MINPOLL)"", ""    {"", ""    fprintf(stderr, \""Poll count is %d, which is less than %d.\\n\"","", ""            poll, MINPOLL);"", ""  if (poll && poll < MINPOLL) {"", ""    fprintf(stderr, \""Poll count is %d, which is less than %d.\\n\"", poll,"", ""            MINPOLL);"", ""    result = 1;"", ""    }"", ""  }"", """", ""  return result;"", ""}""]","[0, 0, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, 1, 0, -1, -1, -1, 1, 1, 0, 0, -1, -1, -1, 1, 1, 0, -1, -1, -1, 1, 1, 0, -1, 1, 0, 0, -1, -1, 1, 0, -1, 1, 0, -1, -1, 1, 0, 0, -1, 1, 0, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, 1, 1, 1, 0, 0, 0, 0, 0, -1, -1, -2, -1, 1, 2, 0, -1, 0, -1, -1, -1, 1, 1, 0, -1, 0, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, 1, 1, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, -1, 1, 0, -1, -1, -1, 1, 0, -1, 1, 0, -1, -1, 1, 0, -2, 2, 1, 0, -2, 2, 1, 0, -2, 2, 1, 0, -2, -1, 2, 0, -1, 1, 1, 0, -2, 2, 1, 0, 0, 0, 0, -1, 1, 1, 0, -2, 2, 1, 0, 0, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 0, -1, 1, 0, -1, -1, -1, 1, 1, 0, -1, 1, 0, -1, 0, 1, 0, -1, -1, 1, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, -1, -1, -2, -1, 1, 2, 1, 0, -1, 1, 0, 0, 0]","[[81, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""-"", ""fprintf(stdout, \""Poll count reached limit %d.\\n\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_new.cpp""], [84, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""+"", ""fprintf(stdout, \""Poll count reached limit %d.\\n\"", MAXPOLL);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_new.cpp""], [133, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""-"", ""printf(\""No process has been executed.\\n\""); break;"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_new.cpp""], [134, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""+"", ""printf(\""No process has been executed.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_new.cpp""], [137, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""-"", ""printf(\""The process is still executing.\\n\""); break;"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_new.cpp""], [138, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""+"", ""printf(\""The process is still executing.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_new.cpp""], [141, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""-"", ""printf(\""Child was killed when timeout expired.\\n\""); break;"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_new.cpp""], [142, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""+"", ""printf(\""Child was killed when timeout expired.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_new.cpp""], [145, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""-"", ""printf(\""Child exited with value = %d\\n\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_new.cpp""], [147, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""+"", ""printf(\""Child exited with value = %d\\n\"", kwsysProcess_GetExitValue(kp));"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_new.cpp""], [153, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""-"", ""printf(\""Child was killed by parent.\\n\""); break;"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_new.cpp""], [154, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""+"", ""printf(\""Child was killed by parent.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_new.cpp""], [164, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""-"", ""printf(\""Child was disowned.\\n\""); break;"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_new.cpp""], [165, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""+"", ""printf(\""Child was disowned.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_new.cpp""], [213, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""-"", ""fprintf(stderr, \""Poll count is %d, which is less than %d.\\n\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_new.cpp""], [216, ""95a97a40e48a0db2b206c4560d6962be3666812c"", ""Merge branch 'upstream-KWSys' into update-kwsys\n\n* upstream-KWSys:\n  KWSys 2016-11-09 (18c65411)"", ""Source/kwsys/testProcess.c"", ""+"", ""fprintf(stderr, \""Poll count is %d, which is less than %d.\\n\"", poll,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_96_new.cpp""]]",368,362
"["""", ""// Read an integer value from an input stream."", ""template <class T>"", ""std::istream&"", ""IOStreamScanTemplate(std::istream& is, T& value, char type)"", ""std::istream& IOStreamScanTemplate(std::istream& is, T& value, char type)"", ""{"", ""  int state = std::ios_base::goodbit;"", """", ""  // Skip leading whitespace."", ""  std::istream::sentry okay(is);"", """", ""  if(okay)"", ""    {"", ""  if (okay) {"", ""    try {"", ""    // Copy the string to a buffer and construct the format string."", ""    char buffer[KWSYS_IOS_INT64_MAX_DIG];"", ""#   if defined(_MSC_VER)"", ""    char format[] = \""%I64_\"";"", ""    const int typeIndex = 4;"", ""#   else"", ""    char format[] = \""%ll_\"";"", ""    const int typeIndex = 3;"", ""#   endif"", ""    switch(IOStreamScanStream(is, buffer))"", ""      {"", ""      case 8: format[typeIndex] = 'o'; break;"", ""      case 0: // Default to decimal if not told otherwise."", ""      case 10: format[typeIndex] = type; break;"", ""      case 16: format[typeIndex] = 'x'; break;"", ""      // Copy the string to a buffer and construct the format string."", ""      char buffer[KWSYS_IOS_INT64_MAX_DIG];"", ""#if defined(_MSC_VER)"", ""      char format[] = \""%I64_\"";"", ""      const int typeIndex = 4;"", ""#else"", ""      char format[] = \""%ll_\"";"", ""      const int typeIndex = 3;"", ""#endif"", ""      switch (IOStreamScanStream(is, buffer)) {"", ""        case 8:"", ""          format[typeIndex] = 'o';"", ""          break;"", ""        case 0: // Default to decimal if not told otherwise."", ""        case 10:"", ""          format[typeIndex] = type;"", ""          break;"", ""        case 16:"", ""          format[typeIndex] = 'x';"", ""          break;"", ""      };"", """", ""    // Use sscanf to parse the number from the buffer."", ""    T result;"", ""    int success = (sscanf(buffer, format, &result) == 1)?1:0;"", ""      // Use sscanf to parse the number from the buffer."", ""      T result;"", ""      int success = (sscanf(buffer, format, &result) == 1) ? 1 : 0;"", """", ""    // Set flags for resulting state."", ""    if(is.peek() == EOF) { state |= std::ios_base::eofbit; }"", ""    if(!success) { state |= std::ios_base::failbit; }"", ""    else { value = result; }"", ""    } catch(...) { state |= std::ios_base::badbit; }"", ""      // Set flags for resulting state."", ""      if (is.peek() == EOF) {"", ""        state |= std::ios_base::eofbit;"", ""      }"", ""      if (!success) {"", ""        state |= std::ios_base::failbit;"", ""      } else {"", ""        value = result;"", ""      }"", ""    } catch (...) {"", ""      state |= std::ios_base::badbit;"", ""    }"", ""  }"", """", ""  is.setstate(std::ios_base::iostate(state));"", ""  return is;"", ""}"", """", ""// Print an integer value to an output stream."", ""template <class T>"", ""std::ostream&"", ""IOStreamPrintTemplate(std::ostream& os, T value, char type)"", ""std::ostream& IOStreamPrintTemplate(std::ostream& os, T value, char type)"", ""{"", ""  std::ostream::sentry okay(os);"", ""  if(okay)"", ""    {"", ""  if (okay) {"", ""    try {"", ""    // Construct the format string."", ""    char format[8];"", ""    char* f = format;"", ""    *f++ = '%';"", ""    if(os.flags() & std::ios_base::showpos) { *f++ = '+'; }"", ""    if(os.flags() & std::ios_base::showbase) { *f++ = '#'; }"", ""#   if defined(_MSC_VER)"", ""    *f++ = 'I'; *f++ = '6'; *f++ = '4';"", ""#   else"", ""    *f++ = 'l'; *f++ = 'l';"", ""#   endif"", ""    long bflags = os.flags() & std::ios_base::basefield;"", ""    if(bflags == std::ios_base::oct) { *f++ = 'o'; }"", ""    else if(bflags != std::ios_base::hex) { *f++ = type; }"", ""    else if(os.flags() & std::ios_base::uppercase) { *f++ = 'X'; }"", ""    else { *f++ = 'x'; }"", ""    *f = '\\0';"", """", ""    // Use sprintf to print to a buffer and then write the"", ""    // buffer to the stream."", ""    char buffer[2*KWSYS_IOS_INT64_MAX_DIG];"", ""    sprintf(buffer, format, value);"", ""    os << buffer;"", ""    } catch(...) { os.clear(os.rdstate() | std::ios_base::badbit); }"", ""      // Construct the format string."", ""      char format[8];"", ""      char* f = format;"", ""      *f++ = '%';"", ""      if (os.flags() & std::ios_base::showpos) {"", ""        *f++ = '+';"", ""      }"", ""      if (os.flags() & std::ios_base::showbase) {"", ""        *f++ = '#';"", ""      }"", ""#if defined(_MSC_VER)"", ""      *f++ = 'I';"", ""      *f++ = '6';"", ""      *f++ = '4';"", ""#else"", ""      *f++ = 'l';"", ""      *f++ = 'l';"", ""#endif"", ""      long bflags = os.flags() & std::ios_base::basefield;"", ""      if (bflags == std::ios_base::oct) {"", ""        *f++ = 'o';"", ""      } else if (bflags != std::ios_base::hex) {"", ""        *f++ = type;"", ""      } else if (os.flags() & std::ios_base::uppercase) {"", ""        *f++ = 'X';"", ""      } else {"", ""        *f++ = 'x';"", ""      }"", ""      *f = '\\0';"", """", ""      // Use sprintf to print to a buffer and then write the"", ""      // buffer to the stream."", ""      char buffer[2 * KWSYS_IOS_INT64_MAX_DIG];"", ""      sprintf(buffer, format, value);"", ""      os << buffer;"", ""    } catch (...) {"", ""      os.clear(os.rdstate() | std::ios_base::badbit);"", ""    }"", ""  }"", ""  return os;"", ""}"", """", ""# if !KWSYS_IOS_HAS_ISTREAM_LONG_LONG"", ""#if !KWSYS_IOS_HAS_ISTREAM_LONG_LONG"", ""// Implement input stream operator for IOStreamSLL."", ""std::istream& IOStreamScan(std::istream& is, IOStreamSLL& value)"", ""{""]","[0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, 1, 0, 0, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0]","[[115, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""IOStream.cxx"", ""-"", ""sprintf(buffer, format, value);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_97_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_97_new.cpp""], [151, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""IOStream.cxx"", ""+"", ""sprintf(buffer, format, value);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_97_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_97_new.cpp""]]",123,107
"["" * of the structure of the compiled regexp."", "" */"", """", """", ""// compile -- compile a regular expression into internal code"", ""// for later pattern matching."", """", ""bool RegularExpression::compile (const char* exp) {"", ""    const char* scan;"", ""    const char* longest;"", ""    size_t      len;"", ""    int         flags;"", ""bool RegularExpression::compile(const char* exp)"", ""{"", ""  const char* scan;"", ""  const char* longest;"", ""  size_t len;"", ""  int flags;"", """", ""  if (exp == 0) {"", ""    // RAISE Error, SYM(RegularExpression), SYM(No_Expr),"", ""    printf(\""RegularExpression::compile(): No expression supplied.\\n\"");"", ""    return false;"", ""  }"", """", ""    if (exp == 0) {"", ""      //RAISE Error, SYM(RegularExpression), SYM(No_Expr),"", ""      printf (\""RegularExpression::compile(): No expression supplied.\\n\"");"", ""      return false;"", ""    }"", ""  // First pass: determine size, legality."", ""  regparse = exp;"", ""  regnpar = 1;"", ""  regsize = 0L;"", ""  regcode = &regdummy;"", ""  regc(static_cast<char>(MAGIC));"", ""  if (!reg(0, &flags)) {"", ""    printf(\""RegularExpression::compile(): Error in compile.\\n\"");"", ""    return false;"", ""  }"", ""  this->startp[0] = this->endp[0] = this->searchstring = 0;"", """", ""    // First pass: determine size, legality."", ""    regparse = exp;"", ""    regnpar = 1;"", ""    regsize = 0L;"", ""    regcode = &regdummy;"", ""    regc(static_cast<char>(MAGIC));"", ""    if(!reg(0, &flags))"", ""      {"", ""        printf (\""RegularExpression::compile(): Error in compile.\\n\"");"", ""        return false;"", ""      }"", ""    this->startp[0] = this->endp[0] = this->searchstring = 0;"", ""  // Small enough for pointer-storage convention?"", ""  if (regsize >= 32767L) { // Probably could be 65535L."", ""    // RAISE Error, SYM(RegularExpression), SYM(Expr_Too_Big),"", ""    printf(\""RegularExpression::compile(): Expression too big.\\n\"");"", ""    return false;"", ""  }"", """", ""    // Small enough for pointer-storage convention?"", ""    if (regsize >= 32767L) {    // Probably could be 65535L."", ""      //RAISE Error, SYM(RegularExpression), SYM(Expr_Too_Big),"", ""      printf (\""RegularExpression::compile(): Expression too big.\\n\"");"", ""      return false;"", ""    }"", ""  // Allocate space."", ""  //#ifndef _WIN32"", ""  if (this->program != 0)"", ""    delete[] this->program;"", ""  //#endif"", ""  this->program = new char[regsize];"", ""  this->progsize = static_cast<int>(regsize);"", """", ""  if (this->program == 0) {"", ""    // RAISE Error, SYM(RegularExpression), SYM(Out_Of_Memory),"", ""    printf(\""RegularExpression::compile(): Out of memory.\\n\"");"", ""    return false;"", ""  }"", """", ""    // Allocate space."", ""//#ifndef _WIN32"", ""    if (this->program != 0) delete [] this->program;"", ""//#endif"", ""    this->program = new char[regsize];"", ""    this->progsize = static_cast<int>(regsize);"", """", ""    if (this->program == 0) {"", ""      //RAISE Error, SYM(RegularExpression), SYM(Out_Of_Memory),"", ""      printf (\""RegularExpression::compile(): Out of memory.\\n\"");"", ""      return false;"", ""    }"", ""  // Second pass: emit code."", ""  regparse = exp;"", ""  regnpar = 1;"", ""  regcode = this->program;"", ""  regc(static_cast<char>(MAGIC));"", ""  reg(0, &flags);"", """", ""  // Dig out information for optimizations."", ""  this->regstart = '\\0'; // Worst-case defaults."", ""  this->reganch = 0;"", ""  this->regmust = 0;"", ""  this->regmlen = 0;"", ""  scan = this->program + 1;       // First BRANCH."", ""  if (OP(regnext(scan)) == END) { // Only one top-level choice."", ""    scan = OPERAND(scan);"", """", ""    // Starting-point info."", ""    if (OP(scan) == EXACTLY)"", ""      this->regstart = *OPERAND(scan);"", ""    else if (OP(scan) == BOL)"", ""      this->reganch++;"", """", ""    // Second pass: emit code."", ""    regparse = exp;"", ""    regnpar = 1;"", ""    regcode = this->program;"", ""    regc(static_cast<char>(MAGIC));"", ""    reg(0, &flags);"", """", ""    // Dig out information for optimizations."", ""    this->regstart = '\\0';              // Worst-case defaults."", ""    this->reganch = 0;"", ""    this->regmust = 0;"", ""    this->regmlen = 0;"", ""    scan = this->program + 1;   // First BRANCH."", ""    if (OP(regnext(scan)) == END) {     // Only one top-level choice."", ""        scan = OPERAND(scan);"", """", ""        // Starting-point info."", ""        if (OP(scan) == EXACTLY)"", ""            this->regstart = *OPERAND(scan);"", ""        else if (OP(scan) == BOL)"", ""            this->reganch++;"", """", ""         //"", ""         // If there's something expensive in the r.e., find the longest"", ""         // literal string that must appear and make it the regmust.  Resolve"", ""         // ties in favor of later strings, since the regstart check works"", ""         // with the beginning of the r.e. and avoiding duplication"", ""         // strengthens checking.  Not a strong reason, but sufficient in the"", ""         // absence of others."", ""         //"", ""        if (flags & SPSTART) {"", ""            longest = 0;"", ""            len = 0;"", ""            for (; scan != 0; scan = regnext(scan))"", ""                if (OP(scan) == EXACTLY && strlen(OPERAND(scan)) >= len) {"", ""                    longest = OPERAND(scan);"", ""                    len = strlen(OPERAND(scan));"", ""                }"", ""            this->regmust = longest;"", ""            this->regmlen = len;"", ""    //"", ""    // If there's something expensive in the r.e., find the longest"", ""    // literal string that must appear and make it the regmust.  Resolve"", ""    // ties in favor of later strings, since the regstart check works"", ""    // with the beginning of the r.e. and avoiding duplication"", ""    // strengthens checking.  Not a strong reason, but sufficient in the"", ""    // absence of others."", ""    //"", ""    if (flags & SPSTART) {"", ""      longest = 0;"", ""      len = 0;"", ""      for (; scan != 0; scan = regnext(scan))"", ""        if (OP(scan) == EXACTLY && strlen(OPERAND(scan)) >= len) {"", ""          longest = OPERAND(scan);"", ""          len = strlen(OPERAND(scan));"", ""        }"", ""      this->regmust = longest;"", ""      this->regmlen = len;"", ""    }"", ""    return true;"", ""  }"", ""  return true;"", ""}"", """", """", ""/*"", "" - reg - regular expression, i.e. main body or parenthesized thing"", "" *""]","[0, 0, 0, -1, 0, 0, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 2, 1, 1, 0, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, -1, 1, 1, 0, 0, -1, 0, 0, 0]","[[21, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): No expression supplied.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_new.cpp""], [37, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Error in compile.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_new.cpp""], [57, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Expression too big.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_new.cpp""], [77, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Out of memory.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_new.cpp""]]",339,325
"["" * is a trifle forced, but the need to tie the tails of the branches to what"", "" * follows makes it hard to avoid."", "" */"", ""static char* reg (int paren, int *flagp) {"", ""    char* ret;"", ""    char* br;"", ""    char* ender;"", ""    int   parno =0;"", ""    int   flags;"", """", ""    *flagp = HASWIDTH;          // Tentatively."", """", ""    // Make an OPEN node, if parenthesized."", ""    if (paren) {"", ""        if (regnpar >=  RegularExpression::NSUBEXP) {"", ""          //RAISE Error, SYM(RegularExpression), SYM(Too_Many_Parens),"", ""          printf (\""RegularExpression::compile(): Too many parentheses.\\n\"");"", ""          return 0;"", ""        }"", ""        parno = regnpar;"", ""        regnpar++;"", ""        ret = regnode(static_cast<char>(OPEN + parno));"", ""static char* reg(int paren, int* flagp)"", ""{"", ""  char* ret;"", ""  char* br;"", ""  char* ender;"", ""  int parno = 0;"", ""  int flags;"", """", ""  *flagp = HASWIDTH; // Tentatively."", """", ""  // Make an OPEN node, if parenthesized."", ""  if (paren) {"", ""    if (regnpar >= RegularExpression::NSUBEXP) {"", ""      // RAISE Error, SYM(RegularExpression), SYM(Too_Many_Parens),"", ""      printf(\""RegularExpression::compile(): Too many parentheses.\\n\"");"", ""      return 0;"", ""    }"", ""    else"", ""        ret = 0;"", """", ""    // Pick up the branches, linking them together."", ""    parno = regnpar;"", ""    regnpar++;"", ""    ret = regnode(static_cast<char>(OPEN + parno));"", ""  } else"", ""    ret = 0;"", """", ""  // Pick up the branches, linking them together."", ""  br = regbranch(&flags);"", ""  if (br == 0)"", ""    return (0);"", ""  if (ret != 0)"", ""    regtail(ret, br); // OPEN -> first."", ""  else"", ""    ret = br;"", ""  if (!(flags & HASWIDTH))"", ""    *flagp &= ~HASWIDTH;"", ""  *flagp |= flags & SPSTART;"", ""  while (*regparse == '|') {"", ""    regparse++;"", ""    br = regbranch(&flags);"", ""    if (br == 0)"", ""        return (0);"", ""    if (ret != 0)"", ""        regtail(ret, br);       // OPEN -> first."", ""    else"", ""        ret = br;"", ""      return (0);"", ""    regtail(ret, br); // BRANCH -> BRANCH."", ""    if (!(flags & HASWIDTH))"", ""        *flagp &= ~HASWIDTH;"", ""      *flagp &= ~HASWIDTH;"", ""    *flagp |= flags & SPSTART;"", ""    while (*regparse == '|') {"", ""        regparse++;"", ""        br = regbranch(&flags);"", ""        if (br == 0)"", ""            return (0);"", ""        regtail(ret, br);       // BRANCH -> BRANCH."", ""        if (!(flags & HASWIDTH))"", ""            *flagp &= ~HASWIDTH;"", ""        *flagp |= flags & SPSTART;"", ""      }"", """", ""    // Make a closing node, and hook it on the end."", ""    ender = regnode(static_cast<char>((paren) ? CLOSE + parno : END));"", ""    regtail(ret, ender);"", """", ""    // Hook the tails of the branches to the closing node."", ""    for (br = ret; br != 0; br = regnext(br))"", ""        regoptail(br, ender);"", ""  }"", """", ""    // Check for proper termination."", ""    if (paren && *regparse++ != ')') {"", ""        //RAISE Error, SYM(RegularExpression), SYM(Unmatched_Parens),"", ""        printf (\""RegularExpression::compile(): Unmatched parentheses.\\n\"");"", ""        return 0;"", ""    }"", ""    else if (!paren && *regparse != '\\0') {"", ""        if (*regparse == ')') {"", ""            //RAISE Error, SYM(RegularExpression), SYM(Unmatched_Parens),"", ""            printf (\""RegularExpression::compile(): Unmatched parentheses.\\n\"");"", ""            return 0;"", ""        }"", ""        else {"", ""            //RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""            printf (\""RegularExpression::compile(): Internal error.\\n\"");"", ""            return 0;"", ""        }"", ""        // NOTREACHED"", ""  // Make a closing node, and hook it on the end."", ""  ender = regnode(static_cast<char>((paren) ? CLOSE + parno : END));"", ""  regtail(ret, ender);"", """", ""  // Hook the tails of the branches to the closing node."", ""  for (br = ret; br != 0; br = regnext(br))"", ""    regoptail(br, ender);"", """", ""  // Check for proper termination."", ""  if (paren && *regparse++ != ')') {"", ""    // RAISE Error, SYM(RegularExpression), SYM(Unmatched_Parens),"", ""    printf(\""RegularExpression::compile(): Unmatched parentheses.\\n\"");"", ""    return 0;"", ""  } else if (!paren && *regparse != '\\0') {"", ""    if (*regparse == ')') {"", ""      // RAISE Error, SYM(RegularExpression), SYM(Unmatched_Parens),"", ""      printf(\""RegularExpression::compile(): Unmatched parentheses.\\n\"");"", ""      return 0;"", ""    } else {"", ""      // RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""      printf(\""RegularExpression::compile(): Internal error.\\n\"");"", ""      return 0;"", ""    }"", ""    return (ret);"", ""    // NOTREACHED"", ""  }"", ""  return (ret);"", ""}"", """", """", ""/*"", "" - regbranch - one alternative of an | operator"", "" *"", "" * Implements the concatenation operator."", "" */"", ""static char* regbranch (int *flagp) {"", ""    char* ret;"", ""    char* chain;"", ""    char* latest;"", ""    int   flags;"", """", ""    *flagp = WORST;             // Tentatively."", """", ""    ret = regnode(BRANCH);"", ""    chain = 0;"", ""    while (*regparse != '\\0' && *regparse != '|' && *regparse != ')') {"", ""        latest = regpiece(&flags);"", ""        if (latest == 0)"", ""            return (0);"", ""        *flagp |= flags & HASWIDTH;"", ""        if (chain == 0) // First piece."", ""            *flagp |= flags & SPSTART;"", ""        else"", ""            regtail(chain, latest);"", ""        chain = latest;"", ""    }"", ""    if (chain == 0)             // Loop ran zero times."", ""        regnode(NOTHING);"", ""static char* regbranch(int* flagp)"", ""{"", ""  char* ret;"", ""  char* chain;"", ""  char* latest;"", ""  int flags;"", """", ""  *flagp = WORST; // Tentatively."", """", ""  ret = regnode(BRANCH);"", ""  chain = 0;"", ""  while (*regparse != '\\0' && *regparse != '|' && *regparse != ')') {"", ""    latest = regpiece(&flags);"", ""    if (latest == 0)"", ""      return (0);"", ""    *flagp |= flags & HASWIDTH;"", ""    if (chain == 0) // First piece."", ""      *flagp |= flags & SPSTART;"", ""    else"", ""      regtail(chain, latest);"", ""    chain = latest;"", ""  }"", ""  if (chain == 0) // Loop ran zero times."", ""    regnode(NOTHING);"", """", ""    return (ret);"", ""  return (ret);"", ""}"", """", """", ""/*"", "" - regpiece - something followed by possible [*+?]"", "" *""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, 1, 1, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 0, -1, 1, 1, 1, 0, 0, -1, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, 0, -1, 0, 0, 0]","[[36, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Too many parentheses.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_new.cpp""], [124, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Unmatched parentheses.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_new.cpp""], [129, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Unmatched parentheses.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_new.cpp""], [133, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Internal error.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_new.cpp""]]",443,428
"["" * It might seem that this node could be dispensed with entirely, but the"", "" * endmarker role is not redundant."", "" */"", ""static char* regpiece (int *flagp) {"", ""    char* ret;"", ""    char  op;"", ""    char* next;"", ""    int   flags;"", """", ""    ret = regatom(&flags);"", ""    if (ret == 0)"", ""        return (0);"", ""static char* regpiece(int* flagp)"", ""{"", ""  char* ret;"", ""  char op;"", ""  char* next;"", ""  int flags;"", """", ""    op = *regparse;"", ""    if (!ISMULT(op)) {"", ""        *flagp = flags;"", ""        return (ret);"", ""    }"", ""  ret = regatom(&flags);"", ""  if (ret == 0)"", ""    return (0);"", """", ""    if (!(flags & HASWIDTH) && op != '?') {"", ""        //RAISE Error, SYM(RegularExpression), SYM(Empty_Operand),"", ""        printf (\""RegularExpression::compile() : *+ operand could be empty.\\n\"");"", ""        return 0;"", ""    }"", ""    *flagp = (op != '+') ? (WORST | SPSTART) : (WORST | HASWIDTH);"", """", ""    if (op == '*' && (flags & SIMPLE))"", ""        reginsert(STAR, ret);"", ""    else if (op == '*') {"", ""        // Emit x* as (x&|), where & means \""self\""."", ""        reginsert(BRANCH, ret); // Either x"", ""        regoptail(ret, regnode(BACK));  // and loop"", ""        regoptail(ret, ret);    // back"", ""        regtail(ret, regnode(BRANCH));  // or"", ""        regtail(ret, regnode(NOTHING)); // null."", ""    }"", ""    else if (op == '+' && (flags & SIMPLE))"", ""        reginsert(PLUS, ret);"", ""    else if (op == '+') {"", ""        // Emit x+ as x(&|), where & means \""self\""."", ""        next = regnode(BRANCH); // Either"", ""        regtail(ret, next);"", ""        regtail(regnode(BACK), ret);    // loop back"", ""        regtail(next, regnode(BRANCH)); // or"", ""        regtail(ret, regnode(NOTHING)); // null."", ""    }"", ""    else if (op == '?') {"", ""        // Emit x? as (x|)"", ""        reginsert(BRANCH, ret); // Either x"", ""        regtail(ret, regnode(BRANCH));  // or"", ""        next = regnode(NOTHING);// null."", ""        regtail(ret, next);"", ""        regoptail(ret, next);"", ""    }"", ""    regparse++;"", ""    if (ISMULT(*regparse)) {"", ""        //RAISE Error, SYM(RegularExpression), SYM(Nested_Operand),"", ""        printf (\""RegularExpression::compile(): Nested *?+.\\n\"");"", ""        return 0;"", ""    }"", ""  op = *regparse;"", ""  if (!ISMULT(op)) {"", ""    *flagp = flags;"", ""    return (ret);"", ""}"", ""  }"", """", ""  if (!(flags & HASWIDTH) && op != '?') {"", ""    // RAISE Error, SYM(RegularExpression), SYM(Empty_Operand),"", ""    printf(\""RegularExpression::compile() : *+ operand could be empty.\\n\"");"", ""    return 0;"", ""  }"", ""  *flagp = (op != '+') ? (WORST | SPSTART) : (WORST | HASWIDTH);"", """", ""  if (op == '*' && (flags & SIMPLE))"", ""    reginsert(STAR, ret);"", ""  else if (op == '*') {"", ""    // Emit x* as (x&|), where & means \""self\""."", ""    reginsert(BRANCH, ret);         // Either x"", ""    regoptail(ret, regnode(BACK));  // and loop"", ""    regoptail(ret, ret);            // back"", ""    regtail(ret, regnode(BRANCH));  // or"", ""    regtail(ret, regnode(NOTHING)); // null."", ""  } else if (op == '+' && (flags & SIMPLE))"", ""    reginsert(PLUS, ret);"", ""  else if (op == '+') {"", ""    // Emit x+ as x(&|), where & means \""self\""."", ""    next = regnode(BRANCH); // Either"", ""    regtail(ret, next);"", ""    regtail(regnode(BACK), ret);    // loop back"", ""    regtail(next, regnode(BRANCH)); // or"", ""    regtail(ret, regnode(NOTHING)); // null."", ""  } else if (op == '?') {"", ""    // Emit x? as (x|)"", ""    reginsert(BRANCH, ret);        // Either x"", ""    regtail(ret, regnode(BRANCH)); // or"", ""    next = regnode(NOTHING);       // null."", ""    regtail(ret, next);"", ""    regoptail(ret, next);"", ""  }"", ""  regparse++;"", ""  if (ISMULT(*regparse)) {"", ""    // RAISE Error, SYM(RegularExpression), SYM(Nested_Operand),"", ""    printf(\""RegularExpression::compile(): Nested *?+.\\n\"");"", ""    return 0;"", ""  }"", ""  return (ret);"", ""}"", """", ""/*"", "" - regatom - the lowest level""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 0, -1, 1, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0]","[[78, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile() : *+ operand could be empty.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_new.cpp""], [112, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Nested *?+.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_new.cpp""]]",561,543
"["" * faster to run.  Backslashed characters are exceptions, each becoming a"", "" * separate node; the code is simpler that way and it's not worth fixing."", "" */"", ""static char* regatom (int *flagp) {"", ""    char* ret;"", ""    int   flags;"", """", ""    *flagp = WORST;             // Tentatively."", """", ""    switch (*regparse++) {"", ""        case '^':"", ""            ret = regnode(BOL);"", ""            break;"", ""        case '$':"", ""            ret = regnode(EOL);"", ""            break;"", ""        case '.':"", ""            ret = regnode(ANY);"", ""            *flagp |= HASWIDTH | SIMPLE;"", ""            break;"", ""        case '[':{"", ""                int    rxpclass;"", ""                int    rxpclassend;"", """", ""                if (*regparse == '^') { // Complement of range."", ""                    ret = regnode(ANYBUT);"", ""                    regparse++;"", ""                }"", ""                else"", ""                    ret = regnode(ANYOF);"", ""                if (*regparse == ']' || *regparse == '-')"", ""                    regc(*regparse++);"", ""                while (*regparse != '\\0' && *regparse != ']') {"", ""                    if (*regparse == '-') {"", ""                        regparse++;"", ""                        if (*regparse == ']' || *regparse == '\\0')"", ""                            regc('-');"", ""                        else {"", ""                            rxpclass = UCHARAT(regparse - 2) + 1;"", ""                            rxpclassend = UCHARAT(regparse);"", ""                            if (rxpclass > rxpclassend + 1) {"", ""                               //RAISE Error, SYM(RegularExpression), SYM(Invalid_Range),"", ""                               printf (\""RegularExpression::compile(): Invalid range in [].\\n\"");"", ""                               return 0;"", ""                            }"", ""                            for (; rxpclass <= rxpclassend; rxpclass++)"", ""                              regc(static_cast<char>(rxpclass));"", ""                            regparse++;"", ""                        }"", ""                    }"", ""                    else"", ""                        regc(*regparse++);"", ""                }"", ""                regc('\\0');"", ""                if (*regparse != ']') {"", ""                    //RAISE Error, SYM(RegularExpression), SYM(Unmatched_Bracket),"", ""                    printf (\""RegularExpression::compile(): Unmatched [].\\n\"");"", ""                    return 0;"", ""                }"", ""                regparse++;"", ""                *flagp |= HASWIDTH | SIMPLE;"", ""            }"", ""            break;"", ""        case '(':"", ""            ret = reg(1, &flags);"", ""            if (ret == 0)"", ""                return (0);"", ""            *flagp |= flags & (HASWIDTH | SPSTART);"", ""            break;"", ""        case '\\0':"", ""        case '|':"", ""        case ')':"", ""            //RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""            printf (\""RegularExpression::compile(): Internal error.\\n\""); // Never here"", ""            return 0;"", ""        case '?':"", ""        case '+':"", ""        case '*':"", ""            //RAISE Error, SYM(RegularExpression), SYM(No_Operand),"", ""            printf (\""RegularExpression::compile(): ?+* follows nothing.\\n\"");"", ""            return 0;"", ""        case '\\\\':"", ""            if (*regparse == '\\0') {"", ""                //RAISE Error, SYM(RegularExpression), SYM(Trailing_Backslash),"", ""                printf (\""RegularExpression::compile(): Trailing backslash.\\n\"");"", ""                return 0;"", ""            }"", ""            ret = regnode(EXACTLY);"", ""            regc(*regparse++);"", ""            regc('\\0');"", ""            *flagp |= HASWIDTH | SIMPLE;"", ""            break;"", ""        default:{"", ""                int    len;"", ""                char   ender;"", """", ""                regparse--;"", ""                len = int(strcspn(regparse, META));"", ""                if (len <= 0) {"", ""                    //RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""                    printf (\""RegularExpression::compile(): Internal error.\\n\"");"", ""                    return 0;"", ""                }"", ""                ender = *(regparse + len);"", ""                if (len > 1 && ISMULT(ender))"", ""                    len--;      // Back off clear of ?+* operand."", ""                *flagp |= HASWIDTH;"", ""                if (len == 1)"", ""                    *flagp |= SIMPLE;"", ""                ret = regnode(EXACTLY);"", ""                while (len > 0) {"", ""                    regc(*regparse++);"", ""                    len--;"", ""                }"", ""                regc('\\0');"", ""static char* regatom(int* flagp)"", ""{"", ""  char* ret;"", ""  int flags;"", """", ""  *flagp = WORST; // Tentatively."", """", ""  switch (*regparse++) {"", ""    case '^':"", ""      ret = regnode(BOL);"", ""      break;"", ""    case '$':"", ""      ret = regnode(EOL);"", ""      break;"", ""    case '.':"", ""      ret = regnode(ANY);"", ""      *flagp |= HASWIDTH | SIMPLE;"", ""      break;"", ""    case '[': {"", ""      int rxpclass;"", ""      int rxpclassend;"", """", ""      if (*regparse == '^') { // Complement of range."", ""        ret = regnode(ANYBUT);"", ""        regparse++;"", ""      } else"", ""        ret = regnode(ANYOF);"", ""      if (*regparse == ']' || *regparse == '-')"", ""        regc(*regparse++);"", ""      while (*regparse != '\\0' && *regparse != ']') {"", ""        if (*regparse == '-') {"", ""          regparse++;"", ""          if (*regparse == ']' || *regparse == '\\0')"", ""            regc('-');"", ""          else {"", ""            rxpclass = UCHARAT(regparse - 2) + 1;"", ""            rxpclassend = UCHARAT(regparse);"", ""            if (rxpclass > rxpclassend + 1) {"", ""              // RAISE Error, SYM(RegularExpression), SYM(Invalid_Range),"", ""              printf(\""RegularExpression::compile(): Invalid range in [].\\n\"");"", ""              return 0;"", ""            }"", ""            break;"", ""    }"", ""    return (ret);"", ""            for (; rxpclass <= rxpclassend; rxpclass++)"", ""              regc(static_cast<char>(rxpclass));"", ""            regparse++;"", ""          }"", ""        } else"", ""          regc(*regparse++);"", ""      }"", ""      regc('\\0');"", ""      if (*regparse != ']') {"", ""        // RAISE Error, SYM(RegularExpression), SYM(Unmatched_Bracket),"", ""        printf(\""RegularExpression::compile(): Unmatched [].\\n\"");"", ""        return 0;"", ""      }"", ""      regparse++;"", ""      *flagp |= HASWIDTH | SIMPLE;"", ""    } break;"", ""    case '(':"", ""      ret = reg(1, &flags);"", ""      if (ret == 0)"", ""        return (0);"", ""      *flagp |= flags & (HASWIDTH | SPSTART);"", ""      break;"", ""    case '\\0':"", ""    case '|':"", ""    case ')':"", ""      // RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""      printf(\""RegularExpression::compile(): Internal error.\\n\""); // Never here"", ""      return 0;"", ""    case '?':"", ""    case '+':"", ""    case '*':"", ""      // RAISE Error, SYM(RegularExpression), SYM(No_Operand),"", ""      printf(\""RegularExpression::compile(): ?+* follows nothing.\\n\"");"", ""      return 0;"", ""    case '\\\\':"", ""      if (*regparse == '\\0') {"", ""        // RAISE Error, SYM(RegularExpression), SYM(Trailing_Backslash),"", ""        printf(\""RegularExpression::compile(): Trailing backslash.\\n\"");"", ""        return 0;"", ""      }"", ""      ret = regnode(EXACTLY);"", ""      regc(*regparse++);"", ""      regc('\\0');"", ""      *flagp |= HASWIDTH | SIMPLE;"", ""      break;"", ""    default: {"", ""      int len;"", ""      char ender;"", """", ""      regparse--;"", ""      len = int(strcspn(regparse, META));"", ""      if (len <= 0) {"", ""        // RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""        printf(\""RegularExpression::compile(): Internal error.\\n\"");"", ""        return 0;"", ""      }"", ""      ender = *(regparse + len);"", ""      if (len > 1 && ISMULT(ender))"", ""        len--; // Back off clear of ?+* operand."", ""      *flagp |= HASWIDTH;"", ""      if (len == 1)"", ""        *flagp |= SIMPLE;"", ""      ret = regnode(EXACTLY);"", ""      while (len > 0) {"", ""        regc(*regparse++);"", ""        len--;"", ""      }"", ""      regc('\\0');"", ""    } break;"", ""  }"", ""  return (ret);"", ""}"", """", """", ""/*"", "" - regnode - emit a node"", ""   Location."", "" */"", ""static char* regnode (char op) {"", ""    char* ret;"", ""    char* ptr;"", """", ""    ret = regcode;"", ""    if (ret == &regdummy) {"", ""        regsize += 3;"", ""        return (ret);"", ""    }"", """", ""    ptr = ret;"", ""    *ptr++ = op;"", ""    *ptr++ = '\\0';              // Null \""next\"" pointer."", ""    *ptr++ = '\\0';"", ""    regcode = ptr;"", ""static char* regnode(char op)"", ""{"", ""  char* ret;"", ""  char* ptr;"", """", ""  ret = regcode;"", ""  if (ret == &regdummy) {"", ""    regsize += 3;"", ""    return (ret);"", ""}"", ""  }"", """", ""  ptr = ret;"", ""  *ptr++ = op;"", ""  *ptr++ = '\\0'; // Null \""next\"" pointer."", ""  *ptr++ = '\\0';"", ""  regcode = ptr;"", """", ""  return (ret);"", ""}"", """", ""/*"", "" - regc - emit (if appropriate) a byte of code"", "" */"", ""static void regc (char b) {"", ""    if (regcode != &regdummy)"", ""        *regcode++ = b;"", ""    else"", ""        regsize++;"", ""static void regc(char b)"", ""{"", ""  if (regcode != &regdummy)"", ""    *regcode++ = b;"", ""  else"", ""    regsize++;"", ""}"", """", """", ""/*"", "" - reginsert - insert an operator in front of already-emitted operand"", "" *"", "" * Means relocating the operand."", "" */"", ""static void reginsert (char op, char* opnd) {"", ""    char* src;"", ""    char* dst;"", ""    char* place;"", """", ""    if (regcode == &regdummy) {"", ""        regsize += 3;"", ""        return;"", ""    }"", ""static void reginsert(char op, char* opnd)"", ""{"", ""  char* src;"", ""  char* dst;"", ""  char* place;"", """", ""  if (regcode == &regdummy) {"", ""    regsize += 3;"", ""    return;"", ""  }"", """", ""    src = regcode;"", ""    regcode += 3;"", ""    dst = regcode;"", ""    while (src > opnd)"", ""        *--dst = *--src;"", ""  src = regcode;"", ""  regcode += 3;"", ""  dst = regcode;"", ""  while (src > opnd)"", ""    *--dst = *--src;"", """", ""    place = opnd;               // Op node, where operand used to be."", ""    *place++ = op;"", ""    *place++ = '\\0';"", ""    *place = '\\0';"", ""  place = opnd; // Op node, where operand used to be."", ""  *place++ = op;"", ""  *place++ = '\\0';"", ""  *place = '\\0';"", ""}"", """", """", ""/*"", "" - regtail - set the next-pointer at the end of a node chain"", "" */"", ""static void regtail (char* p, const char* val) {"", ""    char* scan;"", ""    char* temp;"", ""    int   offset;"", """", ""    if (p == &regdummy)"", ""        return;"", """", ""    // Find last node."", ""    scan = p;"", ""    for (;;) {"", ""        temp = regnext(scan);"", ""        if (temp == 0)"", ""            break;"", ""        scan = temp;"", ""    }"", ""static void regtail(char* p, const char* val)"", ""{"", ""  char* scan;"", ""  char* temp;"", ""  int offset;"", """", ""    if (OP(scan) == BACK)"", ""        offset = int(scan - val);"", ""    else"", ""        offset = int(val - scan);"", ""    *(scan + 1) = static_cast<char>((offset >> 8) & 0377);"", ""    *(scan + 2) = static_cast<char>(offset & 0377);"", ""}"", ""  if (p == &regdummy)"", ""    return;"", """", ""  // Find last node."", ""  scan = p;"", ""  for (;;) {"", ""    temp = regnext(scan);"", ""    if (temp == 0)"", ""      break;"", ""    scan = temp;"", ""  }"", """", ""  if (OP(scan) == BACK)"", ""    offset = int(scan - val);"", ""  else"", ""    offset = int(val - scan);"", ""  *(scan + 1) = static_cast<char>((offset >> 8) & 0377);"", ""  *(scan + 2) = static_cast<char>(offset & 0377);"", ""}"", """", ""/*"", "" - regoptail - regtail on operand of first argument; nop if operandless"", "" */"", ""static void regoptail (char* p, const char* val) {"", ""    // \""Operandless\"" and \""op != BRANCH\"" are synonymous in practice."", ""    if (p == 0 || p == &regdummy || OP(p) != BRANCH)"", ""        return;"", ""    regtail(OPERAND(p), val);"", ""static void regoptail(char* p, const char* val)"", ""{"", ""  // \""Operandless\"" and \""op != BRANCH\"" are synonymous in practice."", ""  if (p == 0 || p == &regdummy || OP(p) != BRANCH)"", ""    return;"", ""  regtail(OPERAND(p), val);"", ""}"", """", """", """", ""////////////////////////////////////////////////////////////////////////"", ""// "", ""//"", ""//  find and friends"", ""// "", ""//"", ""////////////////////////////////////////////////////////////////////////"", """", """", ""/*"", "" * Global work variables for find()."", "" */"", ""static const char*  reginput;   // String-input pointer."", ""static const char*  regbol;     // Beginning of input, for ^ check."", ""static const char* *regstartp;  // Pointer to startp array."", ""static const char* *regendp;    // Ditto for endp."", ""static const char* reginput;   // String-input pointer."", ""static const char* regbol;     // Beginning of input, for ^ check."", ""static const char** regstartp; // Pointer to startp array."", ""static const char** regendp;   // Ditto for endp."", """", ""/*"", "" * Forwards."", "" */"", ""static int regtry (const char*, const char* *,"", ""                   const char* *, const char*);"", ""static int regmatch (const char*);"", ""static int regrepeat (const char*);"", ""static int regtry(const char*, const char**, const char**, const char*);"", ""static int regmatch(const char*);"", ""static int regrepeat(const char*);"", """", ""#ifdef DEBUG"", ""int          regnarrate = 0;"", ""void         regdump ();"", ""static char* regprop ();"", ""int regnarrate = 0;"", ""void regdump();"", ""static char* regprop();"", ""#endif"", """", ""// find -- Matches the regular expression to the given string."", ""// Returns true if found, and sets start and end indexes accordingly."", """", ""bool RegularExpression::find (const char* string) {"", ""    const char* s;"", ""bool RegularExpression::find(const char* string)"", ""{"", ""  const char* s;"", """", ""    this->searchstring = string;"", ""  this->searchstring = string;"", """", ""    if (!this->program)"", ""      {"", ""      return false;"", ""      }"", ""  if (!this->program) {"", ""    return false;"", ""  }"", """", ""    // Check validity of program."", ""    if (UCHARAT(this->program) != MAGIC) {"", ""        //RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""        printf (\""RegularExpression::find(): Compiled regular expression corrupted.\\n\"");"", ""        return 0;"", ""    }"", ""  // Check validity of program."", ""  if (UCHARAT(this->program) != MAGIC) {"", ""    // RAISE Error, SYM(RegularExpression), SYM(Internal_Error),"", ""    printf("", ""      \""RegularExpression::find(): Compiled regular expression corrupted.\\n\"");"", ""    return 0;"", ""  }"", """", ""    // If there is a \""must appear\"" string, look for it."", ""    if (this->regmust != 0) {"", ""        s = string;"", ""        while ((s = strchr(s, this->regmust[0])) != 0) {"", ""            if (strncmp(s, this->regmust, this->regmlen) == 0)"", ""                break;          // Found it."", ""            s++;"", ""        }"", ""        if (s == 0)             // Not present."", ""            return (0);"", ""  // If there is a \""must appear\"" string, look for it."", ""  if (this->regmust != 0) {"", ""    s = string;"", ""    while ((s = strchr(s, this->regmust[0])) != 0) {"", ""      if (strncmp(s, this->regmust, this->regmlen) == 0)"", ""        break; // Found it."", ""      s++;"", ""    }"", ""    if (s == 0) // Not present."", ""      return (0);"", ""  }"", """", ""    // Mark beginning of line for ^ ."", ""    regbol = string;"", """", ""    // Simplest case:  anchored match need be tried only once."", ""    if (this->reganch)"", ""        return (regtry(string, this->startp, this->endp, this->program) != 0);"", ""  // Mark beginning of line for ^ ."", ""  regbol = string;"", """", ""    // Messy cases:  unanchored match."", ""    s = string;"", ""    if (this->regstart != '\\0')"", ""        // We know what char it must start with."", ""        while ((s = strchr(s, this->regstart)) != 0) {"", ""            if (regtry(s, this->startp, this->endp, this->program))"", ""                return (1);"", ""            s++;"", ""  // Simplest case:  anchored match need be tried only once."", ""  if (this->reganch)"", ""    return (regtry(string, this->startp, this->endp, this->program) != 0);"", """", ""        }"", ""    else"", ""        // We don't -- general case."", ""        do {"", ""            if (regtry(s, this->startp, this->endp, this->program))"", ""                return (1);"", ""        } while (*s++ != '\\0');"", ""  // Messy cases:  unanchored match."", ""  s = string;"", ""  if (this->regstart != '\\0')"", ""    // We know what char it must start with."", ""    while ((s = strchr(s, this->regstart)) != 0) {"", ""      if (regtry(s, this->startp, this->endp, this->program))"", ""        return (1);"", ""      s++;"", ""    }"", ""  else"", ""    // We don't -- general case."", ""    do {"", ""      if (regtry(s, this->startp, this->endp, this->program))"", ""        return (1);"", ""    } while (*s++ != '\\0');"", """", ""    // Failure."", ""    return (0);"", ""  // Failure."", ""  return (0);"", ""}"", """", """", ""/*"", "" - regtry - try match at specific point"", ""   0 failure, 1 success"", "" */"", ""static int regtry (const char* string, const char* *start,"", ""                   const char* *end, const char* prog) {"", ""                   int    i;"", ""                   const char* *sp1;"", ""                   const char* *ep;"", """", ""    reginput = string;"", ""    regstartp = start;"", ""    regendp = end;"", """", ""    sp1 = start;"", ""    ep = end;"", ""    for (i = RegularExpression::NSUBEXP; i > 0; i--) {"", ""        *sp1++ = 0;"", ""        *ep++ = 0;"", ""    }"", ""    if (regmatch(prog + 1)) {"", ""        start[0] = string;"", ""        end[0] = reginput;"", ""        return (1);"", ""    }"", ""    else"", ""        return (0);"", ""static int regtry(const char* string, const char** start, const char** end,"", ""                  const char* prog)"", ""{"", ""  int i;"", ""  const char** sp1;"", ""  const char** ep;"", """", ""  reginput = string;"", ""  regstartp = start;"", ""  regendp = end;"", """", ""  sp1 = start;"", ""  ep = end;"", ""  for (i = RegularExpression::NSUBEXP; i > 0; i--) {"", ""    *sp1++ = 0;"", ""    *ep++ = 0;"", ""  }"", ""  if (regmatch(prog + 1)) {"", ""    start[0] = string;"", ""    end[0] = reginput;"", ""    return (1);"", ""  } else"", ""    return (0);"", ""}"", """", """", ""/*"", "" - regmatch - main matching routine"", "" *""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 0, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 0, 1, 1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 0, 0, -1, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, 0, -1, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, 0, -1, 1, 0, -1, 1, 0, 0, -1, 0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, 0, 0, 0, -1, -1, 1, 1, 1, 0, -1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, 1, 1, 1, 2, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, 1, 1, 0, 0, -1, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, 0, 0, 0]","[[154, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Invalid range in [].\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_new.cpp""], [170, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Unmatched [].\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_new.cpp""], [186, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Internal error.\\n\""); // Never here"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_new.cpp""], [192, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): ?+* follows nothing.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_new.cpp""], [197, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Trailing backslash.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_new.cpp""], [213, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""RegularExpression.cxx"", ""+"", ""printf(\""RegularExpression::compile(): Internal error.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_new.cpp""], [478, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""RegularExpression.cxx"", ""+"", ""printf("", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_98_new.cpp""]]",630,610
"[""#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)"", ""  CONSOLE_SCREEN_BUFFER_INFO hOutInfo;"", ""  HANDLE hOut = kwsysTerminalGetStreamHandle(stream);"", ""  if(GetConsoleScreenBufferInfo(hOut, &hOutInfo))"", ""    {"", ""  if (GetConsoleScreenBufferInfo(hOut, &hOutInfo)) {"", ""    pipeIsConsole = 1;"", ""    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream, color);"", ""    }"", ""  }"", ""#endif"", ""  if(!pipeIsConsole && kwsysTerminalStreamIsVT100(stream,"", ""                                                  default_vt100, default_tty))"", ""    {"", ""  if (!pipeIsConsole &&"", ""      kwsysTerminalStreamIsVT100(stream, default_vt100, default_tty)) {"", ""    pipeIsVT100 = 1;"", ""    kwsysTerminalSetVT100Color(stream, color);"", ""    }"", ""  }"", """", ""  /* Format the text into the stream.  */"", ""  {"", ""  va_list var_args;"", ""  va_start(var_args, format);"", ""  vfprintf(stream, format, var_args);"", ""  va_end(var_args);"", ""    va_list var_args;"", ""    va_start(var_args, format);"", ""    vfprintf(stream, format, var_args);"", ""    va_end(var_args);"", ""  }"", """", ""  /* Restore the normal color state for the stream.  */"", ""/* Restore the normal color state for the stream.  */"", ""#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)"", ""  if(pipeIsConsole)"", ""    {"", ""  if (pipeIsConsole) {"", ""    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream,"", ""                                 kwsysTerminal_Color_Normal);"", ""    }"", ""  }"", ""#endif"", ""  if(pipeIsVT100)"", ""    {"", ""  if (pipeIsVT100) {"", ""    kwsysTerminalSetVT100Color(stream, kwsysTerminal_Color_Normal);"", ""    }"", ""  }"", ""}"", """", ""/*--------------------------------------------------------------------------*/""]","[0, 0, 0, -1, -1, 1, 0, 0, -1, 1, 0, -1, -1, -1, 1, 1, 0, 0, -1, 1, 0, 0, 0, -1, -1, -2, -1, 1, 1, 2, 1, 0, 0, -1, 1, 0, -1, -1, 1, 0, 0, -1, 1, 0, -1, -1, 1, 0, -1, 1, 0, 0, 0]","[[25, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""Terminal.c"", ""-"", ""vfprintf(stream, format, var_args);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_99_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_99_new.cpp""], [29, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""Terminal.c"", ""+"", ""vfprintf(stream, format, var_args);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_99_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_99_new.cpp""]]",68,58
"[""  return 0;"", ""}"", """", ""static int runChild2(kwsysProcess* kp,"", ""              const char* cmd[], int state, int exception, int value,"", ""              int share, int output, int delay, double timeout,"", ""              int poll, int disown, int createNewGroup,"", ""              unsigned int interruptDelay)"", ""static int runChild2(kwsysProcess* kp, const char* cmd[], int state,"", ""                     int exception, int value, int share, int output,"", ""                     int delay, double timeout, int poll, int disown,"", ""                     int createNewGroup, unsigned int interruptDelay)"", ""{"", ""  int result = 0;"", ""  char* data = 0;"", ""  int length = 0;"", ""  double userTimeout = 0;"", ""  double* pUserTimeout = 0;"", ""  kwsysProcess_SetCommand(kp, cmd);"", ""  if(timeout >= 0)"", ""    {"", ""  if (timeout >= 0) {"", ""    kwsysProcess_SetTimeout(kp, timeout);"", ""    }"", ""  if(share)"", ""    {"", ""  }"", ""  if (share) {"", ""    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);"", ""    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);"", ""    }"", ""  if(disown)"", ""    {"", ""  }"", ""  if (disown) {"", ""    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);"", ""    }"", ""  if(createNewGroup)"", ""    {"", ""  }"", ""  if (createNewGroup) {"", ""    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);"", ""    }"", ""  }"", ""  kwsysProcess_Execute(kp);"", """", ""  if(poll)"", ""    {"", ""  if (poll) {"", ""    pUserTimeout = &userTimeout;"", ""    }"", ""  }"", """", ""  if(interruptDelay)"", ""    {"", ""  if (interruptDelay) {"", ""    testProcess_sleep(interruptDelay);"", ""    kwsysProcess_Interrupt(kp);"", ""    }"", ""  }"", """", ""  if(!share && !disown)"", ""    {"", ""  if (!share && !disown) {"", ""    int p;"", ""    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))"", ""      {"", ""      if(output)"", ""        {"", ""        if(poll && p == kwsysProcess_Pipe_Timeout)"", ""          {"", ""    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {"", ""      if (output) {"", ""        if (poll && p == kwsysProcess_Pipe_Timeout) {"", ""          fprintf(stdout, \""WaitForData timeout reached.\\n\"");"", ""          fflush(stdout);"", """", ""          /* Count the number of times we polled without getting data."", ""             If it is excessive then kill the child and fail.  */"", ""          if(++poll >= MAXPOLL)"", ""            {"", ""            fprintf(stdout, \""Poll count reached limit %d.\\n\"","", ""                    MAXPOLL);"", ""          if (++poll >= MAXPOLL) {"", ""            fprintf(stdout, \""Poll count reached limit %d.\\n\"", MAXPOLL);"", ""            kwsysProcess_Kill(kp);"", ""            }"", ""          }"", ""        else"", ""          {"", ""          fwrite(data, 1, (size_t) length, stdout);"", ""        } else {"", ""          fwrite(data, 1, (size_t)length, stdout);"", ""          fflush(stdout);"", ""          }"", ""        }"", ""      if(poll)"", ""        {"", ""      }"", ""      if (poll) {"", ""        /* Delay to avoid busy loop during polling.  */"", ""        testProcess_usleep(100000);"", ""        }"", ""      if(delay)"", ""        {"", ""        /* Purposely sleeping only on Win32 to let pipe fill up.  */"", ""      }"", ""      if (delay) {"", ""/* Purposely sleeping only on Win32 to let pipe fill up.  */"", ""#if defined(_WIN32)"", ""        testProcess_usleep(100000);"", ""#endif"", ""        }"", ""      }"", ""    }"", ""  }"", """", ""  if(disown)"", ""    {"", ""  if (disown) {"", ""    kwsysProcess_Disown(kp);"", ""    }"", ""  else"", ""    {"", ""  } else {"", ""    kwsysProcess_WaitForExit(kp, 0);"", ""    }"", ""  }"", """", ""  switch (kwsysProcess_GetState(kp))"", ""    {"", ""  switch (kwsysProcess_GetState(kp)) {"", ""    case kwsysProcess_State_Starting:"", ""      printf(\""No process has been executed.\\n\""); break;"", ""      printf(\""No process has been executed.\\n\"");"", ""      break;"", ""    case kwsysProcess_State_Executing:"", ""      printf(\""The process is still executing.\\n\""); break;"", ""      printf(\""The process is still executing.\\n\"");"", ""      break;"", ""    case kwsysProcess_State_Expired:"", ""      printf(\""Child was killed when timeout expired.\\n\""); break;"", ""      printf(\""Child was killed when timeout expired.\\n\"");"", ""      break;"", ""    case kwsysProcess_State_Exited:"", ""      printf(\""Child exited with value = %d\\n\"","", ""             kwsysProcess_GetExitValue(kp));"", ""      printf(\""Child exited with value = %d\\n\"", kwsysProcess_GetExitValue(kp));"", ""      result = ((exception != kwsysProcess_GetExitException(kp)) ||"", ""                (value != kwsysProcess_GetExitValue(kp))); break;"", ""                (value != kwsysProcess_GetExitValue(kp)));"", ""      break;"", ""    case kwsysProcess_State_Killed:"", ""      printf(\""Child was killed by parent.\\n\""); break;"", ""      printf(\""Child was killed by parent.\\n\"");"", ""      break;"", ""    case kwsysProcess_State_Exception:"", ""      printf(\""Child terminated abnormally: %s\\n\"","", ""             kwsysProcess_GetExceptionString(kp));"", ""      result = ((exception != kwsysProcess_GetExitException(kp)) ||"", ""                (value != kwsysProcess_GetExitValue(kp))); break;"", ""                (value != kwsysProcess_GetExitValue(kp)));"", ""      break;"", ""    case kwsysProcess_State_Disowned:"", ""      printf(\""Child was disowned.\\n\""); break;"", ""      printf(\""Child was disowned.\\n\"");"", ""      break;"", ""    case kwsysProcess_State_Error:"", ""      printf(\""Error in administrating child process: [%s]\\n\"","", ""             kwsysProcess_GetErrorString(kp)); break;"", ""    };"", ""             kwsysProcess_GetErrorString(kp));"", ""      break;"", ""  };"", """", ""  if(result)"", ""    {"", ""    if(exception != kwsysProcess_GetExitException(kp))"", ""      {"", ""  if (result) {"", ""    if (exception != kwsysProcess_GetExitException(kp)) {"", ""      fprintf(stderr, \""Mismatch in exit exception.  \"""", ""              \""Should have been %d, was %d.\\n\"","", ""                      \""Should have been %d, was %d.\\n\"","", ""              exception, kwsysProcess_GetExitException(kp));"", ""      }"", ""    if(value != kwsysProcess_GetExitValue(kp))"", ""      {"", ""    }"", ""    if (value != kwsysProcess_GetExitValue(kp)) {"", ""      fprintf(stderr, \""Mismatch in exit value.  \"""", ""              \""Should have been %d, was %d.\\n\"","", ""                      \""Should have been %d, was %d.\\n\"","", ""              value, kwsysProcess_GetExitValue(kp));"", ""      }"", ""    }"", ""  }"", """", ""  if(kwsysProcess_GetState(kp) != state)"", ""    {"", ""  if (kwsysProcess_GetState(kp) != state) {"", ""    fprintf(stderr, \""Mismatch in state.  \"""", ""            \""Should have been %d, was %d.\\n\"","", ""                    \""Should have been %d, was %d.\\n\"","", ""            state, kwsysProcess_GetState(kp));"", ""    result = 1;"", ""    }"", ""  }"", """", ""  /* We should have polled more times than there were data if polling"", ""     was enabled.  */"", ""  if(poll && poll < MINPOLL)"", ""    {"", ""    fprintf(stderr, \""Poll count is %d, which is less than %d.\\n\"","", ""            poll, MINPOLL);"", ""  if (poll && poll < MINPOLL) {"", ""    fprintf(stderr, \""Poll count is %d, which is less than %d.\\n\"", poll,"", ""            MINPOLL);"", ""    result = 1;"", ""    }"", ""  }"", """", ""  return result;"", ""}""]","[0, 0, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, 1, 0, -1, -1, -1, 1, 1, 0, 0, -1, -1, -1, 1, 1, 0, -1, -1, -1, 1, 1, 0, -1, 1, 0, 0, -1, -1, 1, 0, -1, 1, 0, -1, -1, 1, 0, 0, -1, 1, 0, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, 1, 1, 1, 0, 0, 0, 0, 0, -1, -1, -2, -1, 1, 2, 0, -1, 0, -1, -1, -1, 1, 1, 0, -1, 0, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, 1, 1, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, -1, 1, 0, -1, -1, -1, 1, 0, -1, 1, 0, -1, -1, 1, 0, -2, 2, 1, 0, -2, 2, 1, 0, -2, 2, 1, 0, -2, -1, 2, 0, -1, 1, 1, 0, -2, 2, 1, 0, 0, 0, 0, -1, 1, 1, 0, -2, 2, 1, 0, 0, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 0, -1, 1, 0, -1, -1, -1, 1, 1, 0, -1, 1, 0, -1, 0, 1, 0, -1, -1, 1, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, -1, -1, -2, -1, 1, 2, 1, 0, -1, 1, 0, 0, 0]","[[81, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""testProcess.c"", ""-"", ""fprintf(stdout, \""Poll count reached limit %d.\\n\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_new.cpp""], [84, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""testProcess.c"", ""+"", ""fprintf(stdout, \""Poll count reached limit %d.\\n\"", MAXPOLL);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_new.cpp""], [133, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""testProcess.c"", ""-"", ""printf(\""No process has been executed.\\n\""); break;"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_new.cpp""], [134, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""testProcess.c"", ""+"", ""printf(\""No process has been executed.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_new.cpp""], [137, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""testProcess.c"", ""-"", ""printf(\""The process is still executing.\\n\""); break;"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_new.cpp""], [138, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""testProcess.c"", ""+"", ""printf(\""The process is still executing.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_new.cpp""], [141, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""testProcess.c"", ""-"", ""printf(\""Child was killed when timeout expired.\\n\""); break;"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_new.cpp""], [142, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""testProcess.c"", ""+"", ""printf(\""Child was killed when timeout expired.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_new.cpp""], [145, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""testProcess.c"", ""-"", ""printf(\""Child exited with value = %d\\n\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_new.cpp""], [147, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""testProcess.c"", ""+"", ""printf(\""Child exited with value = %d\\n\"", kwsysProcess_GetExitValue(kp));"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_new.cpp""], [153, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""testProcess.c"", ""-"", ""printf(\""Child was killed by parent.\\n\""); break;"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_new.cpp""], [154, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""testProcess.c"", ""+"", ""printf(\""Child was killed by parent.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_new.cpp""], [164, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""testProcess.c"", ""-"", ""printf(\""Child was disowned.\\n\""); break;"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_new.cpp""], [165, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""testProcess.c"", ""+"", ""printf(\""Child was disowned.\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_new.cpp""], [213, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""testProcess.c"", ""-"", ""fprintf(stderr, \""Poll count is %d, which is less than %d.\\n\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_new.cpp""], [216, ""773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d"", ""KWSys 2016-11-09 (18c65411)\n\nCode extracted from:\n\n    http://public.kitware.com/KWSys.git\n\nat commit 18c654114de3aa65429542f95308720bc68f9231 (master).\n\nUpstream Shortlog\n-----------------\n\nBrad King (14):\n      37306a1c FStream: Quiet unused argument warning\n      15e90a3c Sort includes to stabilize include order w.r.t. clang-format\n      26509227 Copyright.txt: Add notice of copyright by contributors\n      fc42d3f2 Add temporary script to filter license notices\n      c41c1bc4 Simplify KWSys per-source license notices\n      1d4c0b4a Remove temporary script that filtered license notices\n      a4f5ef79 SystemInformation: Remove stray comment\n      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format\n      89b98af5 Configure clang-format for KWSys source tree\n      547dacad Add a script to run clang-format on the entire source tree\n      aa94be0c CONTRIBUTING: Add a section on coding style\n      6604c4b6 Empty commit at end of history preceding clang-format style transition\n      2b3e2b1c Tell Git to not export 'clang-format' infrastructure\n      18c65411 FStream: Include Configure.hxx before other headers\n\nKitware Robot (1):\n      6c973b46 Revise C++ coding style using clang-format"", ""testProcess.c"", ""+"", ""fprintf(stderr, \""Poll count is %d, which is less than %d.\\n\"", poll,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_100_new.cpp""]]",368,362
"[""    this->SnapshotData.Pop(pos);"", ""  }"", """", ""  return Snapshot(this, prevPos);"", ""}"", """", ""cmState::Snapshot::Snapshot(cmState* state)"", ""  : State(state)"", ""  , Position()"", ""{"", ""}"", """", ""std::vector<cmState::Snapshot> cmState::Snapshot::GetChildren()"", ""{"", ""  return this->Position->BuildSystemDirectory->Children;"", ""}"", """", ""cmState::Snapshot::Snapshot(cmState* state, PositionType position)"", ""  : State(state)"", ""  , Position(position)"", ""{"", ""}"", """", ""cmState::SnapshotType cmState::Snapshot::GetType() const"", ""{"", ""  return this->Position->SnapshotType;"", ""}"", """", ""const char* cmState::Directory::GetCurrentSource() const"", ""{"", ""  return this->DirectoryState->Location.c_str();"", ""}"", """", ""void cmState::Directory::SetCurrentSource(std::string const& dir)"", ""{"", ""  std::string& loc = this->DirectoryState->Location;"", ""  loc = dir;"", ""  cmSystemTools::ConvertToUnixSlashes(loc);"", ""  loc = cmSystemTools::CollapseFullPath(loc);"", """", ""  this->ComputeRelativePathTopSource();"", """", ""  this->Snapshot_.SetDefinition(\""CMAKE_CURRENT_SOURCE_DIR\"", loc);"", ""}"", """", ""const char* cmState::Directory::GetCurrentBinary() const"", ""{"", ""  return this->DirectoryState->OutputLocation.c_str();"", ""}"", """", ""void cmState::Directory::SetCurrentBinary(std::string const& dir)"", ""{"", ""  std::string& loc = this->DirectoryState->OutputLocation;"", ""  loc = dir;"", ""  cmSystemTools::ConvertToUnixSlashes(loc);"", ""  loc = cmSystemTools::CollapseFullPath(loc);"", """", ""  this->ComputeRelativePathTopBinary();"", """", ""  this->Snapshot_.SetDefinition(\""CMAKE_CURRENT_BINARY_DIR\"", loc);"", ""}"", """", ""void cmState::Snapshot::SetListFile(const std::string& listfile)"", ""{"", ""  *this->Position->ExecutionListFile = listfile;"", ""}"", """", ""const char* cmState::Directory::GetRelativePathTopSource() const"", ""{"", ""  return this->DirectoryState->RelativePathTopSource.c_str();"", ""}"", """", ""const char* cmState::Directory::GetRelativePathTopBinary() const"", ""{"", ""  return this->DirectoryState->RelativePathTopBinary.c_str();"", ""}"", """", ""void cmState::Directory::SetRelativePathTopSource(const char* dir)"", ""{"", ""  this->DirectoryState->RelativePathTopSource = dir;"", ""}"", """", ""void cmState::Directory::SetRelativePathTopBinary(const char* dir)"", ""{"", ""  this->DirectoryState->RelativePathTopBinary = dir;"", ""}"", """", ""std::string cmState::Snapshot::GetExecutionListFile() const"", ""{"", ""  return *this->Position->ExecutionListFile;"", ""}"", """", ""bool cmState::Snapshot::IsValid() const"", ""{"", ""  return this->State && this->Position.IsValid()"", ""    ? this->Position != this->State->SnapshotData.Root()"", ""    : false;"", ""}"", """", ""cmState::Snapshot cmState::Snapshot::GetBuildsystemDirectoryParent() const"", ""{"", ""  Snapshot snapshot;"", ""  if (!this->State || this->Position == this->State->SnapshotData.Root()) {"", ""    return snapshot;"", ""  }"", ""  PositionType parentPos = this->Position->DirectoryParent;"", ""  if (parentPos != this->State->SnapshotData.Root()) {"", ""    snapshot ="", ""      Snapshot(this->State, parentPos->BuildSystemDirectory->DirectoryEnd);"", ""  }"", """", ""  return snapshot;"", ""}"", """", ""cmState::Snapshot cmState::Snapshot::GetCallStackParent() const"", ""{"", ""  assert(this->State);"", ""  assert(this->Position != this->State->SnapshotData.Root());"", """", ""  Snapshot snapshot;"", ""  PositionType parentPos = this->Position;"", ""  while (parentPos->SnapshotType == cmState::PolicyScopeType ||"", ""         parentPos->SnapshotType == cmState::VariableScopeType) {"", ""    ++parentPos;"", ""  }"", ""  if (parentPos->SnapshotType == cmState::BuildsystemDirectoryType ||"", ""      parentPos->SnapshotType == cmState::BaseType) {"", ""    return snapshot;"", ""  }"", """", ""  ++parentPos;"", ""  while (parentPos->SnapshotType == cmState::PolicyScopeType ||"", ""         parentPos->SnapshotType == cmState::VariableScopeType) {"", ""    ++parentPos;"", ""  }"", """", ""  if (parentPos == this->State->SnapshotData.Root()) {"", ""    return snapshot;"", ""  }"", """", ""  snapshot = Snapshot(this->State, parentPos);"", ""  return snapshot;"", ""}"", """", ""cmState::Snapshot cmState::Snapshot::GetCallStackBottom() const"", ""{"", ""  assert(this->State);"", ""  assert(this->Position != this->State->SnapshotData.Root());"", """", ""  PositionType pos = this->Position;"", ""  while (pos->SnapshotType != cmState::BaseType &&"", ""         pos->SnapshotType != cmState::BuildsystemDirectoryType &&"", ""         pos != this->State->SnapshotData.Root()) {"", ""    ++pos;"", ""  }"", ""  return Snapshot(this->State, pos);"", ""}"", """", ""void cmState::Snapshot::PushPolicy(cmPolicies::PolicyMap entry, bool weak)"", ""{"", ""  PositionType pos = this->Position;"", ""  pos->Policies = this->State->PolicyStack.Push(pos->Policies,"", ""                                                PolicyStackEntry(entry, weak));"", ""}"", """", ""bool cmState::Snapshot::PopPolicy()"", ""{"", ""  PositionType pos = this->Position;"", ""  if (pos->Policies == pos->PolicyScope) {"", ""    return false;"", ""  }"", ""  pos->Policies = this->State->PolicyStack.Pop(pos->Policies);"", ""  return true;"", ""}"", """", ""bool cmState::Snapshot::CanPopPolicyScope()"", ""{"", ""  return this->Position->Policies == this->Position->PolicyScope;"", ""}"", """", ""void cmState::Snapshot::SetPolicy(cmPolicies::PolicyID id,"", ""                                  cmPolicies::PolicyStatus status)"", ""{"", ""  // Update the policy stack from the top to the top-most strong entry."", ""  bool previous_was_weak = true;"", ""  for (cmLinkedTree<PolicyStackEntry>::iterator psi = this->Position->Policies;"", ""       previous_was_weak && psi != this->Position->PolicyRoot; ++psi) {"", ""    psi->Set(id, status);"", ""    previous_was_weak = psi->Weak;"", ""  }"", ""}"", """", ""cmPolicies::PolicyStatus cmState::Snapshot::GetPolicy("", ""  cmPolicies::PolicyID id) const"", ""{"", ""  cmPolicies::PolicyStatus status = cmPolicies::GetPolicyStatus(id);"", """", ""  if (status == cmPolicies::REQUIRED_ALWAYS ||"", ""      status == cmPolicies::REQUIRED_IF_USED) {"", ""    return status;"", ""  }"", """", ""  cmLinkedTree<BuildsystemDirectoryStateType>::iterator dir ="", ""    this->Position->BuildSystemDirectory;"", """", ""  while (true) {"", ""    assert(dir.IsValid());"", ""    cmLinkedTree<PolicyStackEntry>::iterator leaf ="", ""      dir->DirectoryEnd->Policies;"", ""    cmLinkedTree<PolicyStackEntry>::iterator root ="", ""      dir->DirectoryEnd->PolicyRoot;"", ""    for (; leaf != root; ++leaf) {"", ""      if (leaf->IsDefined(id)) {"", ""        status = leaf->Get(id);"", ""        return status;"", ""      }"", ""    }"", ""    cmState::PositionType e = dir->DirectoryEnd;"", ""    cmState::PositionType p = e->DirectoryParent;"", ""    if (p == this->State->SnapshotData.Root()) {"", ""      break;"", ""    }"", ""    dir = p->BuildSystemDirectory;"", ""  }"", ""  return status;"", ""}"", """", ""bool cmState::Snapshot::HasDefinedPolicyCMP0011()"", ""{"", ""  return !this->Position->Policies->IsEmpty();"", ""}"", """", ""const char* cmState::Snapshot::GetDefinition(std::string const& name) const"", ""{"", ""  assert(this->Position->Vars.IsValid());"", ""  return cmDefinitions::Get(name, this->Position->Vars, this->Position->Root);"", ""}"", """", ""bool cmState::Snapshot::IsInitialized(std::string const& name) const"", ""{"", ""  return cmDefinitions::HasKey(name, this->Position->Vars,"", ""                               this->Position->Root);"", ""}"", """", ""void cmState::Snapshot::SetDefinition(std::string const& name,"", ""                                      std::string const& value)"", ""{"", ""  this->Position->Vars->Set(name, value.c_str());"", ""}"", """", ""void cmState::Snapshot::RemoveDefinition(std::string const& name)"", ""{"", ""  this->Position->Vars->Set(name, CM_NULLPTR);"", ""}"", """", ""std::vector<std::string> cmState::Snapshot::UnusedKeys() const"", ""{"", ""  return this->Position->Vars->UnusedKeys();"", ""}"", """", ""std::vector<std::string> cmState::Snapshot::ClosureKeys() const"", ""{"", ""  return cmDefinitions::ClosureKeys(this->Position->Vars,"", ""                                    this->Position->Root);"", ""}"", """", ""bool cmState::Snapshot::RaiseScope(std::string const& var, const char* varDef)"", ""{"", ""  if (this->Position->ScopeParent == this->Position->DirectoryParent) {"", ""    Snapshot parentDir = this->GetBuildsystemDirectoryParent();"", ""    if (!parentDir.IsValid()) {"", ""      return false;"", ""    }"", ""    // Update the definition in the parent directory top scope.  This"", ""    // directory's scope was initialized by the closure of the parent"", ""    // scope, so we do not need to localize the definition first."", ""    if (varDef) {"", ""      parentDir.SetDefinition(var, varDef);"", ""    } else {"", ""      parentDir.RemoveDefinition(var);"", ""    }"", ""    return true;"", ""  }"", ""  // First localize the definition in the current scope."", ""  cmDefinitions::Raise(var, this->Position->Vars, this->Position->Root);"", """", ""  // Now update the definition in the parent scope."", ""  this->Position->Parent->Set(var, varDef);"", ""  return true;"", ""}"", """", ""static const std::string cmPropertySentinal = std::string();"", """", ""template <typename T, typename U, typename V>"", ""void InitializeContentFromParent(T& parentContent, T& thisContent,"", ""                                 U& parentBacktraces, U& thisBacktraces,"", ""                                 V& contentEndPosition)"", ""{"", ""  std::vector<std::string>::const_iterator parentBegin = parentContent.begin();"", ""  std::vector<std::string>::const_iterator parentEnd = parentContent.end();"", """", ""  std::vector<std::string>::const_reverse_iterator parentRbegin ="", ""    cmMakeReverseIterator(parentEnd);"", ""  std::vector<std::string>::const_reverse_iterator parentRend ="", ""    parentContent.rend();"", ""  parentRbegin = std::find(parentRbegin, parentRend, cmPropertySentinal);"", ""  std::vector<std::string>::const_iterator parentIt = parentRbegin.base();"", """", ""  thisContent = std::vector<std::string>(parentIt, parentEnd);"", """", ""  std::vector<cmListFileBacktrace>::const_iterator btIt ="", ""    parentBacktraces.begin() + std::distance(parentBegin, parentIt);"", ""  std::vector<cmListFileBacktrace>::const_iterator btEnd ="", ""    parentBacktraces.end();"", """", ""  thisBacktraces = std::vector<cmListFileBacktrace>(btIt, btEnd);"", """", ""  contentEndPosition = thisContent.size();"", ""}"", """", ""void cmState::Snapshot::SetDefaultDefinitions()"", ""{"", ""/* Up to CMake 2.4 here only WIN32, UNIX and APPLE were set."", ""  With CMake must separate between target and host platform. In most cases"", ""  the tests for WIN32, UNIX and APPLE will be for the target system, so an"", ""  additional set of variables for the host system is required ->"", ""  CMAKE_HOST_WIN32, CMAKE_HOST_UNIX, CMAKE_HOST_APPLE."", ""  WIN32, UNIX and APPLE are now set in the platform files in"", ""  Modules/Platforms/."", ""  To keep cmake scripts (-P) and custom language and compiler modules"", ""  working, these variables are still also set here in this place, but they"", ""  will be reset in CMakeSystemSpecificInformation.cmake before the platform"", ""  files are executed. */"", ""#if defined(_WIN32)"", ""  this->SetDefinition(\""WIN32\"", \""1\"");"", ""  this->SetDefinition(\""CMAKE_HOST_WIN32\"", \""1\"");"", ""#else"", ""  this->SetDefinition(\""UNIX\"", \""1\"");"", ""  this->SetDefinition(\""CMAKE_HOST_UNIX\"", \""1\"");"", ""#endif"", ""#if defined(__CYGWIN__)"", ""  std::string legacy;"", ""  if (cmSystemTools::GetEnv(\""CMAKE_LEGACY_CYGWIN_WIN32\"", legacy) &&"", ""      cmSystemTools::IsOn(legacy.c_str())) {"", ""    this->SetDefinition(\""WIN32\"", \""1\"");"", ""    this->SetDefinition(\""CMAKE_HOST_WIN32\"", \""1\"");"", ""  }"", ""#endif"", ""#if defined(__APPLE__)"", ""  this->SetDefinition(\""APPLE\"", \""1\"");"", ""  this->SetDefinition(\""CMAKE_HOST_APPLE\"", \""1\"");"", ""#endif"", ""#if defined(__sun__)"", ""  this->SetDefinition(\""CMAKE_HOST_SOLARIS\"", \""1\"");"", ""#endif"", """", ""  char temp[1024];"", ""  sprintf(temp, \""%d\"", cmVersion::GetMinorVersion());"", ""  this->SetDefinition(\""CMAKE_MINOR_VERSION\"", temp);"", ""  sprintf(temp, \""%d\"", cmVersion::GetMajorVersion());"", ""  this->SetDefinition(\""CMAKE_MAJOR_VERSION\"", temp);"", ""  sprintf(temp, \""%d\"", cmVersion::GetPatchVersion());"", ""  this->SetDefinition(\""CMAKE_PATCH_VERSION\"", temp);"", ""  sprintf(temp, \""%d\"", cmVersion::GetTweakVersion());"", ""  this->SetDefinition(\""CMAKE_TWEAK_VERSION\"", temp);"", ""  this->SetDefinition(\""CMAKE_VERSION\"", cmVersion::GetCMakeVersion());"", """", ""  this->SetDefinition(\""CMAKE_FILES_DIRECTORY\"","", ""                      cmake::GetCMakeFilesDirectory());"", """", ""  // Setup the default include file regular expression (match everything)."", ""  this->Position->BuildSystemDirectory->Properties.SetProperty("", ""    \""INCLUDE_REGULAR_EXPRESSION\"", \""^.*$\"");"", ""}"", """", ""void cmState::Snapshot::SetDirectoryDefinitions()"", ""{"", ""  this->SetDefinition(\""CMAKE_SOURCE_DIR\"", this->State->GetSourceDirectory());"", ""  this->SetDefinition(\""CMAKE_CURRENT_SOURCE_DIR\"","", ""                      this->State->GetSourceDirectory());"", ""  this->SetDefinition(\""CMAKE_BINARY_DIR\"", this->State->GetBinaryDirectory());"", ""  this->SetDefinition(\""CMAKE_CURRENT_BINARY_DIR\"","", ""                      this->State->GetBinaryDirectory());"", ""}"", """", ""void cmState::Snapshot::InitializeFromParent()"", ""{"", ""  PositionType parent = this->Position->DirectoryParent;"", ""  assert(this->Position->Vars.IsValid());"", ""  assert(parent->Vars.IsValid());"", """", ""  *this->Position->Vars ="", ""    cmDefinitions::MakeClosure(parent->Vars, parent->Root);"", """", ""  InitializeContentFromParent("", ""    parent->BuildSystemDirectory->IncludeDirectories,"", ""    this->Position->BuildSystemDirectory->IncludeDirectories,"", ""    parent->BuildSystemDirectory->IncludeDirectoryBacktraces,"", ""    this->Position->BuildSystemDirectory->IncludeDirectoryBacktraces,"", ""    this->Position->IncludeDirectoryPosition);"", """", ""  InitializeContentFromParent("", ""    parent->BuildSystemDirectory->CompileDefinitions,"", ""    this->Position->BuildSystemDirectory->CompileDefinitions,"", ""    parent->BuildSystemDirectory->CompileDefinitionsBacktraces,"", ""    this->Position->BuildSystemDirectory->CompileDefinitionsBacktraces,"", ""    this->Position->CompileDefinitionsPosition);"", """", ""  InitializeContentFromParent("", ""    parent->BuildSystemDirectory->CompileOptions,"", ""    this->Position->BuildSystemDirectory->CompileOptions,"", ""    parent->BuildSystemDirectory->CompileOptionsBacktraces,"", ""    this->Position->BuildSystemDirectory->CompileOptionsBacktraces,"", ""    this->Position->CompileOptionsPosition);"", ""}"", """", ""cmState* cmState::Snapshot::GetState() const"", ""{"", ""  return this->State;"", ""}"", """", ""cmState::Directory cmState::Snapshot::GetDirectory() const"", ""{"", ""  return Directory(this->Position->BuildSystemDirectory, *this);"", ""}"", """", ""void cmState::Snapshot::SetProjectName(const std::string& name)"", ""{"", ""  this->Position->BuildSystemDirectory->ProjectName = name;"", ""}"", """", ""std::string cmState::Snapshot::GetProjectName() const"", ""{"", ""  return this->Position->BuildSystemDirectory->ProjectName;"", ""}"", """", ""void cmState::Snapshot::InitializeFromParent_ForSubdirsCommand()"", ""{"", ""  std::string currentSrcDir = this->GetDefinition(\""CMAKE_CURRENT_SOURCE_DIR\"");"", ""  std::string currentBinDir = this->GetDefinition(\""CMAKE_CURRENT_BINARY_DIR\"");"", ""  this->InitializeFromParent();"", ""  this->SetDefinition(\""CMAKE_SOURCE_DIR\"", this->State->GetSourceDirectory());"", ""  this->SetDefinition(\""CMAKE_BINARY_DIR\"", this->State->GetBinaryDirectory());"", """", ""  this->SetDefinition(\""CMAKE_CURRENT_SOURCE_DIR\"", currentSrcDir);"", ""  this->SetDefinition(\""CMAKE_CURRENT_BINARY_DIR\"", currentBinDir);"", ""}"", """", ""cmState::Directory::Directory("", ""  cmLinkedTree<BuildsystemDirectoryStateType>::iterator iter,"", ""  const cmState::Snapshot& snapshot)"", ""  : DirectoryState(iter)"", ""  , Snapshot_(snapshot)"", ""{"", ""}"", """", ""template <typename T, typename U>"", ""cmStringRange GetPropertyContent(T const& content, U contentEndPosition)"", ""{"", ""  std::vector<std::string>::const_iterator end ="", ""    content.begin() + contentEndPosition;"", """", ""  std::vector<std::string>::const_reverse_iterator rbegin ="", ""    cmMakeReverseIterator(end);"", ""  rbegin = std::find(rbegin, content.rend(), cmPropertySentinal);"", """", ""  return cmMakeRange(rbegin.base(), end);"", ""}"", """", ""template <typename T, typename U, typename V>"", ""cmBacktraceRange GetPropertyBacktraces(T const& content, U const& backtraces,"", ""                                       V contentEndPosition)"", ""{"", ""  std::vector<std::string>::const_iterator entryEnd ="", ""    content.begin() + contentEndPosition;"", """", ""  std::vector<std::string>::const_reverse_iterator rbegin ="", ""    cmMakeReverseIterator(entryEnd);"", ""  rbegin = std::find(rbegin, content.rend(), cmPropertySentinal);"", """", ""  std::vector<cmListFileBacktrace>::const_iterator it ="", ""    backtraces.begin() + std::distance(content.begin(), rbegin.base());"", """", ""  std::vector<cmListFileBacktrace>::const_iterator end = backtraces.end();"", ""  return cmMakeRange(it, end);"", ""}"", """", ""template <typename T, typename U, typename V>"", ""void AppendEntry(T& content, U& backtraces, V& endContentPosition,"", ""                 const std::string& value, const cmListFileBacktrace& lfbt)"", ""{"", ""  if (value.empty()) {"", ""    return;"", ""  }"", """", ""  assert(endContentPosition == content.size());"", """", ""  content.push_back(value);"", ""  backtraces.push_back(lfbt);"", """", ""  endContentPosition = content.size();"", ""}"", """", ""template <typename T, typename U, typename V>"", ""void SetContent(T& content, U& backtraces, V& endContentPosition,"", ""                const std::string& vec, const cmListFileBacktrace& lfbt)"", ""{"", ""  assert(endContentPosition == content.size());"", """", ""  content.resize(content.size() + 2);"", ""  backtraces.resize(backtraces.size() + 2);"", """", ""  content.back() = vec;"", ""  backtraces.back() = lfbt;"", """", ""  endContentPosition = content.size();"", ""}"", """", ""template <typename T, typename U, typename V>"", ""void ClearContent(T& content, U& backtraces, V& endContentPosition)"", ""{"", ""  assert(endContentPosition == content.size());"", """", ""  content.resize(content.size() + 1);"", ""  backtraces.resize(backtraces.size() + 1);"", """", ""  endContentPosition = content.size();"", ""}"", """", ""cmStringRange cmState::Directory::GetIncludeDirectoriesEntries() const"", ""{"", ""  return GetPropertyContent("", ""    this->DirectoryState->IncludeDirectories,"", ""    this->Snapshot_.Position->IncludeDirectoryPosition);"", ""}"", """", ""cmBacktraceRange cmState::Directory::GetIncludeDirectoriesEntryBacktraces()"", ""  const"", ""{"", ""  return GetPropertyBacktraces("", ""    this->DirectoryState->IncludeDirectories,"", ""    this->DirectoryState->IncludeDirectoryBacktraces,"", ""    this->Snapshot_.Position->IncludeDirectoryPosition);"", ""}"", """", ""void cmState::Directory::AppendIncludeDirectoriesEntry("", ""  const std::string& vec, const cmListFileBacktrace& lfbt)"", ""{"", ""  AppendEntry(this->DirectoryState->IncludeDirectories,"", ""              this->DirectoryState->IncludeDirectoryBacktraces,"", ""              this->Snapshot_.Position->IncludeDirectoryPosition, vec, lfbt);"", ""}"", """", ""void cmState::Directory::PrependIncludeDirectoriesEntry("", ""  const std::string& vec, const cmListFileBacktrace& lfbt)"", ""{"", ""  std::vector<std::string>::iterator entryEnd ="", ""    this->DirectoryState->IncludeDirectories.begin() +"", ""    this->Snapshot_.Position->IncludeDirectoryPosition;"", """", ""  std::vector<std::string>::reverse_iterator rend ="", ""    this->DirectoryState->IncludeDirectories.rend();"", ""  std::vector<std::string>::reverse_iterator rbegin ="", ""    cmMakeReverseIterator(entryEnd);"", ""  rbegin = std::find(rbegin, rend, cmPropertySentinal);"", """", ""  std::vector<std::string>::iterator entryIt = rbegin.base();"", ""  std::vector<std::string>::iterator entryBegin ="", ""    this->DirectoryState->IncludeDirectories.begin();"", """", ""  std::vector<cmListFileBacktrace>::iterator btIt ="", ""    this->DirectoryState->IncludeDirectoryBacktraces.begin() +"", ""    std::distance(entryBegin, entryIt);"", """", ""  this->DirectoryState->IncludeDirectories.insert(entryIt, vec);"", ""  this->DirectoryState->IncludeDirectoryBacktraces.insert(btIt, lfbt);"", """", ""  this->Snapshot_.Position->IncludeDirectoryPosition ="", ""    this->DirectoryState->IncludeDirectories.size();"", ""}"", """", ""void cmState::Directory::SetIncludeDirectories(const std::string& vec,"", ""                                               const cmListFileBacktrace& lfbt)"", ""{"", ""  SetContent(this->DirectoryState->IncludeDirectories,"", ""             this->DirectoryState->IncludeDirectoryBacktraces,"", ""             this->Snapshot_.Position->IncludeDirectoryPosition, vec, lfbt);"", ""}"", """", ""void cmState::Directory::ClearIncludeDirectories()"", ""{"", ""  ClearContent(this->DirectoryState->IncludeDirectories,"", ""               this->DirectoryState->IncludeDirectoryBacktraces,"", ""               this->Snapshot_.Position->IncludeDirectoryPosition);"", ""}"", """", ""cmStringRange cmState::Directory::GetCompileDefinitionsEntries() const"", ""{"", ""  return GetPropertyContent("", ""    this->DirectoryState->CompileDefinitions,"", ""    this->Snapshot_.Position->CompileDefinitionsPosition);"", ""}"", """", ""cmBacktraceRange cmState::Directory::GetCompileDefinitionsEntryBacktraces()"", ""  const"", ""{"", ""  return GetPropertyBacktraces("", ""    this->DirectoryState->CompileDefinitions,"", ""    this->DirectoryState->CompileDefinitionsBacktraces,"", ""    this->Snapshot_.Position->CompileDefinitionsPosition);"", ""}"", """", ""void cmState::Directory::AppendCompileDefinitionsEntry("", ""  const std::string& vec, const cmListFileBacktrace& lfbt)"", ""{"", ""  AppendEntry(this->DirectoryState->CompileDefinitions,"", ""              this->DirectoryState->CompileDefinitionsBacktraces,"", ""              this->Snapshot_.Position->CompileDefinitionsPosition, vec, lfbt);"", ""}"", """", ""void cmState::Directory::SetCompileDefinitions(const std::string& vec,"", ""                                               const cmListFileBacktrace& lfbt)"", ""{"", ""  SetContent(this->DirectoryState->CompileDefinitions,"", ""             this->DirectoryState->CompileDefinitionsBacktraces,"", ""             this->Snapshot_.Position->CompileDefinitionsPosition, vec, lfbt);"", ""}"", """", ""void cmState::Directory::ClearCompileDefinitions()"", ""{"", ""  ClearContent(this->DirectoryState->CompileDefinitions,"", ""               this->DirectoryState->CompileDefinitionsBacktraces,"", ""               this->Snapshot_.Position->CompileDefinitionsPosition);"", ""}"", """", ""cmStringRange cmState::Directory::GetCompileOptionsEntries() const"", ""{"", ""  return GetPropertyContent(this->DirectoryState->CompileOptions,"", ""                            this->Snapshot_.Position->CompileOptionsPosition);"", ""}"", """", ""cmBacktraceRange cmState::Directory::GetCompileOptionsEntryBacktraces() const"", ""{"", ""  return GetPropertyBacktraces("", ""    this->DirectoryState->CompileOptions,"", ""    this->DirectoryState->CompileOptionsBacktraces,"", ""    this->Snapshot_.Position->CompileOptionsPosition);"", ""}"", """", ""void cmState::Directory::AppendCompileOptionsEntry("", ""  const std::string& vec, const cmListFileBacktrace& lfbt)"", ""{"", ""  AppendEntry(this->DirectoryState->CompileOptions,"", ""              this->DirectoryState->CompileOptionsBacktraces,"", ""              this->Snapshot_.Position->CompileOptionsPosition, vec, lfbt);"", ""}"", """", ""void cmState::Directory::SetCompileOptions(const std::string& vec,"", ""                                           const cmListFileBacktrace& lfbt)"", ""{"", ""  SetContent(this->DirectoryState->CompileOptions,"", ""             this->DirectoryState->CompileOptionsBacktraces,"", ""             this->Snapshot_.Position->CompileOptionsPosition, vec, lfbt);"", ""}"", """", ""void cmState::Directory::ClearCompileOptions()"", ""{"", ""  ClearContent(this->DirectoryState->CompileOptions,"", ""               this->DirectoryState->CompileOptionsBacktraces,"", ""               this->Snapshot_.Position->CompileOptionsPosition);"", ""}"", """", ""bool cmState::Snapshot::StrictWeakOrder::operator()("", ""  const cmState::Snapshot& lhs, const cmState::Snapshot& rhs) const"", ""{"", ""  return lhs.Position.StrictWeakOrdered(rhs.Position);"", ""}"", """", ""void cmState::Directory::SetProperty(const std::string& prop,"", ""                                     const char* value,"", ""                                     cmListFileBacktrace const& lfbt)"", ""{"", ""  if (prop == \""INCLUDE_DIRECTORIES\"") {"", ""    if (!value) {"", ""      this->ClearIncludeDirectories();"", ""      return;"", ""    }"", ""    this->SetIncludeDirectories(value, lfbt);"", ""    return;"", ""  }"", ""  if (prop == \""COMPILE_OPTIONS\"") {"", ""    if (!value) {"", ""      this->ClearCompileOptions();"", ""      return;"", ""    }"", ""    this->SetCompileOptions(value, lfbt);"", ""    return;"", ""  }"", ""  if (prop == \""COMPILE_DEFINITIONS\"") {"", ""    if (!value) {"", ""      this->ClearCompileDefinitions();"", ""      return;"", ""    }"", ""    this->SetCompileDefinitions(value, lfbt);"", ""    return;"", ""  }"", """", ""  this->DirectoryState->Properties.SetProperty(prop, value);"", ""}"", """", ""void cmState::Directory::AppendProperty(const std::string& prop,"", ""                                        const char* value, bool asString,"", ""                                        cmListFileBacktrace const& lfbt)"", ""{"", ""  if (prop == \""INCLUDE_DIRECTORIES\"") {"", ""    this->AppendIncludeDirectoriesEntry(value, lfbt);"", ""    return;"", ""  }"", ""  if (prop == \""COMPILE_OPTIONS\"") {"", ""    this->AppendCompileOptionsEntry(value, lfbt);"", ""    return;"", ""  }"", ""  if (prop == \""COMPILE_DEFINITIONS\"") {"", ""    this->AppendCompileDefinitionsEntry(value, lfbt);"", ""    return;"", ""  }"", """", ""  this->DirectoryState->Properties.AppendProperty(prop, value, asString);"", ""}"", """", ""const char* cmState::Directory::GetProperty(const std::string& prop) const"", ""{"", ""  const bool chain ="", ""    this->Snapshot_.State->IsPropertyChained(prop, cmProperty::DIRECTORY);"", ""  return this->GetProperty(prop, chain);"", ""}"", """", ""const char* cmState::Directory::GetProperty(const std::string& prop,"", ""                                            bool chain) const"", ""{"", ""  static std::string output;"", ""  output = \""\"";"", ""  if (prop == \""PARENT_DIRECTORY\"") {"", ""    cmState::Snapshot parent = this->Snapshot_.GetBuildsystemDirectoryParent();"", ""    if (parent.IsValid()) {"", ""      return parent.GetDirectory().GetCurrentSource();"", ""    }"", ""    return \""\"";"", ""  }"", ""  if (prop == kBINARY_DIR) {"", ""    output = this->GetCurrentBinary();"", ""    return output.c_str();"", ""  }"", ""  if (prop == kSOURCE_DIR) {"", ""    output = this->GetCurrentSource();"", ""    return output.c_str();"", ""  }"", ""  if (prop == kSUBDIRECTORIES) {"", ""    std::vector<std::string> child_dirs;"", ""    std::vector<cmState::Snapshot> const& children ="", ""      this->DirectoryState->Children;"", ""    for (std::vector<cmState::Snapshot>::const_iterator ci = children.begin();"", ""         ci != children.end(); ++ci) {"", ""      child_dirs.push_back(ci->GetDirectory().GetCurrentSource());"", ""    }"", ""    output = cmJoin(child_dirs, \"";\"");"", ""    return output.c_str();"", ""  }"", ""  if (prop == kBUILDSYSTEM_TARGETS) {"", ""    output = cmJoin(this->DirectoryState->NormalTargetNames, \"";\"");"", ""    return output.c_str();"", ""  }"", """", ""  if (prop == \""LISTFILE_STACK\"") {"", ""    std::vector<std::string> listFiles;"", ""    cmState::Snapshot snp = this->Snapshot_;"", ""    while (snp.IsValid()) {"", ""      listFiles.push_back(snp.GetExecutionListFile());"", ""      snp = snp.GetCallStackParent();"", ""    }"", ""    std::reverse(listFiles.begin(), listFiles.end());"", ""    output = cmJoin(listFiles, \"";\"");"", ""    return output.c_str();"", ""  }"", ""  if (prop == \""CACHE_VARIABLES\"") {"", ""    output = cmJoin(this->Snapshot_.State->GetCacheEntryKeys(), \"";\"");"", ""    return output.c_str();"", ""  }"", ""  if (prop == \""VARIABLES\"") {"", ""    std::vector<std::string> res = this->Snapshot_.ClosureKeys();"", ""    std::vector<std::string> cacheKeys ="", ""      this->Snapshot_.State->GetCacheEntryKeys();"", ""    res.insert(res.end(), cacheKeys.begin(), cacheKeys.end());"", ""    std::sort(res.begin(), res.end());"", ""    output = cmJoin(res, \"";\"");"", ""    return output.c_str();"", ""  }"", ""  if (prop == \""INCLUDE_DIRECTORIES\"") {"", ""    output = cmJoin(this->GetIncludeDirectoriesEntries(), \"";\"");"", ""    return output.c_str();"", ""  }"", ""  if (prop == \""COMPILE_OPTIONS\"") {"", ""    output = cmJoin(this->GetCompileOptionsEntries(), \"";\"");"", ""    return output.c_str();"", ""  }"", ""  if (prop == \""COMPILE_DEFINITIONS\"") {"", ""    output = cmJoin(this->GetCompileDefinitionsEntries(), \"";\"");"", ""    return output.c_str();"", ""  }"", """", ""  const char* retVal = this->DirectoryState->Properties.GetPropertyValue(prop);"", ""  if (!retVal && chain) {"", ""    Snapshot parentSnapshot = this->Snapshot_.GetBuildsystemDirectoryParent();"", ""    if (parentSnapshot.IsValid()) {"", ""      return parentSnapshot.GetDirectory().GetProperty(prop, chain);"", ""    }"", ""    return this->Snapshot_.State->GetGlobalProperty(prop);"", ""  }"", """", ""  return retVal;"", ""}"", """", ""bool cmState::Directory::GetPropertyAsBool(const std::string& prop) const"", ""{"", ""  return cmSystemTools::IsOn(this->GetProperty(prop));"", ""}"", """", ""std::vector<std::string> cmState::Directory::GetPropertyKeys() const"", ""{"", ""  std::vector<std::string> keys;"", ""  keys.reserve(this->DirectoryState->Properties.size());"", ""  for (cmPropertyMap::const_iterator it ="", ""         this->DirectoryState->Properties.begin();"", ""       it != this->DirectoryState->Properties.end(); ++it) {"", ""    keys.push_back(it->first);"", ""  }"", ""  return keys;"", ""}"", """", ""void cmState::Directory::AddNormalTargetName(std::string const& name)"", ""{"", ""  this->DirectoryState->NormalTargetNames.push_back(name);"", ""}"", """", ""bool operator==(const cmState::Snapshot& lhs, const cmState::Snapshot& rhs)"", ""{"", ""  return lhs.Position == rhs.Position;"", ""}"", """", ""bool operator!=(const cmState::Snapshot& lhs, const cmState::Snapshot& rhs)"", ""{"", ""  return lhs.Position != rhs.Position;"", ""  return cmStateSnapshot(this, prevPos);"", ""}"", """", ""static bool ParseEntryWithoutType(const std::string& entry, std::string& var,""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -2, -1, -2, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, 0, 0]","[[357, ""92c3cab223845ca83533bba7b6d73f6180223935"", ""Merge topic 'split-cmState'\n\ne6eecec7 cmListFileCache: Remove cmState header include\ne3587ee0 cmTargetPropertyComputer: Add missing include\ne0a84904 cmState: Split auxiliary classes into separate files\na91eaf38 cmState: Port dependents to new cmStateTypes header\n27be1d81 cmState: Move extracted declarations to a separate file\n34433c88 cmState: Remove compatibility typedefs\ncde6eb62 cmState: Port dependent code to new cmStateSnapshot name\na9bf981a cmState: Move Snapshot type to separate namespace\n17d27893 cmState: Port dependent code to new cmStateDirectory name\n34bcec39 cmState: Move Directory class to separate namespace\n2fe3e55d cmState: Move CacheEntryType enum to separate namespace\na49751fb cmState: Move TargetType enum to separate namespace\n0060391d cmState: Move SnapshotType enum to separate namespace\n5bc964ed cmState: Move PositionType to separate namespace\n2dc40996 cmState: Move PolicyStackEntry to separate namespace\ncb40af5d cmState: Move SnapshotDataType to separate namespace\n..."", ""Source/cmState.cxx"", ""-"", ""sprintf(temp, \""%d\"", cmVersion::GetMinorVersion());"", 0, ""/data/download/CMake/CMake/Kitware_CMake_101_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_101_new.cpp""], [359, ""92c3cab223845ca83533bba7b6d73f6180223935"", ""Merge topic 'split-cmState'\n\ne6eecec7 cmListFileCache: Remove cmState header include\ne3587ee0 cmTargetPropertyComputer: Add missing include\ne0a84904 cmState: Split auxiliary classes into separate files\na91eaf38 cmState: Port dependents to new cmStateTypes header\n27be1d81 cmState: Move extracted declarations to a separate file\n34433c88 cmState: Remove compatibility typedefs\ncde6eb62 cmState: Port dependent code to new cmStateSnapshot name\na9bf981a cmState: Move Snapshot type to separate namespace\n17d27893 cmState: Port dependent code to new cmStateDirectory name\n34bcec39 cmState: Move Directory class to separate namespace\n2fe3e55d cmState: Move CacheEntryType enum to separate namespace\na49751fb cmState: Move TargetType enum to separate namespace\n0060391d cmState: Move SnapshotType enum to separate namespace\n5bc964ed cmState: Move PositionType to separate namespace\n2dc40996 cmState: Move PolicyStackEntry to separate namespace\ncb40af5d cmState: Move SnapshotDataType to separate namespace\n..."", ""Source/cmState.cxx"", ""-"", ""sprintf(temp, \""%d\"", cmVersion::GetMajorVersion());"", 0, ""/data/download/CMake/CMake/Kitware_CMake_101_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_101_new.cpp""], [361, ""92c3cab223845ca83533bba7b6d73f6180223935"", ""Merge topic 'split-cmState'\n\ne6eecec7 cmListFileCache: Remove cmState header include\ne3587ee0 cmTargetPropertyComputer: Add missing include\ne0a84904 cmState: Split auxiliary classes into separate files\na91eaf38 cmState: Port dependents to new cmStateTypes header\n27be1d81 cmState: Move extracted declarations to a separate file\n34433c88 cmState: Remove compatibility typedefs\ncde6eb62 cmState: Port dependent code to new cmStateSnapshot name\na9bf981a cmState: Move Snapshot type to separate namespace\n17d27893 cmState: Port dependent code to new cmStateDirectory name\n34bcec39 cmState: Move Directory class to separate namespace\n2fe3e55d cmState: Move CacheEntryType enum to separate namespace\na49751fb cmState: Move TargetType enum to separate namespace\n0060391d cmState: Move SnapshotType enum to separate namespace\n5bc964ed cmState: Move PositionType to separate namespace\n2dc40996 cmState: Move PolicyStackEntry to separate namespace\ncb40af5d cmState: Move SnapshotDataType to separate namespace\n..."", ""Source/cmState.cxx"", ""-"", ""sprintf(temp, \""%d\"", cmVersion::GetPatchVersion());"", 0, ""/data/download/CMake/CMake/Kitware_CMake_101_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_101_new.cpp""], [363, ""92c3cab223845ca83533bba7b6d73f6180223935"", ""Merge topic 'split-cmState'\n\ne6eecec7 cmListFileCache: Remove cmState header include\ne3587ee0 cmTargetPropertyComputer: Add missing include\ne0a84904 cmState: Split auxiliary classes into separate files\na91eaf38 cmState: Port dependents to new cmStateTypes header\n27be1d81 cmState: Move extracted declarations to a separate file\n34433c88 cmState: Remove compatibility typedefs\ncde6eb62 cmState: Port dependent code to new cmStateSnapshot name\na9bf981a cmState: Move Snapshot type to separate namespace\n17d27893 cmState: Port dependent code to new cmStateDirectory name\n34bcec39 cmState: Move Directory class to separate namespace\n2fe3e55d cmState: Move CacheEntryType enum to separate namespace\na49751fb cmState: Move TargetType enum to separate namespace\n0060391d cmState: Move SnapshotType enum to separate namespace\n5bc964ed cmState: Move PositionType to separate namespace\n2dc40996 cmState: Move PolicyStackEntry to separate namespace\ncb40af5d cmState: Move SnapshotDataType to separate namespace\n..."", ""Source/cmState.cxx"", ""-"", ""sprintf(temp, \""%d\"", cmVersion::GetTweakVersion());"", 0, ""/data/download/CMake/CMake/Kitware_CMake_101_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_101_new.cpp""]]",920,778
"[""#  define YYFPRINTF fprintf"", ""# endif"", """", ""# define YYDPRINTF(Args)      \\"", ""do {            \\"", ""  if (yydebug)          \\"", ""    YYFPRINTF Args;        \\"", ""# define YYDPRINTF(Args)                        \\"", ""do {                                            \\"", ""  if (yydebug)                                  \\"", ""    YYFPRINTF Args;                             \\"", ""} while (0)"", """", ""# define YYDSYMPRINT(Args)      \\"", ""do {            \\"", ""  if (yydebug)          \\"", ""    yysymprint Args;        \\"", ""} while (0)"", ""/* This macro is provided for backward compatibility. */"", ""#ifndef YY_LOCATION_PRINT"", ""# define YY_LOCATION_PRINT(File, Loc) ((void) 0)"", ""#endif"", """", ""# define YYDSYMPRINTF(Title, Token, Value, Location)    \\"", ""do {                \\"", ""  if (yydebug)              \\"", ""    {                \\"", ""      YYFPRINTF (stderr, \""%s \"", Title);        \\"", ""      yysymprint (stderr,           \\"", ""                  Token, Value);  \\"", ""      YYFPRINTF (stderr, \""\\n\"");          \\"", ""    }                \\"", """", ""# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \\"", ""do {                                                                      \\"", ""  if (yydebug)                                                            \\"", ""    {                                                                     \\"", ""      YYFPRINTF (stderr, \""%s \"", Title);                                   \\"", ""      yy_symbol_print (stderr,                                            \\"", ""                  Type, Value, yyscanner); \\"", ""      YYFPRINTF (stderr, \""\\n\"");                                           \\"", ""    }                                                                     \\"", ""} while (0)"", """", """", ""/*----------------------------------------."", ""| Print this symbol's value on YYOUTPUT.  |"", ""`----------------------------------------*/"", """", ""static void"", ""yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, yyscan_t yyscanner)"", ""{"", ""  FILE *yyo = yyoutput;"", ""  YYUSE (yyo);"", ""  YYUSE (yyscanner);"", ""  if (!yyvaluep)"", ""    return;"", ""# ifdef YYPRINT"", ""  if (yytype < YYNTOKENS)"", ""    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);"", ""# endif"", ""  YYUSE (yytype);"", ""}"", """", """", ""/*--------------------------------."", ""| Print this symbol on YYOUTPUT.  |"", ""`--------------------------------*/"", """", ""static void"", ""yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, yyscan_t yyscanner)"", ""{"", ""  YYFPRINTF (yyoutput, \""%s %s (\"","", ""             yytype < YYNTOKENS ? \""token\"" : \""nterm\"", yytname[yytype]);"", """", ""  yy_symbol_value_print (yyoutput, yytype, yyvaluep, yyscanner);"", ""  YYFPRINTF (yyoutput, \"")\"");"", ""}"", """", ""/*------------------------------------------------------------------."", ""| yy_stack_print -- Print the state stack from its BOTTOM up to its |"", ""| TOP (included).                                                   |"", ""`------------------------------------------------------------------*/"", """", ""#if defined (__STDC__) || defined (__cplusplus)"", ""static void"", ""yy_stack_print (short int *bottom, short int *top)"", ""#else"", ""static void"", ""yy_stack_print (bottom, top)"", ""    short int *bottom;"", ""    short int *top;"", ""#endif"", ""yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)"", ""{"", ""  YYFPRINTF (stderr, \""Stack now\"");"", ""  for (/* Nothing. */; bottom <= top; ++bottom)"", ""    YYFPRINTF (stderr, \"" %d\"", *bottom);"", ""  for (; yybottom <= yytop; yybottom++)"", ""    {"", ""      int yybot = *yybottom;"", ""      YYFPRINTF (stderr, \"" %d\"", yybot);"", ""    }"", ""  YYFPRINTF (stderr, \""\\n\"");"", ""}"", """", ""# define YY_STACK_PRINT(Bottom, Top)        \\"", ""do {                \\"", ""  if (yydebug)              \\"", ""    yy_stack_print ((Bottom), (Top));        \\"", ""# define YY_STACK_PRINT(Bottom, Top)                            \\"", ""do {                                                            \\"", ""  if (yydebug)                                                  \\"", ""    yy_stack_print ((Bottom), (Top));                           \\"", ""} while (0)"", """", """", ""/*------------------------------------------------."", ""| Report that the YYRULE is going to be reduced.  |"", ""`------------------------------------------------*/"", """", ""#if defined (__STDC__) || defined (__cplusplus)"", ""static void"", ""yy_reduce_print (int yyrule)"", ""#else"", ""static void"", ""yy_reduce_print (yyrule)"", ""    int yyrule;"", ""#endif"", ""yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule, yyscan_t yyscanner)"", ""{"", ""  unsigned long int yylno = yyrline[yyrule];"", ""  int yynrhs = yyr2[yyrule];"", ""  int yyi;"", ""  unsigned int yylno = yyrline[yyrule];"", ""  YYFPRINTF (stderr, \""Reducing stack by rule %d (line %u), \"","", ""  YYFPRINTF (stderr, \""Reducing stack by rule %d (line %lu):\\n\"","", ""             yyrule - 1, yylno);"", ""  /* Print the symbols being reduced, and their result.  */"", ""  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)"", ""    YYFPRINTF (stderr, \""%s \"", yytname [yyrhs[yyi]]);"", ""  YYFPRINTF (stderr, \""-> %s\\n\"", yytname [yyr1[yyrule]]);"", ""  /* The symbols being reduced.  */"", ""  for (yyi = 0; yyi < yynrhs; yyi++)"", ""    {"", ""      YYFPRINTF (stderr, \""   $%d = \"", yyi + 1);"", ""      yy_symbol_print (stderr,"", ""                       yystos[yyssp[yyi + 1 - yynrhs]],"", ""                       &(yyvsp[(yyi + 1) - (yynrhs)])"", ""                                              , yyscanner);"", ""      YYFPRINTF (stderr, \""\\n\"");"", ""    }"", ""}"", """", ""# define YY_REDUCE_PRINT(Rule)    \\"", ""do {          \\"", ""  if (yydebug)        \\"", ""    yy_reduce_print (Rule);    \\"", ""# define YY_REDUCE_PRINT(Rule)          \\"", ""do {                                    \\"", ""  if (yydebug)                          \\"", ""    yy_reduce_print (yyssp, yyvsp, Rule, yyscanner); \\"", ""} while (0)"", """", ""/* Nonzero means print parse trace.  It is left uninitialized so that"", ""   multiple parsers can coexist.  */"", ""int yydebug;"", ""#else /* !YYDEBUG */"", ""# define YYDPRINTF(Args)"", ""# define YYDSYMPRINT(Args)"", ""# define YYDSYMPRINTF(Title, Token, Value, Location)"", ""# define YY_SYMBOL_PRINT(Title, Type, Value, Location)"", ""# define YY_STACK_PRINT(Bottom, Top)"", ""# define YY_REDUCE_PRINT(Rule)"", ""#endif /* !YYDEBUG */"", """", """", ""/* YYINITDEPTH -- initial size of the parser's stacks.  */"", ""#ifndef  YYINITDEPTH"", ""#ifndef YYINITDEPTH"", ""# define YYINITDEPTH 200"", ""#endif"", """", ""/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only"", ""   if the built-in stack extension method is used)."", """", ""   Do not make this value too large; the results are undefined if"", ""   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)"", ""   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)"", ""   evaluated with infinite-precision integer arithmetic.  */"", """", ""#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0"", ""# undef YYMAXDEPTH"", ""#endif"", """", ""#ifndef YYMAXDEPTH"", ""# define YYMAXDEPTH 10000"", ""#endif"", """", ""\f"", """", ""#if YYERROR_VERBOSE"", """", ""# ifndef yystrlen"", ""#  if defined (__GLIBC__) && defined (_STRING_H)"", ""#  if defined __GLIBC__ && defined _STRING_H"", ""#   define yystrlen strlen"", ""#  else"", ""/* Return the length of YYSTR.  */"", ""static YYSIZE_T"", ""#   if defined (__STDC__) || defined (__cplusplus)"", ""yystrlen (const char *yystr)"", ""#   else"", ""yystrlen (yystr)"", ""     const char *yystr;"", ""#   endif"", ""{"", ""  const char *yys = yystr;"", """", ""  while (*yys++ != '\\0')"", ""  YYSIZE_T yylen;"", ""  for (yylen = 0; yystr[yylen]; yylen++)"", ""    continue;"", """", ""  return yys - yystr - 1;"", ""  return yylen;"", ""}"", ""#  endif"", ""# endif"", """", ""# ifndef yystpcpy"", ""#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)"", ""#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE"", ""#   define yystpcpy stpcpy"", ""#  else"", ""/* Copy YYSRC to YYDEST, returning the address of the terminating '\\0' in"", ""   YYDEST.  */"", ""static char *"", ""#   if defined (__STDC__) || defined (__cplusplus)"", ""yystpcpy (char *yydest, const char *yysrc)"", ""#   else"", ""yystpcpy (yydest, yysrc)"", ""     char *yydest;"", ""     const char *yysrc;"", ""#   endif"", ""{"", ""  char *yyd = yydest;"", ""  const char *yys = yysrc;""]","[0, 0, 0, -2, -1, -1, -1, 2, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 0, -2, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, -1, -1, -1, 0, -1, -1, -1, -1, 1, 0, 0, -1, -1, 1, 1, 1, 1, 1, 0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0, -1, -1, -1, -1, -1, -1, 1, 0, 1, 1, 0, -1, -1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -2, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, -1, -1, -1, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 0, -1, -1, -1, -1, 0, -1, -1, -1, 1, 1, 0, -1, -1, 1, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, -1, 0, -1, -1, -1, -1, -1, 0, 0, 0]","[[3, ""9519d79b63af5912ecb620ea28079a2341ee0253"", ""Merge topic 'math-EXPR-unary'\n\n2810e561 math(EXPR): Add support for unary `+` and `-` expressions\n834f52a6 cmExprParser: Revise indentation style to match rest of CMake\n7aaed265 cmExprParser: Port to bison 3"", ""Source/cmExprParser.cxx"", ""-"", ""# define YYDPRINTF(Args)      \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_102_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_102_new.cpp""], [7, ""9519d79b63af5912ecb620ea28079a2341ee0253"", ""Merge topic 'math-EXPR-unary'\n\n2810e561 math(EXPR): Add support for unary `+` and `-` expressions\n834f52a6 cmExprParser: Revise indentation style to match rest of CMake\n7aaed265 cmExprParser: Port to bison 3"", ""Source/cmExprParser.cxx"", ""+"", ""# define YYDPRINTF(Args)                        \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_102_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_102_new.cpp""], [23, ""9519d79b63af5912ecb620ea28079a2341ee0253"", ""Merge topic 'math-EXPR-unary'\n\n2810e561 math(EXPR): Add support for unary `+` and `-` expressions\n834f52a6 cmExprParser: Revise indentation style to match rest of CMake\n7aaed265 cmExprParser: Port to bison 3"", ""Source/cmExprParser.cxx"", ""-"", ""# define YYDSYMPRINTF(Title, Token, Value, Location)    \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_102_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_102_new.cpp""], [170, ""9519d79b63af5912ecb620ea28079a2341ee0253"", ""Merge topic 'math-EXPR-unary'\n\n2810e561 math(EXPR): Add support for unary `+` and `-` expressions\n834f52a6 cmExprParser: Revise indentation style to match rest of CMake\n7aaed265 cmExprParser: Port to bison 3"", ""Source/cmExprParser.cxx"", ""-"", ""# define YYDSYMPRINTF(Title, Token, Value, Location)"", 0, ""/data/download/CMake/CMake/Kitware_CMake_102_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_102_new.cpp""]]",552,642
"[""#  define YYFPRINTF fprintf"", ""# endif"", """", ""# define YYDPRINTF(Args)      \\"", ""do {            \\"", ""  if (yydebug)          \\"", ""    YYFPRINTF Args;        \\"", ""# define YYDPRINTF(Args)                        \\"", ""do {                                            \\"", ""  if (yydebug)                                  \\"", ""    YYFPRINTF Args;                             \\"", ""} while (0)"", """", ""# define YYDSYMPRINT(Args)      \\"", ""do {            \\"", ""  if (yydebug)          \\"", ""    yysymprint Args;        \\"", ""} while (0)"", ""/* This macro is provided for backward compatibility. */"", ""#ifndef YY_LOCATION_PRINT"", ""# define YY_LOCATION_PRINT(File, Loc) ((void) 0)"", ""#endif"", """", """", ""# define YYDSYMPRINTF(Title, Token, Value, Location)    \\"", ""do {                \\"", ""  if (yydebug)              \\"", ""    {                \\"", ""      YYFPRINTF (stderr, \""%s \"", Title);        \\"", ""      yysymprint (stderr,           \\"", ""                  Token, Value);  \\"", ""      YYFPRINTF (stderr, \""\\n\"");          \\"", ""    }                \\"", ""# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \\"", ""do {                                                                      \\"", ""  if (yydebug)                                                            \\"", ""    {                                                                     \\"", ""      YYFPRINTF (stderr, \""%s \"", Title);                                   \\"", ""      yy_symbol_print (stderr,                                            \\"", ""                  Type, Value, yyscanner); \\"", ""      YYFPRINTF (stderr, \""\\n\"");                                           \\"", ""    }                                                                     \\"", ""} while (0)"", """", """", ""/*----------------------------------------."", ""| Print this symbol's value on YYOUTPUT.  |"", ""`----------------------------------------*/"", """", ""static void"", ""yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, yyscan_t yyscanner)"", ""{"", ""  FILE *yyo = yyoutput;"", ""  YYUSE (yyo);"", ""  YYUSE (yyscanner);"", ""  if (!yyvaluep)"", ""    return;"", ""# ifdef YYPRINT"", ""  if (yytype < YYNTOKENS)"", ""    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);"", ""# endif"", ""  YYUSE (yytype);"", ""}"", """", """", ""/*--------------------------------."", ""| Print this symbol on YYOUTPUT.  |"", ""`--------------------------------*/"", """", ""static void"", ""yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, yyscan_t yyscanner)"", ""{"", ""  YYFPRINTF (yyoutput, \""%s %s (\"","", ""             yytype < YYNTOKENS ? \""token\"" : \""nterm\"", yytname[yytype]);"", """", ""  yy_symbol_value_print (yyoutput, yytype, yyvaluep, yyscanner);"", ""  YYFPRINTF (yyoutput, \"")\"");"", ""}"", """", ""/*------------------------------------------------------------------."", ""| yy_stack_print -- Print the state stack from its BOTTOM up to its |"", ""| TOP (included).                                                   |"", ""`------------------------------------------------------------------*/"", """", ""#if defined (__STDC__) || defined (__cplusplus)"", ""static void"", ""yy_stack_print (short int *bottom, short int *top)"", ""#else"", ""static void"", ""yy_stack_print (bottom, top)"", ""    short int *bottom;"", ""    short int *top;"", ""#endif"", ""yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)"", ""{"", ""  YYFPRINTF (stderr, \""Stack now\"");"", ""  for (/* Nothing. */; bottom <= top; ++bottom)"", ""    YYFPRINTF (stderr, \"" %d\"", *bottom);"", ""  for (; yybottom <= yytop; yybottom++)"", ""    {"", ""      int yybot = *yybottom;"", ""      YYFPRINTF (stderr, \"" %d\"", yybot);"", ""    }"", ""  YYFPRINTF (stderr, \""\\n\"");"", ""}"", """", ""# define YY_STACK_PRINT(Bottom, Top)        \\"", ""do {                \\"", ""  if (yydebug)              \\"", ""    yy_stack_print ((Bottom), (Top));        \\"", ""# define YY_STACK_PRINT(Bottom, Top)                            \\"", ""do {                                                            \\"", ""  if (yydebug)                                                  \\"", ""    yy_stack_print ((Bottom), (Top));                           \\"", ""} while (0)"", """", """", ""/*------------------------------------------------."", ""| Report that the YYRULE is going to be reduced.  |"", ""`------------------------------------------------*/"", """", ""#if defined (__STDC__) || defined (__cplusplus)"", ""static void"", ""yy_reduce_print (int yyrule)"", ""#else"", ""static void"", ""yy_reduce_print (yyrule)"", ""    int yyrule;"", ""#endif"", ""yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule, yyscan_t yyscanner)"", ""{"", ""  unsigned long int yylno = yyrline[yyrule];"", ""  int yynrhs = yyr2[yyrule];"", ""  int yyi;"", ""  unsigned int yylno = yyrline[yyrule];"", ""  YYFPRINTF (stderr, \""Reducing stack by rule %d (line %u), \"","", ""  YYFPRINTF (stderr, \""Reducing stack by rule %d (line %lu):\\n\"","", ""             yyrule - 1, yylno);"", ""  /* Print the symbols being reduced, and their result.  */"", ""  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)"", ""    YYFPRINTF (stderr, \""%s \"", yytname [yyrhs[yyi]]);"", ""  YYFPRINTF (stderr, \""-> %s\\n\"", yytname [yyr1[yyrule]]);"", ""  /* The symbols being reduced.  */"", ""  for (yyi = 0; yyi < yynrhs; yyi++)"", ""    {"", ""      YYFPRINTF (stderr, \""   $%d = \"", yyi + 1);"", ""      yy_symbol_print (stderr,"", ""                       yystos[yyssp[yyi + 1 - yynrhs]],"", ""                       &(yyvsp[(yyi + 1) - (yynrhs)])"", ""                                              , yyscanner);"", ""      YYFPRINTF (stderr, \""\\n\"");"", ""    }"", ""}"", """", ""# define YY_REDUCE_PRINT(Rule)    \\"", ""do {          \\"", ""  if (yydebug)        \\"", ""    yy_reduce_print (Rule);    \\"", ""# define YY_REDUCE_PRINT(Rule)          \\"", ""do {                                    \\"", ""  if (yydebug)                          \\"", ""    yy_reduce_print (yyssp, yyvsp, Rule, yyscanner); \\"", ""} while (0)"", """", ""/* Nonzero means print parse trace.  It is left uninitialized so that"", ""   multiple parsers can coexist.  */"", ""int yydebug;"", ""#else /* !YYDEBUG */"", ""# define YYDPRINTF(Args)"", ""# define YYDSYMPRINT(Args)"", ""# define YYDSYMPRINTF(Title, Token, Value, Location)"", ""# define YY_SYMBOL_PRINT(Title, Type, Value, Location)"", ""# define YY_STACK_PRINT(Bottom, Top)"", ""# define YY_REDUCE_PRINT(Rule)"", ""#endif /* !YYDEBUG */"", """", """", ""/* YYINITDEPTH -- initial size of the parser's stacks.  */"", ""#ifndef  YYINITDEPTH"", ""#ifndef YYINITDEPTH"", ""# define YYINITDEPTH 200"", ""#endif"", """", ""/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only"", ""   if the built-in stack extension method is used)."", """", ""   Do not make this value too large; the results are undefined if"", ""   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)"", ""   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)"", ""   evaluated with infinite-precision integer arithmetic.  */"", """", ""#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0"", ""# undef YYMAXDEPTH"", ""#endif"", """", ""#ifndef YYMAXDEPTH"", ""# define YYMAXDEPTH 10000"", ""#endif"", """", ""\f"", """", ""#if YYERROR_VERBOSE"", """", ""# ifndef yystrlen"", ""#  if defined (__GLIBC__) && defined (_STRING_H)"", ""#  if defined __GLIBC__ && defined _STRING_H"", ""#   define yystrlen strlen"", ""#  else"", ""/* Return the length of YYSTR.  */"", ""static YYSIZE_T"", ""#   if defined (__STDC__) || defined (__cplusplus)"", ""yystrlen (const char *yystr)"", ""#   else"", ""yystrlen (yystr)"", ""     const char *yystr;"", ""#   endif"", ""{"", ""  const char *yys = yystr;"", """", ""  while (*yys++ != '\\0')"", ""  YYSIZE_T yylen;"", ""  for (yylen = 0; yystr[yylen]; yylen++)"", ""    continue;"", """", ""  return yys - yystr - 1;"", ""  return yylen;"", ""}"", ""#  endif"", ""# endif"", """", ""# ifndef yystpcpy"", ""#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)"", ""#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE"", ""#   define yystpcpy stpcpy"", ""#  else"", ""/* Copy YYSRC to YYDEST, returning the address of the terminating '\\0' in"", ""   YYDEST.  */"", ""static char *"", ""#   if defined (__STDC__) || defined (__cplusplus)"", ""yystpcpy (char *yydest, const char *yysrc)"", ""#   else"", ""yystpcpy (yydest, yysrc)"", ""     char *yydest;"", ""     const char *yysrc;"", ""#   endif"", ""{"", ""  char *yyd = yydest;"", ""  const char *yys = yysrc;""]","[0, 0, 0, -2, -1, -1, -1, 2, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 0, -2, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, 0, -1, -1, -1, -1, -1, -1, -1, 1, 0, 0, -1, -1, 1, 1, 1, 1, 1, 0, 0, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, 0, -1, -1, -1, 1, 0, 1, 1, 0, -1, -1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -2, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, -1, -1, -1, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 0, -1, -1, -1, -1, 0, -1, -1, -1, 1, 1, 0, -1, -1, 1, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, -1, 0, -1, -1, -1, -1, -1, 0, 0, 0]","[[3, ""7aaed265ade4c3b38967e83095497280a7a55153"", ""cmExprParser: Port to bison 3\n\nUse %-directives to specify the scanner/lexer arguments and update the\nyyerror signature.  Reduce the list of post-bison modifications needed."", ""Source/cmExprParser.cxx"", ""-"", ""# define YYDPRINTF(Args)      \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_103_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_103_new.cpp""], [7, ""7aaed265ade4c3b38967e83095497280a7a55153"", ""cmExprParser: Port to bison 3\n\nUse %-directives to specify the scanner/lexer arguments and update the\nyyerror signature.  Reduce the list of post-bison modifications needed."", ""Source/cmExprParser.cxx"", ""+"", ""# define YYDPRINTF(Args)                        \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_103_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_103_new.cpp""], [24, ""7aaed265ade4c3b38967e83095497280a7a55153"", ""cmExprParser: Port to bison 3\n\nUse %-directives to specify the scanner/lexer arguments and update the\nyyerror signature.  Reduce the list of post-bison modifications needed."", ""Source/cmExprParser.cxx"", ""-"", ""# define YYDSYMPRINTF(Title, Token, Value, Location)    \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_103_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_103_new.cpp""], [170, ""7aaed265ade4c3b38967e83095497280a7a55153"", ""cmExprParser: Port to bison 3\n\nUse %-directives to specify the scanner/lexer arguments and update the\nyyerror signature.  Reduce the list of post-bison modifications needed."", ""Source/cmExprParser.cxx"", ""-"", ""# define YYDSYMPRINTF(Title, Token, Value, Location)"", 0, ""/data/download/CMake/CMake/Kitware_CMake_103_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_103_new.cpp""]]",552,640
"[""/* This used to be an fputs(), but since the string might contain NUL's,"", "" * we now use fwrite()."", "" */"", ""#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)"", ""#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)"", ""#endif"", """", ""/* Gets input and stuffs it into \""buf\"".  number of characters read, or YY_NULL,"", "" * is returned in \""result\""."", "" */"", ""#ifndef YY_INPUT"", ""#define YY_INPUT(buf,result,max_size) \\"", ""        if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\"", ""                { \\"", ""                int c = '*'; \\"", ""                size_t n; \\"", ""                for ( n = 0; n < max_size && \\"", ""                             (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\"", ""                        buf[n] = (char) c; \\"", ""                if ( c == '\\n' ) \\"", ""                        buf[n++] = (char) c; \\"", ""                if ( c == EOF && ferror( yyin ) ) \\"", ""                        YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""                result = n; \\"", ""                } \\"", ""        else \\"", ""                { \\"", ""                errno=0; \\"", ""                while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\"", ""                        { \\"", ""                        if( errno != EINTR) \\"", ""                                { \\"", ""                                YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""                                break; \\"", ""                                } \\"", ""                        errno=0; \\"", ""                        clearerr(yyin); \\"", ""                        } \\"", ""                }\\"", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\"", ""\t\t{ \\"", ""\t\tint c = '*'; \\"", ""\t\tsize_t n; \\"", ""\t\tfor ( n = 0; n < max_size && \\"", ""\t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\"", ""\t\t\tbuf[n] = (char) c; \\"", ""\t\tif ( c == '\\n' ) \\"", ""\t\t\tbuf[n++] = (char) c; \\"", ""\t\tif ( c == EOF && ferror( yyin ) ) \\"", ""\t\t\tYY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""\t\tresult = n; \\"", ""\t\t} \\"", ""\telse \\"", ""\t\t{ \\"", ""\t\terrno=0; \\"", ""\t\twhile ( (result = (int) fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\"", ""\t\t\t{ \\"", ""\t\t\tif( errno != EINTR) \\"", ""\t\t\t\t{ \\"", ""\t\t\t\tYY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""\t\t\t\tbreak; \\"", ""\t\t\t\t} \\"", ""\t\t\terrno=0; \\"", ""\t\t\tclearerr(yyin); \\"", ""\t\t\t} \\"", ""\t\t}\\"", ""\\"", """", ""#endif""]","[0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[22, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [32, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [49, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [59, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""]]",836,810
"[""    unput(yytext[strlen(yytext)-1]);"", ""    }"", ""}"", ""        YY_BREAK"", ""\tYY_BREAK"", ""case 8:"", ""/* rule 8 can match eol */"", ""YY_RULE_SETUP"", ""#line 106 \""cmFortranLexer.in.l\"""", ""#line 99 \""cmFortranLexer.in.l\"""", ""{"", ""  unput ('\\n');"", ""  BEGIN(INITIAL);"", ""  return UNTERMINATED_STRING;"", ""}"", ""case 9:"", ""YY_RULE_SETUP"", ""#line 112 \""cmFortranLexer.in.l\"""", ""#line 105 \""cmFortranLexer.in.l\"""", ""{"", ""  cmFortranParser_StringAppend(yyextra, yytext[0]);"", ""}"", ""        YY_BREAK"", ""\tYY_BREAK"", ""case 10:"", ""/* rule 10 can match eol */"", ""YY_RULE_SETUP"", ""#line 116 \""cmFortranLexer.in.l\"""", ""#line 109 \""cmFortranLexer.in.l\"""", ""{ return EOSTMT; } /* Treat comments like */"", ""case 11:"", ""/* rule 11 can match eol */"", ""YY_RULE_SETUP"", ""#line 117 \""cmFortranLexer.in.l\"""", ""#line 110 \""cmFortranLexer.in.l\"""", ""{ return EOSTMT; } /* empty lines */"", ""case 12:"", ""YY_RULE_SETUP"", ""#line 119 \""cmFortranLexer.in.l\"""", ""#line 112 \""cmFortranLexer.in.l\"""", ""{ return CPP_LINE_DIRECTIVE; }"", ""case 13:"", ""/* rule 13 can match eol */"", ""YY_RULE_SETUP"", ""#line 120 \""cmFortranLexer.in.l\"""", ""#line 113 \""cmFortranLexer.in.l\"""", ""{"", ""  yytext[yyleng-1] = 0;"", ""  yylvalp->string = strdup(strchr(yytext, '<')+1);"", ""  return CPP_INCLUDE_ANGLE;"", ""}"", ""case 14:"", ""YY_RULE_SETUP"", ""#line 125 \""cmFortranLexer.in.l\"""", ""#line 118 \""cmFortranLexer.in.l\"""", ""{ return CPP_INCLUDE; }"", ""case 15:"", ""YY_RULE_SETUP"", ""#line 126 \""cmFortranLexer.in.l\"""", ""#line 119 \""cmFortranLexer.in.l\"""", ""{ return F90PPR_INCLUDE; }"", ""case 16:"", ""YY_RULE_SETUP"", ""#line 127 \""cmFortranLexer.in.l\"""", ""#line 120 \""cmFortranLexer.in.l\"""", ""{ return COCO_INCLUDE; }"", ""case 17:"", ""YY_RULE_SETUP"", ""#line 129 \""cmFortranLexer.in.l\"""", ""#line 122 \""cmFortranLexer.in.l\"""", ""{ return CPP_DEFINE; }"", ""case 18:"", ""YY_RULE_SETUP"", ""#line 130 \""cmFortranLexer.in.l\"""", ""#line 123 \""cmFortranLexer.in.l\"""", ""{ return F90PPR_DEFINE; }"", ""case 19:"", ""YY_RULE_SETUP"", ""#line 132 \""cmFortranLexer.in.l\"""", ""#line 125 \""cmFortranLexer.in.l\"""", ""{ return CPP_UNDEF; }"", ""case 20:"", ""YY_RULE_SETUP"", ""#line 133 \""cmFortranLexer.in.l\"""", ""#line 126 \""cmFortranLexer.in.l\"""", ""{ return F90PPR_UNDEF; }"", ""case 21:"", ""YY_RULE_SETUP"", ""#line 135 \""cmFortranLexer.in.l\"""", ""#line 128 \""cmFortranLexer.in.l\"""", ""{ return CPP_IFDEF; }"", ""case 22:"", ""YY_RULE_SETUP"", ""#line 136 \""cmFortranLexer.in.l\"""", ""#line 129 \""cmFortranLexer.in.l\"""", ""{ return CPP_IFNDEF; }"", ""case 23:"", ""YY_RULE_SETUP"", ""#line 137 \""cmFortranLexer.in.l\"""", ""#line 130 \""cmFortranLexer.in.l\"""", ""{ return CPP_IF; }"", ""case 24:"", ""YY_RULE_SETUP"", ""#line 138 \""cmFortranLexer.in.l\"""", ""#line 131 \""cmFortranLexer.in.l\"""", ""{ return CPP_ELIF; }"", ""case 25:"", ""YY_RULE_SETUP"", ""#line 139 \""cmFortranLexer.in.l\"""", ""#line 132 \""cmFortranLexer.in.l\"""", ""{ return CPP_ELSE; }"", ""case 26:"", ""YY_RULE_SETUP"", ""#line 140 \""cmFortranLexer.in.l\"""", ""#line 133 \""cmFortranLexer.in.l\"""", ""{ return CPP_ENDIF; }"", ""case 27:"", ""YY_RULE_SETUP"", ""#line 142 \""cmFortranLexer.in.l\"""", ""#line 135 \""cmFortranLexer.in.l\"""", ""{ return F90PPR_IFDEF; }"", ""case 28:"", ""YY_RULE_SETUP"", ""#line 143 \""cmFortranLexer.in.l\"""", ""#line 136 \""cmFortranLexer.in.l\"""", ""{ return F90PPR_IFNDEF; }"", ""case 29:"", ""YY_RULE_SETUP"", ""#line 144 \""cmFortranLexer.in.l\"""", ""#line 137 \""cmFortranLexer.in.l\"""", ""{ return F90PPR_IF; }"", ""case 30:"", ""YY_RULE_SETUP"", ""#line 145 \""cmFortranLexer.in.l\"""", ""#line 138 \""cmFortranLexer.in.l\"""", ""{ return F90PPR_ELIF; }"", ""case 31:"", ""YY_RULE_SETUP"", ""#line 146 \""cmFortranLexer.in.l\"""", ""#line 139 \""cmFortranLexer.in.l\"""", ""{ return F90PPR_ELSE; }"", ""case 32:"", ""YY_RULE_SETUP"", ""#line 147 \""cmFortranLexer.in.l\"""", ""#line 140 \""cmFortranLexer.in.l\"""", ""{ return F90PPR_ENDIF; }"", ""/* Line continuations, possible involving comments.  */"", ""case 33:"", ""/* rule 33 can match eol */"", ""YY_RULE_SETUP"", ""#line 150 \""cmFortranLexer.in.l\"""", ""#line 143 \""cmFortranLexer.in.l\"""", """", ""        YY_BREAK"", ""\tYY_BREAK"", ""case 34:"", ""/* rule 34 can match eol */"", ""YY_RULE_SETUP"", ""#line 151 \""cmFortranLexer.in.l\"""", ""#line 144 \""cmFortranLexer.in.l\"""", """", ""        YY_BREAK"", ""\tYY_BREAK"", ""case 35:"", ""YY_RULE_SETUP"", ""#line 153 \""cmFortranLexer.in.l\"""", ""#line 146 \""cmFortranLexer.in.l\"""", ""{ return COMMA; }"", ""case 36:"", ""YY_RULE_SETUP"", ""#line 155 \""cmFortranLexer.in.l\"""", ""#line 148 \""cmFortranLexer.in.l\"""", ""{ return DCOLON; }"", ""case 37:"", ""/* rule 37 can match eol */"", ""YY_RULE_SETUP"", ""#line 157 \""cmFortranLexer.in.l\"""", ""#line 150 \""cmFortranLexer.in.l\"""", ""{ return GARBAGE; }"", ""case 38:"", ""YY_RULE_SETUP"", ""#line 159 \""cmFortranLexer.in.l\"""", ""#line 152 \""cmFortranLexer.in.l\"""", ""{ return ASSIGNMENT_OP; }"", ""case 39:"", ""YY_RULE_SETUP"", ""#line 161 \""cmFortranLexer.in.l\"""", ""#line 154 \""cmFortranLexer.in.l\"""", ""{"", ""  yylvalp->string = strdup(yytext);"", ""  return WORD;"", ""}"", ""case 40:"", ""YY_RULE_SETUP"", ""#line 166 \""cmFortranLexer.in.l\"""", ""#line 159 \""cmFortranLexer.in.l\"""", ""{ return GARBAGE; }"", ""case 41:"", ""/* rule 41 can match eol */"", ""YY_RULE_SETUP"", ""#line 168 \""cmFortranLexer.in.l\"""", ""#line 161 \""cmFortranLexer.in.l\"""", ""{ return EOSTMT; }"", ""case 42:"", ""YY_RULE_SETUP"", ""#line 171 \""cmFortranLexer.in.l\"""", ""#line 164 \""cmFortranLexer.in.l\"""", ""/* Ignore */"", ""        YY_BREAK"", ""\tYY_BREAK"", ""case 43:"", ""/* rule 43 can match eol */"", ""YY_RULE_SETUP"", ""#line 172 \""cmFortranLexer.in.l\"""", ""#line 165 \""cmFortranLexer.in.l\"""", ""/* Ignore line-endings preceded by \\ */"", ""        YY_BREAK"", ""\tYY_BREAK"", ""case 44:"", ""YY_RULE_SETUP"", ""#line 174 \""cmFortranLexer.in.l\"""", ""#line 167 \""cmFortranLexer.in.l\"""", ""{ return *yytext; }"", ""case YY_STATE_EOF(INITIAL):"", ""case YY_STATE_EOF(free_fmt):"", ""case YY_STATE_EOF(fixed_fmt):"", ""case YY_STATE_EOF(str_sq):"", ""case YY_STATE_EOF(str_dq):"", ""#line 176 \""cmFortranLexer.in.l\"""", ""#line 169 \""cmFortranLexer.in.l\"""", ""{"", ""  if(!cmFortranParser_FilePop(yyextra) )"", ""    {"", ""    return YY_NULL;"", ""    }"", ""}"", ""        YY_BREAK"", ""\tYY_BREAK"", ""case 45:"", ""YY_RULE_SETUP"", ""#line 183 \""cmFortranLexer.in.l\"""", ""#line 176 \""cmFortranLexer.in.l\"""", ""ECHO;"", ""        YY_BREAK"", ""#line 1291 \""cmFortranLexer.cxx\"""", """", ""        case YY_END_OF_BUFFER:"", ""                {"", ""                /* Amount of text matched not including the EOB char. */"", ""                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;"", """", ""                /* Undo the effects of YY_DO_BEFORE_ACTION. */"", ""                *yy_cp = yyg->yy_hold_char;"", ""                YY_RESTORE_YY_MORE_OFFSET"", """", ""                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )"", ""                        {"", ""                        /* We're scanning a new file or input source.  It's"", ""                         * possible that this happened because the user"", ""                         * just pointed yyin at a new source and called"", ""                         * cmFortran_yylex().  If so, then we have to assure"", ""                         * consistency between YY_CURRENT_BUFFER and our"", ""                         * globals.  Here is the right place to do so, because"", ""                         * this is the first action (other than possibly a"", ""                         * back-up) that will match for the new input source."", ""                         */"", ""                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;"", ""                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;"", ""                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;"", ""                        }"", """", ""                /* Note that here we test for yy_c_buf_p \""<=\"" to the position"", ""                 * of the first EOB in the buffer, since yy_c_buf_p will"", ""                 * already have been incremented past the NUL character"", ""                 * (since all states make transitions on EOB to the"", ""                 * end-of-buffer state).  Contrast this with the test"", ""                 * in input()."", ""                 */"", ""                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )"", ""                        { /* This was really a NUL. */"", ""                        yy_state_type yy_next_state;"", """", ""                        yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""                        yy_current_state = yy_get_previous_state( yyscanner );"", """", ""                        /* Okay, we're now positioned to make the NUL"", ""                         * transition.  We couldn't have"", ""                         * yy_get_previous_state() go ahead and do it"", ""                         * for us because it doesn't know how to deal"", ""                         * with the possibility of jamming (and we don't"", ""                         * want to build jamming into it because then it"", ""                         * will run more slowly)."", ""                         */"", """", ""                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);"", """", ""                        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""                        if ( yy_next_state )"", ""                                {"", ""                                /* Consume the NUL. */"", ""                                yy_cp = ++yyg->yy_c_buf_p;"", ""                                yy_current_state = yy_next_state;"", ""                                goto yy_match;"", ""                                }"", """", ""                        else"", ""                                {"", ""                                yy_cp = yyg->yy_c_buf_p;"", ""                                goto yy_find_action;"", ""                                }"", ""                        }"", """", ""                else switch ( yy_get_next_buffer( yyscanner ) )"", ""                        {"", ""                        case EOB_ACT_END_OF_FILE:"", ""                                {"", ""                                yyg->yy_did_buffer_switch_on_eof = 0;"", """", ""                                if ( cmFortran_yywrap(yyscanner ) )"", ""                                        {"", ""                                        /* Note: because we've taken care in"", ""                                         * yy_get_next_buffer() to have set up"", ""                                         * yytext, we can now set up"", ""                                         * yy_c_buf_p so that if some total"", ""                                         * hoser (like flex itself) wants to"", ""                                         * call the scanner after we return the"", ""                                         * YY_NULL, it'll still work - another"", ""                                         * YY_NULL will get returned."", ""                                         */"", ""                                        yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""                                        yy_act = YY_STATE_EOF(YY_START);"", ""                                        goto do_action;"", ""                                        }"", """", ""                                else"", ""                                        {"", ""                                        if ( ! yyg->yy_did_buffer_switch_on_eof )"", ""                                                YY_NEW_FILE;"", ""                                        }"", ""                                break;"", ""                                }"", """", ""                        case EOB_ACT_CONTINUE_SCAN:"", ""                                yyg->yy_c_buf_p ="", ""                                        yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""                                yy_current_state = yy_get_previous_state( yyscanner );"", """", ""                                yy_cp = yyg->yy_c_buf_p;"", ""                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""                                goto yy_match;"", """", ""                        case EOB_ACT_LAST_MATCH:"", ""                                yyg->yy_c_buf_p ="", ""                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];"", """", ""                                yy_current_state = yy_get_previous_state( yyscanner );"", """", ""                                yy_cp = yyg->yy_c_buf_p;"", ""                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""                                goto yy_find_action;"", ""                        }"", ""                break;"", ""                }"", """", ""        default:"", ""                YY_FATAL_ERROR("", ""                        \""fatal flex scanner internal error--no action found\"" );"", ""        } /* end of action switch */"", ""                } /* end of scanning one token */"", ""        } /* end of user's declarations */"", ""\tYY_BREAK"", ""#line 1276 \""cmFortranLexer.cxx\"""", """", ""\tcase YY_END_OF_BUFFER:"", ""\t\t{"", ""\t\t/* Amount of text matched not including the EOB char. */"", ""\t\tint yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;"", """", ""\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */"", ""\t\t*yy_cp = yyg->yy_hold_char;"", ""\t\tYY_RESTORE_YY_MORE_OFFSET"", """", ""\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )"", ""\t\t\t{"", ""\t\t\t/* We're scanning a new file or input source.  It's"", ""\t\t\t * possible that this happened because the user"", ""\t\t\t * just pointed yyin at a new source and called"", ""\t\t\t * cmFortran_yylex().  If so, then we have to assure"", ""\t\t\t * consistency between YY_CURRENT_BUFFER and our"", ""\t\t\t * globals.  Here is the right place to do so, because"", ""\t\t\t * this is the first action (other than possibly a"", ""\t\t\t * back-up) that will match for the new input source."", ""\t\t\t */"", ""\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;"", ""\t\t\t}"", """", ""\t\t/* Note that here we test for yy_c_buf_p \""<=\"" to the position"", ""\t\t * of the first EOB in the buffer, since yy_c_buf_p will"", ""\t\t * already have been incremented past the NUL character"", ""\t\t * (since all states make transitions on EOB to the"", ""\t\t * end-of-buffer state).  Contrast this with the test"", ""\t\t * in input()."", ""\t\t */"", ""\t\tif ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )"", ""\t\t\t{ /* This was really a NUL. */"", ""\t\t\tyy_state_type yy_next_state;"", """", ""\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t/* Okay, we're now positioned to make the NUL"", ""\t\t\t * transition.  We couldn't have"", ""\t\t\t * yy_get_previous_state() go ahead and do it"", ""\t\t\t * for us because it doesn't know how to deal"", ""\t\t\t * with the possibility of jamming (and we don't"", ""\t\t\t * want to build jamming into it because then it"", ""\t\t\t * will run more slowly)."", ""\t\t\t */"", """", ""\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);"", """", ""\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""\t\t\tif ( yy_next_state )"", ""\t\t\t\t{"", ""\t\t\t\t/* Consume the NUL. */"", ""\t\t\t\tyy_cp = ++yyg->yy_c_buf_p;"", ""\t\t\t\tyy_current_state = yy_next_state;"", ""\t\t\t\tgoto yy_match;"", ""\t\t\t\t}"", """", ""\t\t\telse"", ""\t\t\t\t{"", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tgoto yy_find_action;"", ""\t\t\t\t}"", ""\t\t\t}"", """", ""\t\telse switch ( yy_get_next_buffer( yyscanner ) )"", ""\t\t\t{"", ""\t\t\tcase EOB_ACT_END_OF_FILE:"", ""\t\t\t\t{"", ""\t\t\t\tyyg->yy_did_buffer_switch_on_eof = 0;"", """", ""\t\t\t\tif ( cmFortran_yywrap(yyscanner ) )"", ""\t\t\t\t\t{"", ""\t\t\t\t\t/* Note: because we've taken care in"", ""\t\t\t\t\t * yy_get_next_buffer() to have set up"", ""\t\t\t\t\t * yytext, we can now set up"", ""\t\t\t\t\t * yy_c_buf_p so that if some total"", ""\t\t\t\t\t * hoser (like flex itself) wants to"", ""\t\t\t\t\t * call the scanner after we return the"", ""\t\t\t\t\t * YY_NULL, it'll still work - another"", ""\t\t\t\t\t * YY_NULL will get returned."", ""\t\t\t\t\t */"", ""\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);"", ""\t\t\t\t\tgoto do_action;"", ""\t\t\t\t\t}"", """", ""\t\t\t\telse"", ""\t\t\t\t\t{"", ""\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )"", ""\t\t\t\t\t\tYY_NEW_FILE;"", ""\t\t\t\t\t}"", ""\t\t\t\tbreak;"", ""\t\t\t\t}"", """", ""\t\t\tcase EOB_ACT_CONTINUE_SCAN:"", ""\t\t\t\tyyg->yy_c_buf_p ="", ""\t\t\t\t\tyyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""\t\t\t\tgoto yy_match;"", """", ""\t\t\tcase EOB_ACT_LAST_MATCH:"", ""\t\t\t\tyyg->yy_c_buf_p ="", ""\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];"", """", ""\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""\t\t\t\tgoto yy_find_action;"", ""\t\t\t}"", ""\t\tbreak;"", ""\t\t}"", """", ""\tdefault:"", ""\t\tYY_FATAL_ERROR("", ""\t\t\t\""fatal flex scanner internal error--no action found\"" );"", ""\t} /* end of action switch */"", ""\t\t} /* end of scanning one token */"", ""\t} /* end of user's declarations */"", ""} /* end of cmFortran_yylex */"", """", ""/* yy_get_next_buffer - try to read in a new buffer"", "" *"", "" * Returns a code representing an action:"", "" *      EOB_ACT_LAST_MATCH -"", "" *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position"", "" *      EOB_ACT_END_OF_FILE - end of file"", "" *\tEOB_ACT_LAST_MATCH -"", "" *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position"", "" *\tEOB_ACT_END_OF_FILE - end of file"", "" */"", ""static int yy_get_next_buffer (yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;"", ""        char *source = yyg->yytext_ptr;"", ""        int number_to_move, i;"", ""        int ret_val;"", """", ""        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )"", ""                YY_FATAL_ERROR("", ""                \""fatal flex scanner internal error--end of buffer missed\"" );"", """", ""        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )"", ""                { /* Don't try to fill the buffer, so this is an EOF. */"", ""                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )"", ""                        {"", ""                        /* We matched a single character, the EOB, so"", ""                         * treat this as a final EOF."", ""                         */"", ""                        return EOB_ACT_END_OF_FILE;"", ""                        }"", """", ""                else"", ""                        {"", ""                        /* We matched some text prior to the EOB, first"", ""                         * process it."", ""                         */"", ""                        return EOB_ACT_LAST_MATCH;"", ""                        }"", ""                }"", """", ""        /* Try to read more data. */"", """", ""        /* First move last chars to start of buffer. */"", ""        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;"", """", ""        for ( i = 0; i < number_to_move; ++i )"", ""                *(dest++) = *(source++);"", """", ""        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )"", ""                /* don't do the read, it's not guaranteed to return an EOF,"", ""                 * just force an EOF"", ""                 */"", ""                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;"", """", ""        else"", ""                {"", ""                        yy_size_t num_to_read ="", ""                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;"", """", ""                while ( num_to_read <= 0 )"", ""                        { /* Not enough room in the buffer - grow it. */"", """", ""                        /* just a shorter name for the current buffer */"", ""                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;"", """", ""                        int yy_c_buf_p_offset ="", ""                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);"", """", ""                        if ( b->yy_is_our_buffer )"", ""                                {"", ""                                yy_size_t new_size = b->yy_buf_size * 2;"", """", ""                                if ( new_size <= 0 )"", ""                                        b->yy_buf_size += b->yy_buf_size / 8;"", ""                                else"", ""                                        b->yy_buf_size *= 2;"", """", ""                                b->yy_ch_buf = (char *)"", ""                                        /* Include room in for 2 EOB chars. */"", ""                                        cmFortran_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );"", ""                                }"", ""                        else"", ""                                /* Can't grow it, we don't own it. */"", ""                                b->yy_ch_buf = 0;"", """", ""                        if ( ! b->yy_ch_buf )"", ""                                YY_FATAL_ERROR("", ""                                \""fatal error - scanner input buffer overflow\"" );"", """", ""                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];"", """", ""                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -"", ""                                                number_to_move - 1;"", """", ""                        }"", """", ""                if ( num_to_read > YY_READ_BUF_SIZE )"", ""                        num_to_read = YY_READ_BUF_SIZE;"", """", ""                /* Read in more data. */"", ""                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),"", ""                        yyg->yy_n_chars, num_to_read );"", """", ""                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;"", ""                }"", """", ""        if ( yyg->yy_n_chars == 0 )"", ""                {"", ""                if ( number_to_move == YY_MORE_ADJ )"", ""                        {"", ""                        ret_val = EOB_ACT_END_OF_FILE;"", ""                        cmFortran_yyrestart(yyin  ,yyscanner);"", ""                        }"", """", ""                else"", ""                        {"", ""                        ret_val = EOB_ACT_LAST_MATCH;"", ""                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status ="", ""                                YY_BUFFER_EOF_PENDING;"", ""                        }"", ""                }"", """", ""        else"", ""                ret_val = EOB_ACT_CONTINUE_SCAN;"", """", ""        if ((yy_size_t) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {"", ""                /* Extend the array by 50%, plus the number we really need. */"", ""                yy_size_t new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);"", ""                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmFortran_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );"", ""                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""                        YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", ""        }"", """", ""        yyg->yy_n_chars += number_to_move;"", ""        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;"", ""        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;"", """", ""        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];"", ""\tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;"", ""\tchar *source = yyg->yytext_ptr;"", ""\tyy_size_t number_to_move, i;"", ""\tint ret_val;"", """", ""\tif ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )"", ""\t\tYY_FATAL_ERROR("", ""\t\t\""fatal flex scanner internal error--end of buffer missed\"" );"", """", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )"", ""\t\t{ /* Don't try to fill the buffer, so this is an EOF. */"", ""\t\tif ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )"", ""\t\t\t{"", ""\t\t\t/* We matched a single character, the EOB, so"", ""\t\t\t * treat this as a final EOF."", ""\t\t\t */"", ""\t\t\treturn EOB_ACT_END_OF_FILE;"", ""\t\t\t}"", """", ""\t\telse"", ""\t\t\t{"", ""\t\t\t/* We matched some text prior to the EOB, first"", ""\t\t\t * process it."", ""\t\t\t */"", ""\t\t\treturn EOB_ACT_LAST_MATCH;"", ""\t\t\t}"", ""\t\t}"", """", ""\t/* Try to read more data. */"", """", ""\t/* First move last chars to start of buffer. */"", ""\tnumber_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;"", """", ""\tfor ( i = 0; i < number_to_move; ++i )"", ""\t\t*(dest++) = *(source++);"", """", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )"", ""\t\t/* don't do the read, it's not guaranteed to return an EOF,"", ""\t\t * just force an EOF"", ""\t\t */"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;"", """", ""\telse"", ""\t\t{"", ""\t\t\tint num_to_read ="", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;"", """", ""\t\twhile ( num_to_read <= 0 )"", ""\t\t\t{ /* Not enough room in the buffer - grow it. */"", """", ""\t\t\t/* just a shorter name for the current buffer */"", ""\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;"", """", ""\t\t\tint yy_c_buf_p_offset ="", ""\t\t\t\t(int) (yyg->yy_c_buf_p - b->yy_ch_buf);"", """", ""\t\t\tif ( b->yy_is_our_buffer )"", ""\t\t\t\t{"", ""\t\t\t\tint new_size = b->yy_buf_size * 2;"", """", ""\t\t\t\tif ( new_size <= 0 )"", ""\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;"", ""\t\t\t\telse"", ""\t\t\t\t\tb->yy_buf_size *= 2;"", """", ""\t\t\t\tb->yy_ch_buf = (char *)"", ""\t\t\t\t\t/* Include room in for 2 EOB chars. */"", ""\t\t\t\t\tcmFortran_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );"", ""\t\t\t\t}"", ""\t\t\telse"", ""\t\t\t\t/* Can't grow it, we don't own it. */"", ""\t\t\t\tb->yy_ch_buf = NULL;"", """", ""\t\t\tif ( ! b->yy_ch_buf )"", ""\t\t\t\tYY_FATAL_ERROR("", ""\t\t\t\t\""fatal error - scanner input buffer overflow\"" );"", """", ""\t\t\tyyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];"", """", ""\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -"", ""\t\t\t\t\t\tnumber_to_move - 1;"", """", ""\t\t\t}"", """", ""\t\tif ( num_to_read > YY_READ_BUF_SIZE )"", ""\t\t\tnum_to_read = YY_READ_BUF_SIZE;"", """", ""\t\t/* Read in more data. */"", ""\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),"", ""\t\t\tyyg->yy_n_chars, num_to_read );"", """", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;"", ""\t\t}"", """", ""\tif ( yyg->yy_n_chars == 0 )"", ""\t\t{"", ""\t\tif ( number_to_move == YY_MORE_ADJ )"", ""\t\t\t{"", ""\t\t\tret_val = EOB_ACT_END_OF_FILE;"", ""\t\t\tcmFortran_yyrestart(yyin  ,yyscanner);"", ""\t\t\t}"", """", ""\t\telse"", ""\t\t\t{"", ""\t\t\tret_val = EOB_ACT_LAST_MATCH;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status ="", ""\t\t\t\tYY_BUFFER_EOF_PENDING;"", ""\t\t\t}"", ""\t\t}"", """", ""\telse"", ""\t\tret_val = EOB_ACT_CONTINUE_SCAN;"", """", ""\tif ((int) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {"", ""\t\t/* Extend the array by 50%, plus the number we really need. */"", ""\t\tint new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmFortran_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );"", ""\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", ""\t}"", """", ""\tyyg->yy_n_chars += number_to_move;"", ""\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;"", ""\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;"", """", ""\tyyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];"", """", ""        return ret_val;"", ""\treturn ret_val;"", ""}"", """", ""/* yy_get_previous_state - get the state just before the EOB char was reached */"", """", ""    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)"", ""{"", ""        yy_state_type yy_current_state;"", ""        char *yy_cp;"", ""\tyy_state_type yy_current_state;"", ""\tchar *yy_cp;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        yy_current_state = yyg->yy_start;"", ""        yy_current_state += YY_AT_BOL();"", """", ""        for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )"", ""                {"", ""                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);"", ""                if ( yy_accept[yy_current_state] )"", ""                        {"", ""                        yyg->yy_last_accepting_state = yy_current_state;"", ""                        yyg->yy_last_accepting_cpos = yy_cp;"", ""                        }"", ""                while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""                        {"", ""                        yy_current_state = (int) yy_def[yy_current_state];"", ""                        if ( yy_current_state >= 173 )"", ""                                yy_c = yy_meta[(unsigned int) yy_c];"", ""                        }"", ""                yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""                }"", """", ""        return yy_current_state;"", ""\tyy_current_state = yyg->yy_start;"", ""\tyy_current_state += YY_AT_BOL();"", """", ""\tfor ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )"", ""\t\t{"", ""\t\tYY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);"", ""\t\tif ( yy_accept[yy_current_state] )"", ""\t\t\t{"", ""\t\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t\t}"", ""\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t\t{"", ""\t\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\t\tif ( yy_current_state >= 173 )"", ""\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t\t}"", ""\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];"", ""\t\t}"", """", ""\treturn yy_current_state;"", ""}"", """", ""/* yy_try_NUL_trans - try to make a transition on the NUL character"", "" *"", "" * synopsis"", "" *      next_state = yy_try_NUL_trans( current_state );"", "" *\tnext_state = yy_try_NUL_trans( current_state );"", "" */"", ""    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)"", ""{"", ""        int yy_is_jam;"", ""\tint yy_is_jam;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */"", ""        char *yy_cp = yyg->yy_c_buf_p;"", """", ""        YY_CHAR yy_c = 1;"", ""        if ( yy_accept[yy_current_state] )"", ""                {"", ""                yyg->yy_last_accepting_state = yy_current_state;"", ""                yyg->yy_last_accepting_cpos = yy_cp;"", ""                }"", ""        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""                {"", ""                yy_current_state = (int) yy_def[yy_current_state];"", ""                if ( yy_current_state >= 173 )"", ""                        yy_c = yy_meta[(unsigned int) yy_c];"", ""                }"", ""        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""        yy_is_jam = (yy_current_state == 172);"", """", ""        (void)yyg;"", ""        return yy_is_jam ? 0 : yy_current_state;"", ""\tchar *yy_cp = yyg->yy_c_buf_p;"", """", ""\tYY_CHAR yy_c = 1;"", ""\tif ( yy_accept[yy_current_state] )"", ""\t\t{"", ""\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t}"", ""\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t{"", ""\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\tif ( yy_current_state >= 173 )"", ""\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t}"", ""\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];"", ""\tyy_is_jam = (yy_current_state == 172);"", """", ""\t(void)yyg;"", ""\treturn yy_is_jam ? 0 : yy_current_state;"", ""}"", """", ""#ifndef YY_NO_UNPUT"", """", ""    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)"", ""{"", ""        char *yy_cp;"", ""\tchar *yy_cp;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""    yy_cp = yyg->yy_c_buf_p;"", """", ""        /* undo effects of setting up yytext */"", ""        *yy_cp = yyg->yy_hold_char;"", ""\t/* undo effects of setting up yytext */"", ""\t*yy_cp = yyg->yy_hold_char;"", """", ""        if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )"", ""                { /* need to shift things up to make room */"", ""                /* +2 for EOB chars. */"", ""                yy_size_t number_to_move = yyg->yy_n_chars + 2;"", ""                char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf["", ""                                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];"", ""                char *source ="", ""                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];"", ""\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )"", ""\t\t{ /* need to shift things up to make room */"", ""\t\t/* +2 for EOB chars. */"", ""\t\tint number_to_move = yyg->yy_n_chars + 2;"", ""\t\tchar *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf["", ""\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];"", ""\t\tchar *source ="", ""\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];"", """", ""                while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""                        *--dest = *--source;"", ""\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""\t\t\t*--dest = *--source;"", """", ""                yy_cp += (int) (dest - source);"", ""                yy_bp += (int) (dest - source);"", ""                YY_CURRENT_BUFFER_LVALUE->yy_n_chars ="", ""                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;"", ""\t\tyy_cp += (int) (dest - source);"", ""\t\tyy_bp += (int) (dest - source);"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars ="", ""\t\t\tyyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;"", """", ""                if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )"", ""                        YY_FATAL_ERROR( \""flex scanner push-back overflow\"" );"", ""                }"", ""\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )"", ""\t\t\tYY_FATAL_ERROR( \""flex scanner push-back overflow\"" );"", ""\t\t}"", """", ""        *--yy_cp = (char) c;"", ""\t*--yy_cp = (char) c;"", """", ""        yyg->yytext_ptr = yy_bp;"", ""        yyg->yy_hold_char = *yy_cp;"", ""        yyg->yy_c_buf_p = yy_cp;"", ""\tyyg->yytext_ptr = yy_bp;"", ""\tyyg->yy_hold_char = *yy_cp;"", ""\tyyg->yy_c_buf_p = yy_cp;"", ""}"", """", ""#endif"", """", ""#ifndef YY_NO_INPUT"", ""#ifdef __cplusplus"", ""    static int yyinput (yyscan_t yyscanner)""]","[0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, -1, 1, 0, -1, 1, 0, 0, 0, -1, 1, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, -1, 1, 0, 0, 0, -1, 1, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, -1, 1, 0, 0, 0, 0, -1, -1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, -2, -1, 1, 2, 1, 0, -1, 1, 0, -1, -1, -1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0]","[[369, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [500, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [526, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [594, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [638, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [652, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [720, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [764, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [929, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""flex scanner push-back overflow\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [932, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""flex scanner push-back overflow\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""]]",1070,1044
"["" */"", ""    YY_BUFFER_STATE cmFortran_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)"", ""{"", ""        YY_BUFFER_STATE b;"", ""\tYY_BUFFER_STATE b;"", """", ""        b = (YY_BUFFER_STATE) cmFortran_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""        if ( ! b )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_create_buffer()\"" );"", ""\tb = (YY_BUFFER_STATE) cmFortran_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_create_buffer()\"" );"", """", ""        b->yy_buf_size = size;"", ""\tb->yy_buf_size = (yy_size_t)size;"", """", ""        /* yy_ch_buf has to be 2 characters longer than the size given because"", ""         * we need to put in 2 end-of-buffer characters."", ""         */"", ""        b->yy_ch_buf = (char *) cmFortran_yyalloc(b->yy_buf_size + 2 ,yyscanner );"", ""        if ( ! b->yy_ch_buf )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_create_buffer()\"" );"", ""\t/* yy_ch_buf has to be 2 characters longer than the size given because"", ""\t * we need to put in 2 end-of-buffer characters."", ""\t */"", ""\tb->yy_ch_buf = (char *) cmFortran_yyalloc(b->yy_buf_size + 2 ,yyscanner );"", ""\tif ( ! b->yy_ch_buf )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_create_buffer()\"" );"", """", ""        b->yy_is_our_buffer = 1;"", ""\tb->yy_is_our_buffer = 1;"", """", ""        cmFortran_yy_init_buffer(b,file ,yyscanner);"", ""\tcmFortran_yy_init_buffer(b,file ,yyscanner);"", """", ""        return b;"", ""\treturn b;"", ""}"", """", ""/** Destroy the buffer.""]","[0, 0, 0, -1, 1, 0, -1, -1, -2, 1, 1, 2, 0, -1, 1, 0, -1, -1, -1, -1, -1, -2, 1, 1, 1, 1, 1, 2, 0, -1, 1, 0, -1, 1, 0, -1, 1, 0, 0, 0]","[[8, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [11, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [21, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [27, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""]]",1785,1763
"[""void cmFortran_yypop_buffer_state (yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""        if (!YY_CURRENT_BUFFER)"", ""                return;"", """", ""        cmFortran_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);"", ""        YY_CURRENT_BUFFER_LVALUE = NULL;"", ""        if (yyg->yy_buffer_stack_top > 0)"", ""                --yyg->yy_buffer_stack_top;"", """", ""        if (YY_CURRENT_BUFFER) {"", ""                cmFortran_yy_load_buffer_state(yyscanner );"", ""                yyg->yy_did_buffer_switch_on_eof = 1;"", ""        }"", ""\tif (!YY_CURRENT_BUFFER)"", ""\t\treturn;"", """", ""\tcmFortran_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);"", ""\tYY_CURRENT_BUFFER_LVALUE = NULL;"", ""\tif (yyg->yy_buffer_stack_top > 0)"", ""\t\t--yyg->yy_buffer_stack_top;"", """", ""\tif (YY_CURRENT_BUFFER) {"", ""\t\tcmFortran_yy_load_buffer_state(yyscanner );"", ""\t\tyyg->yy_did_buffer_switch_on_eof = 1;"", ""\t}"", ""}"", """", ""/* Allocates the stack if it does not exist."", "" *  Guarantees space for at least one push."", "" */"", ""static void cmFortran_yyensure_buffer_stack (yyscan_t yyscanner)"", ""{"", ""        yy_size_t num_to_alloc;"", ""\tint num_to_alloc;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        if (!yyg->yy_buffer_stack) {"", ""\tif (!yyg->yy_buffer_stack) {"", """", ""                /* First allocation is just for 2 elements, since we don't know if this"", ""                 * scanner will even need a stack. We use 2 instead of 1 to avoid an"", ""                 * immediate realloc on the next call."", ""\t\t/* First allocation is just for 2 elements, since we don't know if this"", ""\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an"", ""\t\t * immediate realloc on the next call."", ""         */"", ""                num_to_alloc = 1;"", ""                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyalloc"", ""                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)"", ""                                                                , yyscanner);"", ""                if ( ! yyg->yy_buffer_stack )"", ""                        YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yyensure_buffer_stack()\"" );"", """", ""                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));"", """", ""                yyg->yy_buffer_stack_max = num_to_alloc;"", ""                yyg->yy_buffer_stack_top = 0;"", ""                return;"", ""        }"", """", ""        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){"", """", ""                /* Increase the buffer to prepare for a possible push. */"", ""                int grow_size = 8 /* arbitrary grow size */;"", """", ""                num_to_alloc = yyg->yy_buffer_stack_max + grow_size;"", ""                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyrealloc"", ""                                                                (yyg->yy_buffer_stack,"", ""                                                                num_to_alloc * sizeof(struct yy_buffer_state*)"", ""                                                                , yyscanner);"", ""                if ( ! yyg->yy_buffer_stack )"", ""                        YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yyensure_buffer_stack()\"" );"", """", ""                /* zero only the new slots.*/"", ""                memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));"", ""                yyg->yy_buffer_stack_max = num_to_alloc;"", ""        }"", ""      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */"", ""\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyalloc"", ""\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)"", ""\t\t\t\t\t\t\t\t, yyscanner);"", ""\t\tif ( ! yyg->yy_buffer_stack )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yyensure_buffer_stack()\"" );"", """", ""\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));"", """", ""\t\tyyg->yy_buffer_stack_max = num_to_alloc;"", ""\t\tyyg->yy_buffer_stack_top = 0;"", ""\t\treturn;"", ""\t}"", """", ""\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){"", """", ""\t\t/* Increase the buffer to prepare for a possible push. */"", ""\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;"", """", ""\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;"", ""\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyrealloc"", ""\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,"", ""\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)"", ""\t\t\t\t\t\t\t\t, yyscanner);"", ""\t\tif ( ! yyg->yy_buffer_stack )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yyensure_buffer_stack()\"" );"", """", ""\t\t/* zero only the new slots.*/"", ""\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));"", ""\t\tyyg->yy_buffer_stack_max = num_to_alloc;"", ""\t}"", ""}"", """", ""/** Setup the input buffer state to scan directly from a user-specified character buffer.""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 0, 0]","[[53, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [73, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [84, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [104, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""]]",1924,1902
"["" */"", ""YY_BUFFER_STATE cmFortran_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)"", ""{"", ""        YY_BUFFER_STATE b;"", """", ""        if ( size < 2 ||"", ""             base[size-2] != YY_END_OF_BUFFER_CHAR ||"", ""             base[size-1] != YY_END_OF_BUFFER_CHAR )"", ""                /* They forgot to leave room for the EOB's. */"", ""                return 0;"", """", ""        b = (YY_BUFFER_STATE) cmFortran_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""        if ( ! b )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_scan_buffer()\"" );"", """", ""        b->yy_buf_size = size - 2;      /* \""- 2\"" to take care of EOB's */"", ""        b->yy_buf_pos = b->yy_ch_buf = base;"", ""        b->yy_is_our_buffer = 0;"", ""        b->yy_input_file = 0;"", ""        b->yy_n_chars = b->yy_buf_size;"", ""        b->yy_is_interactive = 0;"", ""        b->yy_at_bol = 1;"", ""        b->yy_fill_buffer = 0;"", ""        b->yy_buffer_status = YY_BUFFER_NEW;"", """", ""        cmFortran_yy_switch_to_buffer(b ,yyscanner );"", """", ""        return b;"", ""\tYY_BUFFER_STATE b;"", """", ""\tif ( size < 2 ||"", ""\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||"", ""\t     base[size-1] != YY_END_OF_BUFFER_CHAR )"", ""\t\t/* They forgot to leave room for the EOB's. */"", ""\t\treturn NULL;"", """", ""\tb = (YY_BUFFER_STATE) cmFortran_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_scan_buffer()\"" );"", """", ""\tb->yy_buf_size = size - 2;\t/* \""- 2\"" to take care of EOB's */"", ""\tb->yy_buf_pos = b->yy_ch_buf = base;"", ""\tb->yy_is_our_buffer = 0;"", ""\tb->yy_input_file = NULL;"", ""\tb->yy_n_chars = b->yy_buf_size;"", ""\tb->yy_is_interactive = 0;"", ""\tb->yy_at_bol = 1;"", ""\tb->yy_fill_buffer = 0;"", ""\tb->yy_buffer_status = YY_BUFFER_NEW;"", """", ""\tcmFortran_yy_switch_to_buffer(b ,yyscanner );"", """", ""\treturn b;"", ""}"", """", ""/** Setup the input buffer state to scan a string. The next call to cmFortran_yylex() will""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[13, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_scan_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [38, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_scan_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""]]",1993,1971
"["" * @param yyscanner The scanner object."", "" * @return the newly allocated buffer state object."", "" */"", ""YY_BUFFER_STATE cmFortran_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)"", ""YY_BUFFER_STATE cmFortran_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)"", ""{"", ""        YY_BUFFER_STATE b;"", ""        char *buf;"", ""        yy_size_t n;"", ""        yy_size_t i;"", ""\tYY_BUFFER_STATE b;"", ""\tchar *buf;"", ""\tyy_size_t n;"", ""\tyy_size_t i;"", """", ""        /* Get memory for full buffer, including space for trailing EOB's. */"", ""        n = _yybytes_len + 2;"", ""        buf = (char *) cmFortran_yyalloc(n ,yyscanner );"", ""        if ( ! buf )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_scan_bytes()\"" );"", ""\t/* Get memory for full buffer, including space for trailing EOB's. */"", ""\tn = (yy_size_t) _yybytes_len + 2;"", ""\tbuf = (char *) cmFortran_yyalloc(n ,yyscanner );"", ""\tif ( ! buf )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_scan_bytes()\"" );"", """", ""        for ( i = 0; i < _yybytes_len; ++i )"", ""                buf[i] = yybytes[i];"", ""\tfor ( i = 0; i < (size_t)_yybytes_len; ++i )"", ""\t\tbuf[i] = yybytes[i];"", """", ""        buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;"", ""\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;"", """", ""        b = cmFortran_yy_scan_buffer(buf,n ,yyscanner);"", ""        if ( ! b )"", ""                YY_FATAL_ERROR( \""bad buffer in cmFortran_yy_scan_bytes()\"" );"", ""\tb = cmFortran_yy_scan_buffer(buf,n ,yyscanner);"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""bad buffer in cmFortran_yy_scan_bytes()\"" );"", """", ""        /* It's okay to grow etc. this buffer, and we should throw it"", ""         * away when we're done."", ""         */"", ""        b->yy_is_our_buffer = 1;"", ""\t/* It's okay to grow etc. this buffer, and we should throw it"", ""\t * away when we're done."", ""\t */"", ""\tb->yy_is_our_buffer = 1;"", """", ""        return b;"", ""\treturn b;"", ""}"", """", ""#ifndef YY_EXIT_FAILURE"", ""#define YY_EXIT_FAILURE 2"", ""#endif"", """", ""static void yy_fatal_error (yyconst char* msg , yyscan_t)"", ""static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)"", ""{"", ""        (void) fprintf( stderr, \""%s\\n\"", msg );"", ""        exit( YY_EXIT_FAILURE );"", ""\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""\t(void)yyg;"", ""\t(void) fprintf( stderr, \""%s\\n\"", msg );"", ""\texit( YY_EXIT_FAILURE );"", ""}"", """", ""/* Redefine yyless() so it works in section 3 code. */"", """", ""#undef yyless"", ""#define yyless(n) \\"", ""        do \\"", ""                { \\"", ""                /* Undo effects of setting up yytext. */ \\"", ""\tdo \\"", ""\t\t{ \\"", ""\t\t/* Undo effects of setting up yytext. */ \\"", ""        int yyless_macro_arg = (n); \\"", ""        YY_LESS_LINENO(yyless_macro_arg);\\"", ""                yytext[yyleng] = yyg->yy_hold_char; \\"", ""                yyg->yy_c_buf_p = yytext + yyless_macro_arg; \\"", ""                yyg->yy_hold_char = *yyg->yy_c_buf_p; \\"", ""                *yyg->yy_c_buf_p = '\\0'; \\"", ""                yyleng = yyless_macro_arg; \\"", ""                } \\"", ""        while ( 0 )"", ""\t\tyytext[yyleng] = yyg->yy_hold_char; \\"", ""\t\tyyg->yy_c_buf_p = yytext + yyless_macro_arg; \\"", ""\t\tyyg->yy_hold_char = *yyg->yy_c_buf_p; \\"", ""\t\t*yyg->yy_c_buf_p = '\\0'; \\"", ""\t\tyyleng = yyless_macro_arg; \\"", ""\t\t} \\"", ""\twhile ( 0 )"", """", ""/* Accessor  methods (get/set functions) to struct members. */"", """"]","[0, 0, 0, -1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -2, 1, 1, 1, 1, 2, 0, -1, -1, 1, 1, 0, -1, 1, 0, -1, -1, -2, 1, 1, 2, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, -2, -1, 1, 1, 2, 1, 0, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[19, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [24, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [36, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""bad buffer in cmFortran_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [39, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""bad buffer in cmFortran_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [61, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""-"", ""(void) fprintf( stderr, \""%s\\n\"", msg );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""], [65, ""f506489d1ed222761f9ce752144a458290020e55"", ""Merge topic 'fortran-depend-cleanup'\n\nd28da906 cmFortranParser: Inject a newline at end-of-file when missing\n8c65a501 cmFortranParser: Revise indentation style to match rest of CMake\nf70c71c5 cmFortranLexer: Update to flex 2.6\ne11cd31f Fortran: Warn when dependency scanning fails to parse a source file"", ""Source/cmFortranLexer.cxx"", ""+"", ""(void) fprintf( stderr, \""%s\\n\"", msg );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_104_new.cpp""]]",2041,2019
"[""/* This used to be an fputs(), but since the string might contain NUL's,"", "" * we now use fwrite()."", "" */"", ""#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)"", ""#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)"", ""#endif"", """", ""/* Gets input and stuffs it into \""buf\"".  number of characters read, or YY_NULL,"", "" * is returned in \""result\""."", "" */"", ""#ifndef YY_INPUT"", ""#define YY_INPUT(buf,result,max_size) \\"", ""        if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\"", ""                { \\"", ""                int c = '*'; \\"", ""                size_t n; \\"", ""                for ( n = 0; n < max_size && \\"", ""                             (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\"", ""                        buf[n] = (char) c; \\"", ""                if ( c == '\\n' ) \\"", ""                        buf[n++] = (char) c; \\"", ""                if ( c == EOF && ferror( yyin ) ) \\"", ""                        YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""                result = n; \\"", ""                } \\"", ""        else \\"", ""                { \\"", ""                errno=0; \\"", ""                while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\"", ""                        { \\"", ""                        if( errno != EINTR) \\"", ""                                { \\"", ""                                YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""                                break; \\"", ""                                } \\"", ""                        errno=0; \\"", ""                        clearerr(yyin); \\"", ""                        } \\"", ""                }\\"", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\"", ""\t\t{ \\"", ""\t\tint c = '*'; \\"", ""\t\tsize_t n; \\"", ""\t\tfor ( n = 0; n < max_size && \\"", ""\t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\"", ""\t\t\tbuf[n] = (char) c; \\"", ""\t\tif ( c == '\\n' ) \\"", ""\t\t\tbuf[n++] = (char) c; \\"", ""\t\tif ( c == EOF && ferror( yyin ) ) \\"", ""\t\t\tYY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""\t\tresult = n; \\"", ""\t\t} \\"", ""\telse \\"", ""\t\t{ \\"", ""\t\terrno=0; \\"", ""\t\twhile ( (result = (int) fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\"", ""\t\t\t{ \\"", ""\t\t\tif( errno != EINTR) \\"", ""\t\t\t\t{ \\"", ""\t\t\t\tYY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""\t\t\t\tbreak; \\"", ""\t\t\t\t} \\"", ""\t\t\terrno=0; \\"", ""\t\t\tclearerr(yyin); \\"", ""\t\t\t} \\"", ""\t\t}\\"", ""\\"", """", ""#endif""]","[0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[22, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [32, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [49, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [59, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""]]",836,810
"[""    unput(yytext[strlen(yytext)-1]);"", ""    }"", ""}"", ""        YY_BREAK"", ""\tYY_BREAK"", ""case 8:"", ""/* rule 8 can match eol */"", ""YY_RULE_SETUP"", ""#line 106 \""cmFortranLexer.in.l\"""", ""#line 99 \""cmFortranLexer.in.l\"""", ""{"", ""  unput ('\\n');"", ""  BEGIN(INITIAL);"", ""  return UNTERMINATED_STRING;"", ""}"", ""case 9:"", ""YY_RULE_SETUP"", ""#line 112 \""cmFortranLexer.in.l\"""", ""#line 105 \""cmFortranLexer.in.l\"""", ""{"", ""  cmFortranParser_StringAppend(yyextra, yytext[0]);"", ""}"", ""        YY_BREAK"", ""\tYY_BREAK"", ""case 10:"", ""/* rule 10 can match eol */"", ""YY_RULE_SETUP"", ""#line 116 \""cmFortranLexer.in.l\"""", ""#line 109 \""cmFortranLexer.in.l\"""", ""{ return EOSTMT; } /* Treat comments like */"", ""case 11:"", ""/* rule 11 can match eol */"", ""YY_RULE_SETUP"", ""#line 117 \""cmFortranLexer.in.l\"""", ""#line 110 \""cmFortranLexer.in.l\"""", ""{ return EOSTMT; } /* empty lines */"", ""case 12:"", ""YY_RULE_SETUP"", ""#line 119 \""cmFortranLexer.in.l\"""", ""#line 112 \""cmFortranLexer.in.l\"""", ""{ return CPP_LINE_DIRECTIVE; }"", ""case 13:"", ""/* rule 13 can match eol */"", ""YY_RULE_SETUP"", ""#line 120 \""cmFortranLexer.in.l\"""", ""#line 113 \""cmFortranLexer.in.l\"""", ""{"", ""  yytext[yyleng-1] = 0;"", ""  yylvalp->string = strdup(strchr(yytext, '<')+1);"", ""  return CPP_INCLUDE_ANGLE;"", ""}"", ""case 14:"", ""YY_RULE_SETUP"", ""#line 125 \""cmFortranLexer.in.l\"""", ""#line 118 \""cmFortranLexer.in.l\"""", ""{ return CPP_INCLUDE; }"", ""case 15:"", ""YY_RULE_SETUP"", ""#line 126 \""cmFortranLexer.in.l\"""", ""#line 119 \""cmFortranLexer.in.l\"""", ""{ return F90PPR_INCLUDE; }"", ""case 16:"", ""YY_RULE_SETUP"", ""#line 127 \""cmFortranLexer.in.l\"""", ""#line 120 \""cmFortranLexer.in.l\"""", ""{ return COCO_INCLUDE; }"", ""case 17:"", ""YY_RULE_SETUP"", ""#line 129 \""cmFortranLexer.in.l\"""", ""#line 122 \""cmFortranLexer.in.l\"""", ""{ return CPP_DEFINE; }"", ""case 18:"", ""YY_RULE_SETUP"", ""#line 130 \""cmFortranLexer.in.l\"""", ""#line 123 \""cmFortranLexer.in.l\"""", ""{ return F90PPR_DEFINE; }"", ""case 19:"", ""YY_RULE_SETUP"", ""#line 132 \""cmFortranLexer.in.l\"""", ""#line 125 \""cmFortranLexer.in.l\"""", ""{ return CPP_UNDEF; }"", ""case 20:"", ""YY_RULE_SETUP"", ""#line 133 \""cmFortranLexer.in.l\"""", ""#line 126 \""cmFortranLexer.in.l\"""", ""{ return F90PPR_UNDEF; }"", ""case 21:"", ""YY_RULE_SETUP"", ""#line 135 \""cmFortranLexer.in.l\"""", ""#line 128 \""cmFortranLexer.in.l\"""", ""{ return CPP_IFDEF; }"", ""case 22:"", ""YY_RULE_SETUP"", ""#line 136 \""cmFortranLexer.in.l\"""", ""#line 129 \""cmFortranLexer.in.l\"""", ""{ return CPP_IFNDEF; }"", ""case 23:"", ""YY_RULE_SETUP"", ""#line 137 \""cmFortranLexer.in.l\"""", ""#line 130 \""cmFortranLexer.in.l\"""", ""{ return CPP_IF; }"", ""case 24:"", ""YY_RULE_SETUP"", ""#line 138 \""cmFortranLexer.in.l\"""", ""#line 131 \""cmFortranLexer.in.l\"""", ""{ return CPP_ELIF; }"", ""case 25:"", ""YY_RULE_SETUP"", ""#line 139 \""cmFortranLexer.in.l\"""", ""#line 132 \""cmFortranLexer.in.l\"""", ""{ return CPP_ELSE; }"", ""case 26:"", ""YY_RULE_SETUP"", ""#line 140 \""cmFortranLexer.in.l\"""", ""#line 133 \""cmFortranLexer.in.l\"""", ""{ return CPP_ENDIF; }"", ""case 27:"", ""YY_RULE_SETUP"", ""#line 142 \""cmFortranLexer.in.l\"""", ""#line 135 \""cmFortranLexer.in.l\"""", ""{ return F90PPR_IFDEF; }"", ""case 28:"", ""YY_RULE_SETUP"", ""#line 143 \""cmFortranLexer.in.l\"""", ""#line 136 \""cmFortranLexer.in.l\"""", ""{ return F90PPR_IFNDEF; }"", ""case 29:"", ""YY_RULE_SETUP"", ""#line 144 \""cmFortranLexer.in.l\"""", ""#line 137 \""cmFortranLexer.in.l\"""", ""{ return F90PPR_IF; }"", ""case 30:"", ""YY_RULE_SETUP"", ""#line 145 \""cmFortranLexer.in.l\"""", ""#line 138 \""cmFortranLexer.in.l\"""", ""{ return F90PPR_ELIF; }"", ""case 31:"", ""YY_RULE_SETUP"", ""#line 146 \""cmFortranLexer.in.l\"""", ""#line 139 \""cmFortranLexer.in.l\"""", ""{ return F90PPR_ELSE; }"", ""case 32:"", ""YY_RULE_SETUP"", ""#line 147 \""cmFortranLexer.in.l\"""", ""#line 140 \""cmFortranLexer.in.l\"""", ""{ return F90PPR_ENDIF; }"", ""/* Line continuations, possible involving comments.  */"", ""case 33:"", ""/* rule 33 can match eol */"", ""YY_RULE_SETUP"", ""#line 150 \""cmFortranLexer.in.l\"""", ""#line 143 \""cmFortranLexer.in.l\"""", """", ""        YY_BREAK"", ""\tYY_BREAK"", ""case 34:"", ""/* rule 34 can match eol */"", ""YY_RULE_SETUP"", ""#line 151 \""cmFortranLexer.in.l\"""", ""#line 144 \""cmFortranLexer.in.l\"""", """", ""        YY_BREAK"", ""\tYY_BREAK"", ""case 35:"", ""YY_RULE_SETUP"", ""#line 153 \""cmFortranLexer.in.l\"""", ""#line 146 \""cmFortranLexer.in.l\"""", ""{ return COMMA; }"", ""case 36:"", ""YY_RULE_SETUP"", ""#line 155 \""cmFortranLexer.in.l\"""", ""#line 148 \""cmFortranLexer.in.l\"""", ""{ return DCOLON; }"", ""case 37:"", ""/* rule 37 can match eol */"", ""YY_RULE_SETUP"", ""#line 157 \""cmFortranLexer.in.l\"""", ""#line 150 \""cmFortranLexer.in.l\"""", ""{ return GARBAGE; }"", ""case 38:"", ""YY_RULE_SETUP"", ""#line 159 \""cmFortranLexer.in.l\"""", ""#line 152 \""cmFortranLexer.in.l\"""", ""{ return ASSIGNMENT_OP; }"", ""case 39:"", ""YY_RULE_SETUP"", ""#line 161 \""cmFortranLexer.in.l\"""", ""#line 154 \""cmFortranLexer.in.l\"""", ""{"", ""  yylvalp->string = strdup(yytext);"", ""  return WORD;"", ""}"", ""case 40:"", ""YY_RULE_SETUP"", ""#line 166 \""cmFortranLexer.in.l\"""", ""#line 159 \""cmFortranLexer.in.l\"""", ""{ return GARBAGE; }"", ""case 41:"", ""/* rule 41 can match eol */"", ""YY_RULE_SETUP"", ""#line 168 \""cmFortranLexer.in.l\"""", ""#line 161 \""cmFortranLexer.in.l\"""", ""{ return EOSTMT; }"", ""case 42:"", ""YY_RULE_SETUP"", ""#line 171 \""cmFortranLexer.in.l\"""", ""#line 164 \""cmFortranLexer.in.l\"""", ""/* Ignore */"", ""        YY_BREAK"", ""\tYY_BREAK"", ""case 43:"", ""/* rule 43 can match eol */"", ""YY_RULE_SETUP"", ""#line 172 \""cmFortranLexer.in.l\"""", ""#line 165 \""cmFortranLexer.in.l\"""", ""/* Ignore line-endings preceded by \\ */"", ""        YY_BREAK"", ""\tYY_BREAK"", ""case 44:"", ""YY_RULE_SETUP"", ""#line 174 \""cmFortranLexer.in.l\"""", ""#line 167 \""cmFortranLexer.in.l\"""", ""{ return *yytext; }"", ""case YY_STATE_EOF(INITIAL):"", ""case YY_STATE_EOF(free_fmt):"", ""case YY_STATE_EOF(fixed_fmt):"", ""case YY_STATE_EOF(str_sq):"", ""case YY_STATE_EOF(str_dq):"", ""#line 176 \""cmFortranLexer.in.l\"""", ""#line 169 \""cmFortranLexer.in.l\"""", ""{"", ""  if(!cmFortranParser_FilePop(yyextra) )"", ""    {"", ""    return YY_NULL;"", ""    }"", ""}"", ""        YY_BREAK"", ""\tYY_BREAK"", ""case 45:"", ""YY_RULE_SETUP"", ""#line 183 \""cmFortranLexer.in.l\"""", ""#line 176 \""cmFortranLexer.in.l\"""", ""ECHO;"", ""        YY_BREAK"", ""#line 1291 \""cmFortranLexer.cxx\"""", """", ""        case YY_END_OF_BUFFER:"", ""                {"", ""                /* Amount of text matched not including the EOB char. */"", ""                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;"", """", ""                /* Undo the effects of YY_DO_BEFORE_ACTION. */"", ""                *yy_cp = yyg->yy_hold_char;"", ""                YY_RESTORE_YY_MORE_OFFSET"", """", ""                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )"", ""                        {"", ""                        /* We're scanning a new file or input source.  It's"", ""                         * possible that this happened because the user"", ""                         * just pointed yyin at a new source and called"", ""                         * cmFortran_yylex().  If so, then we have to assure"", ""                         * consistency between YY_CURRENT_BUFFER and our"", ""                         * globals.  Here is the right place to do so, because"", ""                         * this is the first action (other than possibly a"", ""                         * back-up) that will match for the new input source."", ""                         */"", ""                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;"", ""                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;"", ""                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;"", ""                        }"", """", ""                /* Note that here we test for yy_c_buf_p \""<=\"" to the position"", ""                 * of the first EOB in the buffer, since yy_c_buf_p will"", ""                 * already have been incremented past the NUL character"", ""                 * (since all states make transitions on EOB to the"", ""                 * end-of-buffer state).  Contrast this with the test"", ""                 * in input()."", ""                 */"", ""                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )"", ""                        { /* This was really a NUL. */"", ""                        yy_state_type yy_next_state;"", """", ""                        yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""                        yy_current_state = yy_get_previous_state( yyscanner );"", """", ""                        /* Okay, we're now positioned to make the NUL"", ""                         * transition.  We couldn't have"", ""                         * yy_get_previous_state() go ahead and do it"", ""                         * for us because it doesn't know how to deal"", ""                         * with the possibility of jamming (and we don't"", ""                         * want to build jamming into it because then it"", ""                         * will run more slowly)."", ""                         */"", """", ""                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);"", """", ""                        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""                        if ( yy_next_state )"", ""                                {"", ""                                /* Consume the NUL. */"", ""                                yy_cp = ++yyg->yy_c_buf_p;"", ""                                yy_current_state = yy_next_state;"", ""                                goto yy_match;"", ""                                }"", """", ""                        else"", ""                                {"", ""                                yy_cp = yyg->yy_c_buf_p;"", ""                                goto yy_find_action;"", ""                                }"", ""                        }"", """", ""                else switch ( yy_get_next_buffer( yyscanner ) )"", ""                        {"", ""                        case EOB_ACT_END_OF_FILE:"", ""                                {"", ""                                yyg->yy_did_buffer_switch_on_eof = 0;"", """", ""                                if ( cmFortran_yywrap(yyscanner ) )"", ""                                        {"", ""                                        /* Note: because we've taken care in"", ""                                         * yy_get_next_buffer() to have set up"", ""                                         * yytext, we can now set up"", ""                                         * yy_c_buf_p so that if some total"", ""                                         * hoser (like flex itself) wants to"", ""                                         * call the scanner after we return the"", ""                                         * YY_NULL, it'll still work - another"", ""                                         * YY_NULL will get returned."", ""                                         */"", ""                                        yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""                                        yy_act = YY_STATE_EOF(YY_START);"", ""                                        goto do_action;"", ""                                        }"", """", ""                                else"", ""                                        {"", ""                                        if ( ! yyg->yy_did_buffer_switch_on_eof )"", ""                                                YY_NEW_FILE;"", ""                                        }"", ""                                break;"", ""                                }"", """", ""                        case EOB_ACT_CONTINUE_SCAN:"", ""                                yyg->yy_c_buf_p ="", ""                                        yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""                                yy_current_state = yy_get_previous_state( yyscanner );"", """", ""                                yy_cp = yyg->yy_c_buf_p;"", ""                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""                                goto yy_match;"", """", ""                        case EOB_ACT_LAST_MATCH:"", ""                                yyg->yy_c_buf_p ="", ""                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];"", """", ""                                yy_current_state = yy_get_previous_state( yyscanner );"", """", ""                                yy_cp = yyg->yy_c_buf_p;"", ""                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""                                goto yy_find_action;"", ""                        }"", ""                break;"", ""                }"", """", ""        default:"", ""                YY_FATAL_ERROR("", ""                        \""fatal flex scanner internal error--no action found\"" );"", ""        } /* end of action switch */"", ""                } /* end of scanning one token */"", ""        } /* end of user's declarations */"", ""\tYY_BREAK"", ""#line 1276 \""cmFortranLexer.cxx\"""", """", ""\tcase YY_END_OF_BUFFER:"", ""\t\t{"", ""\t\t/* Amount of text matched not including the EOB char. */"", ""\t\tint yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;"", """", ""\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */"", ""\t\t*yy_cp = yyg->yy_hold_char;"", ""\t\tYY_RESTORE_YY_MORE_OFFSET"", """", ""\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )"", ""\t\t\t{"", ""\t\t\t/* We're scanning a new file or input source.  It's"", ""\t\t\t * possible that this happened because the user"", ""\t\t\t * just pointed yyin at a new source and called"", ""\t\t\t * cmFortran_yylex().  If so, then we have to assure"", ""\t\t\t * consistency between YY_CURRENT_BUFFER and our"", ""\t\t\t * globals.  Here is the right place to do so, because"", ""\t\t\t * this is the first action (other than possibly a"", ""\t\t\t * back-up) that will match for the new input source."", ""\t\t\t */"", ""\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;"", ""\t\t\t}"", """", ""\t\t/* Note that here we test for yy_c_buf_p \""<=\"" to the position"", ""\t\t * of the first EOB in the buffer, since yy_c_buf_p will"", ""\t\t * already have been incremented past the NUL character"", ""\t\t * (since all states make transitions on EOB to the"", ""\t\t * end-of-buffer state).  Contrast this with the test"", ""\t\t * in input()."", ""\t\t */"", ""\t\tif ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )"", ""\t\t\t{ /* This was really a NUL. */"", ""\t\t\tyy_state_type yy_next_state;"", """", ""\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t/* Okay, we're now positioned to make the NUL"", ""\t\t\t * transition.  We couldn't have"", ""\t\t\t * yy_get_previous_state() go ahead and do it"", ""\t\t\t * for us because it doesn't know how to deal"", ""\t\t\t * with the possibility of jamming (and we don't"", ""\t\t\t * want to build jamming into it because then it"", ""\t\t\t * will run more slowly)."", ""\t\t\t */"", """", ""\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);"", """", ""\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""\t\t\tif ( yy_next_state )"", ""\t\t\t\t{"", ""\t\t\t\t/* Consume the NUL. */"", ""\t\t\t\tyy_cp = ++yyg->yy_c_buf_p;"", ""\t\t\t\tyy_current_state = yy_next_state;"", ""\t\t\t\tgoto yy_match;"", ""\t\t\t\t}"", """", ""\t\t\telse"", ""\t\t\t\t{"", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tgoto yy_find_action;"", ""\t\t\t\t}"", ""\t\t\t}"", """", ""\t\telse switch ( yy_get_next_buffer( yyscanner ) )"", ""\t\t\t{"", ""\t\t\tcase EOB_ACT_END_OF_FILE:"", ""\t\t\t\t{"", ""\t\t\t\tyyg->yy_did_buffer_switch_on_eof = 0;"", """", ""\t\t\t\tif ( cmFortran_yywrap(yyscanner ) )"", ""\t\t\t\t\t{"", ""\t\t\t\t\t/* Note: because we've taken care in"", ""\t\t\t\t\t * yy_get_next_buffer() to have set up"", ""\t\t\t\t\t * yytext, we can now set up"", ""\t\t\t\t\t * yy_c_buf_p so that if some total"", ""\t\t\t\t\t * hoser (like flex itself) wants to"", ""\t\t\t\t\t * call the scanner after we return the"", ""\t\t\t\t\t * YY_NULL, it'll still work - another"", ""\t\t\t\t\t * YY_NULL will get returned."", ""\t\t\t\t\t */"", ""\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);"", ""\t\t\t\t\tgoto do_action;"", ""\t\t\t\t\t}"", """", ""\t\t\t\telse"", ""\t\t\t\t\t{"", ""\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )"", ""\t\t\t\t\t\tYY_NEW_FILE;"", ""\t\t\t\t\t}"", ""\t\t\t\tbreak;"", ""\t\t\t\t}"", """", ""\t\t\tcase EOB_ACT_CONTINUE_SCAN:"", ""\t\t\t\tyyg->yy_c_buf_p ="", ""\t\t\t\t\tyyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""\t\t\t\tgoto yy_match;"", """", ""\t\t\tcase EOB_ACT_LAST_MATCH:"", ""\t\t\t\tyyg->yy_c_buf_p ="", ""\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];"", """", ""\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""\t\t\t\tgoto yy_find_action;"", ""\t\t\t}"", ""\t\tbreak;"", ""\t\t}"", """", ""\tdefault:"", ""\t\tYY_FATAL_ERROR("", ""\t\t\t\""fatal flex scanner internal error--no action found\"" );"", ""\t} /* end of action switch */"", ""\t\t} /* end of scanning one token */"", ""\t} /* end of user's declarations */"", ""} /* end of cmFortran_yylex */"", """", ""/* yy_get_next_buffer - try to read in a new buffer"", "" *"", "" * Returns a code representing an action:"", "" *      EOB_ACT_LAST_MATCH -"", "" *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position"", "" *      EOB_ACT_END_OF_FILE - end of file"", "" *\tEOB_ACT_LAST_MATCH -"", "" *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position"", "" *\tEOB_ACT_END_OF_FILE - end of file"", "" */"", ""static int yy_get_next_buffer (yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;"", ""        char *source = yyg->yytext_ptr;"", ""        int number_to_move, i;"", ""        int ret_val;"", """", ""        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )"", ""                YY_FATAL_ERROR("", ""                \""fatal flex scanner internal error--end of buffer missed\"" );"", """", ""        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )"", ""                { /* Don't try to fill the buffer, so this is an EOF. */"", ""                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )"", ""                        {"", ""                        /* We matched a single character, the EOB, so"", ""                         * treat this as a final EOF."", ""                         */"", ""                        return EOB_ACT_END_OF_FILE;"", ""                        }"", """", ""                else"", ""                        {"", ""                        /* We matched some text prior to the EOB, first"", ""                         * process it."", ""                         */"", ""                        return EOB_ACT_LAST_MATCH;"", ""                        }"", ""                }"", """", ""        /* Try to read more data. */"", """", ""        /* First move last chars to start of buffer. */"", ""        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;"", """", ""        for ( i = 0; i < number_to_move; ++i )"", ""                *(dest++) = *(source++);"", """", ""        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )"", ""                /* don't do the read, it's not guaranteed to return an EOF,"", ""                 * just force an EOF"", ""                 */"", ""                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;"", """", ""        else"", ""                {"", ""                        yy_size_t num_to_read ="", ""                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;"", """", ""                while ( num_to_read <= 0 )"", ""                        { /* Not enough room in the buffer - grow it. */"", """", ""                        /* just a shorter name for the current buffer */"", ""                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;"", """", ""                        int yy_c_buf_p_offset ="", ""                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);"", """", ""                        if ( b->yy_is_our_buffer )"", ""                                {"", ""                                yy_size_t new_size = b->yy_buf_size * 2;"", """", ""                                if ( new_size <= 0 )"", ""                                        b->yy_buf_size += b->yy_buf_size / 8;"", ""                                else"", ""                                        b->yy_buf_size *= 2;"", """", ""                                b->yy_ch_buf = (char *)"", ""                                        /* Include room in for 2 EOB chars. */"", ""                                        cmFortran_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );"", ""                                }"", ""                        else"", ""                                /* Can't grow it, we don't own it. */"", ""                                b->yy_ch_buf = 0;"", """", ""                        if ( ! b->yy_ch_buf )"", ""                                YY_FATAL_ERROR("", ""                                \""fatal error - scanner input buffer overflow\"" );"", """", ""                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];"", """", ""                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -"", ""                                                number_to_move - 1;"", """", ""                        }"", """", ""                if ( num_to_read > YY_READ_BUF_SIZE )"", ""                        num_to_read = YY_READ_BUF_SIZE;"", """", ""                /* Read in more data. */"", ""                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),"", ""                        yyg->yy_n_chars, num_to_read );"", """", ""                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;"", ""                }"", """", ""        if ( yyg->yy_n_chars == 0 )"", ""                {"", ""                if ( number_to_move == YY_MORE_ADJ )"", ""                        {"", ""                        ret_val = EOB_ACT_END_OF_FILE;"", ""                        cmFortran_yyrestart(yyin  ,yyscanner);"", ""                        }"", """", ""                else"", ""                        {"", ""                        ret_val = EOB_ACT_LAST_MATCH;"", ""                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status ="", ""                                YY_BUFFER_EOF_PENDING;"", ""                        }"", ""                }"", """", ""        else"", ""                ret_val = EOB_ACT_CONTINUE_SCAN;"", """", ""        if ((yy_size_t) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {"", ""                /* Extend the array by 50%, plus the number we really need. */"", ""                yy_size_t new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);"", ""                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmFortran_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );"", ""                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""                        YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", ""        }"", """", ""        yyg->yy_n_chars += number_to_move;"", ""        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;"", ""        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;"", """", ""        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];"", ""\tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;"", ""\tchar *source = yyg->yytext_ptr;"", ""\tyy_size_t number_to_move, i;"", ""\tint ret_val;"", """", ""\tif ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )"", ""\t\tYY_FATAL_ERROR("", ""\t\t\""fatal flex scanner internal error--end of buffer missed\"" );"", """", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )"", ""\t\t{ /* Don't try to fill the buffer, so this is an EOF. */"", ""\t\tif ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )"", ""\t\t\t{"", ""\t\t\t/* We matched a single character, the EOB, so"", ""\t\t\t * treat this as a final EOF."", ""\t\t\t */"", ""\t\t\treturn EOB_ACT_END_OF_FILE;"", ""\t\t\t}"", """", ""\t\telse"", ""\t\t\t{"", ""\t\t\t/* We matched some text prior to the EOB, first"", ""\t\t\t * process it."", ""\t\t\t */"", ""\t\t\treturn EOB_ACT_LAST_MATCH;"", ""\t\t\t}"", ""\t\t}"", """", ""\t/* Try to read more data. */"", """", ""\t/* First move last chars to start of buffer. */"", ""\tnumber_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;"", """", ""\tfor ( i = 0; i < number_to_move; ++i )"", ""\t\t*(dest++) = *(source++);"", """", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )"", ""\t\t/* don't do the read, it's not guaranteed to return an EOF,"", ""\t\t * just force an EOF"", ""\t\t */"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;"", """", ""\telse"", ""\t\t{"", ""\t\t\tint num_to_read ="", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;"", """", ""\t\twhile ( num_to_read <= 0 )"", ""\t\t\t{ /* Not enough room in the buffer - grow it. */"", """", ""\t\t\t/* just a shorter name for the current buffer */"", ""\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;"", """", ""\t\t\tint yy_c_buf_p_offset ="", ""\t\t\t\t(int) (yyg->yy_c_buf_p - b->yy_ch_buf);"", """", ""\t\t\tif ( b->yy_is_our_buffer )"", ""\t\t\t\t{"", ""\t\t\t\tint new_size = b->yy_buf_size * 2;"", """", ""\t\t\t\tif ( new_size <= 0 )"", ""\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;"", ""\t\t\t\telse"", ""\t\t\t\t\tb->yy_buf_size *= 2;"", """", ""\t\t\t\tb->yy_ch_buf = (char *)"", ""\t\t\t\t\t/* Include room in for 2 EOB chars. */"", ""\t\t\t\t\tcmFortran_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );"", ""\t\t\t\t}"", ""\t\t\telse"", ""\t\t\t\t/* Can't grow it, we don't own it. */"", ""\t\t\t\tb->yy_ch_buf = NULL;"", """", ""\t\t\tif ( ! b->yy_ch_buf )"", ""\t\t\t\tYY_FATAL_ERROR("", ""\t\t\t\t\""fatal error - scanner input buffer overflow\"" );"", """", ""\t\t\tyyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];"", """", ""\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -"", ""\t\t\t\t\t\tnumber_to_move - 1;"", """", ""\t\t\t}"", """", ""\t\tif ( num_to_read > YY_READ_BUF_SIZE )"", ""\t\t\tnum_to_read = YY_READ_BUF_SIZE;"", """", ""\t\t/* Read in more data. */"", ""\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),"", ""\t\t\tyyg->yy_n_chars, num_to_read );"", """", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;"", ""\t\t}"", """", ""\tif ( yyg->yy_n_chars == 0 )"", ""\t\t{"", ""\t\tif ( number_to_move == YY_MORE_ADJ )"", ""\t\t\t{"", ""\t\t\tret_val = EOB_ACT_END_OF_FILE;"", ""\t\t\tcmFortran_yyrestart(yyin  ,yyscanner);"", ""\t\t\t}"", """", ""\t\telse"", ""\t\t\t{"", ""\t\t\tret_val = EOB_ACT_LAST_MATCH;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status ="", ""\t\t\t\tYY_BUFFER_EOF_PENDING;"", ""\t\t\t}"", ""\t\t}"", """", ""\telse"", ""\t\tret_val = EOB_ACT_CONTINUE_SCAN;"", """", ""\tif ((int) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {"", ""\t\t/* Extend the array by 50%, plus the number we really need. */"", ""\t\tint new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmFortran_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );"", ""\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", ""\t}"", """", ""\tyyg->yy_n_chars += number_to_move;"", ""\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;"", ""\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;"", """", ""\tyyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];"", """", ""        return ret_val;"", ""\treturn ret_val;"", ""}"", """", ""/* yy_get_previous_state - get the state just before the EOB char was reached */"", """", ""    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)"", ""{"", ""        yy_state_type yy_current_state;"", ""        char *yy_cp;"", ""\tyy_state_type yy_current_state;"", ""\tchar *yy_cp;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        yy_current_state = yyg->yy_start;"", ""        yy_current_state += YY_AT_BOL();"", """", ""        for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )"", ""                {"", ""                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);"", ""                if ( yy_accept[yy_current_state] )"", ""                        {"", ""                        yyg->yy_last_accepting_state = yy_current_state;"", ""                        yyg->yy_last_accepting_cpos = yy_cp;"", ""                        }"", ""                while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""                        {"", ""                        yy_current_state = (int) yy_def[yy_current_state];"", ""                        if ( yy_current_state >= 173 )"", ""                                yy_c = yy_meta[(unsigned int) yy_c];"", ""                        }"", ""                yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""                }"", """", ""        return yy_current_state;"", ""\tyy_current_state = yyg->yy_start;"", ""\tyy_current_state += YY_AT_BOL();"", """", ""\tfor ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )"", ""\t\t{"", ""\t\tYY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);"", ""\t\tif ( yy_accept[yy_current_state] )"", ""\t\t\t{"", ""\t\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t\t}"", ""\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t\t{"", ""\t\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\t\tif ( yy_current_state >= 173 )"", ""\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t\t}"", ""\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];"", ""\t\t}"", """", ""\treturn yy_current_state;"", ""}"", """", ""/* yy_try_NUL_trans - try to make a transition on the NUL character"", "" *"", "" * synopsis"", "" *      next_state = yy_try_NUL_trans( current_state );"", "" *\tnext_state = yy_try_NUL_trans( current_state );"", "" */"", ""    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)"", ""{"", ""        int yy_is_jam;"", ""\tint yy_is_jam;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */"", ""        char *yy_cp = yyg->yy_c_buf_p;"", """", ""        YY_CHAR yy_c = 1;"", ""        if ( yy_accept[yy_current_state] )"", ""                {"", ""                yyg->yy_last_accepting_state = yy_current_state;"", ""                yyg->yy_last_accepting_cpos = yy_cp;"", ""                }"", ""        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""                {"", ""                yy_current_state = (int) yy_def[yy_current_state];"", ""                if ( yy_current_state >= 173 )"", ""                        yy_c = yy_meta[(unsigned int) yy_c];"", ""                }"", ""        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""        yy_is_jam = (yy_current_state == 172);"", """", ""        (void)yyg;"", ""        return yy_is_jam ? 0 : yy_current_state;"", ""\tchar *yy_cp = yyg->yy_c_buf_p;"", """", ""\tYY_CHAR yy_c = 1;"", ""\tif ( yy_accept[yy_current_state] )"", ""\t\t{"", ""\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t}"", ""\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t{"", ""\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\tif ( yy_current_state >= 173 )"", ""\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t}"", ""\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];"", ""\tyy_is_jam = (yy_current_state == 172);"", """", ""\t(void)yyg;"", ""\treturn yy_is_jam ? 0 : yy_current_state;"", ""}"", """", ""#ifndef YY_NO_UNPUT"", """", ""    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)"", ""{"", ""        char *yy_cp;"", ""\tchar *yy_cp;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""    yy_cp = yyg->yy_c_buf_p;"", """", ""        /* undo effects of setting up yytext */"", ""        *yy_cp = yyg->yy_hold_char;"", ""\t/* undo effects of setting up yytext */"", ""\t*yy_cp = yyg->yy_hold_char;"", """", ""        if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )"", ""                { /* need to shift things up to make room */"", ""                /* +2 for EOB chars. */"", ""                yy_size_t number_to_move = yyg->yy_n_chars + 2;"", ""                char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf["", ""                                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];"", ""                char *source ="", ""                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];"", ""\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )"", ""\t\t{ /* need to shift things up to make room */"", ""\t\t/* +2 for EOB chars. */"", ""\t\tint number_to_move = yyg->yy_n_chars + 2;"", ""\t\tchar *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf["", ""\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];"", ""\t\tchar *source ="", ""\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];"", """", ""                while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""                        *--dest = *--source;"", ""\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""\t\t\t*--dest = *--source;"", """", ""                yy_cp += (int) (dest - source);"", ""                yy_bp += (int) (dest - source);"", ""                YY_CURRENT_BUFFER_LVALUE->yy_n_chars ="", ""                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;"", ""\t\tyy_cp += (int) (dest - source);"", ""\t\tyy_bp += (int) (dest - source);"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars ="", ""\t\t\tyyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;"", """", ""                if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )"", ""                        YY_FATAL_ERROR( \""flex scanner push-back overflow\"" );"", ""                }"", ""\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )"", ""\t\t\tYY_FATAL_ERROR( \""flex scanner push-back overflow\"" );"", ""\t\t}"", """", ""        *--yy_cp = (char) c;"", ""\t*--yy_cp = (char) c;"", """", ""        yyg->yytext_ptr = yy_bp;"", ""        yyg->yy_hold_char = *yy_cp;"", ""        yyg->yy_c_buf_p = yy_cp;"", ""\tyyg->yytext_ptr = yy_bp;"", ""\tyyg->yy_hold_char = *yy_cp;"", ""\tyyg->yy_c_buf_p = yy_cp;"", ""}"", """", ""#endif"", """", ""#ifndef YY_NO_INPUT"", ""#ifdef __cplusplus"", ""    static int yyinput (yyscan_t yyscanner)""]","[0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, -1, 1, 0, -1, 1, 0, 0, 0, -1, 1, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, -1, 1, 0, 0, 0, -1, 1, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, -1, 1, 0, 0, 0, 0, -1, -1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, -2, -1, 1, 2, 1, 0, -1, 1, 0, -1, -1, -1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0]","[[369, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [500, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [526, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [594, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [638, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [652, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [720, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [764, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [929, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""flex scanner push-back overflow\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [932, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""flex scanner push-back overflow\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""]]",1070,1044
"["" */"", ""    YY_BUFFER_STATE cmFortran_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)"", ""{"", ""        YY_BUFFER_STATE b;"", ""\tYY_BUFFER_STATE b;"", """", ""        b = (YY_BUFFER_STATE) cmFortran_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""        if ( ! b )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_create_buffer()\"" );"", ""\tb = (YY_BUFFER_STATE) cmFortran_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_create_buffer()\"" );"", """", ""        b->yy_buf_size = size;"", ""\tb->yy_buf_size = (yy_size_t)size;"", """", ""        /* yy_ch_buf has to be 2 characters longer than the size given because"", ""         * we need to put in 2 end-of-buffer characters."", ""         */"", ""        b->yy_ch_buf = (char *) cmFortran_yyalloc(b->yy_buf_size + 2 ,yyscanner );"", ""        if ( ! b->yy_ch_buf )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_create_buffer()\"" );"", ""\t/* yy_ch_buf has to be 2 characters longer than the size given because"", ""\t * we need to put in 2 end-of-buffer characters."", ""\t */"", ""\tb->yy_ch_buf = (char *) cmFortran_yyalloc(b->yy_buf_size + 2 ,yyscanner );"", ""\tif ( ! b->yy_ch_buf )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_create_buffer()\"" );"", """", ""        b->yy_is_our_buffer = 1;"", ""\tb->yy_is_our_buffer = 1;"", """", ""        cmFortran_yy_init_buffer(b,file ,yyscanner);"", ""\tcmFortran_yy_init_buffer(b,file ,yyscanner);"", """", ""        return b;"", ""\treturn b;"", ""}"", """", ""/** Destroy the buffer.""]","[0, 0, 0, -1, 1, 0, -1, -1, -2, 1, 1, 2, 0, -1, 1, 0, -1, -1, -1, -1, -1, -2, 1, 1, 1, 1, 1, 2, 0, -1, 1, 0, -1, 1, 0, -1, 1, 0, 0, 0]","[[8, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [11, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [21, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [27, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""]]",1785,1763
"[""void cmFortran_yypop_buffer_state (yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""        if (!YY_CURRENT_BUFFER)"", ""                return;"", """", ""        cmFortran_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);"", ""        YY_CURRENT_BUFFER_LVALUE = NULL;"", ""        if (yyg->yy_buffer_stack_top > 0)"", ""                --yyg->yy_buffer_stack_top;"", """", ""        if (YY_CURRENT_BUFFER) {"", ""                cmFortran_yy_load_buffer_state(yyscanner );"", ""                yyg->yy_did_buffer_switch_on_eof = 1;"", ""        }"", ""\tif (!YY_CURRENT_BUFFER)"", ""\t\treturn;"", """", ""\tcmFortran_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);"", ""\tYY_CURRENT_BUFFER_LVALUE = NULL;"", ""\tif (yyg->yy_buffer_stack_top > 0)"", ""\t\t--yyg->yy_buffer_stack_top;"", """", ""\tif (YY_CURRENT_BUFFER) {"", ""\t\tcmFortran_yy_load_buffer_state(yyscanner );"", ""\t\tyyg->yy_did_buffer_switch_on_eof = 1;"", ""\t}"", ""}"", """", ""/* Allocates the stack if it does not exist."", "" *  Guarantees space for at least one push."", "" */"", ""static void cmFortran_yyensure_buffer_stack (yyscan_t yyscanner)"", ""{"", ""        yy_size_t num_to_alloc;"", ""\tint num_to_alloc;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        if (!yyg->yy_buffer_stack) {"", ""\tif (!yyg->yy_buffer_stack) {"", """", ""                /* First allocation is just for 2 elements, since we don't know if this"", ""                 * scanner will even need a stack. We use 2 instead of 1 to avoid an"", ""                 * immediate realloc on the next call."", ""\t\t/* First allocation is just for 2 elements, since we don't know if this"", ""\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an"", ""\t\t * immediate realloc on the next call."", ""         */"", ""                num_to_alloc = 1;"", ""                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyalloc"", ""                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)"", ""                                                                , yyscanner);"", ""                if ( ! yyg->yy_buffer_stack )"", ""                        YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yyensure_buffer_stack()\"" );"", """", ""                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));"", """", ""                yyg->yy_buffer_stack_max = num_to_alloc;"", ""                yyg->yy_buffer_stack_top = 0;"", ""                return;"", ""        }"", """", ""        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){"", """", ""                /* Increase the buffer to prepare for a possible push. */"", ""                int grow_size = 8 /* arbitrary grow size */;"", """", ""                num_to_alloc = yyg->yy_buffer_stack_max + grow_size;"", ""                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyrealloc"", ""                                                                (yyg->yy_buffer_stack,"", ""                                                                num_to_alloc * sizeof(struct yy_buffer_state*)"", ""                                                                , yyscanner);"", ""                if ( ! yyg->yy_buffer_stack )"", ""                        YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yyensure_buffer_stack()\"" );"", """", ""                /* zero only the new slots.*/"", ""                memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));"", ""                yyg->yy_buffer_stack_max = num_to_alloc;"", ""        }"", ""      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */"", ""\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyalloc"", ""\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)"", ""\t\t\t\t\t\t\t\t, yyscanner);"", ""\t\tif ( ! yyg->yy_buffer_stack )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yyensure_buffer_stack()\"" );"", """", ""\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));"", """", ""\t\tyyg->yy_buffer_stack_max = num_to_alloc;"", ""\t\tyyg->yy_buffer_stack_top = 0;"", ""\t\treturn;"", ""\t}"", """", ""\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){"", """", ""\t\t/* Increase the buffer to prepare for a possible push. */"", ""\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;"", """", ""\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;"", ""\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyrealloc"", ""\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,"", ""\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)"", ""\t\t\t\t\t\t\t\t, yyscanner);"", ""\t\tif ( ! yyg->yy_buffer_stack )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yyensure_buffer_stack()\"" );"", """", ""\t\t/* zero only the new slots.*/"", ""\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));"", ""\t\tyyg->yy_buffer_stack_max = num_to_alloc;"", ""\t}"", ""}"", """", ""/** Setup the input buffer state to scan directly from a user-specified character buffer.""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 0, 0]","[[53, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [73, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [84, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [104, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""]]",1924,1902
"["" */"", ""YY_BUFFER_STATE cmFortran_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)"", ""{"", ""        YY_BUFFER_STATE b;"", """", ""        if ( size < 2 ||"", ""             base[size-2] != YY_END_OF_BUFFER_CHAR ||"", ""             base[size-1] != YY_END_OF_BUFFER_CHAR )"", ""                /* They forgot to leave room for the EOB's. */"", ""                return 0;"", """", ""        b = (YY_BUFFER_STATE) cmFortran_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""        if ( ! b )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_scan_buffer()\"" );"", """", ""        b->yy_buf_size = size - 2;      /* \""- 2\"" to take care of EOB's */"", ""        b->yy_buf_pos = b->yy_ch_buf = base;"", ""        b->yy_is_our_buffer = 0;"", ""        b->yy_input_file = 0;"", ""        b->yy_n_chars = b->yy_buf_size;"", ""        b->yy_is_interactive = 0;"", ""        b->yy_at_bol = 1;"", ""        b->yy_fill_buffer = 0;"", ""        b->yy_buffer_status = YY_BUFFER_NEW;"", """", ""        cmFortran_yy_switch_to_buffer(b ,yyscanner );"", """", ""        return b;"", ""\tYY_BUFFER_STATE b;"", """", ""\tif ( size < 2 ||"", ""\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||"", ""\t     base[size-1] != YY_END_OF_BUFFER_CHAR )"", ""\t\t/* They forgot to leave room for the EOB's. */"", ""\t\treturn NULL;"", """", ""\tb = (YY_BUFFER_STATE) cmFortran_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_scan_buffer()\"" );"", """", ""\tb->yy_buf_size = size - 2;\t/* \""- 2\"" to take care of EOB's */"", ""\tb->yy_buf_pos = b->yy_ch_buf = base;"", ""\tb->yy_is_our_buffer = 0;"", ""\tb->yy_input_file = NULL;"", ""\tb->yy_n_chars = b->yy_buf_size;"", ""\tb->yy_is_interactive = 0;"", ""\tb->yy_at_bol = 1;"", ""\tb->yy_fill_buffer = 0;"", ""\tb->yy_buffer_status = YY_BUFFER_NEW;"", """", ""\tcmFortran_yy_switch_to_buffer(b ,yyscanner );"", """", ""\treturn b;"", ""}"", """", ""/** Setup the input buffer state to scan a string. The next call to cmFortran_yylex() will""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[13, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_scan_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [38, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_scan_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""]]",1993,1971
"["" * @param yyscanner The scanner object."", "" * @return the newly allocated buffer state object."", "" */"", ""YY_BUFFER_STATE cmFortran_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)"", ""YY_BUFFER_STATE cmFortran_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)"", ""{"", ""        YY_BUFFER_STATE b;"", ""        char *buf;"", ""        yy_size_t n;"", ""        yy_size_t i;"", ""\tYY_BUFFER_STATE b;"", ""\tchar *buf;"", ""\tyy_size_t n;"", ""\tyy_size_t i;"", """", ""        /* Get memory for full buffer, including space for trailing EOB's. */"", ""        n = _yybytes_len + 2;"", ""        buf = (char *) cmFortran_yyalloc(n ,yyscanner );"", ""        if ( ! buf )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_scan_bytes()\"" );"", ""\t/* Get memory for full buffer, including space for trailing EOB's. */"", ""\tn = (yy_size_t) _yybytes_len + 2;"", ""\tbuf = (char *) cmFortran_yyalloc(n ,yyscanner );"", ""\tif ( ! buf )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_scan_bytes()\"" );"", """", ""        for ( i = 0; i < _yybytes_len; ++i )"", ""                buf[i] = yybytes[i];"", ""\tfor ( i = 0; i < (size_t)_yybytes_len; ++i )"", ""\t\tbuf[i] = yybytes[i];"", """", ""        buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;"", ""\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;"", """", ""        b = cmFortran_yy_scan_buffer(buf,n ,yyscanner);"", ""        if ( ! b )"", ""                YY_FATAL_ERROR( \""bad buffer in cmFortran_yy_scan_bytes()\"" );"", ""\tb = cmFortran_yy_scan_buffer(buf,n ,yyscanner);"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""bad buffer in cmFortran_yy_scan_bytes()\"" );"", """", ""        /* It's okay to grow etc. this buffer, and we should throw it"", ""         * away when we're done."", ""         */"", ""        b->yy_is_our_buffer = 1;"", ""\t/* It's okay to grow etc. this buffer, and we should throw it"", ""\t * away when we're done."", ""\t */"", ""\tb->yy_is_our_buffer = 1;"", """", ""        return b;"", ""\treturn b;"", ""}"", """", ""#ifndef YY_EXIT_FAILURE"", ""#define YY_EXIT_FAILURE 2"", ""#endif"", """", ""static void yy_fatal_error (yyconst char* msg , yyscan_t)"", ""static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)"", ""{"", ""        (void) fprintf( stderr, \""%s\\n\"", msg );"", ""        exit( YY_EXIT_FAILURE );"", ""\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""\t(void)yyg;"", ""\t(void) fprintf( stderr, \""%s\\n\"", msg );"", ""\texit( YY_EXIT_FAILURE );"", ""}"", """", ""/* Redefine yyless() so it works in section 3 code. */"", """", ""#undef yyless"", ""#define yyless(n) \\"", ""        do \\"", ""                { \\"", ""                /* Undo effects of setting up yytext. */ \\"", ""\tdo \\"", ""\t\t{ \\"", ""\t\t/* Undo effects of setting up yytext. */ \\"", ""        int yyless_macro_arg = (n); \\"", ""        YY_LESS_LINENO(yyless_macro_arg);\\"", ""                yytext[yyleng] = yyg->yy_hold_char; \\"", ""                yyg->yy_c_buf_p = yytext + yyless_macro_arg; \\"", ""                yyg->yy_hold_char = *yyg->yy_c_buf_p; \\"", ""                *yyg->yy_c_buf_p = '\\0'; \\"", ""                yyleng = yyless_macro_arg; \\"", ""                } \\"", ""        while ( 0 )"", ""\t\tyytext[yyleng] = yyg->yy_hold_char; \\"", ""\t\tyyg->yy_c_buf_p = yytext + yyless_macro_arg; \\"", ""\t\tyyg->yy_hold_char = *yyg->yy_c_buf_p; \\"", ""\t\t*yyg->yy_c_buf_p = '\\0'; \\"", ""\t\tyyleng = yyless_macro_arg; \\"", ""\t\t} \\"", ""\twhile ( 0 )"", """", ""/* Accessor  methods (get/set functions) to struct members. */"", """"]","[0, 0, 0, -1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -2, 1, 1, 1, 1, 2, 0, -1, -1, 1, 1, 0, -1, 1, 0, -1, -1, -2, 1, 1, 2, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, -2, -1, 1, 1, 2, 1, 0, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[19, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [24, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmFortran_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [36, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""-"", ""YY_FATAL_ERROR( \""bad buffer in cmFortran_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [39, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""+"", ""YY_FATAL_ERROR( \""bad buffer in cmFortran_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [61, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""-"", ""(void) fprintf( stderr, \""%s\\n\"", msg );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""], [65, ""f70c71c5a9759324d9e610bc919832b7500fd116"", ""cmFortranLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nAlso drop the duplicate copyright notice block from the generated file."", ""Source/cmFortranLexer.cxx"", ""+"", ""(void) fprintf( stderr, \""%s\\n\"", msg );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_105_new.cpp""]]",2041,2019
"[""  return true;"", ""}"", """", ""cmake::MessageType cmake::ConvertMessageType(cmake::MessageType t) const"", ""{"", ""  bool warningsAsErrors;"", """", ""  if (t == cmake::AUTHOR_WARNING || t == cmake::AUTHOR_ERROR) {"", ""    warningsAsErrors = this->GetDevWarningsAsErrors();"", ""    if (warningsAsErrors && t == cmake::AUTHOR_WARNING) {"", ""      t = cmake::AUTHOR_ERROR;"", ""    } else if (!warningsAsErrors && t == cmake::AUTHOR_ERROR) {"", ""      t = cmake::AUTHOR_WARNING;"", ""    }"", ""  } else if (t == cmake::DEPRECATION_WARNING ||"", ""             t == cmake::DEPRECATION_ERROR) {"", ""    warningsAsErrors = this->GetDeprecatedWarningsAsErrors();"", ""    if (warningsAsErrors && t == cmake::DEPRECATION_WARNING) {"", ""      t = cmake::DEPRECATION_ERROR;"", ""    } else if (!warningsAsErrors && t == cmake::DEPRECATION_ERROR) {"", ""      t = cmake::DEPRECATION_WARNING;"", ""    }"", ""  }"", """", ""  return t;"", ""}"", """", ""bool cmake::IsMessageTypeVisible(cmake::MessageType t) const"", ""{"", ""  bool isVisible = true;"", """", ""  if (t == cmake::DEPRECATION_ERROR) {"", ""    if (!this->GetDeprecatedWarningsAsErrors()) {"", ""      isVisible = false;"", ""    }"", ""  } else if (t == cmake::DEPRECATION_WARNING) {"", ""    if (this->GetSuppressDeprecatedWarnings()) {"", ""      isVisible = false;"", ""    }"", ""  } else if (t == cmake::AUTHOR_ERROR) {"", ""    if (!this->GetDevWarningsAsErrors()) {"", ""      isVisible = false;"", ""    }"", ""  } else if (t == cmake::AUTHOR_WARNING) {"", ""    if (this->GetSuppressDevWarnings()) {"", ""      isVisible = false;"", ""    }"", ""  }"", """", ""  return isVisible;"", ""}"", """", ""static bool printMessagePreamble(cmake::MessageType t, std::ostream& msg)"", ""{"", ""  // Construct the message header."", ""  if (t == cmake::FATAL_ERROR) {"", ""    msg << \""CMake Error\"";"", ""  } else if (t == cmake::INTERNAL_ERROR) {"", ""    msg << \""CMake Internal Error (please report a bug)\"";"", ""  } else if (t == cmake::LOG) {"", ""    msg << \""CMake Debug Log\"";"", ""  } else if (t == cmake::DEPRECATION_ERROR) {"", ""    msg << \""CMake Deprecation Error\"";"", ""  } else if (t == cmake::DEPRECATION_WARNING) {"", ""    msg << \""CMake Deprecation Warning\"";"", ""  } else if (t == cmake::AUTHOR_WARNING) {"", ""    msg << \""CMake Warning (dev)\"";"", ""  } else if (t == cmake::AUTHOR_ERROR) {"", ""    msg << \""CMake Error (dev)\"";"", ""  } else {"", ""    msg << \""CMake Warning\"";"", ""  }"", ""  return true;"", ""}"", """", ""void printMessageText(std::ostream& msg, std::string const& text)"", ""{"", ""  msg << \"":\\n\"";"", ""  cmDocumentationFormatter formatter;"", ""  formatter.SetIndent(\""  \"");"", ""  formatter.PrintFormatted(msg, text.c_str());"", ""}"", """", ""void displayMessage(cmake::MessageType t, std::ostringstream& msg)"", ""{"", """", ""  // Add a note about warning suppression."", ""  if (t == cmake::AUTHOR_WARNING) {"", ""    msg << \""This warning is for project developers.  Use -Wno-dev to suppress \"""", ""           \""it.\"";"", ""  } else if (t == cmake::AUTHOR_ERROR) {"", ""    msg << \""This error is for project developers. Use -Wno-error=dev to \"""", ""           \""suppress \"""", ""           \""it.\"";"", ""  }"", """", ""  // Add a terminating blank line."", ""  msg << \""\\n\"";"", """", ""#if defined(CMAKE_BUILD_WITH_CMAKE)"", ""  // Add a C++ stack trace to internal errors."", ""  if (t == cmake::INTERNAL_ERROR) {"", ""    std::string stack = cmsys::SystemInformation::GetProgramStack(0, 0);"", ""    if (!stack.empty()) {"", ""      if (cmHasLiteralPrefix(stack, \""WARNING:\"")) {"", ""        stack = \""Note:\"" + stack.substr(8);"", ""      }"", ""      msg << stack << \""\\n\"";"", ""    }"", ""  }"", ""#endif"", """", ""  // Output the message."", ""  if (t == cmake::FATAL_ERROR || t == cmake::INTERNAL_ERROR ||"", ""      t == cmake::DEPRECATION_ERROR || t == cmake::AUTHOR_ERROR) {"", ""    cmSystemTools::SetErrorOccured();"", ""    cmSystemTools::Message(msg.str().c_str(), \""Error\"");"", ""  } else {"", ""    cmSystemTools::Message(msg.str().c_str(), \""Warning\"");"", ""  }"", ""}"", """", ""void cmake::IssueMessage(cmake::MessageType t, std::string const& text,"", ""                         cmListFileBacktrace const& backtrace) const"", ""{"", ""  bool force = false;"", ""  // override the message type, if needed, for warnings and errors"", ""  cmake::MessageType override = this->ConvertMessageType(t);"", ""  if (override != t) {"", ""    t = override;"", ""    force = true;"", ""  }"", """", ""  if (!force && !this->IsMessageTypeVisible(t)) {"", ""    return;"", ""  }"", """", ""  this->DisplayMessage(t, text, backtrace);"", ""}"", """", ""void cmake::DisplayMessage(cmake::MessageType t, std::string const& text,"", ""                           cmListFileBacktrace const& backtrace) const"", ""{"", ""  std::ostringstream msg;"", ""  if (!printMessagePreamble(t, msg)) {"", ""    return;"", ""  }"", """", ""  // Add the immediate context."", ""  backtrace.PrintTitle(msg);"", """", ""  printMessageText(msg, text);"", """", ""  // Add the rest of the context."", ""  backtrace.PrintCallStack(msg);"", """", ""  displayMessage(t, msg);"", ""  this->Messenger->IssueMessage(t, text, backtrace);"", ""}"", """", ""std::vector<std::string> cmake::GetDebugConfigs()""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, 0, 0]","[[80, ""a79abb82fe1c90b65f124a8dd31e4a0227583ce4"", ""Merge topic 'extract-cmMessenger'\n\n1462576b Parser: Port away from cmMakefile\n421012a3 cmMessenger: Extract from cmake class\n14a8d61f cmMakefile: Port nested error logic away from cmExecutionStatus\n2af853de cmMakefile: Simplify IssueMessage implementation\n33bb9cfa Parser: Issue messages through cmake, not cmSystemTools\ndb7de303 Parser: Store the Backtrace for use in issuing messages"", ""Source/cmake.cxx"", ""-"", ""formatter.PrintFormatted(msg, text.c_str());"", 0, ""/data/download/CMake/CMake/Kitware_CMake_106_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_106_new.cpp""]]",2281,2284
"[""  return true;"", ""}"", """", ""cmake::MessageType cmake::ConvertMessageType(cmake::MessageType t) const"", ""{"", ""  bool warningsAsErrors;"", """", ""  if (t == cmake::AUTHOR_WARNING || t == cmake::AUTHOR_ERROR) {"", ""    warningsAsErrors = this->GetDevWarningsAsErrors();"", ""    if (warningsAsErrors && t == cmake::AUTHOR_WARNING) {"", ""      t = cmake::AUTHOR_ERROR;"", ""    } else if (!warningsAsErrors && t == cmake::AUTHOR_ERROR) {"", ""      t = cmake::AUTHOR_WARNING;"", ""    }"", ""  } else if (t == cmake::DEPRECATION_WARNING ||"", ""             t == cmake::DEPRECATION_ERROR) {"", ""    warningsAsErrors = this->GetDeprecatedWarningsAsErrors();"", ""    if (warningsAsErrors && t == cmake::DEPRECATION_WARNING) {"", ""      t = cmake::DEPRECATION_ERROR;"", ""    } else if (!warningsAsErrors && t == cmake::DEPRECATION_ERROR) {"", ""      t = cmake::DEPRECATION_WARNING;"", ""    }"", ""  }"", """", ""  return t;"", ""}"", """", ""bool cmake::IsMessageTypeVisible(cmake::MessageType t) const"", ""{"", ""  bool isVisible = true;"", """", ""  if (t == cmake::DEPRECATION_ERROR) {"", ""    if (!this->GetDeprecatedWarningsAsErrors()) {"", ""      isVisible = false;"", ""    }"", ""  } else if (t == cmake::DEPRECATION_WARNING) {"", ""    if (this->GetSuppressDeprecatedWarnings()) {"", ""      isVisible = false;"", ""    }"", ""  } else if (t == cmake::AUTHOR_ERROR) {"", ""    if (!this->GetDevWarningsAsErrors()) {"", ""      isVisible = false;"", ""    }"", ""  } else if (t == cmake::AUTHOR_WARNING) {"", ""    if (this->GetSuppressDevWarnings()) {"", ""      isVisible = false;"", ""    }"", ""  }"", """", ""  return isVisible;"", ""}"", """", ""static bool printMessagePreamble(cmake::MessageType t, std::ostream& msg)"", ""{"", ""  // Construct the message header."", ""  if (t == cmake::FATAL_ERROR) {"", ""    msg << \""CMake Error\"";"", ""  } else if (t == cmake::INTERNAL_ERROR) {"", ""    msg << \""CMake Internal Error (please report a bug)\"";"", ""  } else if (t == cmake::LOG) {"", ""    msg << \""CMake Debug Log\"";"", ""  } else if (t == cmake::DEPRECATION_ERROR) {"", ""    msg << \""CMake Deprecation Error\"";"", ""  } else if (t == cmake::DEPRECATION_WARNING) {"", ""    msg << \""CMake Deprecation Warning\"";"", ""  } else if (t == cmake::AUTHOR_WARNING) {"", ""    msg << \""CMake Warning (dev)\"";"", ""  } else if (t == cmake::AUTHOR_ERROR) {"", ""    msg << \""CMake Error (dev)\"";"", ""  } else {"", ""    msg << \""CMake Warning\"";"", ""  }"", ""  return true;"", ""}"", """", ""void printMessageText(std::ostream& msg, std::string const& text)"", ""{"", ""  msg << \"":\\n\"";"", ""  cmDocumentationFormatter formatter;"", ""  formatter.SetIndent(\""  \"");"", ""  formatter.PrintFormatted(msg, text.c_str());"", ""}"", """", ""void displayMessage(cmake::MessageType t, std::ostringstream& msg)"", ""{"", """", ""  // Add a note about warning suppression."", ""  if (t == cmake::AUTHOR_WARNING) {"", ""    msg << \""This warning is for project developers.  Use -Wno-dev to suppress \"""", ""           \""it.\"";"", ""  } else if (t == cmake::AUTHOR_ERROR) {"", ""    msg << \""This error is for project developers. Use -Wno-error=dev to \"""", ""           \""suppress \"""", ""           \""it.\"";"", ""  }"", """", ""  // Add a terminating blank line."", ""  msg << \""\\n\"";"", """", ""#if defined(CMAKE_BUILD_WITH_CMAKE)"", ""  // Add a C++ stack trace to internal errors."", ""  if (t == cmake::INTERNAL_ERROR) {"", ""    std::string stack = cmsys::SystemInformation::GetProgramStack(0, 0);"", ""    if (!stack.empty()) {"", ""      if (cmHasLiteralPrefix(stack, \""WARNING:\"")) {"", ""        stack = \""Note:\"" + stack.substr(8);"", ""      }"", ""      msg << stack << \""\\n\"";"", ""    }"", ""  }"", ""#endif"", """", ""  // Output the message."", ""  if (t == cmake::FATAL_ERROR || t == cmake::INTERNAL_ERROR ||"", ""      t == cmake::DEPRECATION_ERROR || t == cmake::AUTHOR_ERROR) {"", ""    cmSystemTools::SetErrorOccured();"", ""    cmSystemTools::Message(msg.str().c_str(), \""Error\"");"", ""  } else {"", ""    cmSystemTools::Message(msg.str().c_str(), \""Warning\"");"", ""  }"", ""}"", """", ""void cmake::IssueMessage(cmake::MessageType t, std::string const& text,"", ""                         cmListFileBacktrace const& backtrace) const"", ""{"", ""  bool force = false;"", ""  // override the message type, if needed, for warnings and errors"", ""  cmake::MessageType override = this->ConvertMessageType(t);"", ""  if (override != t) {"", ""    t = override;"", ""    force = true;"", ""  }"", """", ""  if (!force && !this->IsMessageTypeVisible(t)) {"", ""    return;"", ""  }"", """", ""  this->DisplayMessage(t, text, backtrace);"", ""}"", """", ""void cmake::DisplayMessage(cmake::MessageType t, std::string const& text,"", ""                           cmListFileBacktrace const& backtrace) const"", ""{"", ""  std::ostringstream msg;"", ""  if (!printMessagePreamble(t, msg)) {"", ""    return;"", ""  }"", """", ""  // Add the immediate context."", ""  backtrace.PrintTitle(msg);"", """", ""  printMessageText(msg, text);"", """", ""  // Add the rest of the context."", ""  backtrace.PrintCallStack(msg);"", """", ""  displayMessage(t, msg);"", ""  this->Messenger->IssueMessage(t, text, backtrace);"", ""}"", """", ""std::vector<std::string> cmake::GetDebugConfigs()""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, 0, 0]","[[80, ""421012a330989a64b24a3289379bb4938e6ed3ea"", ""cmMessenger: Extract from cmake class\n\nThis way messages can be issued independent of the cmake instance.\n\nIt is now possible to make DisplayMessage a virtual interface and\noverride it to handle messages in the cmake-gui or future IDE\ninteraction interfaces."", ""Source/cmake.cxx"", ""-"", ""formatter.PrintFormatted(msg, text.c_str());"", 0, ""/data/download/CMake/CMake/Kitware_CMake_107_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_107_new.cpp""]]",2281,2284
"[""  return 0;"", ""}"", """", ""void cmCursesMainForm::AddError(const char* message, const char*)"", ""void cmCursesMainForm::AddError(const char* message, const char* /*unused*/)"", ""{"", ""  this->Errors.push_back(message);"", ""}""]","[0, 0, 0, -2, 2, 0, 0, 0]","[[3, ""67a7dcef45fef6172514d6df1bea3ca94a04735a"", ""Merge topic 'readability-named-parameter'\n\ne7b842e1 Make sure unnused parameters are /*named*/"", ""Source/CursesDialog/cmCursesMainForm.cxx"", ""-"", ""void cmCursesMainForm::AddError(const char* message, const char*)"", 0, ""/data/download/CMake/CMake/Kitware_CMake_108_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_108_new.cpp""], [4, ""67a7dcef45fef6172514d6df1bea3ca94a04735a"", ""Merge topic 'readability-named-parameter'\n\ne7b842e1 Make sure unnused parameters are /*named*/"", ""Source/CursesDialog/cmCursesMainForm.cxx"", ""+"", ""void cmCursesMainForm::AddError(const char* message, const char* /*unused*/)"", 0, ""/data/download/CMake/CMake/Kitware_CMake_108_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_108_new.cpp""]]",675,675
"[""  return 0;"", ""}"", """", ""void cmCursesMainForm::AddError(const char* message, const char*)"", ""void cmCursesMainForm::AddError(const char* message, const char* /*unused*/)"", ""{"", ""  this->Errors.push_back(message);"", ""}""]","[0, 0, 0, -2, 2, 0, 0, 0]","[[3, ""e7b842e18955d13f6d9c021bab4a8935bf282744"", ""Make sure unnused parameters are /*named*/"", ""Source/CursesDialog/cmCursesMainForm.cxx"", ""-"", ""void cmCursesMainForm::AddError(const char* message, const char*)"", 0, ""/data/download/CMake/CMake/Kitware_CMake_109_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_109_new.cpp""], [4, ""e7b842e18955d13f6d9c021bab4a8935bf282744"", ""Make sure unnused parameters are /*named*/"", ""Source/CursesDialog/cmCursesMainForm.cxx"", ""+"", ""void cmCursesMainForm::AddError(const char* message, const char* /*unused*/)"", 0, ""/data/download/CMake/CMake/Kitware_CMake_109_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_109_new.cpp""]]",675,675
"[""/* returns an allocated key to find a bundle for this connection */"", ""static char *hashkey(struct connectdata *conn)"", ""{"", ""  return aprintf(\""%s:%d\"","", ""                 conn->bits.proxy?conn->proxy.name:conn->host.name,"", ""                 conn->localport);"", ""  const char *hostname;"", """", ""  if(conn->bits.proxy)"", ""    hostname = conn->proxy.name;"", ""  else if(conn->bits.conn_to_host)"", ""    hostname = conn->conn_to_host.name;"", ""  else"", ""    hostname = conn->host.name;"", """", ""  return aprintf(\""%s:%d\"", hostname, conn->port);"", ""}"", """", ""/* Look up the bundle with all the connections to the same host this""]","[0, 0, 0, -2, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0]","[[3, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/conncache.c"", ""-"", ""return aprintf(\""%s:%d\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_110_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_110_new.cpp""], [15, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/conncache.c"", ""+"", ""return aprintf(\""%s:%d\"", hostname, conn->port);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_110_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_110_new.cpp""]]",132,131
"[""      return 1; /* failure */"", ""  }"", """", ""  if(c) {"", ""    char *format_ptr;"", ""  fputs(\""# Netscape HTTP Cookie File\\n\"""", ""        \""# https://curl.haxx.se/docs/http-cookies.html\\n\"""", ""        \""# This file was generated by libcurl! Edit at your own risk.\\n\\n\"","", ""        out);"", """", ""    fputs(\""# Netscape HTTP Cookie File\\n\"""", ""          \""# http://curl.haxx.se/docs/http-cookies.html\\n\"""", ""          \""# This file was generated by libcurl! Edit at your own risk.\\n\\n\"","", ""          out);"", """", ""    for(co = c->cookies; co; co = co->next) {"", ""      if(!co->domain)"", ""        continue;"", ""      format_ptr = get_netscape_format(co);"", ""      if(format_ptr == NULL) {"", ""        fprintf(out, \""#\\n# Fatal libcurl error\\n\"");"", ""        if(!use_stdout)"", ""          fclose(out);"", ""        return 1;"", ""      }"", ""      fprintf(out, \""%s\\n\"", format_ptr);"", ""      free(format_ptr);"", ""  for(co = c->cookies; co; co = co->next) {"", ""    if(!co->domain)"", ""      continue;"", ""    format_ptr = get_netscape_format(co);"", ""    if(format_ptr == NULL) {"", ""      fprintf(out, \""#\\n# Fatal libcurl error\\n\"");"", ""      if(!use_stdout)"", ""        fclose(out);"", ""      return 1;"", ""    }"", ""    fprintf(out, \""%s\\n\"", format_ptr);"", ""    free(format_ptr);"", ""  }"", """", ""  if(!use_stdout)""]","[0, 0, 0, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -2, -1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, 2, 1, 0, 0, 0]","[[20, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/cookie.c"", ""-"", ""fprintf(out, \""#\\n# Fatal libcurl error\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_111_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_111_new.cpp""], [25, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/cookie.c"", ""-"", ""fprintf(out, \""%s\\n\"", format_ptr);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_111_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_111_new.cpp""], [32, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/cookie.c"", ""+"", ""fprintf(out, \""#\\n# Fatal libcurl error\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_111_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_111_new.cpp""], [37, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/cookie.c"", ""+"", ""fprintf(out, \""%s\\n\"", format_ptr);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_111_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_111_new.cpp""]]",1267,1301
"[""  size_t        len;   /* Name length */"", ""  unsigned int  bit;   /* Flag bit */"", ""} mechtable[] = {"", ""  { \""LOGIN\"",      5,  SASL_MECH_LOGIN },"", ""  { \""PLAIN\"",      5,  SASL_MECH_PLAIN },"", ""  { \""CRAM-MD5\"",   8,  SASL_MECH_CRAM_MD5 },"", ""  { \""DIGEST-MD5\"", 10, SASL_MECH_DIGEST_MD5 },"", ""  { \""GSSAPI\"",     6,  SASL_MECH_GSSAPI },"", ""  { \""EXTERNAL\"",   8,  SASL_MECH_EXTERNAL },"", ""  { \""NTLM\"",       4,  SASL_MECH_NTLM },"", ""  { \""XOAUTH2\"",    7,  SASL_MECH_XOAUTH2 },"", ""  { ZERO_NULL,    0,  0 }"", ""  { \""LOGIN\"",        5,  SASL_MECH_LOGIN },"", ""  { \""PLAIN\"",        5,  SASL_MECH_PLAIN },"", ""  { \""CRAM-MD5\"",     8,  SASL_MECH_CRAM_MD5 },"", ""  { \""DIGEST-MD5\"",   10, SASL_MECH_DIGEST_MD5 },"", ""  { \""GSSAPI\"",       6,  SASL_MECH_GSSAPI },"", ""  { \""EXTERNAL\"",     8,  SASL_MECH_EXTERNAL },"", ""  { \""NTLM\"",         4,  SASL_MECH_NTLM },"", ""  { \""XOAUTH2\"",      7,  SASL_MECH_XOAUTH2 },"", ""  { \""OAUTHBEARER\"",  11, SASL_MECH_OAUTHBEARER },"", ""  { ZERO_NULL,      0,  0 }"", ""};"", """", ""#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)"", ""#define DIGEST_QOP_VALUE_AUTH             (1 << 0)"", ""#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)"", ""#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)"", """", ""#define DIGEST_QOP_VALUE_STRING_AUTH      \""auth\"""", ""#define DIGEST_QOP_VALUE_STRING_AUTH_INT  \""auth-int\"""", ""#define DIGEST_QOP_VALUE_STRING_AUTH_CONF \""auth-conf\"""", """", ""/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines."", ""   It converts digest text to ASCII so the MD5 will be correct for"", ""   what ultimately goes over the network."", ""*/"", ""#define CURL_OUTPUT_DIGEST_CONV(a, b) \\"", ""  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \\"", ""  if(result) { \\"", ""    free(b); \\"", ""    return result; \\"", ""  }"", """", ""#endif"", """", ""#if !defined(CURL_DISABLE_CRYPTO_AUTH)"", ""/*"", "" * Returns 0 on success and then the buffers are filled in fine."", "" *"", "" * Non-zero means failure to parse."", "" */"", ""int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,"", ""                              const char **endptr)"", ""{"", ""  int c;"", ""  bool starts_with_quote = FALSE;"", ""  bool escape = FALSE;"", """", ""  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )"", ""    *value++ = *str++;"", ""  *value = 0;"", """", ""  if('=' != *str++)"", ""    /* eek, no match */"", ""    return 1;"", """", ""  if('\\\""' == *str) {"", ""    /* this starts with a quote so it must end with one as well! */"", ""    str++;"", ""    starts_with_quote = TRUE;"", ""  }"", """", ""  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; str++) {"", ""    switch(*str) {"", ""    case '\\\\':"", ""      if(!escape) {"", ""        /* possibly the start of an escaped quote */"", ""        escape = TRUE;"", ""        *content++ = '\\\\'; /* even though this is an escape character, we still"", ""                              store it as-is in the target buffer */"", ""        continue;"", ""      }"", ""      break;"", ""    case ',':"", ""      if(!starts_with_quote) {"", ""        /* this signals the end of the content if we didn't get a starting"", ""           quote and then we do \""sloppy\"" parsing */"", ""        c = 0; /* the end */"", ""        continue;"", ""      }"", ""      break;"", ""    case '\\r':"", ""    case '\\n':"", ""      /* end of string */"", ""      c = 0;"", ""      continue;"", ""    case '\\\""':"", ""      if(!escape && starts_with_quote) {"", ""        /* end of string */"", ""        c = 0;"", ""        continue;"", ""      }"", ""      break;"", ""    }"", ""    escape = FALSE;"", ""    *content++ = *str;"", ""  }"", ""  *content = 0;"", """", ""  *endptr = str;"", """", ""  return 0; /* all is fine! */"", ""}"", ""#endif"", """", ""#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)"", ""/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/"", ""static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */"", ""                                     unsigned char *dest) /* 33 bytes */"", ""{"", ""  int i;"", ""  for(i = 0; i < 16; i++)"", ""    snprintf((char *)&dest[i*2], 3, \""%02x\"", source[i]);"", ""}"", """", ""/* Perform quoted-string escaping as described in RFC2616 and its errata */"", ""static char *sasl_digest_string_quoted(const char *source)"", ""{"", ""  char *dest, *d;"", ""  const char *s = source;"", ""  size_t n = 1; /* null terminator */"", """", ""  /* Calculate size needed */"", ""  while(*s) {"", ""    ++n;"", ""    if(*s == '\""' || *s == '\\\\') {"", ""      ++n;"", ""    }"", ""    ++s;"", ""  }"", """", ""  dest = malloc(n);"", ""  if(dest) {"", ""    s = source;"", ""    d = dest;"", ""    while(*s) {"", ""      if(*s == '\""' || *s == '\\\\') {"", ""        *d++ = '\\\\';"", ""      }"", ""      *d++ = *s++;"", ""    }"", ""    *d = 0;"", ""  }"", """", ""  return dest;"", ""}"", """", ""/* Retrieves the value for a corresponding key from the challenge string"", "" * returns TRUE if the key could be found, FALSE if it does not exists"", "" */"", ""static bool sasl_digest_get_key_value(const char *chlg,"", ""                                      const char *key,"", ""                                      char *value,"", ""                                      size_t max_val_len,"", ""                                      char end_char)"", ""{"", ""  char *find_pos;"", ""  size_t i;"", """", ""  find_pos = strstr(chlg, key);"", ""  if(!find_pos)"", ""    return FALSE;"", """", ""  find_pos += strlen(key);"", """", ""  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ++i)"", ""    value[i] = *find_pos++;"", ""  value[i] = '\\0';"", """", ""  return TRUE;"", ""}"", """", ""static CURLcode sasl_digest_get_qop_values(const char *options, int *value)"", ""{"", ""  char *tmp;"", ""  char *token;"", ""  char *tok_buf;"", """", ""  /* Initialise the output */"", ""  *value = 0;"", """", ""  /* Tokenise the list of qop values. Use a temporary clone of the buffer since"", ""     strtok_r() ruins it. */"", ""  tmp = strdup(options);"", ""  if(!tmp)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  token = strtok_r(tmp, \"",\"", &tok_buf);"", ""  while(token != NULL) {"", ""    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))"", ""      *value |= DIGEST_QOP_VALUE_AUTH;"", ""    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))"", ""      *value |= DIGEST_QOP_VALUE_AUTH_INT;"", ""    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))"", ""      *value |= DIGEST_QOP_VALUE_AUTH_CONF;"", """", ""    token = strtok_r(NULL, \"",\"", &tok_buf);"", ""  }"", """", ""  free(tmp);"", """", ""  return CURLE_OK;"", ""}"", ""#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */"", """", ""#if !defined(USE_WINDOWS_SSPI)"", ""/*"", "" * Curl_sasl_build_spn()"", "" *"", "" * This is used to build a SPN string in the format service/host."", "" *"", "" * Parameters:"", "" *"", "" * service  [in] - The service type such as www, smtp, pop or imap."", "" * host     [in] - The host name or realm."", "" *"", "" * Returns a pointer to the newly allocated SPN."", "" */"", ""char *Curl_sasl_build_spn(const char *service, const char *host)"", ""{"", ""  /* Generate and return our SPN */"", ""  return aprintf(\""%s/%s\"", service, host);"", ""}"", ""#endif"", """", ""/*"", "" * sasl_create_plain_message()"", "" *"", "" * This is used to generate an already encoded PLAIN message ready"", "" * for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * userp   [in]     - The user name."", "" * passdwp [in]     - The user's password."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_plain_message(struct SessionHandle *data,"", ""                                          const char *userp,"", ""                                          const char *passwdp,"", ""                                          char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result;"", ""  char *plainauth;"", ""  size_t ulen;"", ""  size_t plen;"", """", ""  ulen = strlen(userp);"", ""  plen = strlen(passwdp);"", """", ""  plainauth = malloc(2 * ulen + plen + 2);"", ""  if(!plainauth) {"", ""    *outlen = 0;"", ""    *outptr = NULL;"", ""    return CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  /* Calculate the reply */"", ""  memcpy(plainauth, userp, ulen);"", ""  plainauth[ulen] = '\\0';"", ""  memcpy(plainauth + ulen + 1, userp, ulen);"", ""  plainauth[2 * ulen + 1] = '\\0';"", ""  memcpy(plainauth + 2 * ulen + 2, passwdp, plen);"", """", ""  /* Base64 encode the reply */"", ""  result = Curl_base64_encode(data, plainauth, 2 * ulen + plen + 2, outptr,"", ""                              outlen);"", ""  free(plainauth);"", ""  return result;"", ""}"", """", ""/*"", "" * sasl_create_login_message()"", "" *"", "" * This is used to generate an already encoded LOGIN message containing the"", "" * user name or password ready for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * valuep  [in]     - The user name or user's password."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_login_message(struct SessionHandle *data,"", ""                                          const char *valuep, char **outptr,"", ""                                          size_t *outlen)"", ""{"", ""  size_t vlen = strlen(valuep);"", """", ""  if(!vlen) {"", ""    /* Calculate an empty reply */"", ""    *outptr = strdup(\""=\"");"", ""    if(*outptr) {"", ""      *outlen = (size_t) 1;"", ""      return CURLE_OK;"", ""    }"", """", ""    *outlen = 0;"", ""    return CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  /* Base64 encode the value */"", ""  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);"", ""}"", """", ""/*"", "" * sasl_create_external_message()"", "" *"", "" * This is used to generate an already encoded EXTERNAL message containing"", "" * the user name ready for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * user    [in]     - The user name."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_external_message(struct SessionHandle *data,"", ""                                             const char *user, char **outptr,"", ""                                             size_t *outlen)"", ""{"", ""  /* This is the same formatting as the login message. */"", ""  return sasl_create_login_message(data, user, outptr, outlen);"", ""}"", """", ""#ifndef CURL_DISABLE_CRYPTO_AUTH"", "" /*"", "" * sasl_decode_cram_md5_message()"", "" *"", "" * This is used to decode an already encoded CRAM-MD5 challenge message."", "" *"", "" * Parameters:"", "" *"", "" * chlg64  [in]     - The base64 encoded challenge message."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,"", ""                                             size_t *outlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  size_t chlg64len = strlen(chlg64);"", """", ""  *outptr = NULL;"", ""  *outlen = 0;"", """", ""  /* Decode the challenge if necessary */"", ""  if(chlg64len && *chlg64 != '=')"", ""    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);"", """", ""    return result;"", "" }"", """", "" /*"", "" * sasl_create_cram_md5_message()"", "" *"", "" * This is used to generate an already encoded CRAM-MD5 response message ready"", "" * for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * chlg    [in]     - The challenge."", "" * userp   [in]     - The user name."", "" * passdwp [in]     - The user's password."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,"", ""                                             const char *chlg,"", ""                                             const char *userp,"", ""                                             const char *passwdp,"", ""                                             char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  size_t chlglen = 0;"", ""  HMAC_context *ctxt;"", ""  unsigned char digest[MD5_DIGEST_LEN];"", ""  char *response;"", """", ""  if(chlg)"", ""    chlglen = strlen(chlg);"", """", ""  /* Compute the digest using the password as the key */"", ""  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,"", ""                        (const unsigned char *) passwdp,"", ""                        curlx_uztoui(strlen(passwdp)));"", ""  if(!ctxt)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Update the digest with the given challenge */"", ""  if(chlglen > 0)"", ""    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,"", ""                     curlx_uztoui(chlglen));"", """", ""  /* Finalise the digest */"", ""  Curl_HMAC_final(ctxt, digest);"", """", ""  /* Generate the response */"", ""  response = aprintf("", ""      \""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\"","", ""           userp, digest[0], digest[1], digest[2], digest[3], digest[4],"", ""           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],"", ""           digest[11], digest[12], digest[13], digest[14], digest[15]);"", ""  if(!response)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Base64 encode the response */"", ""  result = Curl_base64_encode(data, response, 0, outptr, outlen);"", """", ""  free(response);"", """", ""  return result;"", ""}"", """", ""#ifndef USE_WINDOWS_SSPI"", ""/*"", "" * sasl_decode_digest_md5_message()"", "" *"", "" * This is used internally to decode an already encoded DIGEST-MD5 challenge"", "" * message into the seperate attributes."", "" *"", "" * Parameters:"", "" *"", "" * chlg64  [in]     - The base64 encoded challenge message."", "" * nonce   [in/out] - The buffer where the nonce will be stored."", "" * nlen    [in]     - The length of the nonce buffer."", "" * realm   [in/out] - The buffer where the realm will be stored."", "" * rlen    [in]     - The length of the realm buffer."", "" * alg     [in/out] - The buffer where the algorithm will be stored."", "" * alen    [in]     - The length of the algorithm buffer."", "" * qop     [in/out] - The buffer where the qop-options will be stored."", "" * qlen    [in]     - The length of the qop buffer."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_decode_digest_md5_message(const char *chlg64,"", ""                                               char *nonce, size_t nlen,"", ""                                               char *realm, size_t rlen,"", ""                                               char *alg, size_t alen,"", ""                                               char *qop, size_t qlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  unsigned char *chlg = NULL;"", ""  size_t chlglen = 0;"", ""  size_t chlg64len = strlen(chlg64);"", """", ""  /* Decode the base-64 encoded challenge message */"", ""  if(chlg64len && *chlg64 != '=') {"", ""    result = Curl_base64_decode(chlg64, &chlg, &chlglen);"", ""    if(result)"", ""      return result;"", ""  }"", """", ""  /* Ensure we have a valid challenge message */"", ""  if(!chlg)"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  /* Retrieve nonce string from the challenge */"", ""  if(!sasl_digest_get_key_value((char *)chlg, \""nonce=\\\""\"", nonce, nlen, '\\\""')) {"", ""    free(chlg);"", ""    return CURLE_BAD_CONTENT_ENCODING;"", ""  }"", """", ""  /* Retrieve realm string from the challenge */"", ""  if(!sasl_digest_get_key_value((char *)chlg, \""realm=\\\""\"", realm, rlen, '\\\""')) {"", ""    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */"", ""    strcpy(realm, \""\"");"", ""  }"", """", ""  /* Retrieve algorithm string from the challenge */"", ""  if(!sasl_digest_get_key_value((char *)chlg, \""algorithm=\"", alg, alen, ',')) {"", ""    free(chlg);"", ""    return CURLE_BAD_CONTENT_ENCODING;"", ""  }"", """", ""  /* Retrieve qop-options string from the challenge */"", ""  if(!sasl_digest_get_key_value((char *)chlg, \""qop=\\\""\"", qop, qlen, '\\\""')) {"", ""    free(chlg);"", ""    return CURLE_BAD_CONTENT_ENCODING;"", ""  }"", """", ""  free(chlg);"", """", ""  return CURLE_OK;"", ""}"", """", ""/*"", "" * Curl_sasl_create_digest_md5_message()"", "" *"", "" * This is used to generate an already encoded DIGEST-MD5 response message"", "" * ready for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * chlg64  [in]     - The base64 encoded challenge message."", "" * userp   [in]     - The user name."", "" * passdwp [in]     - The user's password."", "" * service [in]     - The service type such as www, smtp, pop or imap."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,"", ""                                             const char *chlg64,"", ""                                             const char *userp,"", ""                                             const char *passwdp,"", ""                                             const char *service,"", ""                                             char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  size_t i;"", ""  MD5_context *ctxt;"", ""  char *response = NULL;"", ""  unsigned char digest[MD5_DIGEST_LEN];"", ""  char HA1_hex[2 * MD5_DIGEST_LEN + 1];"", ""  char HA2_hex[2 * MD5_DIGEST_LEN + 1];"", ""  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];"", ""  char nonce[64];"", ""  char realm[128];"", ""  char algorithm[64];"", ""  char qop_options[64];"", ""  int qop_values;"", ""  char cnonce[33];"", ""  unsigned int entropy[4];"", ""  char nonceCount[] = \""00000001\"";"", ""  char method[]     = \""AUTHENTICATE\"";"", ""  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;"", ""  char *spn         = NULL;"", """", ""  /* Decode the challange message */"", ""  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),"", ""                                          realm, sizeof(realm),"", ""                                          algorithm, sizeof(algorithm),"", ""                                          qop_options, sizeof(qop_options));"", ""  if(result)"", ""    return result;"", """", ""  /* We only support md5 sessions */"", ""  if(strcmp(algorithm, \""md5-sess\"") != 0)"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  /* Get the qop-values from the qop-options */"", ""  result = sasl_digest_get_qop_values(qop_options, &qop_values);"", ""  if(result)"", ""    return result;"", """", ""  /* We only support auth quality-of-protection */"", ""  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  /* Generate 16 bytes of random data */"", ""  entropy[0] = Curl_rand(data);"", ""  entropy[1] = Curl_rand(data);"", ""  entropy[2] = Curl_rand(data);"", ""  entropy[3] = Curl_rand(data);"", """", ""  /* Convert the random data into a 32 byte hex string */"", ""  snprintf(cnonce, sizeof(cnonce), \""%08x%08x%08x%08x\"","", ""           entropy[0], entropy[1], entropy[2], entropy[3]);"", """", ""  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */"", ""  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);"", ""  if(!ctxt)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) userp,"", ""                  curlx_uztoui(strlen(userp)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) realm,"", ""                  curlx_uztoui(strlen(realm)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,"", ""                  curlx_uztoui(strlen(passwdp)));"", ""  Curl_MD5_final(ctxt, digest);"", """", ""  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);"", ""  if(!ctxt)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) nonce,"", ""                  curlx_uztoui(strlen(nonce)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,"", ""                  curlx_uztoui(strlen(cnonce)));"", ""  Curl_MD5_final(ctxt, digest);"", """", ""  /* Convert calculated 16 octet hex into 32 bytes string */"", ""  for(i = 0; i < MD5_DIGEST_LEN; i++)"", ""    snprintf(&HA1_hex[2 * i], 3, \""%02x\"", digest[i]);"", """", ""  /* Generate our SPN */"", ""  spn = Curl_sasl_build_spn(service, realm);"", ""  if(!spn)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Calculate H(A2) */"", ""  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);"", ""  if(!ctxt) {"", ""    free(spn);"", """", ""    return CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) method,"", ""                  curlx_uztoui(strlen(method)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) spn,"", ""                  curlx_uztoui(strlen(spn)));"", ""  Curl_MD5_final(ctxt, digest);"", """", ""  for(i = 0; i < MD5_DIGEST_LEN; i++)"", ""    snprintf(&HA2_hex[2 * i], 3, \""%02x\"", digest[i]);"", """", ""  /* Now calculate the response hash */"", ""  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);"", ""  if(!ctxt) {"", ""    free(spn);"", """", ""    return CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) nonce,"", ""                  curlx_uztoui(strlen(nonce)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,"", ""                  curlx_uztoui(strlen(nonceCount)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,"", ""                  curlx_uztoui(strlen(cnonce)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) qop,"", ""                  curlx_uztoui(strlen(qop)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);"", ""  Curl_MD5_final(ctxt, digest);"", """", ""  for(i = 0; i < MD5_DIGEST_LEN; i++)"", ""    snprintf(&resp_hash_hex[2 * i], 3, \""%02x\"", digest[i]);"", """", ""  /* Generate the response */"", ""  response = aprintf(\""username=\\\""%s\\\"",realm=\\\""%s\\\"",nonce=\\\""%s\\\"",\"""", ""                     \""cnonce=\\\""%s\\\"",nc=\\\""%s\\\"",digest-uri=\\\""%s\\\"",response=%s,\"""", ""                     \""qop=%s\"","", ""                     userp, realm, nonce,"", ""                     cnonce, nonceCount, spn, resp_hash_hex, qop);"", ""  free(spn);"", ""  if(!response)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Base64 encode the response */"", ""  result = Curl_base64_encode(data, response, 0, outptr, outlen);"", """", ""  free(response);"", """", ""  return result;"", ""}"", """", ""/*"", "" * Curl_sasl_decode_digest_http_message()"", "" *"", "" * This is used to decode a HTTP DIGEST challenge message into the seperate"", "" * attributes."", "" *"", "" * Parameters:"", "" *"", "" * chlg    [in]     - The challenge message."", "" * digest  [in/out] - The digest data struct being used and modified."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,"", ""                                              struct digestdata *digest)"", ""{"", ""  bool before = FALSE; /* got a nonce before */"", ""  bool foundAuth = FALSE;"", ""  bool foundAuthInt = FALSE;"", ""  char *token = NULL;"", ""  char *tmp = NULL;"", """", ""  /* If we already have received a nonce, keep that in mind */"", ""  if(digest->nonce)"", ""    before = TRUE;"", """", ""  /* Clean up any former leftovers and initialise to defaults */"", ""  Curl_sasl_digest_cleanup(digest);"", """", ""  for(;;) {"", ""    char value[DIGEST_MAX_VALUE_LENGTH];"", ""    char content[DIGEST_MAX_CONTENT_LENGTH];"", """", ""    /* Pass all additional spaces here */"", ""    while(*chlg && ISSPACE(*chlg))"", ""      chlg++;"", """", ""    /* Extract a value=content pair */"", ""    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {"", ""      if(Curl_raw_equal(value, \""nonce\"")) {"", ""        digest->nonce = strdup(content);"", ""        if(!digest->nonce)"", ""          return CURLE_OUT_OF_MEMORY;"", ""      }"", ""      else if(Curl_raw_equal(value, \""stale\"")) {"", ""        if(Curl_raw_equal(content, \""true\"")) {"", ""          digest->stale = TRUE;"", ""          digest->nc = 1; /* we make a new nonce now */"", ""        }"", ""      }"", ""      else if(Curl_raw_equal(value, \""realm\"")) {"", ""        digest->realm = strdup(content);"", ""        if(!digest->realm)"", ""          return CURLE_OUT_OF_MEMORY;"", ""      }"", ""      else if(Curl_raw_equal(value, \""opaque\"")) {"", ""        digest->opaque = strdup(content);"", ""        if(!digest->opaque)"", ""          return CURLE_OUT_OF_MEMORY;"", ""      }"", ""      else if(Curl_raw_equal(value, \""qop\"")) {"", ""        char *tok_buf;"", ""        /* Tokenize the list and choose auth if possible, use a temporary"", ""            clone of the buffer since strtok_r() ruins it */"", ""        tmp = strdup(content);"", ""        if(!tmp)"", ""          return CURLE_OUT_OF_MEMORY;"", """", ""        token = strtok_r(tmp, \"",\"", &tok_buf);"", ""        while(token != NULL) {"", ""          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {"", ""            foundAuth = TRUE;"", ""          }"", ""          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {"", ""            foundAuthInt = TRUE;"", ""          }"", ""          token = strtok_r(NULL, \"",\"", &tok_buf);"", ""        }"", """", ""        free(tmp);"", """", ""        /* Select only auth or auth-int. Otherwise, ignore */"", ""        if(foundAuth) {"", ""          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);"", ""          if(!digest->qop)"", ""            return CURLE_OUT_OF_MEMORY;"", ""        }"", ""        else if(foundAuthInt) {"", ""          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);"", ""          if(!digest->qop)"", ""            return CURLE_OUT_OF_MEMORY;"", ""        }"", ""      }"", ""      else if(Curl_raw_equal(value, \""algorithm\"")) {"", ""        digest->algorithm = strdup(content);"", ""        if(!digest->algorithm)"", ""          return CURLE_OUT_OF_MEMORY;"", """", ""        if(Curl_raw_equal(content, \""MD5-sess\""))"", ""          digest->algo = CURLDIGESTALGO_MD5SESS;"", ""        else if(Curl_raw_equal(content, \""MD5\""))"", ""          digest->algo = CURLDIGESTALGO_MD5;"", ""        else"", ""          return CURLE_BAD_CONTENT_ENCODING;"", ""      }"", ""      else {"", ""        /* unknown specifier, ignore it! */"", ""      }"", ""    }"", ""    else"", ""      break; /* we're done here */"", """", ""    /* Pass all additional spaces here */"", ""    while(*chlg && ISSPACE(*chlg))"", ""      chlg++;"", """", ""    /* Allow the list to be comma-separated */"", ""    if(',' == *chlg)"", ""      chlg++;"", ""  }"", """", ""  /* We had a nonce since before, and we got another one now without"", ""     'stale=true'. This means we provided bad credentials in the previous"", ""     request */"", ""  if(before && !digest->stale)"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  /* We got this header without a nonce, that's a bad Digest line! */"", ""  if(!digest->nonce)"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  return CURLE_OK;"", ""}"", """", ""/*"", "" * Curl_sasl_create_digest_http_message()"", "" *"", "" * This is used to generate a HTTP DIGEST response message ready for sending"", "" * to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * userp   [in]     - The user name."", "" * passdwp [in]     - The user's password."", "" * request [in]     - The HTTP request."", "" * uripath [in]     - The path of the HTTP uri."", "" * digest  [in/out] - The digest data struct being used and modified."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,"", ""                                              const char *userp,"", ""                                              const char *passwdp,"", ""                                              const unsigned char *request,"", ""                                              const unsigned char *uripath,"", ""                                              struct digestdata *digest,"", ""                                              char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result;"", ""  unsigned char md5buf[16]; /* 16 bytes/128 bits */"", ""  unsigned char request_digest[33];"", ""  unsigned char *md5this;"", ""  unsigned char ha1[33];/* 32 digits and 1 zero byte */"", ""  unsigned char ha2[33];/* 32 digits and 1 zero byte */"", ""  char cnoncebuf[33];"", ""  char *cnonce = NULL;"", ""  size_t cnonce_sz = 0;"", ""  char *userp_quoted;"", ""  char *response = NULL;"", ""  char *tmp = NULL;"", """", ""  if(!digest->nc)"", ""    digest->nc = 1;"", """", ""  if(!digest->cnonce) {"", ""    snprintf(cnoncebuf, sizeof(cnoncebuf), \""%08x%08x%08x%08x\"","", ""             Curl_rand(data), Curl_rand(data),"", ""             Curl_rand(data), Curl_rand(data));"", """", ""    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),"", ""                                &cnonce, &cnonce_sz);"", ""    if(result)"", ""      return result;"", """", ""    digest->cnonce = cnonce;"", ""  }"", """", ""  /*"", ""    if the algorithm is \""MD5\"" or unspecified (which then defaults to MD5):"", """", ""    A1 = unq(username-value) \"":\"" unq(realm-value) \"":\"" passwd"", """", ""    if the algorithm is \""MD5-sess\"" then:"", """", ""    A1 = H( unq(username-value) \"":\"" unq(realm-value) \"":\"" passwd )"", ""         \"":\"" unq(nonce-value) \"":\"" unq(cnonce-value)"", ""  */"", """", ""  md5this = (unsigned char *)"", ""    aprintf(\""%s:%s:%s\"", userp, digest->realm, passwdp);"", ""  if(!md5this)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */"", ""  Curl_md5it(md5buf, md5this);"", ""  free(md5this);"", ""  sasl_digest_md5_to_ascii(md5buf, ha1);"", """", ""  if(digest->algo == CURLDIGESTALGO_MD5SESS) {"", ""    /* nonce and cnonce are OUTSIDE the hash */"", ""    tmp = aprintf(\""%s:%s:%s\"", ha1, digest->nonce, digest->cnonce);"", ""    if(!tmp)"", ""      return CURLE_OUT_OF_MEMORY;"", """", ""    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */"", ""    Curl_md5it(md5buf, (unsigned char *)tmp);"", ""    free(tmp);"", ""    sasl_digest_md5_to_ascii(md5buf, ha1);"", ""  }"", """", ""  /*"", ""    If the \""qop\"" directive's value is \""auth\"" or is unspecified, then A2 is:"", """", ""      A2       = Method \"":\"" digest-uri-value"", """", ""          If the \""qop\"" value is \""auth-int\"", then A2 is:"", """", ""      A2       = Method \"":\"" digest-uri-value \"":\"" H(entity-body)"", """", ""    (The \""Method\"" value is the HTTP request method as specified in section"", ""    5.1.1 of RFC 2616)"", ""  */"", """", ""  md5this = (unsigned char *)aprintf(\""%s:%s\"", request, uripath);"", """", ""  if(digest->qop && Curl_raw_equal(digest->qop, \""auth-int\"")) {"", ""    /* We don't support auth-int for PUT or POST at the moment."", ""       TODO: replace md5 of empty string with entity-body for PUT/POST */"", ""    unsigned char *md5this2 = (unsigned char *)"", ""      aprintf(\""%s:%s\"", md5this, \""d41d8cd98f00b204e9800998ecf8427e\"");"", ""    free(md5this);"", ""    md5this = md5this2;"", ""  }"", """", ""  if(!md5this)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */"", ""  Curl_md5it(md5buf, md5this);"", ""  free(md5this);"", ""  sasl_digest_md5_to_ascii(md5buf, ha2);"", """", ""  if(digest->qop) {"", ""    md5this = (unsigned char *)aprintf(\""%s:%s:%08x:%s:%s:%s\"","", ""                                       ha1,"", ""                                       digest->nonce,"", ""                                       digest->nc,"", ""                                       digest->cnonce,"", ""                                       digest->qop,"", ""                                       ha2);"", ""  }"", ""  else {"", ""    md5this = (unsigned char *)aprintf(\""%s:%s:%s\"","", ""                                       ha1,"", ""                                       digest->nonce,"", ""                                       ha2);"", ""  }"", """", ""  if(!md5this)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */"", ""  Curl_md5it(md5buf, md5this);"", ""  free(md5this);"", ""  sasl_digest_md5_to_ascii(md5buf, request_digest);"", """", ""  /* for test case 64 (snooped from a Mozilla 1.3a request)"", """", ""    Authorization: Digest username=\""testuser\"", realm=\""testrealm\"", \\"", ""    nonce=\""1053604145\"", uri=\""/64\"", response=\""c55f7f30d83d774a3d2dcacf725abaca\"""", """", ""    Digest parameters are all quoted strings.  Username which is provided by"", ""    the user will need double quotes and backslashes within it escaped.  For"", ""    the other fields, this shouldn't be an issue.  realm, nonce, and opaque"", ""    are copied as is from the server, escapes and all.  cnonce is generated"", ""    with web-safe characters.  uri is already percent encoded.  nc is 8 hex"", ""    characters.  algorithm and qop with standard values only contain web-safe"", ""    chracters."", ""  */"", ""  userp_quoted = sasl_digest_string_quoted(userp);"", ""  if(!userp_quoted)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  if(digest->qop) {"", ""    response = aprintf(\""username=\\\""%s\\\"", \"""", ""                       \""realm=\\\""%s\\\"", \"""", ""                       \""nonce=\\\""%s\\\"", \"""", ""                       \""uri=\\\""%s\\\"", \"""", ""                       \""cnonce=\\\""%s\\\"", \"""", ""                       \""nc=%08x, \"""", ""                       \""qop=%s, \"""", ""                       \""response=\\\""%s\\\""\"","", ""                       userp_quoted,"", ""                       digest->realm,"", ""                       digest->nonce,"", ""                       uripath,"", ""                       digest->cnonce,"", ""                       digest->nc,"", ""                       digest->qop,"", ""                       request_digest);"", """", ""    if(Curl_raw_equal(digest->qop, \""auth\""))"", ""      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0"", ""                       padded which tells to the server how many times you are"", ""                       using the same nonce in the qop=auth mode */"", ""  }"", ""  else {"", ""    response = aprintf(\""username=\\\""%s\\\"", \"""", ""                       \""realm=\\\""%s\\\"", \"""", ""                       \""nonce=\\\""%s\\\"", \"""", ""                       \""uri=\\\""%s\\\"", \"""", ""                       \""response=\\\""%s\\\""\"","", ""                       userp_quoted,"", ""                       digest->realm,"", ""                       digest->nonce,"", ""                       uripath,"", ""                       request_digest);"", ""  }"", ""  free(userp_quoted);"", ""  if(!response)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Add the optional fields */"", ""  if(digest->opaque) {"", ""    /* Append the opaque */"", ""    tmp = aprintf(\""%s, opaque=\\\""%s\\\""\"", response, digest->opaque);"", ""    free(response);"", ""    if(!tmp)"", ""      return CURLE_OUT_OF_MEMORY;"", """", ""    response = tmp;"", ""  }"", """", ""  if(digest->algorithm) {"", ""    /* Append the algorithm */"", ""    tmp = aprintf(\""%s, algorithm=\\\""%s\\\""\"", response, digest->algorithm);"", ""    free(response);"", ""    if(!tmp)"", ""      return CURLE_OUT_OF_MEMORY;"", """", ""    response = tmp;"", ""  }"", """", ""  /* Return the output */"", ""  *outptr = response;"", ""  *outlen = strlen(response);"", """", ""  return CURLE_OK;"", ""}"", """", ""/*"", "" * Curl_sasl_digest_cleanup()"", "" *"", "" * This is used to clean up the digest specific data."", "" *"", "" * Parameters:"", "" *"", "" * digest    [in/out] - The digest data struct being cleaned up."", "" *"", "" */"", ""void Curl_sasl_digest_cleanup(struct digestdata *digest)"", ""{"", ""  Curl_safefree(digest->nonce);"", ""  Curl_safefree(digest->cnonce);"", ""  Curl_safefree(digest->realm);"", ""  Curl_safefree(digest->opaque);"", ""  Curl_safefree(digest->qop);"", ""  Curl_safefree(digest->algorithm);"", """", ""  digest->nc = 0;"", ""  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */"", ""  digest->stale = FALSE; /* default means normal, not stale */"", ""}"", ""#endif  /* !USE_WINDOWS_SSPI */"", """", ""#endif  /* CURL_DISABLE_CRYPTO_AUTH */"", """", ""#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)"", ""/*"", "" * Curl_sasl_ntlm_cleanup()"", "" *"", "" * This is used to clean up the ntlm specific data."", "" *"", "" * Parameters:"", "" *"", "" * ntlm    [in/out] - The ntlm data struct being cleaned up."", "" *"", "" */"", ""void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)"", ""{"", ""  /* Free the target info */"", ""  Curl_safefree(ntlm->target_info);"", """", ""  /* Reset any variables */"", ""  ntlm->target_info_len = 0;"", ""}"", ""#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/"", """", ""/*"", "" * sasl_create_xoauth2_message()"", "" *"", "" * This is used to generate an already encoded OAuth 2.0 message ready for"", "" * sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * user    [in]     - The user name."", "" * bearer  [in]     - The bearer token."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,"", ""                                            const char *user,"", ""                                            const char *bearer,"", ""                                            char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  char *xoauth = NULL;"", """", ""  /* Generate the message */"", ""  xoauth = aprintf(\""user=%s\\1auth=Bearer %s\\1\\1\"", user, bearer);"", ""  if(!xoauth)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Base64 encode the reply */"", ""  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);"", """", ""  free(xoauth);"", """", ""  return result;"", ""}"", """", ""/*"", "" * Curl_sasl_cleanup()"", "" *""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0]","[[123, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""snprintf((char *)&dest[i*2], 3, \""%02x\"", source[i]);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [232, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""return aprintf(\""%s/%s\"", service, host);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [429, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""response = aprintf("", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [591, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""snprintf(cnonce, sizeof(cnonce), \""%08x%08x%08x%08x\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [624, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""snprintf(&HA1_hex[2 * i], 3, \""%02x\"", digest[i]);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [647, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""snprintf(&HA2_hex[2 * i], 3, \""%02x\"", digest[i]);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [677, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""snprintf(&resp_hash_hex[2 * i], 3, \""%02x\"", digest[i]);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [680, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""response = aprintf(\""username=\\\""%s\\\"",realm=\\\""%s\\\"",nonce=\\\""%s\\\"",\"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [876, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""snprintf(cnoncebuf, sizeof(cnoncebuf), \""%08x%08x%08x%08x\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [900, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""aprintf(\""%s:%s:%s\"", userp, digest->realm, passwdp);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [911, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""tmp = aprintf(\""%s:%s:%s\"", ha1, digest->nonce, digest->cnonce);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [934, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""md5this = (unsigned char *)aprintf(\""%s:%s\"", request, uripath);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [940, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""aprintf(\""%s:%s\"", md5this, \""d41d8cd98f00b204e9800998ecf8427e\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [954, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""md5this = (unsigned char *)aprintf(\""%s:%s:%08x:%s:%s:%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [963, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""md5this = (unsigned char *)aprintf(\""%s:%s:%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [995, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""response = aprintf(\""username=\\\""%s\\\"", \"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [1018, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""response = aprintf(\""username=\\\""%s\\\"", \"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [1036, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""tmp = aprintf(\""%s, opaque=\\\""%s\\\""\"", response, digest->opaque);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [1046, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""tmp = aprintf(\""%s, algorithm=\\\""%s\\\""\"", response, digest->algorithm);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""], [1135, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""xoauth = aprintf(\""user=%s\\1auth=Bearer %s\\1\\1\"", user, bearer);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_112_new.cpp""]]",56,57
"[""    if(result)"", ""      return result;"", """", ""    if(fstated) {"", ""      time_t filetime = (time_t)statbuf.st_mtime;"", ""      struct tm buffer;"", ""      const struct tm *tm = &buffer;"", ""      result = Curl_gmtime(filetime, &buffer);"", ""      if(result)"", ""        return result;"", """", ""      /* format: \""Tue, 15 Nov 1994 12:45:26 GMT\"" */"", ""      snprintf(buf, BUFSIZE-1,"", ""               \""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\\r\\n\"","", ""               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],"", ""               tm->tm_mday,"", ""               Curl_month[tm->tm_mon],"", ""               tm->tm_year + 1900,"", ""               tm->tm_hour,"", ""               tm->tm_min,"", ""               tm->tm_sec);"", ""      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);"", ""    }"", ""    /* if we fstat()ed the file, set the file size to make it available post-"", ""       transfer */"", ""    if(fstated)"", ""    filetime = (time_t)statbuf.st_mtime;"", ""    result = Curl_gmtime(filetime, &buffer);"", ""    if(result)"", ""      return result;"", """", ""    /* format: \""Tue, 15 Nov 1994 12:45:26 GMT\"" */"", ""    snprintf(buf, BUFSIZE-1,"", ""             \""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\\r\\n\"","", ""             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],"", ""             tm->tm_mday,"", ""             Curl_month[tm->tm_mon],"", ""             tm->tm_year + 1900,"", ""             tm->tm_hour,"", ""             tm->tm_min,"", ""             tm->tm_sec);"", ""    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);"", ""    if(!result)"", ""      /* set the file size to make it available post transfer */"", ""      Curl_pgrsSetDownloadSize(data, expected_size);"", ""    return result;"", ""  }""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[12, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/file.c"", ""-"", ""snprintf(buf, BUFSIZE-1,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_113_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_113_new.cpp""], [32, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/file.c"", ""+"", ""snprintf(buf, BUFSIZE-1,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_113_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_113_new.cpp""]]",479,486
"[""    }"", ""  }"", """", ""  cmd = aprintf( \""%s%s%s\"","", ""                 data->set.str[STRING_CUSTOMREQUEST]?"", ""                 data->set.str[STRING_CUSTOMREQUEST]:"", ""                 (data->set.ftp_list_only?\""NLST\"":\""LIST\""),"", ""                 lstArg? \"" \"": \""\"","", ""                 lstArg? lstArg: \""\"" );"", ""  cmd = aprintf(\""%s%s%s\"","", ""                data->set.str[STRING_CUSTOMREQUEST]?"", ""                data->set.str[STRING_CUSTOMREQUEST]:"", ""                (data->set.ftp_list_only?\""NLST\"":\""LIST\""),"", ""                lstArg? \"" \"": \""\"","", ""                lstArg? lstArg: \""\"");"", """", ""  if(!cmd) {"", ""    free(lstArg);""]","[0, 0, 0, -2, -1, -1, -1, -1, -1, 2, 1, 1, 1, 1, 1, 0, 0, 0]","[[3, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/ftp.c"", ""-"", ""cmd = aprintf( \""%s%s%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_114_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_114_new.cpp""], [9, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/ftp.c"", ""+"", ""cmd = aprintf(\""%s%s%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_114_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_114_new.cpp""]]",1513,1524
"["""", ""      if(!result) {"", ""        char *host=(char *)\""\"";"", ""        const char *proxyconn=\""\"";"", ""        const char *useragent=\""\"";"", ""        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?"", ""          \""1.0\"" : \""1.1\"";"", ""        char *hostheader= /* host:port with IPv6 support */"", ""          aprintf(\""%s%s%s:%hu\"", conn->bits.ipv6_ip?\""[\"":\""\"","", ""                  hostname, conn->bits.ipv6_ip?\""]\"":\""\"","", ""        bool ipv6_ip = conn->bits.ipv6_ip;"", ""        char *hostheader;"", """", ""        /* the hostname may be different */"", ""        if(hostname != conn->host.name)"", ""          ipv6_ip = (strchr(hostname, ':') != NULL);"", ""        hostheader= /* host:port with IPv6 support */"", ""          aprintf(\""%s%s%s:%hu\"", ipv6_ip?\""[\"":\""\"", hostname, ipv6_ip?\""]\"":\""\"","", ""                  remote_port);"", ""        if(!hostheader) {"", ""          Curl_add_buffer_free(req_buffer);""]","[0, 0, 0, -1, 0, 0, 0, -1, -2, -1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0]","[[8, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/http_proxy.c"", ""-"", ""aprintf(\""%s%s%s:%hu\"", conn->bits.ipv6_ip?\""[\"":\""\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_115_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_115_new.cpp""], [17, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/http_proxy.c"", ""+"", ""aprintf(\""%s%s%s:%hu\"", ipv6_ip?\""[\"":\""\"", hostname, ipv6_ip?\""]\"":\""\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_115_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_115_new.cpp""]]",150,160
"["" * The message SHALL NOT include any LF or CR."", "" */"", """", ""void Curl_failf(struct SessionHandle *data, const char *fmt, ...)"", ""void Curl_failf(struct Curl_easy *data, const char *fmt, ...)"", ""{"", ""  va_list ap;"", ""  size_t len;""]","[0, 0, 0, -2, 2, 0, 0, 0]","[[3, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/sendf.c"", ""-"", ""void Curl_failf(struct SessionHandle *data, const char *fmt, ...)"", 0, ""/data/download/CMake/CMake/Kitware_CMake_116_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_116_new.cpp""], [4, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/sendf.c"", ""+"", ""void Curl_failf(struct Curl_easy *data, const char *fmt, ...)"", 0, ""/data/download/CMake/CMake/Kitware_CMake_116_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_116_new.cpp""]]",140,225
"["""", ""CURLcode Curl_sendf(curl_socket_t sockfd, struct connectdata *,"", ""                    const char *fmt, ...);"", ""void Curl_infof(struct SessionHandle *, const char *fmt, ...);"", ""void Curl_failf(struct SessionHandle *, const char *fmt, ...);"", ""void Curl_infof(struct Curl_easy *, const char *fmt, ...);"", ""void Curl_failf(struct Curl_easy *, const char *fmt, ...);"", """", ""#if defined(CURL_DISABLE_VERBOSE_STRINGS)"", """"]","[0, 0, 0, -1, -2, 1, 2, 0, 0, 0]","[[4, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/sendf.h"", ""-"", ""void Curl_failf(struct SessionHandle *, const char *fmt, ...);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_117_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_117_new.cpp""], [6, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/sendf.h"", ""+"", ""void Curl_failf(struct Curl_easy *, const char *fmt, ...);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_117_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_117_new.cpp""]]",26,26
"[""      state(conn, SSH_SFTP_NEXT_QUOTE);"", ""      break;"", """", ""#ifdef HAS_STATVFS_SUPPORT"", ""    case SSH_SFTP_QUOTE_STATVFS:"", ""    {"", ""      LIBSSH2_SFTP_STATVFS statvfs;"", ""      rc = libssh2_sftp_statvfs(sshc->sftp_session, sshc->quote_path1,"", ""                                curlx_uztoui(strlen(sshc->quote_path1)),"", ""                                &statvfs);"", """", ""      if(rc == LIBSSH2_ERROR_EAGAIN) {"", ""        break;"", ""      }"", ""      else if(rc != 0 && !sshc->acceptfail) {"", ""        err = sftp_libssh2_last_error(sshc->sftp_session);"", ""        Curl_safefree(sshc->quote_path1);"", ""        failf(data, \""statvfs command failed: %s\"", sftp_libssh2_strerror(err));"", ""        state(conn, SSH_SFTP_CLOSE);"", ""        sshc->nextstate = SSH_NO_STATE;"", ""        sshc->actualcode = CURLE_QUOTE_ERROR;"", ""        break;"", ""      }"", ""      else if(rc == 0) {"", ""        char *tmp = aprintf(\""statvfs:\\n\"""", ""                            \""f_bsize: %llu\\n\"" \""f_frsize: %llu\\n\"""", ""                            \""f_blocks: %llu\\n\"" \""f_bfree: %llu\\n\"""", ""                            \""f_bavail: %llu\\n\"" \""f_files: %llu\\n\"""", ""                            \""f_ffree: %llu\\n\"" \""f_favail: %llu\\n\"""", ""                            \""f_fsid: %llu\\n\"" \""f_flag: %llu\\n\"""", ""                            \""f_namemax: %llu\\n\"","", ""                            statvfs.f_bsize, statvfs.f_frsize,"", ""                            statvfs.f_blocks, statvfs.f_bfree,"", ""                            statvfs.f_bavail, statvfs.f_files,"", ""                            statvfs.f_ffree, statvfs.f_favail,"", ""                            statvfs.f_fsid, statvfs.f_flag,"", ""                            statvfs.f_namemax);"", ""        if(!tmp) {"", ""          result = CURLE_OUT_OF_MEMORY;"", ""          state(conn, SSH_SFTP_CLOSE);"", ""          sshc->nextstate = SSH_NO_STATE;"", ""          break;"", ""        }"", """", ""        result = Curl_client_write(conn, CLIENTWRITE_HEADER, tmp, strlen(tmp));"", ""        free(tmp);"", ""        if(result) {"", ""          state(conn, SSH_SFTP_CLOSE);"", ""          sshc->nextstate = SSH_NO_STATE;"", ""          sshc->actualcode = result;"", ""        }"", ""      }"", ""      state(conn, SSH_SFTP_NEXT_QUOTE);"", ""      break;"", ""    }"", ""#endif"", ""    case SSH_SFTP_GETINFO:"", ""    {"", ""      if(data->set.get_filetime) {"", ""        state(conn, SSH_SFTP_FILETIME);"", ""      }"", ""      else {"", ""        state(conn, SSH_SFTP_TRANS_INIT);"", ""      }"", ""      break;"", ""    }"", """", ""    case SSH_SFTP_FILETIME:"", ""    {"", ""      LIBSSH2_SFTP_ATTRIBUTES attrs;"", """", ""      rc = libssh2_sftp_stat_ex(sshc->sftp_session, sftp_scp->path,"", ""                                curlx_uztoui(strlen(sftp_scp->path)),"", ""                                LIBSSH2_SFTP_STAT, &attrs);"", ""      if(rc == LIBSSH2_ERROR_EAGAIN) {"", ""        break;"", ""      }"", ""      else if(rc == 0) {"", ""        data->info.filetime = (long)attrs.mtime;"", ""      }"", """", ""      state(conn, SSH_SFTP_TRANS_INIT);"", ""      break;"", ""    }"", """", ""    case SSH_SFTP_TRANS_INIT:"", ""      if(data->set.upload)"", ""        state(conn, SSH_SFTP_UPLOAD_INIT);""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[24, ""85d966dcd7a29a17e42fde7b1c109e642f063d82"", ""Merge topic 'update-curl'\n\nf59ab433 curl: Remove CMake-specific README\nf53f4a8a Merge branch 'upstream-curl' into update-curl\n202adcfe curl 2016-08-03 (f2cb3a01)\ne1c11352 curl: Update script to get curl 7.50.1\na51c6c53 Merge branch 'upstream-curl' into update-curl\n7ec709d3 curl 2015-08-11 (1a7f66a3)\n3e9b0343 Add script to update curl from upstream"", ""Utilities/cmcurl/lib/ssh.c"", ""+"", ""char *tmp = aprintf(\""statvfs:\\n\"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_118_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_118_new.cpp""]]",1608,1631
"[""/* returns an allocated key to find a bundle for this connection */"", ""static char *hashkey(struct connectdata *conn)"", ""{"", ""  return aprintf(\""%s:%d\"","", ""                 conn->bits.proxy?conn->proxy.name:conn->host.name,"", ""                 conn->localport);"", ""  const char *hostname;"", """", ""  if(conn->bits.proxy)"", ""    hostname = conn->proxy.name;"", ""  else if(conn->bits.conn_to_host)"", ""    hostname = conn->conn_to_host.name;"", ""  else"", ""    hostname = conn->host.name;"", """", ""  return aprintf(\""%s:%d\"", hostname, conn->port);"", ""}"", """", ""/* Look up the bundle with all the connections to the same host this""]","[0, 0, 0, -2, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0]","[[3, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/conncache.c"", ""-"", ""return aprintf(\""%s:%d\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_119_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_119_new.cpp""], [15, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/conncache.c"", ""+"", ""return aprintf(\""%s:%d\"", hostname, conn->port);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_119_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_119_new.cpp""]]",132,131
"[""      return 1; /* failure */"", ""  }"", """", ""  if(c) {"", ""    char *format_ptr;"", ""  fputs(\""# Netscape HTTP Cookie File\\n\"""", ""        \""# https://curl.haxx.se/docs/http-cookies.html\\n\"""", ""        \""# This file was generated by libcurl! Edit at your own risk.\\n\\n\"","", ""        out);"", """", ""    fputs(\""# Netscape HTTP Cookie File\\n\"""", ""          \""# http://curl.haxx.se/docs/http-cookies.html\\n\"""", ""          \""# This file was generated by libcurl! Edit at your own risk.\\n\\n\"","", ""          out);"", """", ""    for(co = c->cookies; co; co = co->next) {"", ""      if(!co->domain)"", ""        continue;"", ""      format_ptr = get_netscape_format(co);"", ""      if(format_ptr == NULL) {"", ""        fprintf(out, \""#\\n# Fatal libcurl error\\n\"");"", ""        if(!use_stdout)"", ""          fclose(out);"", ""        return 1;"", ""      }"", ""      fprintf(out, \""%s\\n\"", format_ptr);"", ""      free(format_ptr);"", ""  for(co = c->cookies; co; co = co->next) {"", ""    if(!co->domain)"", ""      continue;"", ""    format_ptr = get_netscape_format(co);"", ""    if(format_ptr == NULL) {"", ""      fprintf(out, \""#\\n# Fatal libcurl error\\n\"");"", ""      if(!use_stdout)"", ""        fclose(out);"", ""      return 1;"", ""    }"", ""    fprintf(out, \""%s\\n\"", format_ptr);"", ""    free(format_ptr);"", ""  }"", """", ""  if(!use_stdout)""]","[0, 0, 0, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -2, -1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, 2, 1, 0, 0, 0]","[[20, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/cookie.c"", ""-"", ""fprintf(out, \""#\\n# Fatal libcurl error\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_120_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_120_new.cpp""], [25, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/cookie.c"", ""-"", ""fprintf(out, \""%s\\n\"", format_ptr);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_120_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_120_new.cpp""], [32, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/cookie.c"", ""+"", ""fprintf(out, \""#\\n# Fatal libcurl error\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_120_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_120_new.cpp""], [37, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/cookie.c"", ""+"", ""fprintf(out, \""%s\\n\"", format_ptr);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_120_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_120_new.cpp""]]",1267,1301
"[""  size_t        len;   /* Name length */"", ""  unsigned int  bit;   /* Flag bit */"", ""} mechtable[] = {"", ""  { \""LOGIN\"",      5,  SASL_MECH_LOGIN },"", ""  { \""PLAIN\"",      5,  SASL_MECH_PLAIN },"", ""  { \""CRAM-MD5\"",   8,  SASL_MECH_CRAM_MD5 },"", ""  { \""DIGEST-MD5\"", 10, SASL_MECH_DIGEST_MD5 },"", ""  { \""GSSAPI\"",     6,  SASL_MECH_GSSAPI },"", ""  { \""EXTERNAL\"",   8,  SASL_MECH_EXTERNAL },"", ""  { \""NTLM\"",       4,  SASL_MECH_NTLM },"", ""  { \""XOAUTH2\"",    7,  SASL_MECH_XOAUTH2 },"", ""  { ZERO_NULL,    0,  0 }"", ""  { \""LOGIN\"",        5,  SASL_MECH_LOGIN },"", ""  { \""PLAIN\"",        5,  SASL_MECH_PLAIN },"", ""  { \""CRAM-MD5\"",     8,  SASL_MECH_CRAM_MD5 },"", ""  { \""DIGEST-MD5\"",   10, SASL_MECH_DIGEST_MD5 },"", ""  { \""GSSAPI\"",       6,  SASL_MECH_GSSAPI },"", ""  { \""EXTERNAL\"",     8,  SASL_MECH_EXTERNAL },"", ""  { \""NTLM\"",         4,  SASL_MECH_NTLM },"", ""  { \""XOAUTH2\"",      7,  SASL_MECH_XOAUTH2 },"", ""  { \""OAUTHBEARER\"",  11, SASL_MECH_OAUTHBEARER },"", ""  { ZERO_NULL,      0,  0 }"", ""};"", """", ""#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)"", ""#define DIGEST_QOP_VALUE_AUTH             (1 << 0)"", ""#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)"", ""#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)"", """", ""#define DIGEST_QOP_VALUE_STRING_AUTH      \""auth\"""", ""#define DIGEST_QOP_VALUE_STRING_AUTH_INT  \""auth-int\"""", ""#define DIGEST_QOP_VALUE_STRING_AUTH_CONF \""auth-conf\"""", """", ""/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines."", ""   It converts digest text to ASCII so the MD5 will be correct for"", ""   what ultimately goes over the network."", ""*/"", ""#define CURL_OUTPUT_DIGEST_CONV(a, b) \\"", ""  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \\"", ""  if(result) { \\"", ""    free(b); \\"", ""    return result; \\"", ""  }"", """", ""#endif"", """", ""#if !defined(CURL_DISABLE_CRYPTO_AUTH)"", ""/*"", "" * Returns 0 on success and then the buffers are filled in fine."", "" *"", "" * Non-zero means failure to parse."", "" */"", ""int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,"", ""                              const char **endptr)"", ""{"", ""  int c;"", ""  bool starts_with_quote = FALSE;"", ""  bool escape = FALSE;"", """", ""  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )"", ""    *value++ = *str++;"", ""  *value = 0;"", """", ""  if('=' != *str++)"", ""    /* eek, no match */"", ""    return 1;"", """", ""  if('\\\""' == *str) {"", ""    /* this starts with a quote so it must end with one as well! */"", ""    str++;"", ""    starts_with_quote = TRUE;"", ""  }"", """", ""  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; str++) {"", ""    switch(*str) {"", ""    case '\\\\':"", ""      if(!escape) {"", ""        /* possibly the start of an escaped quote */"", ""        escape = TRUE;"", ""        *content++ = '\\\\'; /* even though this is an escape character, we still"", ""                              store it as-is in the target buffer */"", ""        continue;"", ""      }"", ""      break;"", ""    case ',':"", ""      if(!starts_with_quote) {"", ""        /* this signals the end of the content if we didn't get a starting"", ""           quote and then we do \""sloppy\"" parsing */"", ""        c = 0; /* the end */"", ""        continue;"", ""      }"", ""      break;"", ""    case '\\r':"", ""    case '\\n':"", ""      /* end of string */"", ""      c = 0;"", ""      continue;"", ""    case '\\\""':"", ""      if(!escape && starts_with_quote) {"", ""        /* end of string */"", ""        c = 0;"", ""        continue;"", ""      }"", ""      break;"", ""    }"", ""    escape = FALSE;"", ""    *content++ = *str;"", ""  }"", ""  *content = 0;"", """", ""  *endptr = str;"", """", ""  return 0; /* all is fine! */"", ""}"", ""#endif"", """", ""#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)"", ""/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/"", ""static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */"", ""                                     unsigned char *dest) /* 33 bytes */"", ""{"", ""  int i;"", ""  for(i = 0; i < 16; i++)"", ""    snprintf((char *)&dest[i*2], 3, \""%02x\"", source[i]);"", ""}"", """", ""/* Perform quoted-string escaping as described in RFC2616 and its errata */"", ""static char *sasl_digest_string_quoted(const char *source)"", ""{"", ""  char *dest, *d;"", ""  const char *s = source;"", ""  size_t n = 1; /* null terminator */"", """", ""  /* Calculate size needed */"", ""  while(*s) {"", ""    ++n;"", ""    if(*s == '\""' || *s == '\\\\') {"", ""      ++n;"", ""    }"", ""    ++s;"", ""  }"", """", ""  dest = malloc(n);"", ""  if(dest) {"", ""    s = source;"", ""    d = dest;"", ""    while(*s) {"", ""      if(*s == '\""' || *s == '\\\\') {"", ""        *d++ = '\\\\';"", ""      }"", ""      *d++ = *s++;"", ""    }"", ""    *d = 0;"", ""  }"", """", ""  return dest;"", ""}"", """", ""/* Retrieves the value for a corresponding key from the challenge string"", "" * returns TRUE if the key could be found, FALSE if it does not exists"", "" */"", ""static bool sasl_digest_get_key_value(const char *chlg,"", ""                                      const char *key,"", ""                                      char *value,"", ""                                      size_t max_val_len,"", ""                                      char end_char)"", ""{"", ""  char *find_pos;"", ""  size_t i;"", """", ""  find_pos = strstr(chlg, key);"", ""  if(!find_pos)"", ""    return FALSE;"", """", ""  find_pos += strlen(key);"", """", ""  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ++i)"", ""    value[i] = *find_pos++;"", ""  value[i] = '\\0';"", """", ""  return TRUE;"", ""}"", """", ""static CURLcode sasl_digest_get_qop_values(const char *options, int *value)"", ""{"", ""  char *tmp;"", ""  char *token;"", ""  char *tok_buf;"", """", ""  /* Initialise the output */"", ""  *value = 0;"", """", ""  /* Tokenise the list of qop values. Use a temporary clone of the buffer since"", ""     strtok_r() ruins it. */"", ""  tmp = strdup(options);"", ""  if(!tmp)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  token = strtok_r(tmp, \"",\"", &tok_buf);"", ""  while(token != NULL) {"", ""    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))"", ""      *value |= DIGEST_QOP_VALUE_AUTH;"", ""    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))"", ""      *value |= DIGEST_QOP_VALUE_AUTH_INT;"", ""    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))"", ""      *value |= DIGEST_QOP_VALUE_AUTH_CONF;"", """", ""    token = strtok_r(NULL, \"",\"", &tok_buf);"", ""  }"", """", ""  free(tmp);"", """", ""  return CURLE_OK;"", ""}"", ""#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */"", """", ""#if !defined(USE_WINDOWS_SSPI)"", ""/*"", "" * Curl_sasl_build_spn()"", "" *"", "" * This is used to build a SPN string in the format service/host."", "" *"", "" * Parameters:"", "" *"", "" * service  [in] - The service type such as www, smtp, pop or imap."", "" * host     [in] - The host name or realm."", "" *"", "" * Returns a pointer to the newly allocated SPN."", "" */"", ""char *Curl_sasl_build_spn(const char *service, const char *host)"", ""{"", ""  /* Generate and return our SPN */"", ""  return aprintf(\""%s/%s\"", service, host);"", ""}"", ""#endif"", """", ""/*"", "" * sasl_create_plain_message()"", "" *"", "" * This is used to generate an already encoded PLAIN message ready"", "" * for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * userp   [in]     - The user name."", "" * passdwp [in]     - The user's password."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_plain_message(struct SessionHandle *data,"", ""                                          const char *userp,"", ""                                          const char *passwdp,"", ""                                          char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result;"", ""  char *plainauth;"", ""  size_t ulen;"", ""  size_t plen;"", """", ""  ulen = strlen(userp);"", ""  plen = strlen(passwdp);"", """", ""  plainauth = malloc(2 * ulen + plen + 2);"", ""  if(!plainauth) {"", ""    *outlen = 0;"", ""    *outptr = NULL;"", ""    return CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  /* Calculate the reply */"", ""  memcpy(plainauth, userp, ulen);"", ""  plainauth[ulen] = '\\0';"", ""  memcpy(plainauth + ulen + 1, userp, ulen);"", ""  plainauth[2 * ulen + 1] = '\\0';"", ""  memcpy(plainauth + 2 * ulen + 2, passwdp, plen);"", """", ""  /* Base64 encode the reply */"", ""  result = Curl_base64_encode(data, plainauth, 2 * ulen + plen + 2, outptr,"", ""                              outlen);"", ""  free(plainauth);"", ""  return result;"", ""}"", """", ""/*"", "" * sasl_create_login_message()"", "" *"", "" * This is used to generate an already encoded LOGIN message containing the"", "" * user name or password ready for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * valuep  [in]     - The user name or user's password."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_login_message(struct SessionHandle *data,"", ""                                          const char *valuep, char **outptr,"", ""                                          size_t *outlen)"", ""{"", ""  size_t vlen = strlen(valuep);"", """", ""  if(!vlen) {"", ""    /* Calculate an empty reply */"", ""    *outptr = strdup(\""=\"");"", ""    if(*outptr) {"", ""      *outlen = (size_t) 1;"", ""      return CURLE_OK;"", ""    }"", """", ""    *outlen = 0;"", ""    return CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  /* Base64 encode the value */"", ""  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);"", ""}"", """", ""/*"", "" * sasl_create_external_message()"", "" *"", "" * This is used to generate an already encoded EXTERNAL message containing"", "" * the user name ready for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * user    [in]     - The user name."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_external_message(struct SessionHandle *data,"", ""                                             const char *user, char **outptr,"", ""                                             size_t *outlen)"", ""{"", ""  /* This is the same formatting as the login message. */"", ""  return sasl_create_login_message(data, user, outptr, outlen);"", ""}"", """", ""#ifndef CURL_DISABLE_CRYPTO_AUTH"", "" /*"", "" * sasl_decode_cram_md5_message()"", "" *"", "" * This is used to decode an already encoded CRAM-MD5 challenge message."", "" *"", "" * Parameters:"", "" *"", "" * chlg64  [in]     - The base64 encoded challenge message."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,"", ""                                             size_t *outlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  size_t chlg64len = strlen(chlg64);"", """", ""  *outptr = NULL;"", ""  *outlen = 0;"", """", ""  /* Decode the challenge if necessary */"", ""  if(chlg64len && *chlg64 != '=')"", ""    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);"", """", ""    return result;"", "" }"", """", "" /*"", "" * sasl_create_cram_md5_message()"", "" *"", "" * This is used to generate an already encoded CRAM-MD5 response message ready"", "" * for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * chlg    [in]     - The challenge."", "" * userp   [in]     - The user name."", "" * passdwp [in]     - The user's password."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,"", ""                                             const char *chlg,"", ""                                             const char *userp,"", ""                                             const char *passwdp,"", ""                                             char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  size_t chlglen = 0;"", ""  HMAC_context *ctxt;"", ""  unsigned char digest[MD5_DIGEST_LEN];"", ""  char *response;"", """", ""  if(chlg)"", ""    chlglen = strlen(chlg);"", """", ""  /* Compute the digest using the password as the key */"", ""  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,"", ""                        (const unsigned char *) passwdp,"", ""                        curlx_uztoui(strlen(passwdp)));"", ""  if(!ctxt)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Update the digest with the given challenge */"", ""  if(chlglen > 0)"", ""    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,"", ""                     curlx_uztoui(chlglen));"", """", ""  /* Finalise the digest */"", ""  Curl_HMAC_final(ctxt, digest);"", """", ""  /* Generate the response */"", ""  response = aprintf("", ""      \""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\"","", ""           userp, digest[0], digest[1], digest[2], digest[3], digest[4],"", ""           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],"", ""           digest[11], digest[12], digest[13], digest[14], digest[15]);"", ""  if(!response)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Base64 encode the response */"", ""  result = Curl_base64_encode(data, response, 0, outptr, outlen);"", """", ""  free(response);"", """", ""  return result;"", ""}"", """", ""#ifndef USE_WINDOWS_SSPI"", ""/*"", "" * sasl_decode_digest_md5_message()"", "" *"", "" * This is used internally to decode an already encoded DIGEST-MD5 challenge"", "" * message into the seperate attributes."", "" *"", "" * Parameters:"", "" *"", "" * chlg64  [in]     - The base64 encoded challenge message."", "" * nonce   [in/out] - The buffer where the nonce will be stored."", "" * nlen    [in]     - The length of the nonce buffer."", "" * realm   [in/out] - The buffer where the realm will be stored."", "" * rlen    [in]     - The length of the realm buffer."", "" * alg     [in/out] - The buffer where the algorithm will be stored."", "" * alen    [in]     - The length of the algorithm buffer."", "" * qop     [in/out] - The buffer where the qop-options will be stored."", "" * qlen    [in]     - The length of the qop buffer."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_decode_digest_md5_message(const char *chlg64,"", ""                                               char *nonce, size_t nlen,"", ""                                               char *realm, size_t rlen,"", ""                                               char *alg, size_t alen,"", ""                                               char *qop, size_t qlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  unsigned char *chlg = NULL;"", ""  size_t chlglen = 0;"", ""  size_t chlg64len = strlen(chlg64);"", """", ""  /* Decode the base-64 encoded challenge message */"", ""  if(chlg64len && *chlg64 != '=') {"", ""    result = Curl_base64_decode(chlg64, &chlg, &chlglen);"", ""    if(result)"", ""      return result;"", ""  }"", """", ""  /* Ensure we have a valid challenge message */"", ""  if(!chlg)"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  /* Retrieve nonce string from the challenge */"", ""  if(!sasl_digest_get_key_value((char *)chlg, \""nonce=\\\""\"", nonce, nlen, '\\\""')) {"", ""    free(chlg);"", ""    return CURLE_BAD_CONTENT_ENCODING;"", ""  }"", """", ""  /* Retrieve realm string from the challenge */"", ""  if(!sasl_digest_get_key_value((char *)chlg, \""realm=\\\""\"", realm, rlen, '\\\""')) {"", ""    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */"", ""    strcpy(realm, \""\"");"", ""  }"", """", ""  /* Retrieve algorithm string from the challenge */"", ""  if(!sasl_digest_get_key_value((char *)chlg, \""algorithm=\"", alg, alen, ',')) {"", ""    free(chlg);"", ""    return CURLE_BAD_CONTENT_ENCODING;"", ""  }"", """", ""  /* Retrieve qop-options string from the challenge */"", ""  if(!sasl_digest_get_key_value((char *)chlg, \""qop=\\\""\"", qop, qlen, '\\\""')) {"", ""    free(chlg);"", ""    return CURLE_BAD_CONTENT_ENCODING;"", ""  }"", """", ""  free(chlg);"", """", ""  return CURLE_OK;"", ""}"", """", ""/*"", "" * Curl_sasl_create_digest_md5_message()"", "" *"", "" * This is used to generate an already encoded DIGEST-MD5 response message"", "" * ready for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * chlg64  [in]     - The base64 encoded challenge message."", "" * userp   [in]     - The user name."", "" * passdwp [in]     - The user's password."", "" * service [in]     - The service type such as www, smtp, pop or imap."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,"", ""                                             const char *chlg64,"", ""                                             const char *userp,"", ""                                             const char *passwdp,"", ""                                             const char *service,"", ""                                             char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  size_t i;"", ""  MD5_context *ctxt;"", ""  char *response = NULL;"", ""  unsigned char digest[MD5_DIGEST_LEN];"", ""  char HA1_hex[2 * MD5_DIGEST_LEN + 1];"", ""  char HA2_hex[2 * MD5_DIGEST_LEN + 1];"", ""  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];"", ""  char nonce[64];"", ""  char realm[128];"", ""  char algorithm[64];"", ""  char qop_options[64];"", ""  int qop_values;"", ""  char cnonce[33];"", ""  unsigned int entropy[4];"", ""  char nonceCount[] = \""00000001\"";"", ""  char method[]     = \""AUTHENTICATE\"";"", ""  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;"", ""  char *spn         = NULL;"", """", ""  /* Decode the challange message */"", ""  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),"", ""                                          realm, sizeof(realm),"", ""                                          algorithm, sizeof(algorithm),"", ""                                          qop_options, sizeof(qop_options));"", ""  if(result)"", ""    return result;"", """", ""  /* We only support md5 sessions */"", ""  if(strcmp(algorithm, \""md5-sess\"") != 0)"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  /* Get the qop-values from the qop-options */"", ""  result = sasl_digest_get_qop_values(qop_options, &qop_values);"", ""  if(result)"", ""    return result;"", """", ""  /* We only support auth quality-of-protection */"", ""  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  /* Generate 16 bytes of random data */"", ""  entropy[0] = Curl_rand(data);"", ""  entropy[1] = Curl_rand(data);"", ""  entropy[2] = Curl_rand(data);"", ""  entropy[3] = Curl_rand(data);"", """", ""  /* Convert the random data into a 32 byte hex string */"", ""  snprintf(cnonce, sizeof(cnonce), \""%08x%08x%08x%08x\"","", ""           entropy[0], entropy[1], entropy[2], entropy[3]);"", """", ""  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */"", ""  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);"", ""  if(!ctxt)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) userp,"", ""                  curlx_uztoui(strlen(userp)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) realm,"", ""                  curlx_uztoui(strlen(realm)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,"", ""                  curlx_uztoui(strlen(passwdp)));"", ""  Curl_MD5_final(ctxt, digest);"", """", ""  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);"", ""  if(!ctxt)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) nonce,"", ""                  curlx_uztoui(strlen(nonce)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,"", ""                  curlx_uztoui(strlen(cnonce)));"", ""  Curl_MD5_final(ctxt, digest);"", """", ""  /* Convert calculated 16 octet hex into 32 bytes string */"", ""  for(i = 0; i < MD5_DIGEST_LEN; i++)"", ""    snprintf(&HA1_hex[2 * i], 3, \""%02x\"", digest[i]);"", """", ""  /* Generate our SPN */"", ""  spn = Curl_sasl_build_spn(service, realm);"", ""  if(!spn)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Calculate H(A2) */"", ""  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);"", ""  if(!ctxt) {"", ""    free(spn);"", """", ""    return CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) method,"", ""                  curlx_uztoui(strlen(method)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) spn,"", ""                  curlx_uztoui(strlen(spn)));"", ""  Curl_MD5_final(ctxt, digest);"", """", ""  for(i = 0; i < MD5_DIGEST_LEN; i++)"", ""    snprintf(&HA2_hex[2 * i], 3, \""%02x\"", digest[i]);"", """", ""  /* Now calculate the response hash */"", ""  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);"", ""  if(!ctxt) {"", ""    free(spn);"", """", ""    return CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) nonce,"", ""                  curlx_uztoui(strlen(nonce)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,"", ""                  curlx_uztoui(strlen(nonceCount)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,"", ""                  curlx_uztoui(strlen(cnonce)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) qop,"", ""                  curlx_uztoui(strlen(qop)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);"", ""  Curl_MD5_final(ctxt, digest);"", """", ""  for(i = 0; i < MD5_DIGEST_LEN; i++)"", ""    snprintf(&resp_hash_hex[2 * i], 3, \""%02x\"", digest[i]);"", """", ""  /* Generate the response */"", ""  response = aprintf(\""username=\\\""%s\\\"",realm=\\\""%s\\\"",nonce=\\\""%s\\\"",\"""", ""                     \""cnonce=\\\""%s\\\"",nc=\\\""%s\\\"",digest-uri=\\\""%s\\\"",response=%s,\"""", ""                     \""qop=%s\"","", ""                     userp, realm, nonce,"", ""                     cnonce, nonceCount, spn, resp_hash_hex, qop);"", ""  free(spn);"", ""  if(!response)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Base64 encode the response */"", ""  result = Curl_base64_encode(data, response, 0, outptr, outlen);"", """", ""  free(response);"", """", ""  return result;"", ""}"", """", ""/*"", "" * Curl_sasl_decode_digest_http_message()"", "" *"", "" * This is used to decode a HTTP DIGEST challenge message into the seperate"", "" * attributes."", "" *"", "" * Parameters:"", "" *"", "" * chlg    [in]     - The challenge message."", "" * digest  [in/out] - The digest data struct being used and modified."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,"", ""                                              struct digestdata *digest)"", ""{"", ""  bool before = FALSE; /* got a nonce before */"", ""  bool foundAuth = FALSE;"", ""  bool foundAuthInt = FALSE;"", ""  char *token = NULL;"", ""  char *tmp = NULL;"", """", ""  /* If we already have received a nonce, keep that in mind */"", ""  if(digest->nonce)"", ""    before = TRUE;"", """", ""  /* Clean up any former leftovers and initialise to defaults */"", ""  Curl_sasl_digest_cleanup(digest);"", """", ""  for(;;) {"", ""    char value[DIGEST_MAX_VALUE_LENGTH];"", ""    char content[DIGEST_MAX_CONTENT_LENGTH];"", """", ""    /* Pass all additional spaces here */"", ""    while(*chlg && ISSPACE(*chlg))"", ""      chlg++;"", """", ""    /* Extract a value=content pair */"", ""    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {"", ""      if(Curl_raw_equal(value, \""nonce\"")) {"", ""        digest->nonce = strdup(content);"", ""        if(!digest->nonce)"", ""          return CURLE_OUT_OF_MEMORY;"", ""      }"", ""      else if(Curl_raw_equal(value, \""stale\"")) {"", ""        if(Curl_raw_equal(content, \""true\"")) {"", ""          digest->stale = TRUE;"", ""          digest->nc = 1; /* we make a new nonce now */"", ""        }"", ""      }"", ""      else if(Curl_raw_equal(value, \""realm\"")) {"", ""        digest->realm = strdup(content);"", ""        if(!digest->realm)"", ""          return CURLE_OUT_OF_MEMORY;"", ""      }"", ""      else if(Curl_raw_equal(value, \""opaque\"")) {"", ""        digest->opaque = strdup(content);"", ""        if(!digest->opaque)"", ""          return CURLE_OUT_OF_MEMORY;"", ""      }"", ""      else if(Curl_raw_equal(value, \""qop\"")) {"", ""        char *tok_buf;"", ""        /* Tokenize the list and choose auth if possible, use a temporary"", ""            clone of the buffer since strtok_r() ruins it */"", ""        tmp = strdup(content);"", ""        if(!tmp)"", ""          return CURLE_OUT_OF_MEMORY;"", """", ""        token = strtok_r(tmp, \"",\"", &tok_buf);"", ""        while(token != NULL) {"", ""          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {"", ""            foundAuth = TRUE;"", ""          }"", ""          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {"", ""            foundAuthInt = TRUE;"", ""          }"", ""          token = strtok_r(NULL, \"",\"", &tok_buf);"", ""        }"", """", ""        free(tmp);"", """", ""        /* Select only auth or auth-int. Otherwise, ignore */"", ""        if(foundAuth) {"", ""          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);"", ""          if(!digest->qop)"", ""            return CURLE_OUT_OF_MEMORY;"", ""        }"", ""        else if(foundAuthInt) {"", ""          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);"", ""          if(!digest->qop)"", ""            return CURLE_OUT_OF_MEMORY;"", ""        }"", ""      }"", ""      else if(Curl_raw_equal(value, \""algorithm\"")) {"", ""        digest->algorithm = strdup(content);"", ""        if(!digest->algorithm)"", ""          return CURLE_OUT_OF_MEMORY;"", """", ""        if(Curl_raw_equal(content, \""MD5-sess\""))"", ""          digest->algo = CURLDIGESTALGO_MD5SESS;"", ""        else if(Curl_raw_equal(content, \""MD5\""))"", ""          digest->algo = CURLDIGESTALGO_MD5;"", ""        else"", ""          return CURLE_BAD_CONTENT_ENCODING;"", ""      }"", ""      else {"", ""        /* unknown specifier, ignore it! */"", ""      }"", ""    }"", ""    else"", ""      break; /* we're done here */"", """", ""    /* Pass all additional spaces here */"", ""    while(*chlg && ISSPACE(*chlg))"", ""      chlg++;"", """", ""    /* Allow the list to be comma-separated */"", ""    if(',' == *chlg)"", ""      chlg++;"", ""  }"", """", ""  /* We had a nonce since before, and we got another one now without"", ""     'stale=true'. This means we provided bad credentials in the previous"", ""     request */"", ""  if(before && !digest->stale)"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  /* We got this header without a nonce, that's a bad Digest line! */"", ""  if(!digest->nonce)"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  return CURLE_OK;"", ""}"", """", ""/*"", "" * Curl_sasl_create_digest_http_message()"", "" *"", "" * This is used to generate a HTTP DIGEST response message ready for sending"", "" * to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * userp   [in]     - The user name."", "" * passdwp [in]     - The user's password."", "" * request [in]     - The HTTP request."", "" * uripath [in]     - The path of the HTTP uri."", "" * digest  [in/out] - The digest data struct being used and modified."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,"", ""                                              const char *userp,"", ""                                              const char *passwdp,"", ""                                              const unsigned char *request,"", ""                                              const unsigned char *uripath,"", ""                                              struct digestdata *digest,"", ""                                              char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result;"", ""  unsigned char md5buf[16]; /* 16 bytes/128 bits */"", ""  unsigned char request_digest[33];"", ""  unsigned char *md5this;"", ""  unsigned char ha1[33];/* 32 digits and 1 zero byte */"", ""  unsigned char ha2[33];/* 32 digits and 1 zero byte */"", ""  char cnoncebuf[33];"", ""  char *cnonce = NULL;"", ""  size_t cnonce_sz = 0;"", ""  char *userp_quoted;"", ""  char *response = NULL;"", ""  char *tmp = NULL;"", """", ""  if(!digest->nc)"", ""    digest->nc = 1;"", """", ""  if(!digest->cnonce) {"", ""    snprintf(cnoncebuf, sizeof(cnoncebuf), \""%08x%08x%08x%08x\"","", ""             Curl_rand(data), Curl_rand(data),"", ""             Curl_rand(data), Curl_rand(data));"", """", ""    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),"", ""                                &cnonce, &cnonce_sz);"", ""    if(result)"", ""      return result;"", """", ""    digest->cnonce = cnonce;"", ""  }"", """", ""  /*"", ""    if the algorithm is \""MD5\"" or unspecified (which then defaults to MD5):"", """", ""    A1 = unq(username-value) \"":\"" unq(realm-value) \"":\"" passwd"", """", ""    if the algorithm is \""MD5-sess\"" then:"", """", ""    A1 = H( unq(username-value) \"":\"" unq(realm-value) \"":\"" passwd )"", ""         \"":\"" unq(nonce-value) \"":\"" unq(cnonce-value)"", ""  */"", """", ""  md5this = (unsigned char *)"", ""    aprintf(\""%s:%s:%s\"", userp, digest->realm, passwdp);"", ""  if(!md5this)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */"", ""  Curl_md5it(md5buf, md5this);"", ""  free(md5this);"", ""  sasl_digest_md5_to_ascii(md5buf, ha1);"", """", ""  if(digest->algo == CURLDIGESTALGO_MD5SESS) {"", ""    /* nonce and cnonce are OUTSIDE the hash */"", ""    tmp = aprintf(\""%s:%s:%s\"", ha1, digest->nonce, digest->cnonce);"", ""    if(!tmp)"", ""      return CURLE_OUT_OF_MEMORY;"", """", ""    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */"", ""    Curl_md5it(md5buf, (unsigned char *)tmp);"", ""    free(tmp);"", ""    sasl_digest_md5_to_ascii(md5buf, ha1);"", ""  }"", """", ""  /*"", ""    If the \""qop\"" directive's value is \""auth\"" or is unspecified, then A2 is:"", """", ""      A2       = Method \"":\"" digest-uri-value"", """", ""          If the \""qop\"" value is \""auth-int\"", then A2 is:"", """", ""      A2       = Method \"":\"" digest-uri-value \"":\"" H(entity-body)"", """", ""    (The \""Method\"" value is the HTTP request method as specified in section"", ""    5.1.1 of RFC 2616)"", ""  */"", """", ""  md5this = (unsigned char *)aprintf(\""%s:%s\"", request, uripath);"", """", ""  if(digest->qop && Curl_raw_equal(digest->qop, \""auth-int\"")) {"", ""    /* We don't support auth-int for PUT or POST at the moment."", ""       TODO: replace md5 of empty string with entity-body for PUT/POST */"", ""    unsigned char *md5this2 = (unsigned char *)"", ""      aprintf(\""%s:%s\"", md5this, \""d41d8cd98f00b204e9800998ecf8427e\"");"", ""    free(md5this);"", ""    md5this = md5this2;"", ""  }"", """", ""  if(!md5this)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */"", ""  Curl_md5it(md5buf, md5this);"", ""  free(md5this);"", ""  sasl_digest_md5_to_ascii(md5buf, ha2);"", """", ""  if(digest->qop) {"", ""    md5this = (unsigned char *)aprintf(\""%s:%s:%08x:%s:%s:%s\"","", ""                                       ha1,"", ""                                       digest->nonce,"", ""                                       digest->nc,"", ""                                       digest->cnonce,"", ""                                       digest->qop,"", ""                                       ha2);"", ""  }"", ""  else {"", ""    md5this = (unsigned char *)aprintf(\""%s:%s:%s\"","", ""                                       ha1,"", ""                                       digest->nonce,"", ""                                       ha2);"", ""  }"", """", ""  if(!md5this)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */"", ""  Curl_md5it(md5buf, md5this);"", ""  free(md5this);"", ""  sasl_digest_md5_to_ascii(md5buf, request_digest);"", """", ""  /* for test case 64 (snooped from a Mozilla 1.3a request)"", """", ""    Authorization: Digest username=\""testuser\"", realm=\""testrealm\"", \\"", ""    nonce=\""1053604145\"", uri=\""/64\"", response=\""c55f7f30d83d774a3d2dcacf725abaca\"""", """", ""    Digest parameters are all quoted strings.  Username which is provided by"", ""    the user will need double quotes and backslashes within it escaped.  For"", ""    the other fields, this shouldn't be an issue.  realm, nonce, and opaque"", ""    are copied as is from the server, escapes and all.  cnonce is generated"", ""    with web-safe characters.  uri is already percent encoded.  nc is 8 hex"", ""    characters.  algorithm and qop with standard values only contain web-safe"", ""    chracters."", ""  */"", ""  userp_quoted = sasl_digest_string_quoted(userp);"", ""  if(!userp_quoted)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  if(digest->qop) {"", ""    response = aprintf(\""username=\\\""%s\\\"", \"""", ""                       \""realm=\\\""%s\\\"", \"""", ""                       \""nonce=\\\""%s\\\"", \"""", ""                       \""uri=\\\""%s\\\"", \"""", ""                       \""cnonce=\\\""%s\\\"", \"""", ""                       \""nc=%08x, \"""", ""                       \""qop=%s, \"""", ""                       \""response=\\\""%s\\\""\"","", ""                       userp_quoted,"", ""                       digest->realm,"", ""                       digest->nonce,"", ""                       uripath,"", ""                       digest->cnonce,"", ""                       digest->nc,"", ""                       digest->qop,"", ""                       request_digest);"", """", ""    if(Curl_raw_equal(digest->qop, \""auth\""))"", ""      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0"", ""                       padded which tells to the server how many times you are"", ""                       using the same nonce in the qop=auth mode */"", ""  }"", ""  else {"", ""    response = aprintf(\""username=\\\""%s\\\"", \"""", ""                       \""realm=\\\""%s\\\"", \"""", ""                       \""nonce=\\\""%s\\\"", \"""", ""                       \""uri=\\\""%s\\\"", \"""", ""                       \""response=\\\""%s\\\""\"","", ""                       userp_quoted,"", ""                       digest->realm,"", ""                       digest->nonce,"", ""                       uripath,"", ""                       request_digest);"", ""  }"", ""  free(userp_quoted);"", ""  if(!response)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Add the optional fields */"", ""  if(digest->opaque) {"", ""    /* Append the opaque */"", ""    tmp = aprintf(\""%s, opaque=\\\""%s\\\""\"", response, digest->opaque);"", ""    free(response);"", ""    if(!tmp)"", ""      return CURLE_OUT_OF_MEMORY;"", """", ""    response = tmp;"", ""  }"", """", ""  if(digest->algorithm) {"", ""    /* Append the algorithm */"", ""    tmp = aprintf(\""%s, algorithm=\\\""%s\\\""\"", response, digest->algorithm);"", ""    free(response);"", ""    if(!tmp)"", ""      return CURLE_OUT_OF_MEMORY;"", """", ""    response = tmp;"", ""  }"", """", ""  /* Return the output */"", ""  *outptr = response;"", ""  *outlen = strlen(response);"", """", ""  return CURLE_OK;"", ""}"", """", ""/*"", "" * Curl_sasl_digest_cleanup()"", "" *"", "" * This is used to clean up the digest specific data."", "" *"", "" * Parameters:"", "" *"", "" * digest    [in/out] - The digest data struct being cleaned up."", "" *"", "" */"", ""void Curl_sasl_digest_cleanup(struct digestdata *digest)"", ""{"", ""  Curl_safefree(digest->nonce);"", ""  Curl_safefree(digest->cnonce);"", ""  Curl_safefree(digest->realm);"", ""  Curl_safefree(digest->opaque);"", ""  Curl_safefree(digest->qop);"", ""  Curl_safefree(digest->algorithm);"", """", ""  digest->nc = 0;"", ""  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */"", ""  digest->stale = FALSE; /* default means normal, not stale */"", ""}"", ""#endif  /* !USE_WINDOWS_SSPI */"", """", ""#endif  /* CURL_DISABLE_CRYPTO_AUTH */"", """", ""#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)"", ""/*"", "" * Curl_sasl_ntlm_cleanup()"", "" *"", "" * This is used to clean up the ntlm specific data."", "" *"", "" * Parameters:"", "" *"", "" * ntlm    [in/out] - The ntlm data struct being cleaned up."", "" *"", "" */"", ""void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)"", ""{"", ""  /* Free the target info */"", ""  Curl_safefree(ntlm->target_info);"", """", ""  /* Reset any variables */"", ""  ntlm->target_info_len = 0;"", ""}"", ""#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/"", """", ""/*"", "" * sasl_create_xoauth2_message()"", "" *"", "" * This is used to generate an already encoded OAuth 2.0 message ready for"", "" * sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * user    [in]     - The user name."", "" * bearer  [in]     - The bearer token."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,"", ""                                            const char *user,"", ""                                            const char *bearer,"", ""                                            char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  char *xoauth = NULL;"", """", ""  /* Generate the message */"", ""  xoauth = aprintf(\""user=%s\\1auth=Bearer %s\\1\\1\"", user, bearer);"", ""  if(!xoauth)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Base64 encode the reply */"", ""  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);"", """", ""  free(xoauth);"", """", ""  return result;"", ""}"", """", ""/*"", "" * Curl_sasl_cleanup()"", "" *""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0]","[[123, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""snprintf((char *)&dest[i*2], 3, \""%02x\"", source[i]);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [232, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""return aprintf(\""%s/%s\"", service, host);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [429, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""response = aprintf("", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [591, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""snprintf(cnonce, sizeof(cnonce), \""%08x%08x%08x%08x\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [624, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""snprintf(&HA1_hex[2 * i], 3, \""%02x\"", digest[i]);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [647, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""snprintf(&HA2_hex[2 * i], 3, \""%02x\"", digest[i]);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [677, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""snprintf(&resp_hash_hex[2 * i], 3, \""%02x\"", digest[i]);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [680, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""response = aprintf(\""username=\\\""%s\\\"",realm=\\\""%s\\\"",nonce=\\\""%s\\\"",\"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [876, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""snprintf(cnoncebuf, sizeof(cnoncebuf), \""%08x%08x%08x%08x\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [900, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""aprintf(\""%s:%s:%s\"", userp, digest->realm, passwdp);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [911, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""tmp = aprintf(\""%s:%s:%s\"", ha1, digest->nonce, digest->cnonce);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [934, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""md5this = (unsigned char *)aprintf(\""%s:%s\"", request, uripath);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [940, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""aprintf(\""%s:%s\"", md5this, \""d41d8cd98f00b204e9800998ecf8427e\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [954, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""md5this = (unsigned char *)aprintf(\""%s:%s:%08x:%s:%s:%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [963, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""md5this = (unsigned char *)aprintf(\""%s:%s:%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [995, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""response = aprintf(\""username=\\\""%s\\\"", \"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [1018, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""response = aprintf(\""username=\\\""%s\\\"", \"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [1036, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""tmp = aprintf(\""%s, opaque=\\\""%s\\\""\"", response, digest->opaque);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [1046, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""tmp = aprintf(\""%s, algorithm=\\\""%s\\\""\"", response, digest->algorithm);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""], [1135, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""xoauth = aprintf(\""user=%s\\1auth=Bearer %s\\1\\1\"", user, bearer);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_121_new.cpp""]]",56,57
"[""    if(result)"", ""      return result;"", """", ""    if(fstated) {"", ""      time_t filetime = (time_t)statbuf.st_mtime;"", ""      struct tm buffer;"", ""      const struct tm *tm = &buffer;"", ""      result = Curl_gmtime(filetime, &buffer);"", ""      if(result)"", ""        return result;"", """", ""      /* format: \""Tue, 15 Nov 1994 12:45:26 GMT\"" */"", ""      snprintf(buf, BUFSIZE-1,"", ""               \""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\\r\\n\"","", ""               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],"", ""               tm->tm_mday,"", ""               Curl_month[tm->tm_mon],"", ""               tm->tm_year + 1900,"", ""               tm->tm_hour,"", ""               tm->tm_min,"", ""               tm->tm_sec);"", ""      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);"", ""    }"", ""    /* if we fstat()ed the file, set the file size to make it available post-"", ""       transfer */"", ""    if(fstated)"", ""    filetime = (time_t)statbuf.st_mtime;"", ""    result = Curl_gmtime(filetime, &buffer);"", ""    if(result)"", ""      return result;"", """", ""    /* format: \""Tue, 15 Nov 1994 12:45:26 GMT\"" */"", ""    snprintf(buf, BUFSIZE-1,"", ""             \""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\\r\\n\"","", ""             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],"", ""             tm->tm_mday,"", ""             Curl_month[tm->tm_mon],"", ""             tm->tm_year + 1900,"", ""             tm->tm_hour,"", ""             tm->tm_min,"", ""             tm->tm_sec);"", ""    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);"", ""    if(!result)"", ""      /* set the file size to make it available post transfer */"", ""      Curl_pgrsSetDownloadSize(data, expected_size);"", ""    return result;"", ""  }""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[12, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/file.c"", ""-"", ""snprintf(buf, BUFSIZE-1,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_122_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_122_new.cpp""], [32, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/file.c"", ""+"", ""snprintf(buf, BUFSIZE-1,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_122_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_122_new.cpp""]]",479,486
"[""    }"", ""  }"", """", ""  cmd = aprintf( \""%s%s%s\"","", ""                 data->set.str[STRING_CUSTOMREQUEST]?"", ""                 data->set.str[STRING_CUSTOMREQUEST]:"", ""                 (data->set.ftp_list_only?\""NLST\"":\""LIST\""),"", ""                 lstArg? \"" \"": \""\"","", ""                 lstArg? lstArg: \""\"" );"", ""  cmd = aprintf(\""%s%s%s\"","", ""                data->set.str[STRING_CUSTOMREQUEST]?"", ""                data->set.str[STRING_CUSTOMREQUEST]:"", ""                (data->set.ftp_list_only?\""NLST\"":\""LIST\""),"", ""                lstArg? \"" \"": \""\"","", ""                lstArg? lstArg: \""\"");"", """", ""  if(!cmd) {"", ""    free(lstArg);""]","[0, 0, 0, -2, -1, -1, -1, -1, -1, 2, 1, 1, 1, 1, 1, 0, 0, 0]","[[3, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/ftp.c"", ""-"", ""cmd = aprintf( \""%s%s%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_123_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_123_new.cpp""], [9, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/ftp.c"", ""+"", ""cmd = aprintf(\""%s%s%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_123_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_123_new.cpp""]]",1513,1524
"["""", ""      if(!result) {"", ""        char *host=(char *)\""\"";"", ""        const char *proxyconn=\""\"";"", ""        const char *useragent=\""\"";"", ""        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?"", ""          \""1.0\"" : \""1.1\"";"", ""        char *hostheader= /* host:port with IPv6 support */"", ""          aprintf(\""%s%s%s:%hu\"", conn->bits.ipv6_ip?\""[\"":\""\"","", ""                  hostname, conn->bits.ipv6_ip?\""]\"":\""\"","", ""        bool ipv6_ip = conn->bits.ipv6_ip;"", ""        char *hostheader;"", """", ""        /* the hostname may be different */"", ""        if(hostname != conn->host.name)"", ""          ipv6_ip = (strchr(hostname, ':') != NULL);"", ""        hostheader= /* host:port with IPv6 support */"", ""          aprintf(\""%s%s%s:%hu\"", ipv6_ip?\""[\"":\""\"", hostname, ipv6_ip?\""]\"":\""\"","", ""                  remote_port);"", ""        if(!hostheader) {"", ""          Curl_add_buffer_free(req_buffer);""]","[0, 0, 0, -1, 0, 0, 0, -1, -2, -1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0]","[[8, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/http_proxy.c"", ""-"", ""aprintf(\""%s%s%s:%hu\"", conn->bits.ipv6_ip?\""[\"":\""\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_124_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_124_new.cpp""], [17, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/http_proxy.c"", ""+"", ""aprintf(\""%s%s%s:%hu\"", ipv6_ip?\""[\"":\""\"", hostname, ipv6_ip?\""]\"":\""\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_124_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_124_new.cpp""]]",150,160
"["" * The message SHALL NOT include any LF or CR."", "" */"", """", ""void Curl_failf(struct SessionHandle *data, const char *fmt, ...)"", ""void Curl_failf(struct Curl_easy *data, const char *fmt, ...)"", ""{"", ""  va_list ap;"", ""  size_t len;""]","[0, 0, 0, -2, 2, 0, 0, 0]","[[3, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/sendf.c"", ""-"", ""void Curl_failf(struct SessionHandle *data, const char *fmt, ...)"", 0, ""/data/download/CMake/CMake/Kitware_CMake_125_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_125_new.cpp""], [4, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/sendf.c"", ""+"", ""void Curl_failf(struct Curl_easy *data, const char *fmt, ...)"", 0, ""/data/download/CMake/CMake/Kitware_CMake_125_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_125_new.cpp""]]",140,225
"["""", ""CURLcode Curl_sendf(curl_socket_t sockfd, struct connectdata *,"", ""                    const char *fmt, ...);"", ""void Curl_infof(struct SessionHandle *, const char *fmt, ...);"", ""void Curl_failf(struct SessionHandle *, const char *fmt, ...);"", ""void Curl_infof(struct Curl_easy *, const char *fmt, ...);"", ""void Curl_failf(struct Curl_easy *, const char *fmt, ...);"", """", ""#if defined(CURL_DISABLE_VERBOSE_STRINGS)"", """"]","[0, 0, 0, -1, -2, 1, 2, 0, 0, 0]","[[4, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/sendf.h"", ""-"", ""void Curl_failf(struct SessionHandle *, const char *fmt, ...);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_126_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_126_new.cpp""], [6, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/sendf.h"", ""+"", ""void Curl_failf(struct Curl_easy *, const char *fmt, ...);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_126_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_126_new.cpp""]]",26,26
"[""      state(conn, SSH_SFTP_NEXT_QUOTE);"", ""      break;"", """", ""#ifdef HAS_STATVFS_SUPPORT"", ""    case SSH_SFTP_QUOTE_STATVFS:"", ""    {"", ""      LIBSSH2_SFTP_STATVFS statvfs;"", ""      rc = libssh2_sftp_statvfs(sshc->sftp_session, sshc->quote_path1,"", ""                                curlx_uztoui(strlen(sshc->quote_path1)),"", ""                                &statvfs);"", """", ""      if(rc == LIBSSH2_ERROR_EAGAIN) {"", ""        break;"", ""      }"", ""      else if(rc != 0 && !sshc->acceptfail) {"", ""        err = sftp_libssh2_last_error(sshc->sftp_session);"", ""        Curl_safefree(sshc->quote_path1);"", ""        failf(data, \""statvfs command failed: %s\"", sftp_libssh2_strerror(err));"", ""        state(conn, SSH_SFTP_CLOSE);"", ""        sshc->nextstate = SSH_NO_STATE;"", ""        sshc->actualcode = CURLE_QUOTE_ERROR;"", ""        break;"", ""      }"", ""      else if(rc == 0) {"", ""        char *tmp = aprintf(\""statvfs:\\n\"""", ""                            \""f_bsize: %llu\\n\"" \""f_frsize: %llu\\n\"""", ""                            \""f_blocks: %llu\\n\"" \""f_bfree: %llu\\n\"""", ""                            \""f_bavail: %llu\\n\"" \""f_files: %llu\\n\"""", ""                            \""f_ffree: %llu\\n\"" \""f_favail: %llu\\n\"""", ""                            \""f_fsid: %llu\\n\"" \""f_flag: %llu\\n\"""", ""                            \""f_namemax: %llu\\n\"","", ""                            statvfs.f_bsize, statvfs.f_frsize,"", ""                            statvfs.f_blocks, statvfs.f_bfree,"", ""                            statvfs.f_bavail, statvfs.f_files,"", ""                            statvfs.f_ffree, statvfs.f_favail,"", ""                            statvfs.f_fsid, statvfs.f_flag,"", ""                            statvfs.f_namemax);"", ""        if(!tmp) {"", ""          result = CURLE_OUT_OF_MEMORY;"", ""          state(conn, SSH_SFTP_CLOSE);"", ""          sshc->nextstate = SSH_NO_STATE;"", ""          break;"", ""        }"", """", ""        result = Curl_client_write(conn, CLIENTWRITE_HEADER, tmp, strlen(tmp));"", ""        free(tmp);"", ""        if(result) {"", ""          state(conn, SSH_SFTP_CLOSE);"", ""          sshc->nextstate = SSH_NO_STATE;"", ""          sshc->actualcode = result;"", ""        }"", ""      }"", ""      state(conn, SSH_SFTP_NEXT_QUOTE);"", ""      break;"", ""    }"", ""#endif"", ""    case SSH_SFTP_GETINFO:"", ""    {"", ""      if(data->set.get_filetime) {"", ""        state(conn, SSH_SFTP_FILETIME);"", ""      }"", ""      else {"", ""        state(conn, SSH_SFTP_TRANS_INIT);"", ""      }"", ""      break;"", ""    }"", """", ""    case SSH_SFTP_FILETIME:"", ""    {"", ""      LIBSSH2_SFTP_ATTRIBUTES attrs;"", """", ""      rc = libssh2_sftp_stat_ex(sshc->sftp_session, sftp_scp->path,"", ""                                curlx_uztoui(strlen(sftp_scp->path)),"", ""                                LIBSSH2_SFTP_STAT, &attrs);"", ""      if(rc == LIBSSH2_ERROR_EAGAIN) {"", ""        break;"", ""      }"", ""      else if(rc == 0) {"", ""        data->info.filetime = (long)attrs.mtime;"", ""      }"", """", ""      state(conn, SSH_SFTP_TRANS_INIT);"", ""      break;"", ""    }"", """", ""    case SSH_SFTP_TRANS_INIT:"", ""      if(data->set.upload)"", ""        state(conn, SSH_SFTP_UPLOAD_INIT);""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[24, ""5bcbc3857fd9976389d8eee3bb54e352ea950aec"", ""Merge branch 'update-curl' into release"", ""Utilities/cmcurl/lib/ssh.c"", ""+"", ""char *tmp = aprintf(\""statvfs:\\n\"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_127_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_127_new.cpp""]]",1608,1631
"[""/* returns an allocated key to find a bundle for this connection */"", ""static char *hashkey(struct connectdata *conn)"", ""{"", ""  return aprintf(\""%s:%d\"","", ""                 conn->bits.proxy?conn->proxy.name:conn->host.name,"", ""                 conn->localport);"", ""  const char *hostname;"", """", ""  if(conn->bits.proxy)"", ""    hostname = conn->proxy.name;"", ""  else if(conn->bits.conn_to_host)"", ""    hostname = conn->conn_to_host.name;"", ""  else"", ""    hostname = conn->host.name;"", """", ""  return aprintf(\""%s:%d\"", hostname, conn->port);"", ""}"", """", ""/* Look up the bundle with all the connections to the same host this""]","[0, 0, 0, -2, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0]","[[3, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/conncache.c"", ""-"", ""return aprintf(\""%s:%d\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_128_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_128_new.cpp""], [15, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/conncache.c"", ""+"", ""return aprintf(\""%s:%d\"", hostname, conn->port);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_128_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_128_new.cpp""]]",132,131
"[""      return 1; /* failure */"", ""  }"", """", ""  if(c) {"", ""    char *format_ptr;"", ""  fputs(\""# Netscape HTTP Cookie File\\n\"""", ""        \""# https://curl.haxx.se/docs/http-cookies.html\\n\"""", ""        \""# This file was generated by libcurl! Edit at your own risk.\\n\\n\"","", ""        out);"", """", ""    fputs(\""# Netscape HTTP Cookie File\\n\"""", ""          \""# http://curl.haxx.se/docs/http-cookies.html\\n\"""", ""          \""# This file was generated by libcurl! Edit at your own risk.\\n\\n\"","", ""          out);"", """", ""    for(co = c->cookies; co; co = co->next) {"", ""      if(!co->domain)"", ""        continue;"", ""      format_ptr = get_netscape_format(co);"", ""      if(format_ptr == NULL) {"", ""        fprintf(out, \""#\\n# Fatal libcurl error\\n\"");"", ""        if(!use_stdout)"", ""          fclose(out);"", ""        return 1;"", ""      }"", ""      fprintf(out, \""%s\\n\"", format_ptr);"", ""      free(format_ptr);"", ""  for(co = c->cookies; co; co = co->next) {"", ""    if(!co->domain)"", ""      continue;"", ""    format_ptr = get_netscape_format(co);"", ""    if(format_ptr == NULL) {"", ""      fprintf(out, \""#\\n# Fatal libcurl error\\n\"");"", ""      if(!use_stdout)"", ""        fclose(out);"", ""      return 1;"", ""    }"", ""    fprintf(out, \""%s\\n\"", format_ptr);"", ""    free(format_ptr);"", ""  }"", """", ""  if(!use_stdout)""]","[0, 0, 0, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -2, -1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, 2, 1, 0, 0, 0]","[[20, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/cookie.c"", ""-"", ""fprintf(out, \""#\\n# Fatal libcurl error\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_129_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_129_new.cpp""], [25, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/cookie.c"", ""-"", ""fprintf(out, \""%s\\n\"", format_ptr);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_129_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_129_new.cpp""], [32, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/cookie.c"", ""+"", ""fprintf(out, \""#\\n# Fatal libcurl error\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_129_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_129_new.cpp""], [37, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/cookie.c"", ""+"", ""fprintf(out, \""%s\\n\"", format_ptr);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_129_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_129_new.cpp""]]",1267,1301
"[""  size_t        len;   /* Name length */"", ""  unsigned int  bit;   /* Flag bit */"", ""} mechtable[] = {"", ""  { \""LOGIN\"",      5,  SASL_MECH_LOGIN },"", ""  { \""PLAIN\"",      5,  SASL_MECH_PLAIN },"", ""  { \""CRAM-MD5\"",   8,  SASL_MECH_CRAM_MD5 },"", ""  { \""DIGEST-MD5\"", 10, SASL_MECH_DIGEST_MD5 },"", ""  { \""GSSAPI\"",     6,  SASL_MECH_GSSAPI },"", ""  { \""EXTERNAL\"",   8,  SASL_MECH_EXTERNAL },"", ""  { \""NTLM\"",       4,  SASL_MECH_NTLM },"", ""  { \""XOAUTH2\"",    7,  SASL_MECH_XOAUTH2 },"", ""  { ZERO_NULL,    0,  0 }"", ""  { \""LOGIN\"",        5,  SASL_MECH_LOGIN },"", ""  { \""PLAIN\"",        5,  SASL_MECH_PLAIN },"", ""  { \""CRAM-MD5\"",     8,  SASL_MECH_CRAM_MD5 },"", ""  { \""DIGEST-MD5\"",   10, SASL_MECH_DIGEST_MD5 },"", ""  { \""GSSAPI\"",       6,  SASL_MECH_GSSAPI },"", ""  { \""EXTERNAL\"",     8,  SASL_MECH_EXTERNAL },"", ""  { \""NTLM\"",         4,  SASL_MECH_NTLM },"", ""  { \""XOAUTH2\"",      7,  SASL_MECH_XOAUTH2 },"", ""  { \""OAUTHBEARER\"",  11, SASL_MECH_OAUTHBEARER },"", ""  { ZERO_NULL,      0,  0 }"", ""};"", """", ""#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)"", ""#define DIGEST_QOP_VALUE_AUTH             (1 << 0)"", ""#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)"", ""#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)"", """", ""#define DIGEST_QOP_VALUE_STRING_AUTH      \""auth\"""", ""#define DIGEST_QOP_VALUE_STRING_AUTH_INT  \""auth-int\"""", ""#define DIGEST_QOP_VALUE_STRING_AUTH_CONF \""auth-conf\"""", """", ""/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines."", ""   It converts digest text to ASCII so the MD5 will be correct for"", ""   what ultimately goes over the network."", ""*/"", ""#define CURL_OUTPUT_DIGEST_CONV(a, b) \\"", ""  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \\"", ""  if(result) { \\"", ""    free(b); \\"", ""    return result; \\"", ""  }"", """", ""#endif"", """", ""#if !defined(CURL_DISABLE_CRYPTO_AUTH)"", ""/*"", "" * Returns 0 on success and then the buffers are filled in fine."", "" *"", "" * Non-zero means failure to parse."", "" */"", ""int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,"", ""                              const char **endptr)"", ""{"", ""  int c;"", ""  bool starts_with_quote = FALSE;"", ""  bool escape = FALSE;"", """", ""  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )"", ""    *value++ = *str++;"", ""  *value = 0;"", """", ""  if('=' != *str++)"", ""    /* eek, no match */"", ""    return 1;"", """", ""  if('\\\""' == *str) {"", ""    /* this starts with a quote so it must end with one as well! */"", ""    str++;"", ""    starts_with_quote = TRUE;"", ""  }"", """", ""  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; str++) {"", ""    switch(*str) {"", ""    case '\\\\':"", ""      if(!escape) {"", ""        /* possibly the start of an escaped quote */"", ""        escape = TRUE;"", ""        *content++ = '\\\\'; /* even though this is an escape character, we still"", ""                              store it as-is in the target buffer */"", ""        continue;"", ""      }"", ""      break;"", ""    case ',':"", ""      if(!starts_with_quote) {"", ""        /* this signals the end of the content if we didn't get a starting"", ""           quote and then we do \""sloppy\"" parsing */"", ""        c = 0; /* the end */"", ""        continue;"", ""      }"", ""      break;"", ""    case '\\r':"", ""    case '\\n':"", ""      /* end of string */"", ""      c = 0;"", ""      continue;"", ""    case '\\\""':"", ""      if(!escape && starts_with_quote) {"", ""        /* end of string */"", ""        c = 0;"", ""        continue;"", ""      }"", ""      break;"", ""    }"", ""    escape = FALSE;"", ""    *content++ = *str;"", ""  }"", ""  *content = 0;"", """", ""  *endptr = str;"", """", ""  return 0; /* all is fine! */"", ""}"", ""#endif"", """", ""#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)"", ""/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/"", ""static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */"", ""                                     unsigned char *dest) /* 33 bytes */"", ""{"", ""  int i;"", ""  for(i = 0; i < 16; i++)"", ""    snprintf((char *)&dest[i*2], 3, \""%02x\"", source[i]);"", ""}"", """", ""/* Perform quoted-string escaping as described in RFC2616 and its errata */"", ""static char *sasl_digest_string_quoted(const char *source)"", ""{"", ""  char *dest, *d;"", ""  const char *s = source;"", ""  size_t n = 1; /* null terminator */"", """", ""  /* Calculate size needed */"", ""  while(*s) {"", ""    ++n;"", ""    if(*s == '\""' || *s == '\\\\') {"", ""      ++n;"", ""    }"", ""    ++s;"", ""  }"", """", ""  dest = malloc(n);"", ""  if(dest) {"", ""    s = source;"", ""    d = dest;"", ""    while(*s) {"", ""      if(*s == '\""' || *s == '\\\\') {"", ""        *d++ = '\\\\';"", ""      }"", ""      *d++ = *s++;"", ""    }"", ""    *d = 0;"", ""  }"", """", ""  return dest;"", ""}"", """", ""/* Retrieves the value for a corresponding key from the challenge string"", "" * returns TRUE if the key could be found, FALSE if it does not exists"", "" */"", ""static bool sasl_digest_get_key_value(const char *chlg,"", ""                                      const char *key,"", ""                                      char *value,"", ""                                      size_t max_val_len,"", ""                                      char end_char)"", ""{"", ""  char *find_pos;"", ""  size_t i;"", """", ""  find_pos = strstr(chlg, key);"", ""  if(!find_pos)"", ""    return FALSE;"", """", ""  find_pos += strlen(key);"", """", ""  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ++i)"", ""    value[i] = *find_pos++;"", ""  value[i] = '\\0';"", """", ""  return TRUE;"", ""}"", """", ""static CURLcode sasl_digest_get_qop_values(const char *options, int *value)"", ""{"", ""  char *tmp;"", ""  char *token;"", ""  char *tok_buf;"", """", ""  /* Initialise the output */"", ""  *value = 0;"", """", ""  /* Tokenise the list of qop values. Use a temporary clone of the buffer since"", ""     strtok_r() ruins it. */"", ""  tmp = strdup(options);"", ""  if(!tmp)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  token = strtok_r(tmp, \"",\"", &tok_buf);"", ""  while(token != NULL) {"", ""    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))"", ""      *value |= DIGEST_QOP_VALUE_AUTH;"", ""    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))"", ""      *value |= DIGEST_QOP_VALUE_AUTH_INT;"", ""    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))"", ""      *value |= DIGEST_QOP_VALUE_AUTH_CONF;"", """", ""    token = strtok_r(NULL, \"",\"", &tok_buf);"", ""  }"", """", ""  free(tmp);"", """", ""  return CURLE_OK;"", ""}"", ""#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */"", """", ""#if !defined(USE_WINDOWS_SSPI)"", ""/*"", "" * Curl_sasl_build_spn()"", "" *"", "" * This is used to build a SPN string in the format service/host."", "" *"", "" * Parameters:"", "" *"", "" * service  [in] - The service type such as www, smtp, pop or imap."", "" * host     [in] - The host name or realm."", "" *"", "" * Returns a pointer to the newly allocated SPN."", "" */"", ""char *Curl_sasl_build_spn(const char *service, const char *host)"", ""{"", ""  /* Generate and return our SPN */"", ""  return aprintf(\""%s/%s\"", service, host);"", ""}"", ""#endif"", """", ""/*"", "" * sasl_create_plain_message()"", "" *"", "" * This is used to generate an already encoded PLAIN message ready"", "" * for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * userp   [in]     - The user name."", "" * passdwp [in]     - The user's password."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_plain_message(struct SessionHandle *data,"", ""                                          const char *userp,"", ""                                          const char *passwdp,"", ""                                          char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result;"", ""  char *plainauth;"", ""  size_t ulen;"", ""  size_t plen;"", """", ""  ulen = strlen(userp);"", ""  plen = strlen(passwdp);"", """", ""  plainauth = malloc(2 * ulen + plen + 2);"", ""  if(!plainauth) {"", ""    *outlen = 0;"", ""    *outptr = NULL;"", ""    return CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  /* Calculate the reply */"", ""  memcpy(plainauth, userp, ulen);"", ""  plainauth[ulen] = '\\0';"", ""  memcpy(plainauth + ulen + 1, userp, ulen);"", ""  plainauth[2 * ulen + 1] = '\\0';"", ""  memcpy(plainauth + 2 * ulen + 2, passwdp, plen);"", """", ""  /* Base64 encode the reply */"", ""  result = Curl_base64_encode(data, plainauth, 2 * ulen + plen + 2, outptr,"", ""                              outlen);"", ""  free(plainauth);"", ""  return result;"", ""}"", """", ""/*"", "" * sasl_create_login_message()"", "" *"", "" * This is used to generate an already encoded LOGIN message containing the"", "" * user name or password ready for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * valuep  [in]     - The user name or user's password."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_login_message(struct SessionHandle *data,"", ""                                          const char *valuep, char **outptr,"", ""                                          size_t *outlen)"", ""{"", ""  size_t vlen = strlen(valuep);"", """", ""  if(!vlen) {"", ""    /* Calculate an empty reply */"", ""    *outptr = strdup(\""=\"");"", ""    if(*outptr) {"", ""      *outlen = (size_t) 1;"", ""      return CURLE_OK;"", ""    }"", """", ""    *outlen = 0;"", ""    return CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  /* Base64 encode the value */"", ""  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);"", ""}"", """", ""/*"", "" * sasl_create_external_message()"", "" *"", "" * This is used to generate an already encoded EXTERNAL message containing"", "" * the user name ready for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * user    [in]     - The user name."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_external_message(struct SessionHandle *data,"", ""                                             const char *user, char **outptr,"", ""                                             size_t *outlen)"", ""{"", ""  /* This is the same formatting as the login message. */"", ""  return sasl_create_login_message(data, user, outptr, outlen);"", ""}"", """", ""#ifndef CURL_DISABLE_CRYPTO_AUTH"", "" /*"", "" * sasl_decode_cram_md5_message()"", "" *"", "" * This is used to decode an already encoded CRAM-MD5 challenge message."", "" *"", "" * Parameters:"", "" *"", "" * chlg64  [in]     - The base64 encoded challenge message."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,"", ""                                             size_t *outlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  size_t chlg64len = strlen(chlg64);"", """", ""  *outptr = NULL;"", ""  *outlen = 0;"", """", ""  /* Decode the challenge if necessary */"", ""  if(chlg64len && *chlg64 != '=')"", ""    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);"", """", ""    return result;"", "" }"", """", "" /*"", "" * sasl_create_cram_md5_message()"", "" *"", "" * This is used to generate an already encoded CRAM-MD5 response message ready"", "" * for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * chlg    [in]     - The challenge."", "" * userp   [in]     - The user name."", "" * passdwp [in]     - The user's password."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,"", ""                                             const char *chlg,"", ""                                             const char *userp,"", ""                                             const char *passwdp,"", ""                                             char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  size_t chlglen = 0;"", ""  HMAC_context *ctxt;"", ""  unsigned char digest[MD5_DIGEST_LEN];"", ""  char *response;"", """", ""  if(chlg)"", ""    chlglen = strlen(chlg);"", """", ""  /* Compute the digest using the password as the key */"", ""  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,"", ""                        (const unsigned char *) passwdp,"", ""                        curlx_uztoui(strlen(passwdp)));"", ""  if(!ctxt)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Update the digest with the given challenge */"", ""  if(chlglen > 0)"", ""    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,"", ""                     curlx_uztoui(chlglen));"", """", ""  /* Finalise the digest */"", ""  Curl_HMAC_final(ctxt, digest);"", """", ""  /* Generate the response */"", ""  response = aprintf("", ""      \""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\"","", ""           userp, digest[0], digest[1], digest[2], digest[3], digest[4],"", ""           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],"", ""           digest[11], digest[12], digest[13], digest[14], digest[15]);"", ""  if(!response)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Base64 encode the response */"", ""  result = Curl_base64_encode(data, response, 0, outptr, outlen);"", """", ""  free(response);"", """", ""  return result;"", ""}"", """", ""#ifndef USE_WINDOWS_SSPI"", ""/*"", "" * sasl_decode_digest_md5_message()"", "" *"", "" * This is used internally to decode an already encoded DIGEST-MD5 challenge"", "" * message into the seperate attributes."", "" *"", "" * Parameters:"", "" *"", "" * chlg64  [in]     - The base64 encoded challenge message."", "" * nonce   [in/out] - The buffer where the nonce will be stored."", "" * nlen    [in]     - The length of the nonce buffer."", "" * realm   [in/out] - The buffer where the realm will be stored."", "" * rlen    [in]     - The length of the realm buffer."", "" * alg     [in/out] - The buffer where the algorithm will be stored."", "" * alen    [in]     - The length of the algorithm buffer."", "" * qop     [in/out] - The buffer where the qop-options will be stored."", "" * qlen    [in]     - The length of the qop buffer."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_decode_digest_md5_message(const char *chlg64,"", ""                                               char *nonce, size_t nlen,"", ""                                               char *realm, size_t rlen,"", ""                                               char *alg, size_t alen,"", ""                                               char *qop, size_t qlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  unsigned char *chlg = NULL;"", ""  size_t chlglen = 0;"", ""  size_t chlg64len = strlen(chlg64);"", """", ""  /* Decode the base-64 encoded challenge message */"", ""  if(chlg64len && *chlg64 != '=') {"", ""    result = Curl_base64_decode(chlg64, &chlg, &chlglen);"", ""    if(result)"", ""      return result;"", ""  }"", """", ""  /* Ensure we have a valid challenge message */"", ""  if(!chlg)"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  /* Retrieve nonce string from the challenge */"", ""  if(!sasl_digest_get_key_value((char *)chlg, \""nonce=\\\""\"", nonce, nlen, '\\\""')) {"", ""    free(chlg);"", ""    return CURLE_BAD_CONTENT_ENCODING;"", ""  }"", """", ""  /* Retrieve realm string from the challenge */"", ""  if(!sasl_digest_get_key_value((char *)chlg, \""realm=\\\""\"", realm, rlen, '\\\""')) {"", ""    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */"", ""    strcpy(realm, \""\"");"", ""  }"", """", ""  /* Retrieve algorithm string from the challenge */"", ""  if(!sasl_digest_get_key_value((char *)chlg, \""algorithm=\"", alg, alen, ',')) {"", ""    free(chlg);"", ""    return CURLE_BAD_CONTENT_ENCODING;"", ""  }"", """", ""  /* Retrieve qop-options string from the challenge */"", ""  if(!sasl_digest_get_key_value((char *)chlg, \""qop=\\\""\"", qop, qlen, '\\\""')) {"", ""    free(chlg);"", ""    return CURLE_BAD_CONTENT_ENCODING;"", ""  }"", """", ""  free(chlg);"", """", ""  return CURLE_OK;"", ""}"", """", ""/*"", "" * Curl_sasl_create_digest_md5_message()"", "" *"", "" * This is used to generate an already encoded DIGEST-MD5 response message"", "" * ready for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * chlg64  [in]     - The base64 encoded challenge message."", "" * userp   [in]     - The user name."", "" * passdwp [in]     - The user's password."", "" * service [in]     - The service type such as www, smtp, pop or imap."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,"", ""                                             const char *chlg64,"", ""                                             const char *userp,"", ""                                             const char *passwdp,"", ""                                             const char *service,"", ""                                             char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  size_t i;"", ""  MD5_context *ctxt;"", ""  char *response = NULL;"", ""  unsigned char digest[MD5_DIGEST_LEN];"", ""  char HA1_hex[2 * MD5_DIGEST_LEN + 1];"", ""  char HA2_hex[2 * MD5_DIGEST_LEN + 1];"", ""  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];"", ""  char nonce[64];"", ""  char realm[128];"", ""  char algorithm[64];"", ""  char qop_options[64];"", ""  int qop_values;"", ""  char cnonce[33];"", ""  unsigned int entropy[4];"", ""  char nonceCount[] = \""00000001\"";"", ""  char method[]     = \""AUTHENTICATE\"";"", ""  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;"", ""  char *spn         = NULL;"", """", ""  /* Decode the challange message */"", ""  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),"", ""                                          realm, sizeof(realm),"", ""                                          algorithm, sizeof(algorithm),"", ""                                          qop_options, sizeof(qop_options));"", ""  if(result)"", ""    return result;"", """", ""  /* We only support md5 sessions */"", ""  if(strcmp(algorithm, \""md5-sess\"") != 0)"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  /* Get the qop-values from the qop-options */"", ""  result = sasl_digest_get_qop_values(qop_options, &qop_values);"", ""  if(result)"", ""    return result;"", """", ""  /* We only support auth quality-of-protection */"", ""  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  /* Generate 16 bytes of random data */"", ""  entropy[0] = Curl_rand(data);"", ""  entropy[1] = Curl_rand(data);"", ""  entropy[2] = Curl_rand(data);"", ""  entropy[3] = Curl_rand(data);"", """", ""  /* Convert the random data into a 32 byte hex string */"", ""  snprintf(cnonce, sizeof(cnonce), \""%08x%08x%08x%08x\"","", ""           entropy[0], entropy[1], entropy[2], entropy[3]);"", """", ""  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */"", ""  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);"", ""  if(!ctxt)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) userp,"", ""                  curlx_uztoui(strlen(userp)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) realm,"", ""                  curlx_uztoui(strlen(realm)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,"", ""                  curlx_uztoui(strlen(passwdp)));"", ""  Curl_MD5_final(ctxt, digest);"", """", ""  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);"", ""  if(!ctxt)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) nonce,"", ""                  curlx_uztoui(strlen(nonce)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,"", ""                  curlx_uztoui(strlen(cnonce)));"", ""  Curl_MD5_final(ctxt, digest);"", """", ""  /* Convert calculated 16 octet hex into 32 bytes string */"", ""  for(i = 0; i < MD5_DIGEST_LEN; i++)"", ""    snprintf(&HA1_hex[2 * i], 3, \""%02x\"", digest[i]);"", """", ""  /* Generate our SPN */"", ""  spn = Curl_sasl_build_spn(service, realm);"", ""  if(!spn)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Calculate H(A2) */"", ""  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);"", ""  if(!ctxt) {"", ""    free(spn);"", """", ""    return CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) method,"", ""                  curlx_uztoui(strlen(method)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) spn,"", ""                  curlx_uztoui(strlen(spn)));"", ""  Curl_MD5_final(ctxt, digest);"", """", ""  for(i = 0; i < MD5_DIGEST_LEN; i++)"", ""    snprintf(&HA2_hex[2 * i], 3, \""%02x\"", digest[i]);"", """", ""  /* Now calculate the response hash */"", ""  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);"", ""  if(!ctxt) {"", ""    free(spn);"", """", ""    return CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) nonce,"", ""                  curlx_uztoui(strlen(nonce)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,"", ""                  curlx_uztoui(strlen(nonceCount)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,"", ""                  curlx_uztoui(strlen(cnonce)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) qop,"", ""                  curlx_uztoui(strlen(qop)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);"", ""  Curl_MD5_final(ctxt, digest);"", """", ""  for(i = 0; i < MD5_DIGEST_LEN; i++)"", ""    snprintf(&resp_hash_hex[2 * i], 3, \""%02x\"", digest[i]);"", """", ""  /* Generate the response */"", ""  response = aprintf(\""username=\\\""%s\\\"",realm=\\\""%s\\\"",nonce=\\\""%s\\\"",\"""", ""                     \""cnonce=\\\""%s\\\"",nc=\\\""%s\\\"",digest-uri=\\\""%s\\\"",response=%s,\"""", ""                     \""qop=%s\"","", ""                     userp, realm, nonce,"", ""                     cnonce, nonceCount, spn, resp_hash_hex, qop);"", ""  free(spn);"", ""  if(!response)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Base64 encode the response */"", ""  result = Curl_base64_encode(data, response, 0, outptr, outlen);"", """", ""  free(response);"", """", ""  return result;"", ""}"", """", ""/*"", "" * Curl_sasl_decode_digest_http_message()"", "" *"", "" * This is used to decode a HTTP DIGEST challenge message into the seperate"", "" * attributes."", "" *"", "" * Parameters:"", "" *"", "" * chlg    [in]     - The challenge message."", "" * digest  [in/out] - The digest data struct being used and modified."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,"", ""                                              struct digestdata *digest)"", ""{"", ""  bool before = FALSE; /* got a nonce before */"", ""  bool foundAuth = FALSE;"", ""  bool foundAuthInt = FALSE;"", ""  char *token = NULL;"", ""  char *tmp = NULL;"", """", ""  /* If we already have received a nonce, keep that in mind */"", ""  if(digest->nonce)"", ""    before = TRUE;"", """", ""  /* Clean up any former leftovers and initialise to defaults */"", ""  Curl_sasl_digest_cleanup(digest);"", """", ""  for(;;) {"", ""    char value[DIGEST_MAX_VALUE_LENGTH];"", ""    char content[DIGEST_MAX_CONTENT_LENGTH];"", """", ""    /* Pass all additional spaces here */"", ""    while(*chlg && ISSPACE(*chlg))"", ""      chlg++;"", """", ""    /* Extract a value=content pair */"", ""    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {"", ""      if(Curl_raw_equal(value, \""nonce\"")) {"", ""        digest->nonce = strdup(content);"", ""        if(!digest->nonce)"", ""          return CURLE_OUT_OF_MEMORY;"", ""      }"", ""      else if(Curl_raw_equal(value, \""stale\"")) {"", ""        if(Curl_raw_equal(content, \""true\"")) {"", ""          digest->stale = TRUE;"", ""          digest->nc = 1; /* we make a new nonce now */"", ""        }"", ""      }"", ""      else if(Curl_raw_equal(value, \""realm\"")) {"", ""        digest->realm = strdup(content);"", ""        if(!digest->realm)"", ""          return CURLE_OUT_OF_MEMORY;"", ""      }"", ""      else if(Curl_raw_equal(value, \""opaque\"")) {"", ""        digest->opaque = strdup(content);"", ""        if(!digest->opaque)"", ""          return CURLE_OUT_OF_MEMORY;"", ""      }"", ""      else if(Curl_raw_equal(value, \""qop\"")) {"", ""        char *tok_buf;"", ""        /* Tokenize the list and choose auth if possible, use a temporary"", ""            clone of the buffer since strtok_r() ruins it */"", ""        tmp = strdup(content);"", ""        if(!tmp)"", ""          return CURLE_OUT_OF_MEMORY;"", """", ""        token = strtok_r(tmp, \"",\"", &tok_buf);"", ""        while(token != NULL) {"", ""          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {"", ""            foundAuth = TRUE;"", ""          }"", ""          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {"", ""            foundAuthInt = TRUE;"", ""          }"", ""          token = strtok_r(NULL, \"",\"", &tok_buf);"", ""        }"", """", ""        free(tmp);"", """", ""        /* Select only auth or auth-int. Otherwise, ignore */"", ""        if(foundAuth) {"", ""          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);"", ""          if(!digest->qop)"", ""            return CURLE_OUT_OF_MEMORY;"", ""        }"", ""        else if(foundAuthInt) {"", ""          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);"", ""          if(!digest->qop)"", ""            return CURLE_OUT_OF_MEMORY;"", ""        }"", ""      }"", ""      else if(Curl_raw_equal(value, \""algorithm\"")) {"", ""        digest->algorithm = strdup(content);"", ""        if(!digest->algorithm)"", ""          return CURLE_OUT_OF_MEMORY;"", """", ""        if(Curl_raw_equal(content, \""MD5-sess\""))"", ""          digest->algo = CURLDIGESTALGO_MD5SESS;"", ""        else if(Curl_raw_equal(content, \""MD5\""))"", ""          digest->algo = CURLDIGESTALGO_MD5;"", ""        else"", ""          return CURLE_BAD_CONTENT_ENCODING;"", ""      }"", ""      else {"", ""        /* unknown specifier, ignore it! */"", ""      }"", ""    }"", ""    else"", ""      break; /* we're done here */"", """", ""    /* Pass all additional spaces here */"", ""    while(*chlg && ISSPACE(*chlg))"", ""      chlg++;"", """", ""    /* Allow the list to be comma-separated */"", ""    if(',' == *chlg)"", ""      chlg++;"", ""  }"", """", ""  /* We had a nonce since before, and we got another one now without"", ""     'stale=true'. This means we provided bad credentials in the previous"", ""     request */"", ""  if(before && !digest->stale)"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  /* We got this header without a nonce, that's a bad Digest line! */"", ""  if(!digest->nonce)"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  return CURLE_OK;"", ""}"", """", ""/*"", "" * Curl_sasl_create_digest_http_message()"", "" *"", "" * This is used to generate a HTTP DIGEST response message ready for sending"", "" * to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * userp   [in]     - The user name."", "" * passdwp [in]     - The user's password."", "" * request [in]     - The HTTP request."", "" * uripath [in]     - The path of the HTTP uri."", "" * digest  [in/out] - The digest data struct being used and modified."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,"", ""                                              const char *userp,"", ""                                              const char *passwdp,"", ""                                              const unsigned char *request,"", ""                                              const unsigned char *uripath,"", ""                                              struct digestdata *digest,"", ""                                              char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result;"", ""  unsigned char md5buf[16]; /* 16 bytes/128 bits */"", ""  unsigned char request_digest[33];"", ""  unsigned char *md5this;"", ""  unsigned char ha1[33];/* 32 digits and 1 zero byte */"", ""  unsigned char ha2[33];/* 32 digits and 1 zero byte */"", ""  char cnoncebuf[33];"", ""  char *cnonce = NULL;"", ""  size_t cnonce_sz = 0;"", ""  char *userp_quoted;"", ""  char *response = NULL;"", ""  char *tmp = NULL;"", """", ""  if(!digest->nc)"", ""    digest->nc = 1;"", """", ""  if(!digest->cnonce) {"", ""    snprintf(cnoncebuf, sizeof(cnoncebuf), \""%08x%08x%08x%08x\"","", ""             Curl_rand(data), Curl_rand(data),"", ""             Curl_rand(data), Curl_rand(data));"", """", ""    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),"", ""                                &cnonce, &cnonce_sz);"", ""    if(result)"", ""      return result;"", """", ""    digest->cnonce = cnonce;"", ""  }"", """", ""  /*"", ""    if the algorithm is \""MD5\"" or unspecified (which then defaults to MD5):"", """", ""    A1 = unq(username-value) \"":\"" unq(realm-value) \"":\"" passwd"", """", ""    if the algorithm is \""MD5-sess\"" then:"", """", ""    A1 = H( unq(username-value) \"":\"" unq(realm-value) \"":\"" passwd )"", ""         \"":\"" unq(nonce-value) \"":\"" unq(cnonce-value)"", ""  */"", """", ""  md5this = (unsigned char *)"", ""    aprintf(\""%s:%s:%s\"", userp, digest->realm, passwdp);"", ""  if(!md5this)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */"", ""  Curl_md5it(md5buf, md5this);"", ""  free(md5this);"", ""  sasl_digest_md5_to_ascii(md5buf, ha1);"", """", ""  if(digest->algo == CURLDIGESTALGO_MD5SESS) {"", ""    /* nonce and cnonce are OUTSIDE the hash */"", ""    tmp = aprintf(\""%s:%s:%s\"", ha1, digest->nonce, digest->cnonce);"", ""    if(!tmp)"", ""      return CURLE_OUT_OF_MEMORY;"", """", ""    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */"", ""    Curl_md5it(md5buf, (unsigned char *)tmp);"", ""    free(tmp);"", ""    sasl_digest_md5_to_ascii(md5buf, ha1);"", ""  }"", """", ""  /*"", ""    If the \""qop\"" directive's value is \""auth\"" or is unspecified, then A2 is:"", """", ""      A2       = Method \"":\"" digest-uri-value"", """", ""          If the \""qop\"" value is \""auth-int\"", then A2 is:"", """", ""      A2       = Method \"":\"" digest-uri-value \"":\"" H(entity-body)"", """", ""    (The \""Method\"" value is the HTTP request method as specified in section"", ""    5.1.1 of RFC 2616)"", ""  */"", """", ""  md5this = (unsigned char *)aprintf(\""%s:%s\"", request, uripath);"", """", ""  if(digest->qop && Curl_raw_equal(digest->qop, \""auth-int\"")) {"", ""    /* We don't support auth-int for PUT or POST at the moment."", ""       TODO: replace md5 of empty string with entity-body for PUT/POST */"", ""    unsigned char *md5this2 = (unsigned char *)"", ""      aprintf(\""%s:%s\"", md5this, \""d41d8cd98f00b204e9800998ecf8427e\"");"", ""    free(md5this);"", ""    md5this = md5this2;"", ""  }"", """", ""  if(!md5this)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */"", ""  Curl_md5it(md5buf, md5this);"", ""  free(md5this);"", ""  sasl_digest_md5_to_ascii(md5buf, ha2);"", """", ""  if(digest->qop) {"", ""    md5this = (unsigned char *)aprintf(\""%s:%s:%08x:%s:%s:%s\"","", ""                                       ha1,"", ""                                       digest->nonce,"", ""                                       digest->nc,"", ""                                       digest->cnonce,"", ""                                       digest->qop,"", ""                                       ha2);"", ""  }"", ""  else {"", ""    md5this = (unsigned char *)aprintf(\""%s:%s:%s\"","", ""                                       ha1,"", ""                                       digest->nonce,"", ""                                       ha2);"", ""  }"", """", ""  if(!md5this)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */"", ""  Curl_md5it(md5buf, md5this);"", ""  free(md5this);"", ""  sasl_digest_md5_to_ascii(md5buf, request_digest);"", """", ""  /* for test case 64 (snooped from a Mozilla 1.3a request)"", """", ""    Authorization: Digest username=\""testuser\"", realm=\""testrealm\"", \\"", ""    nonce=\""1053604145\"", uri=\""/64\"", response=\""c55f7f30d83d774a3d2dcacf725abaca\"""", """", ""    Digest parameters are all quoted strings.  Username which is provided by"", ""    the user will need double quotes and backslashes within it escaped.  For"", ""    the other fields, this shouldn't be an issue.  realm, nonce, and opaque"", ""    are copied as is from the server, escapes and all.  cnonce is generated"", ""    with web-safe characters.  uri is already percent encoded.  nc is 8 hex"", ""    characters.  algorithm and qop with standard values only contain web-safe"", ""    chracters."", ""  */"", ""  userp_quoted = sasl_digest_string_quoted(userp);"", ""  if(!userp_quoted)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  if(digest->qop) {"", ""    response = aprintf(\""username=\\\""%s\\\"", \"""", ""                       \""realm=\\\""%s\\\"", \"""", ""                       \""nonce=\\\""%s\\\"", \"""", ""                       \""uri=\\\""%s\\\"", \"""", ""                       \""cnonce=\\\""%s\\\"", \"""", ""                       \""nc=%08x, \"""", ""                       \""qop=%s, \"""", ""                       \""response=\\\""%s\\\""\"","", ""                       userp_quoted,"", ""                       digest->realm,"", ""                       digest->nonce,"", ""                       uripath,"", ""                       digest->cnonce,"", ""                       digest->nc,"", ""                       digest->qop,"", ""                       request_digest);"", """", ""    if(Curl_raw_equal(digest->qop, \""auth\""))"", ""      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0"", ""                       padded which tells to the server how many times you are"", ""                       using the same nonce in the qop=auth mode */"", ""  }"", ""  else {"", ""    response = aprintf(\""username=\\\""%s\\\"", \"""", ""                       \""realm=\\\""%s\\\"", \"""", ""                       \""nonce=\\\""%s\\\"", \"""", ""                       \""uri=\\\""%s\\\"", \"""", ""                       \""response=\\\""%s\\\""\"","", ""                       userp_quoted,"", ""                       digest->realm,"", ""                       digest->nonce,"", ""                       uripath,"", ""                       request_digest);"", ""  }"", ""  free(userp_quoted);"", ""  if(!response)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Add the optional fields */"", ""  if(digest->opaque) {"", ""    /* Append the opaque */"", ""    tmp = aprintf(\""%s, opaque=\\\""%s\\\""\"", response, digest->opaque);"", ""    free(response);"", ""    if(!tmp)"", ""      return CURLE_OUT_OF_MEMORY;"", """", ""    response = tmp;"", ""  }"", """", ""  if(digest->algorithm) {"", ""    /* Append the algorithm */"", ""    tmp = aprintf(\""%s, algorithm=\\\""%s\\\""\"", response, digest->algorithm);"", ""    free(response);"", ""    if(!tmp)"", ""      return CURLE_OUT_OF_MEMORY;"", """", ""    response = tmp;"", ""  }"", """", ""  /* Return the output */"", ""  *outptr = response;"", ""  *outlen = strlen(response);"", """", ""  return CURLE_OK;"", ""}"", """", ""/*"", "" * Curl_sasl_digest_cleanup()"", "" *"", "" * This is used to clean up the digest specific data."", "" *"", "" * Parameters:"", "" *"", "" * digest    [in/out] - The digest data struct being cleaned up."", "" *"", "" */"", ""void Curl_sasl_digest_cleanup(struct digestdata *digest)"", ""{"", ""  Curl_safefree(digest->nonce);"", ""  Curl_safefree(digest->cnonce);"", ""  Curl_safefree(digest->realm);"", ""  Curl_safefree(digest->opaque);"", ""  Curl_safefree(digest->qop);"", ""  Curl_safefree(digest->algorithm);"", """", ""  digest->nc = 0;"", ""  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */"", ""  digest->stale = FALSE; /* default means normal, not stale */"", ""}"", ""#endif  /* !USE_WINDOWS_SSPI */"", """", ""#endif  /* CURL_DISABLE_CRYPTO_AUTH */"", """", ""#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)"", ""/*"", "" * Curl_sasl_ntlm_cleanup()"", "" *"", "" * This is used to clean up the ntlm specific data."", "" *"", "" * Parameters:"", "" *"", "" * ntlm    [in/out] - The ntlm data struct being cleaned up."", "" *"", "" */"", ""void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)"", ""{"", ""  /* Free the target info */"", ""  Curl_safefree(ntlm->target_info);"", """", ""  /* Reset any variables */"", ""  ntlm->target_info_len = 0;"", ""}"", ""#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/"", """", ""/*"", "" * sasl_create_xoauth2_message()"", "" *"", "" * This is used to generate an already encoded OAuth 2.0 message ready for"", "" * sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * user    [in]     - The user name."", "" * bearer  [in]     - The bearer token."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,"", ""                                            const char *user,"", ""                                            const char *bearer,"", ""                                            char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  char *xoauth = NULL;"", """", ""  /* Generate the message */"", ""  xoauth = aprintf(\""user=%s\\1auth=Bearer %s\\1\\1\"", user, bearer);"", ""  if(!xoauth)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Base64 encode the reply */"", ""  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);"", """", ""  free(xoauth);"", """", ""  return result;"", ""}"", """", ""/*"", "" * Curl_sasl_cleanup()"", "" *""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0]","[[123, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""snprintf((char *)&dest[i*2], 3, \""%02x\"", source[i]);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [232, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""return aprintf(\""%s/%s\"", service, host);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [429, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""response = aprintf("", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [591, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""snprintf(cnonce, sizeof(cnonce), \""%08x%08x%08x%08x\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [624, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""snprintf(&HA1_hex[2 * i], 3, \""%02x\"", digest[i]);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [647, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""snprintf(&HA2_hex[2 * i], 3, \""%02x\"", digest[i]);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [677, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""snprintf(&resp_hash_hex[2 * i], 3, \""%02x\"", digest[i]);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [680, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""response = aprintf(\""username=\\\""%s\\\"",realm=\\\""%s\\\"",nonce=\\\""%s\\\"",\"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [876, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""snprintf(cnoncebuf, sizeof(cnoncebuf), \""%08x%08x%08x%08x\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [900, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""aprintf(\""%s:%s:%s\"", userp, digest->realm, passwdp);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [911, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""tmp = aprintf(\""%s:%s:%s\"", ha1, digest->nonce, digest->cnonce);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [934, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""md5this = (unsigned char *)aprintf(\""%s:%s\"", request, uripath);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [940, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""aprintf(\""%s:%s\"", md5this, \""d41d8cd98f00b204e9800998ecf8427e\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [954, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""md5this = (unsigned char *)aprintf(\""%s:%s:%08x:%s:%s:%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [963, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""md5this = (unsigned char *)aprintf(\""%s:%s:%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [995, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""response = aprintf(\""username=\\\""%s\\\"", \"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [1018, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""response = aprintf(\""username=\\\""%s\\\"", \"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [1036, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""tmp = aprintf(\""%s, opaque=\\\""%s\\\""\"", response, digest->opaque);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [1046, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""tmp = aprintf(\""%s, algorithm=\\\""%s\\\""\"", response, digest->algorithm);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""], [1135, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/curl_sasl.c"", ""-"", ""xoauth = aprintf(\""user=%s\\1auth=Bearer %s\\1\\1\"", user, bearer);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_130_new.cpp""]]",56,57
"[""    if(result)"", ""      return result;"", """", ""    if(fstated) {"", ""      time_t filetime = (time_t)statbuf.st_mtime;"", ""      struct tm buffer;"", ""      const struct tm *tm = &buffer;"", ""      result = Curl_gmtime(filetime, &buffer);"", ""      if(result)"", ""        return result;"", """", ""      /* format: \""Tue, 15 Nov 1994 12:45:26 GMT\"" */"", ""      snprintf(buf, BUFSIZE-1,"", ""               \""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\\r\\n\"","", ""               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],"", ""               tm->tm_mday,"", ""               Curl_month[tm->tm_mon],"", ""               tm->tm_year + 1900,"", ""               tm->tm_hour,"", ""               tm->tm_min,"", ""               tm->tm_sec);"", ""      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);"", ""    }"", ""    /* if we fstat()ed the file, set the file size to make it available post-"", ""       transfer */"", ""    if(fstated)"", ""    filetime = (time_t)statbuf.st_mtime;"", ""    result = Curl_gmtime(filetime, &buffer);"", ""    if(result)"", ""      return result;"", """", ""    /* format: \""Tue, 15 Nov 1994 12:45:26 GMT\"" */"", ""    snprintf(buf, BUFSIZE-1,"", ""             \""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\\r\\n\"","", ""             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],"", ""             tm->tm_mday,"", ""             Curl_month[tm->tm_mon],"", ""             tm->tm_year + 1900,"", ""             tm->tm_hour,"", ""             tm->tm_min,"", ""             tm->tm_sec);"", ""    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);"", ""    if(!result)"", ""      /* set the file size to make it available post transfer */"", ""      Curl_pgrsSetDownloadSize(data, expected_size);"", ""    return result;"", ""  }""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[12, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/file.c"", ""-"", ""snprintf(buf, BUFSIZE-1,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_131_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_131_new.cpp""], [32, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/file.c"", ""+"", ""snprintf(buf, BUFSIZE-1,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_131_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_131_new.cpp""]]",479,486
"[""    }"", ""  }"", """", ""  cmd = aprintf( \""%s%s%s\"","", ""                 data->set.str[STRING_CUSTOMREQUEST]?"", ""                 data->set.str[STRING_CUSTOMREQUEST]:"", ""                 (data->set.ftp_list_only?\""NLST\"":\""LIST\""),"", ""                 lstArg? \"" \"": \""\"","", ""                 lstArg? lstArg: \""\"" );"", ""  cmd = aprintf(\""%s%s%s\"","", ""                data->set.str[STRING_CUSTOMREQUEST]?"", ""                data->set.str[STRING_CUSTOMREQUEST]:"", ""                (data->set.ftp_list_only?\""NLST\"":\""LIST\""),"", ""                lstArg? \"" \"": \""\"","", ""                lstArg? lstArg: \""\"");"", """", ""  if(!cmd) {"", ""    free(lstArg);""]","[0, 0, 0, -2, -1, -1, -1, -1, -1, 2, 1, 1, 1, 1, 1, 0, 0, 0]","[[3, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/ftp.c"", ""-"", ""cmd = aprintf( \""%s%s%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_132_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_132_new.cpp""], [9, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/ftp.c"", ""+"", ""cmd = aprintf(\""%s%s%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_132_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_132_new.cpp""]]",1513,1524
"["""", ""      if(!result) {"", ""        char *host=(char *)\""\"";"", ""        const char *proxyconn=\""\"";"", ""        const char *useragent=\""\"";"", ""        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?"", ""          \""1.0\"" : \""1.1\"";"", ""        char *hostheader= /* host:port with IPv6 support */"", ""          aprintf(\""%s%s%s:%hu\"", conn->bits.ipv6_ip?\""[\"":\""\"","", ""                  hostname, conn->bits.ipv6_ip?\""]\"":\""\"","", ""        bool ipv6_ip = conn->bits.ipv6_ip;"", ""        char *hostheader;"", """", ""        /* the hostname may be different */"", ""        if(hostname != conn->host.name)"", ""          ipv6_ip = (strchr(hostname, ':') != NULL);"", ""        hostheader= /* host:port with IPv6 support */"", ""          aprintf(\""%s%s%s:%hu\"", ipv6_ip?\""[\"":\""\"", hostname, ipv6_ip?\""]\"":\""\"","", ""                  remote_port);"", ""        if(!hostheader) {"", ""          Curl_add_buffer_free(req_buffer);""]","[0, 0, 0, -1, 0, 0, 0, -1, -2, -1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0]","[[8, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/http_proxy.c"", ""-"", ""aprintf(\""%s%s%s:%hu\"", conn->bits.ipv6_ip?\""[\"":\""\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_133_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_133_new.cpp""], [17, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/http_proxy.c"", ""+"", ""aprintf(\""%s%s%s:%hu\"", ipv6_ip?\""[\"":\""\"", hostname, ipv6_ip?\""]\"":\""\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_133_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_133_new.cpp""]]",150,160
"["" * The message SHALL NOT include any LF or CR."", "" */"", """", ""void Curl_failf(struct SessionHandle *data, const char *fmt, ...)"", ""void Curl_failf(struct Curl_easy *data, const char *fmt, ...)"", ""{"", ""  va_list ap;"", ""  size_t len;""]","[0, 0, 0, -2, 2, 0, 0, 0]","[[3, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/sendf.c"", ""-"", ""void Curl_failf(struct SessionHandle *data, const char *fmt, ...)"", 0, ""/data/download/CMake/CMake/Kitware_CMake_134_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_134_new.cpp""], [4, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/sendf.c"", ""+"", ""void Curl_failf(struct Curl_easy *data, const char *fmt, ...)"", 0, ""/data/download/CMake/CMake/Kitware_CMake_134_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_134_new.cpp""]]",140,225
"["""", ""CURLcode Curl_sendf(curl_socket_t sockfd, struct connectdata *,"", ""                    const char *fmt, ...);"", ""void Curl_infof(struct SessionHandle *, const char *fmt, ...);"", ""void Curl_failf(struct SessionHandle *, const char *fmt, ...);"", ""void Curl_infof(struct Curl_easy *, const char *fmt, ...);"", ""void Curl_failf(struct Curl_easy *, const char *fmt, ...);"", """", ""#if defined(CURL_DISABLE_VERBOSE_STRINGS)"", """"]","[0, 0, 0, -1, -2, 1, 2, 0, 0, 0]","[[4, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/sendf.h"", ""-"", ""void Curl_failf(struct SessionHandle *, const char *fmt, ...);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_135_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_135_new.cpp""], [6, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/sendf.h"", ""+"", ""void Curl_failf(struct Curl_easy *, const char *fmt, ...);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_135_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_135_new.cpp""]]",26,26
"[""      state(conn, SSH_SFTP_NEXT_QUOTE);"", ""      break;"", """", ""#ifdef HAS_STATVFS_SUPPORT"", ""    case SSH_SFTP_QUOTE_STATVFS:"", ""    {"", ""      LIBSSH2_SFTP_STATVFS statvfs;"", ""      rc = libssh2_sftp_statvfs(sshc->sftp_session, sshc->quote_path1,"", ""                                curlx_uztoui(strlen(sshc->quote_path1)),"", ""                                &statvfs);"", """", ""      if(rc == LIBSSH2_ERROR_EAGAIN) {"", ""        break;"", ""      }"", ""      else if(rc != 0 && !sshc->acceptfail) {"", ""        err = sftp_libssh2_last_error(sshc->sftp_session);"", ""        Curl_safefree(sshc->quote_path1);"", ""        failf(data, \""statvfs command failed: %s\"", sftp_libssh2_strerror(err));"", ""        state(conn, SSH_SFTP_CLOSE);"", ""        sshc->nextstate = SSH_NO_STATE;"", ""        sshc->actualcode = CURLE_QUOTE_ERROR;"", ""        break;"", ""      }"", ""      else if(rc == 0) {"", ""        char *tmp = aprintf(\""statvfs:\\n\"""", ""                            \""f_bsize: %llu\\n\"" \""f_frsize: %llu\\n\"""", ""                            \""f_blocks: %llu\\n\"" \""f_bfree: %llu\\n\"""", ""                            \""f_bavail: %llu\\n\"" \""f_files: %llu\\n\"""", ""                            \""f_ffree: %llu\\n\"" \""f_favail: %llu\\n\"""", ""                            \""f_fsid: %llu\\n\"" \""f_flag: %llu\\n\"""", ""                            \""f_namemax: %llu\\n\"","", ""                            statvfs.f_bsize, statvfs.f_frsize,"", ""                            statvfs.f_blocks, statvfs.f_bfree,"", ""                            statvfs.f_bavail, statvfs.f_files,"", ""                            statvfs.f_ffree, statvfs.f_favail,"", ""                            statvfs.f_fsid, statvfs.f_flag,"", ""                            statvfs.f_namemax);"", ""        if(!tmp) {"", ""          result = CURLE_OUT_OF_MEMORY;"", ""          state(conn, SSH_SFTP_CLOSE);"", ""          sshc->nextstate = SSH_NO_STATE;"", ""          break;"", ""        }"", """", ""        result = Curl_client_write(conn, CLIENTWRITE_HEADER, tmp, strlen(tmp));"", ""        free(tmp);"", ""        if(result) {"", ""          state(conn, SSH_SFTP_CLOSE);"", ""          sshc->nextstate = SSH_NO_STATE;"", ""          sshc->actualcode = result;"", ""        }"", ""      }"", ""      state(conn, SSH_SFTP_NEXT_QUOTE);"", ""      break;"", ""    }"", ""#endif"", ""    case SSH_SFTP_GETINFO:"", ""    {"", ""      if(data->set.get_filetime) {"", ""        state(conn, SSH_SFTP_FILETIME);"", ""      }"", ""      else {"", ""        state(conn, SSH_SFTP_TRANS_INIT);"", ""      }"", ""      break;"", ""    }"", """", ""    case SSH_SFTP_FILETIME:"", ""    {"", ""      LIBSSH2_SFTP_ATTRIBUTES attrs;"", """", ""      rc = libssh2_sftp_stat_ex(sshc->sftp_session, sftp_scp->path,"", ""                                curlx_uztoui(strlen(sftp_scp->path)),"", ""                                LIBSSH2_SFTP_STAT, &attrs);"", ""      if(rc == LIBSSH2_ERROR_EAGAIN) {"", ""        break;"", ""      }"", ""      else if(rc == 0) {"", ""        data->info.filetime = (long)attrs.mtime;"", ""      }"", """", ""      state(conn, SSH_SFTP_TRANS_INIT);"", ""      break;"", ""    }"", """", ""    case SSH_SFTP_TRANS_INIT:"", ""      if(data->set.upload)"", ""        state(conn, SSH_SFTP_UPLOAD_INIT);""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[24, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/ssh.c"", ""+"", ""char *tmp = aprintf(\""statvfs:\\n\"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_136_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_136_new.cpp""]]",1608,1631
"[""             \""%s%c%s%c\"", filename, '\\0',  mode, '\\0');"", ""    sbytes = 4 + strlen(filename) + strlen(mode);"", """", ""    /* add tsize option */"", ""    if(data->set.upload && (data->state.infilesize != -1))"", ""      snprintf(buf, sizeof(buf), \""%\"" CURL_FORMAT_CURL_OFF_T,"", ""               data->state.infilesize);"", ""    else"", ""      strcpy(buf, \""0\""); /* the destination is large enough */"", """", ""    sbytes += tftp_option_add(state, sbytes,"", ""                              (char *)state->spacket.data+sbytes,"", ""                              TFTP_OPTION_TSIZE);"", ""    sbytes += tftp_option_add(state, sbytes,"", ""                              (char *)state->spacket.data+sbytes, buf);"", ""    /* add blksize option */"", ""    snprintf( buf, sizeof(buf), \""%d\"", state->requested_blksize );"", ""    sbytes += tftp_option_add(state, sbytes,"", ""                              (char *)state->spacket.data+sbytes,"", ""                              TFTP_OPTION_BLKSIZE);"", ""    sbytes += tftp_option_add(state, sbytes,"", ""                              (char *)state->spacket.data+sbytes, buf );"", """", ""    /* add timeout option */"", ""    snprintf( buf, sizeof(buf), \""%d\"", state->retry_time);"", ""    sbytes += tftp_option_add(state, sbytes,"", ""                              (char *)state->spacket.data+sbytes,"", ""                              TFTP_OPTION_INTERVAL);"", ""    sbytes += tftp_option_add(state, sbytes,"", ""                              (char *)state->spacket.data+sbytes, buf );"", ""    /* optional addition of TFTP options */"", ""    if(!data->set.tftp_no_options) {"", ""      /* add tsize option */"", ""      if(data->set.upload && (data->state.infilesize != -1))"", ""        snprintf(buf, sizeof(buf), \""%\"" CURL_FORMAT_CURL_OFF_T,"", ""                 data->state.infilesize);"", ""      else"", ""        strcpy(buf, \""0\""); /* the destination is large enough */"", """", ""      sbytes += tftp_option_add(state, sbytes,"", ""                                (char *)state->spacket.data+sbytes,"", ""                                TFTP_OPTION_TSIZE);"", ""      sbytes += tftp_option_add(state, sbytes,"", ""                                (char *)state->spacket.data+sbytes, buf);"", ""      /* add blksize option */"", ""      snprintf(buf, sizeof(buf), \""%d\"", state->requested_blksize);"", ""      sbytes += tftp_option_add(state, sbytes,"", ""                                (char *)state->spacket.data+sbytes,"", ""                                TFTP_OPTION_BLKSIZE);"", ""      sbytes += tftp_option_add(state, sbytes,"", ""                                (char *)state->spacket.data+sbytes, buf);"", """", ""      /* add timeout option */"", ""      snprintf(buf, sizeof(buf), \""%d\"", state->retry_time);"", ""      sbytes += tftp_option_add(state, sbytes,"", ""                                (char *)state->spacket.data+sbytes,"", ""                                TFTP_OPTION_INTERVAL);"", ""      sbytes += tftp_option_add(state, sbytes,"", ""                                (char *)state->spacket.data+sbytes, buf);"", ""    }"", """", ""    /* the typecase for the 3rd argument is mostly for systems that do"", ""       not have a size_t argument, like older unixes that want an 'int' */""]","[0, 0, 0, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[5, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/tftp.c"", ""-"", ""snprintf(buf, sizeof(buf), \""%\"" CURL_FORMAT_CURL_OFF_T,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_137_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_137_new.cpp""], [16, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/tftp.c"", ""-"", ""snprintf( buf, sizeof(buf), \""%d\"", state->requested_blksize );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_137_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_137_new.cpp""], [24, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/tftp.c"", ""-"", ""snprintf( buf, sizeof(buf), \""%d\"", state->retry_time);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_137_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_137_new.cpp""], [34, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/tftp.c"", ""+"", ""snprintf(buf, sizeof(buf), \""%\"" CURL_FORMAT_CURL_OFF_T,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_137_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_137_new.cpp""], [45, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/tftp.c"", ""+"", ""snprintf(buf, sizeof(buf), \""%d\"", state->requested_blksize);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_137_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_137_new.cpp""], [53, ""f53f4a8a2d215dac634effea575a27e000dfcb29"", ""Merge branch 'upstream-curl' into update-curl\n\n* upstream-curl:\n  curl 2016-08-03 (f2cb3a01)"", ""Utilities/cmcurl/lib/tftp.c"", ""+"", ""snprintf(buf, sizeof(buf), \""%d\"", state->retry_time);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_137_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_137_new.cpp""]]",494,494
"[""/* returns an allocated key to find a bundle for this connection */"", ""static char *hashkey(struct connectdata *conn)"", ""{"", ""  return aprintf(\""%s:%d\"","", ""                 conn->bits.proxy?conn->proxy.name:conn->host.name,"", ""                 conn->localport);"", ""  const char *hostname;"", """", ""  if(conn->bits.proxy)"", ""    hostname = conn->proxy.name;"", ""  else if(conn->bits.conn_to_host)"", ""    hostname = conn->conn_to_host.name;"", ""  else"", ""    hostname = conn->host.name;"", """", ""  return aprintf(\""%s:%d\"", hostname, conn->port);"", ""}"", """", ""/* Look up the bundle with all the connections to the same host this""]","[0, 0, 0, -2, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0]","[[3, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/conncache.c"", ""-"", ""return aprintf(\""%s:%d\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_138_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_138_new.cpp""], [15, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/conncache.c"", ""+"", ""return aprintf(\""%s:%d\"", hostname, conn->port);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_138_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_138_new.cpp""]]",132,131
"[""      return 1; /* failure */"", ""  }"", """", ""  if(c) {"", ""    char *format_ptr;"", ""  fputs(\""# Netscape HTTP Cookie File\\n\"""", ""        \""# https://curl.haxx.se/docs/http-cookies.html\\n\"""", ""        \""# This file was generated by libcurl! Edit at your own risk.\\n\\n\"","", ""        out);"", """", ""    fputs(\""# Netscape HTTP Cookie File\\n\"""", ""          \""# http://curl.haxx.se/docs/http-cookies.html\\n\"""", ""          \""# This file was generated by libcurl! Edit at your own risk.\\n\\n\"","", ""          out);"", """", ""    for(co = c->cookies; co; co = co->next) {"", ""      if(!co->domain)"", ""        continue;"", ""      format_ptr = get_netscape_format(co);"", ""      if(format_ptr == NULL) {"", ""        fprintf(out, \""#\\n# Fatal libcurl error\\n\"");"", ""        if(!use_stdout)"", ""          fclose(out);"", ""        return 1;"", ""      }"", ""      fprintf(out, \""%s\\n\"", format_ptr);"", ""      free(format_ptr);"", ""  for(co = c->cookies; co; co = co->next) {"", ""    if(!co->domain)"", ""      continue;"", ""    format_ptr = get_netscape_format(co);"", ""    if(format_ptr == NULL) {"", ""      fprintf(out, \""#\\n# Fatal libcurl error\\n\"");"", ""      if(!use_stdout)"", ""        fclose(out);"", ""      return 1;"", ""    }"", ""    fprintf(out, \""%s\\n\"", format_ptr);"", ""    free(format_ptr);"", ""  }"", """", ""  if(!use_stdout)""]","[0, 0, 0, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -2, -1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, 2, 1, 0, 0, 0]","[[20, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/cookie.c"", ""-"", ""fprintf(out, \""#\\n# Fatal libcurl error\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_139_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_139_new.cpp""], [25, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/cookie.c"", ""-"", ""fprintf(out, \""%s\\n\"", format_ptr);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_139_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_139_new.cpp""], [32, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/cookie.c"", ""+"", ""fprintf(out, \""#\\n# Fatal libcurl error\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_139_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_139_new.cpp""], [37, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/cookie.c"", ""+"", ""fprintf(out, \""%s\\n\"", format_ptr);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_139_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_139_new.cpp""]]",1267,1301
"[""  size_t        len;   /* Name length */"", ""  unsigned int  bit;   /* Flag bit */"", ""} mechtable[] = {"", ""  { \""LOGIN\"",      5,  SASL_MECH_LOGIN },"", ""  { \""PLAIN\"",      5,  SASL_MECH_PLAIN },"", ""  { \""CRAM-MD5\"",   8,  SASL_MECH_CRAM_MD5 },"", ""  { \""DIGEST-MD5\"", 10, SASL_MECH_DIGEST_MD5 },"", ""  { \""GSSAPI\"",     6,  SASL_MECH_GSSAPI },"", ""  { \""EXTERNAL\"",   8,  SASL_MECH_EXTERNAL },"", ""  { \""NTLM\"",       4,  SASL_MECH_NTLM },"", ""  { \""XOAUTH2\"",    7,  SASL_MECH_XOAUTH2 },"", ""  { ZERO_NULL,    0,  0 }"", ""  { \""LOGIN\"",        5,  SASL_MECH_LOGIN },"", ""  { \""PLAIN\"",        5,  SASL_MECH_PLAIN },"", ""  { \""CRAM-MD5\"",     8,  SASL_MECH_CRAM_MD5 },"", ""  { \""DIGEST-MD5\"",   10, SASL_MECH_DIGEST_MD5 },"", ""  { \""GSSAPI\"",       6,  SASL_MECH_GSSAPI },"", ""  { \""EXTERNAL\"",     8,  SASL_MECH_EXTERNAL },"", ""  { \""NTLM\"",         4,  SASL_MECH_NTLM },"", ""  { \""XOAUTH2\"",      7,  SASL_MECH_XOAUTH2 },"", ""  { \""OAUTHBEARER\"",  11, SASL_MECH_OAUTHBEARER },"", ""  { ZERO_NULL,      0,  0 }"", ""};"", """", ""#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)"", ""#define DIGEST_QOP_VALUE_AUTH             (1 << 0)"", ""#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)"", ""#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)"", """", ""#define DIGEST_QOP_VALUE_STRING_AUTH      \""auth\"""", ""#define DIGEST_QOP_VALUE_STRING_AUTH_INT  \""auth-int\"""", ""#define DIGEST_QOP_VALUE_STRING_AUTH_CONF \""auth-conf\"""", """", ""/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines."", ""   It converts digest text to ASCII so the MD5 will be correct for"", ""   what ultimately goes over the network."", ""*/"", ""#define CURL_OUTPUT_DIGEST_CONV(a, b) \\"", ""  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \\"", ""  if(result) { \\"", ""    free(b); \\"", ""    return result; \\"", ""  }"", """", ""#endif"", """", ""#if !defined(CURL_DISABLE_CRYPTO_AUTH)"", ""/*"", "" * Returns 0 on success and then the buffers are filled in fine."", "" *"", "" * Non-zero means failure to parse."", "" */"", ""int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,"", ""                              const char **endptr)"", ""{"", ""  int c;"", ""  bool starts_with_quote = FALSE;"", ""  bool escape = FALSE;"", """", ""  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )"", ""    *value++ = *str++;"", ""  *value = 0;"", """", ""  if('=' != *str++)"", ""    /* eek, no match */"", ""    return 1;"", """", ""  if('\\\""' == *str) {"", ""    /* this starts with a quote so it must end with one as well! */"", ""    str++;"", ""    starts_with_quote = TRUE;"", ""  }"", """", ""  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; str++) {"", ""    switch(*str) {"", ""    case '\\\\':"", ""      if(!escape) {"", ""        /* possibly the start of an escaped quote */"", ""        escape = TRUE;"", ""        *content++ = '\\\\'; /* even though this is an escape character, we still"", ""                              store it as-is in the target buffer */"", ""        continue;"", ""      }"", ""      break;"", ""    case ',':"", ""      if(!starts_with_quote) {"", ""        /* this signals the end of the content if we didn't get a starting"", ""           quote and then we do \""sloppy\"" parsing */"", ""        c = 0; /* the end */"", ""        continue;"", ""      }"", ""      break;"", ""    case '\\r':"", ""    case '\\n':"", ""      /* end of string */"", ""      c = 0;"", ""      continue;"", ""    case '\\\""':"", ""      if(!escape && starts_with_quote) {"", ""        /* end of string */"", ""        c = 0;"", ""        continue;"", ""      }"", ""      break;"", ""    }"", ""    escape = FALSE;"", ""    *content++ = *str;"", ""  }"", ""  *content = 0;"", """", ""  *endptr = str;"", """", ""  return 0; /* all is fine! */"", ""}"", ""#endif"", """", ""#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)"", ""/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/"", ""static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */"", ""                                     unsigned char *dest) /* 33 bytes */"", ""{"", ""  int i;"", ""  for(i = 0; i < 16; i++)"", ""    snprintf((char *)&dest[i*2], 3, \""%02x\"", source[i]);"", ""}"", """", ""/* Perform quoted-string escaping as described in RFC2616 and its errata */"", ""static char *sasl_digest_string_quoted(const char *source)"", ""{"", ""  char *dest, *d;"", ""  const char *s = source;"", ""  size_t n = 1; /* null terminator */"", """", ""  /* Calculate size needed */"", ""  while(*s) {"", ""    ++n;"", ""    if(*s == '\""' || *s == '\\\\') {"", ""      ++n;"", ""    }"", ""    ++s;"", ""  }"", """", ""  dest = malloc(n);"", ""  if(dest) {"", ""    s = source;"", ""    d = dest;"", ""    while(*s) {"", ""      if(*s == '\""' || *s == '\\\\') {"", ""        *d++ = '\\\\';"", ""      }"", ""      *d++ = *s++;"", ""    }"", ""    *d = 0;"", ""  }"", """", ""  return dest;"", ""}"", """", ""/* Retrieves the value for a corresponding key from the challenge string"", "" * returns TRUE if the key could be found, FALSE if it does not exists"", "" */"", ""static bool sasl_digest_get_key_value(const char *chlg,"", ""                                      const char *key,"", ""                                      char *value,"", ""                                      size_t max_val_len,"", ""                                      char end_char)"", ""{"", ""  char *find_pos;"", ""  size_t i;"", """", ""  find_pos = strstr(chlg, key);"", ""  if(!find_pos)"", ""    return FALSE;"", """", ""  find_pos += strlen(key);"", """", ""  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ++i)"", ""    value[i] = *find_pos++;"", ""  value[i] = '\\0';"", """", ""  return TRUE;"", ""}"", """", ""static CURLcode sasl_digest_get_qop_values(const char *options, int *value)"", ""{"", ""  char *tmp;"", ""  char *token;"", ""  char *tok_buf;"", """", ""  /* Initialise the output */"", ""  *value = 0;"", """", ""  /* Tokenise the list of qop values. Use a temporary clone of the buffer since"", ""     strtok_r() ruins it. */"", ""  tmp = strdup(options);"", ""  if(!tmp)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  token = strtok_r(tmp, \"",\"", &tok_buf);"", ""  while(token != NULL) {"", ""    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))"", ""      *value |= DIGEST_QOP_VALUE_AUTH;"", ""    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))"", ""      *value |= DIGEST_QOP_VALUE_AUTH_INT;"", ""    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))"", ""      *value |= DIGEST_QOP_VALUE_AUTH_CONF;"", """", ""    token = strtok_r(NULL, \"",\"", &tok_buf);"", ""  }"", """", ""  free(tmp);"", """", ""  return CURLE_OK;"", ""}"", ""#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */"", """", ""#if !defined(USE_WINDOWS_SSPI)"", ""/*"", "" * Curl_sasl_build_spn()"", "" *"", "" * This is used to build a SPN string in the format service/host."", "" *"", "" * Parameters:"", "" *"", "" * service  [in] - The service type such as www, smtp, pop or imap."", "" * host     [in] - The host name or realm."", "" *"", "" * Returns a pointer to the newly allocated SPN."", "" */"", ""char *Curl_sasl_build_spn(const char *service, const char *host)"", ""{"", ""  /* Generate and return our SPN */"", ""  return aprintf(\""%s/%s\"", service, host);"", ""}"", ""#endif"", """", ""/*"", "" * sasl_create_plain_message()"", "" *"", "" * This is used to generate an already encoded PLAIN message ready"", "" * for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * userp   [in]     - The user name."", "" * passdwp [in]     - The user's password."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_plain_message(struct SessionHandle *data,"", ""                                          const char *userp,"", ""                                          const char *passwdp,"", ""                                          char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result;"", ""  char *plainauth;"", ""  size_t ulen;"", ""  size_t plen;"", """", ""  ulen = strlen(userp);"", ""  plen = strlen(passwdp);"", """", ""  plainauth = malloc(2 * ulen + plen + 2);"", ""  if(!plainauth) {"", ""    *outlen = 0;"", ""    *outptr = NULL;"", ""    return CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  /* Calculate the reply */"", ""  memcpy(plainauth, userp, ulen);"", ""  plainauth[ulen] = '\\0';"", ""  memcpy(plainauth + ulen + 1, userp, ulen);"", ""  plainauth[2 * ulen + 1] = '\\0';"", ""  memcpy(plainauth + 2 * ulen + 2, passwdp, plen);"", """", ""  /* Base64 encode the reply */"", ""  result = Curl_base64_encode(data, plainauth, 2 * ulen + plen + 2, outptr,"", ""                              outlen);"", ""  free(plainauth);"", ""  return result;"", ""}"", """", ""/*"", "" * sasl_create_login_message()"", "" *"", "" * This is used to generate an already encoded LOGIN message containing the"", "" * user name or password ready for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * valuep  [in]     - The user name or user's password."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_login_message(struct SessionHandle *data,"", ""                                          const char *valuep, char **outptr,"", ""                                          size_t *outlen)"", ""{"", ""  size_t vlen = strlen(valuep);"", """", ""  if(!vlen) {"", ""    /* Calculate an empty reply */"", ""    *outptr = strdup(\""=\"");"", ""    if(*outptr) {"", ""      *outlen = (size_t) 1;"", ""      return CURLE_OK;"", ""    }"", """", ""    *outlen = 0;"", ""    return CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  /* Base64 encode the value */"", ""  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);"", ""}"", """", ""/*"", "" * sasl_create_external_message()"", "" *"", "" * This is used to generate an already encoded EXTERNAL message containing"", "" * the user name ready for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * user    [in]     - The user name."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_external_message(struct SessionHandle *data,"", ""                                             const char *user, char **outptr,"", ""                                             size_t *outlen)"", ""{"", ""  /* This is the same formatting as the login message. */"", ""  return sasl_create_login_message(data, user, outptr, outlen);"", ""}"", """", ""#ifndef CURL_DISABLE_CRYPTO_AUTH"", "" /*"", "" * sasl_decode_cram_md5_message()"", "" *"", "" * This is used to decode an already encoded CRAM-MD5 challenge message."", "" *"", "" * Parameters:"", "" *"", "" * chlg64  [in]     - The base64 encoded challenge message."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,"", ""                                             size_t *outlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  size_t chlg64len = strlen(chlg64);"", """", ""  *outptr = NULL;"", ""  *outlen = 0;"", """", ""  /* Decode the challenge if necessary */"", ""  if(chlg64len && *chlg64 != '=')"", ""    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);"", """", ""    return result;"", "" }"", """", "" /*"", "" * sasl_create_cram_md5_message()"", "" *"", "" * This is used to generate an already encoded CRAM-MD5 response message ready"", "" * for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * chlg    [in]     - The challenge."", "" * userp   [in]     - The user name."", "" * passdwp [in]     - The user's password."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,"", ""                                             const char *chlg,"", ""                                             const char *userp,"", ""                                             const char *passwdp,"", ""                                             char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  size_t chlglen = 0;"", ""  HMAC_context *ctxt;"", ""  unsigned char digest[MD5_DIGEST_LEN];"", ""  char *response;"", """", ""  if(chlg)"", ""    chlglen = strlen(chlg);"", """", ""  /* Compute the digest using the password as the key */"", ""  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,"", ""                        (const unsigned char *) passwdp,"", ""                        curlx_uztoui(strlen(passwdp)));"", ""  if(!ctxt)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Update the digest with the given challenge */"", ""  if(chlglen > 0)"", ""    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,"", ""                     curlx_uztoui(chlglen));"", """", ""  /* Finalise the digest */"", ""  Curl_HMAC_final(ctxt, digest);"", """", ""  /* Generate the response */"", ""  response = aprintf("", ""      \""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\"","", ""           userp, digest[0], digest[1], digest[2], digest[3], digest[4],"", ""           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],"", ""           digest[11], digest[12], digest[13], digest[14], digest[15]);"", ""  if(!response)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Base64 encode the response */"", ""  result = Curl_base64_encode(data, response, 0, outptr, outlen);"", """", ""  free(response);"", """", ""  return result;"", ""}"", """", ""#ifndef USE_WINDOWS_SSPI"", ""/*"", "" * sasl_decode_digest_md5_message()"", "" *"", "" * This is used internally to decode an already encoded DIGEST-MD5 challenge"", "" * message into the seperate attributes."", "" *"", "" * Parameters:"", "" *"", "" * chlg64  [in]     - The base64 encoded challenge message."", "" * nonce   [in/out] - The buffer where the nonce will be stored."", "" * nlen    [in]     - The length of the nonce buffer."", "" * realm   [in/out] - The buffer where the realm will be stored."", "" * rlen    [in]     - The length of the realm buffer."", "" * alg     [in/out] - The buffer where the algorithm will be stored."", "" * alen    [in]     - The length of the algorithm buffer."", "" * qop     [in/out] - The buffer where the qop-options will be stored."", "" * qlen    [in]     - The length of the qop buffer."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_decode_digest_md5_message(const char *chlg64,"", ""                                               char *nonce, size_t nlen,"", ""                                               char *realm, size_t rlen,"", ""                                               char *alg, size_t alen,"", ""                                               char *qop, size_t qlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  unsigned char *chlg = NULL;"", ""  size_t chlglen = 0;"", ""  size_t chlg64len = strlen(chlg64);"", """", ""  /* Decode the base-64 encoded challenge message */"", ""  if(chlg64len && *chlg64 != '=') {"", ""    result = Curl_base64_decode(chlg64, &chlg, &chlglen);"", ""    if(result)"", ""      return result;"", ""  }"", """", ""  /* Ensure we have a valid challenge message */"", ""  if(!chlg)"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  /* Retrieve nonce string from the challenge */"", ""  if(!sasl_digest_get_key_value((char *)chlg, \""nonce=\\\""\"", nonce, nlen, '\\\""')) {"", ""    free(chlg);"", ""    return CURLE_BAD_CONTENT_ENCODING;"", ""  }"", """", ""  /* Retrieve realm string from the challenge */"", ""  if(!sasl_digest_get_key_value((char *)chlg, \""realm=\\\""\"", realm, rlen, '\\\""')) {"", ""    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */"", ""    strcpy(realm, \""\"");"", ""  }"", """", ""  /* Retrieve algorithm string from the challenge */"", ""  if(!sasl_digest_get_key_value((char *)chlg, \""algorithm=\"", alg, alen, ',')) {"", ""    free(chlg);"", ""    return CURLE_BAD_CONTENT_ENCODING;"", ""  }"", """", ""  /* Retrieve qop-options string from the challenge */"", ""  if(!sasl_digest_get_key_value((char *)chlg, \""qop=\\\""\"", qop, qlen, '\\\""')) {"", ""    free(chlg);"", ""    return CURLE_BAD_CONTENT_ENCODING;"", ""  }"", """", ""  free(chlg);"", """", ""  return CURLE_OK;"", ""}"", """", ""/*"", "" * Curl_sasl_create_digest_md5_message()"", "" *"", "" * This is used to generate an already encoded DIGEST-MD5 response message"", "" * ready for sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * chlg64  [in]     - The base64 encoded challenge message."", "" * userp   [in]     - The user name."", "" * passdwp [in]     - The user's password."", "" * service [in]     - The service type such as www, smtp, pop or imap."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,"", ""                                             const char *chlg64,"", ""                                             const char *userp,"", ""                                             const char *passwdp,"", ""                                             const char *service,"", ""                                             char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  size_t i;"", ""  MD5_context *ctxt;"", ""  char *response = NULL;"", ""  unsigned char digest[MD5_DIGEST_LEN];"", ""  char HA1_hex[2 * MD5_DIGEST_LEN + 1];"", ""  char HA2_hex[2 * MD5_DIGEST_LEN + 1];"", ""  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];"", ""  char nonce[64];"", ""  char realm[128];"", ""  char algorithm[64];"", ""  char qop_options[64];"", ""  int qop_values;"", ""  char cnonce[33];"", ""  unsigned int entropy[4];"", ""  char nonceCount[] = \""00000001\"";"", ""  char method[]     = \""AUTHENTICATE\"";"", ""  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;"", ""  char *spn         = NULL;"", """", ""  /* Decode the challange message */"", ""  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),"", ""                                          realm, sizeof(realm),"", ""                                          algorithm, sizeof(algorithm),"", ""                                          qop_options, sizeof(qop_options));"", ""  if(result)"", ""    return result;"", """", ""  /* We only support md5 sessions */"", ""  if(strcmp(algorithm, \""md5-sess\"") != 0)"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  /* Get the qop-values from the qop-options */"", ""  result = sasl_digest_get_qop_values(qop_options, &qop_values);"", ""  if(result)"", ""    return result;"", """", ""  /* We only support auth quality-of-protection */"", ""  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  /* Generate 16 bytes of random data */"", ""  entropy[0] = Curl_rand(data);"", ""  entropy[1] = Curl_rand(data);"", ""  entropy[2] = Curl_rand(data);"", ""  entropy[3] = Curl_rand(data);"", """", ""  /* Convert the random data into a 32 byte hex string */"", ""  snprintf(cnonce, sizeof(cnonce), \""%08x%08x%08x%08x\"","", ""           entropy[0], entropy[1], entropy[2], entropy[3]);"", """", ""  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */"", ""  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);"", ""  if(!ctxt)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) userp,"", ""                  curlx_uztoui(strlen(userp)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) realm,"", ""                  curlx_uztoui(strlen(realm)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,"", ""                  curlx_uztoui(strlen(passwdp)));"", ""  Curl_MD5_final(ctxt, digest);"", """", ""  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);"", ""  if(!ctxt)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) nonce,"", ""                  curlx_uztoui(strlen(nonce)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,"", ""                  curlx_uztoui(strlen(cnonce)));"", ""  Curl_MD5_final(ctxt, digest);"", """", ""  /* Convert calculated 16 octet hex into 32 bytes string */"", ""  for(i = 0; i < MD5_DIGEST_LEN; i++)"", ""    snprintf(&HA1_hex[2 * i], 3, \""%02x\"", digest[i]);"", """", ""  /* Generate our SPN */"", ""  spn = Curl_sasl_build_spn(service, realm);"", ""  if(!spn)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Calculate H(A2) */"", ""  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);"", ""  if(!ctxt) {"", ""    free(spn);"", """", ""    return CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) method,"", ""                  curlx_uztoui(strlen(method)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) spn,"", ""                  curlx_uztoui(strlen(spn)));"", ""  Curl_MD5_final(ctxt, digest);"", """", ""  for(i = 0; i < MD5_DIGEST_LEN; i++)"", ""    snprintf(&HA2_hex[2 * i], 3, \""%02x\"", digest[i]);"", """", ""  /* Now calculate the response hash */"", ""  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);"", ""  if(!ctxt) {"", ""    free(spn);"", """", ""    return CURLE_OUT_OF_MEMORY;"", ""  }"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) nonce,"", ""                  curlx_uztoui(strlen(nonce)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,"", ""                  curlx_uztoui(strlen(nonceCount)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,"", ""                  curlx_uztoui(strlen(cnonce)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", ""  Curl_MD5_update(ctxt, (const unsigned char *) qop,"", ""                  curlx_uztoui(strlen(qop)));"", ""  Curl_MD5_update(ctxt, (const unsigned char *) \"":\"", 1);"", """", ""  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);"", ""  Curl_MD5_final(ctxt, digest);"", """", ""  for(i = 0; i < MD5_DIGEST_LEN; i++)"", ""    snprintf(&resp_hash_hex[2 * i], 3, \""%02x\"", digest[i]);"", """", ""  /* Generate the response */"", ""  response = aprintf(\""username=\\\""%s\\\"",realm=\\\""%s\\\"",nonce=\\\""%s\\\"",\"""", ""                     \""cnonce=\\\""%s\\\"",nc=\\\""%s\\\"",digest-uri=\\\""%s\\\"",response=%s,\"""", ""                     \""qop=%s\"","", ""                     userp, realm, nonce,"", ""                     cnonce, nonceCount, spn, resp_hash_hex, qop);"", ""  free(spn);"", ""  if(!response)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Base64 encode the response */"", ""  result = Curl_base64_encode(data, response, 0, outptr, outlen);"", """", ""  free(response);"", """", ""  return result;"", ""}"", """", ""/*"", "" * Curl_sasl_decode_digest_http_message()"", "" *"", "" * This is used to decode a HTTP DIGEST challenge message into the seperate"", "" * attributes."", "" *"", "" * Parameters:"", "" *"", "" * chlg    [in]     - The challenge message."", "" * digest  [in/out] - The digest data struct being used and modified."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,"", ""                                              struct digestdata *digest)"", ""{"", ""  bool before = FALSE; /* got a nonce before */"", ""  bool foundAuth = FALSE;"", ""  bool foundAuthInt = FALSE;"", ""  char *token = NULL;"", ""  char *tmp = NULL;"", """", ""  /* If we already have received a nonce, keep that in mind */"", ""  if(digest->nonce)"", ""    before = TRUE;"", """", ""  /* Clean up any former leftovers and initialise to defaults */"", ""  Curl_sasl_digest_cleanup(digest);"", """", ""  for(;;) {"", ""    char value[DIGEST_MAX_VALUE_LENGTH];"", ""    char content[DIGEST_MAX_CONTENT_LENGTH];"", """", ""    /* Pass all additional spaces here */"", ""    while(*chlg && ISSPACE(*chlg))"", ""      chlg++;"", """", ""    /* Extract a value=content pair */"", ""    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {"", ""      if(Curl_raw_equal(value, \""nonce\"")) {"", ""        digest->nonce = strdup(content);"", ""        if(!digest->nonce)"", ""          return CURLE_OUT_OF_MEMORY;"", ""      }"", ""      else if(Curl_raw_equal(value, \""stale\"")) {"", ""        if(Curl_raw_equal(content, \""true\"")) {"", ""          digest->stale = TRUE;"", ""          digest->nc = 1; /* we make a new nonce now */"", ""        }"", ""      }"", ""      else if(Curl_raw_equal(value, \""realm\"")) {"", ""        digest->realm = strdup(content);"", ""        if(!digest->realm)"", ""          return CURLE_OUT_OF_MEMORY;"", ""      }"", ""      else if(Curl_raw_equal(value, \""opaque\"")) {"", ""        digest->opaque = strdup(content);"", ""        if(!digest->opaque)"", ""          return CURLE_OUT_OF_MEMORY;"", ""      }"", ""      else if(Curl_raw_equal(value, \""qop\"")) {"", ""        char *tok_buf;"", ""        /* Tokenize the list and choose auth if possible, use a temporary"", ""            clone of the buffer since strtok_r() ruins it */"", ""        tmp = strdup(content);"", ""        if(!tmp)"", ""          return CURLE_OUT_OF_MEMORY;"", """", ""        token = strtok_r(tmp, \"",\"", &tok_buf);"", ""        while(token != NULL) {"", ""          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {"", ""            foundAuth = TRUE;"", ""          }"", ""          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {"", ""            foundAuthInt = TRUE;"", ""          }"", ""          token = strtok_r(NULL, \"",\"", &tok_buf);"", ""        }"", """", ""        free(tmp);"", """", ""        /* Select only auth or auth-int. Otherwise, ignore */"", ""        if(foundAuth) {"", ""          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);"", ""          if(!digest->qop)"", ""            return CURLE_OUT_OF_MEMORY;"", ""        }"", ""        else if(foundAuthInt) {"", ""          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);"", ""          if(!digest->qop)"", ""            return CURLE_OUT_OF_MEMORY;"", ""        }"", ""      }"", ""      else if(Curl_raw_equal(value, \""algorithm\"")) {"", ""        digest->algorithm = strdup(content);"", ""        if(!digest->algorithm)"", ""          return CURLE_OUT_OF_MEMORY;"", """", ""        if(Curl_raw_equal(content, \""MD5-sess\""))"", ""          digest->algo = CURLDIGESTALGO_MD5SESS;"", ""        else if(Curl_raw_equal(content, \""MD5\""))"", ""          digest->algo = CURLDIGESTALGO_MD5;"", ""        else"", ""          return CURLE_BAD_CONTENT_ENCODING;"", ""      }"", ""      else {"", ""        /* unknown specifier, ignore it! */"", ""      }"", ""    }"", ""    else"", ""      break; /* we're done here */"", """", ""    /* Pass all additional spaces here */"", ""    while(*chlg && ISSPACE(*chlg))"", ""      chlg++;"", """", ""    /* Allow the list to be comma-separated */"", ""    if(',' == *chlg)"", ""      chlg++;"", ""  }"", """", ""  /* We had a nonce since before, and we got another one now without"", ""     'stale=true'. This means we provided bad credentials in the previous"", ""     request */"", ""  if(before && !digest->stale)"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  /* We got this header without a nonce, that's a bad Digest line! */"", ""  if(!digest->nonce)"", ""    return CURLE_BAD_CONTENT_ENCODING;"", """", ""  return CURLE_OK;"", ""}"", """", ""/*"", "" * Curl_sasl_create_digest_http_message()"", "" *"", "" * This is used to generate a HTTP DIGEST response message ready for sending"", "" * to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * userp   [in]     - The user name."", "" * passdwp [in]     - The user's password."", "" * request [in]     - The HTTP request."", "" * uripath [in]     - The path of the HTTP uri."", "" * digest  [in/out] - The digest data struct being used and modified."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,"", ""                                              const char *userp,"", ""                                              const char *passwdp,"", ""                                              const unsigned char *request,"", ""                                              const unsigned char *uripath,"", ""                                              struct digestdata *digest,"", ""                                              char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result;"", ""  unsigned char md5buf[16]; /* 16 bytes/128 bits */"", ""  unsigned char request_digest[33];"", ""  unsigned char *md5this;"", ""  unsigned char ha1[33];/* 32 digits and 1 zero byte */"", ""  unsigned char ha2[33];/* 32 digits and 1 zero byte */"", ""  char cnoncebuf[33];"", ""  char *cnonce = NULL;"", ""  size_t cnonce_sz = 0;"", ""  char *userp_quoted;"", ""  char *response = NULL;"", ""  char *tmp = NULL;"", """", ""  if(!digest->nc)"", ""    digest->nc = 1;"", """", ""  if(!digest->cnonce) {"", ""    snprintf(cnoncebuf, sizeof(cnoncebuf), \""%08x%08x%08x%08x\"","", ""             Curl_rand(data), Curl_rand(data),"", ""             Curl_rand(data), Curl_rand(data));"", """", ""    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),"", ""                                &cnonce, &cnonce_sz);"", ""    if(result)"", ""      return result;"", """", ""    digest->cnonce = cnonce;"", ""  }"", """", ""  /*"", ""    if the algorithm is \""MD5\"" or unspecified (which then defaults to MD5):"", """", ""    A1 = unq(username-value) \"":\"" unq(realm-value) \"":\"" passwd"", """", ""    if the algorithm is \""MD5-sess\"" then:"", """", ""    A1 = H( unq(username-value) \"":\"" unq(realm-value) \"":\"" passwd )"", ""         \"":\"" unq(nonce-value) \"":\"" unq(cnonce-value)"", ""  */"", """", ""  md5this = (unsigned char *)"", ""    aprintf(\""%s:%s:%s\"", userp, digest->realm, passwdp);"", ""  if(!md5this)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */"", ""  Curl_md5it(md5buf, md5this);"", ""  free(md5this);"", ""  sasl_digest_md5_to_ascii(md5buf, ha1);"", """", ""  if(digest->algo == CURLDIGESTALGO_MD5SESS) {"", ""    /* nonce and cnonce are OUTSIDE the hash */"", ""    tmp = aprintf(\""%s:%s:%s\"", ha1, digest->nonce, digest->cnonce);"", ""    if(!tmp)"", ""      return CURLE_OUT_OF_MEMORY;"", """", ""    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */"", ""    Curl_md5it(md5buf, (unsigned char *)tmp);"", ""    free(tmp);"", ""    sasl_digest_md5_to_ascii(md5buf, ha1);"", ""  }"", """", ""  /*"", ""    If the \""qop\"" directive's value is \""auth\"" or is unspecified, then A2 is:"", """", ""      A2       = Method \"":\"" digest-uri-value"", """", ""          If the \""qop\"" value is \""auth-int\"", then A2 is:"", """", ""      A2       = Method \"":\"" digest-uri-value \"":\"" H(entity-body)"", """", ""    (The \""Method\"" value is the HTTP request method as specified in section"", ""    5.1.1 of RFC 2616)"", ""  */"", """", ""  md5this = (unsigned char *)aprintf(\""%s:%s\"", request, uripath);"", """", ""  if(digest->qop && Curl_raw_equal(digest->qop, \""auth-int\"")) {"", ""    /* We don't support auth-int for PUT or POST at the moment."", ""       TODO: replace md5 of empty string with entity-body for PUT/POST */"", ""    unsigned char *md5this2 = (unsigned char *)"", ""      aprintf(\""%s:%s\"", md5this, \""d41d8cd98f00b204e9800998ecf8427e\"");"", ""    free(md5this);"", ""    md5this = md5this2;"", ""  }"", """", ""  if(!md5this)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */"", ""  Curl_md5it(md5buf, md5this);"", ""  free(md5this);"", ""  sasl_digest_md5_to_ascii(md5buf, ha2);"", """", ""  if(digest->qop) {"", ""    md5this = (unsigned char *)aprintf(\""%s:%s:%08x:%s:%s:%s\"","", ""                                       ha1,"", ""                                       digest->nonce,"", ""                                       digest->nc,"", ""                                       digest->cnonce,"", ""                                       digest->qop,"", ""                                       ha2);"", ""  }"", ""  else {"", ""    md5this = (unsigned char *)aprintf(\""%s:%s:%s\"","", ""                                       ha1,"", ""                                       digest->nonce,"", ""                                       ha2);"", ""  }"", """", ""  if(!md5this)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */"", ""  Curl_md5it(md5buf, md5this);"", ""  free(md5this);"", ""  sasl_digest_md5_to_ascii(md5buf, request_digest);"", """", ""  /* for test case 64 (snooped from a Mozilla 1.3a request)"", """", ""    Authorization: Digest username=\""testuser\"", realm=\""testrealm\"", \\"", ""    nonce=\""1053604145\"", uri=\""/64\"", response=\""c55f7f30d83d774a3d2dcacf725abaca\"""", """", ""    Digest parameters are all quoted strings.  Username which is provided by"", ""    the user will need double quotes and backslashes within it escaped.  For"", ""    the other fields, this shouldn't be an issue.  realm, nonce, and opaque"", ""    are copied as is from the server, escapes and all.  cnonce is generated"", ""    with web-safe characters.  uri is already percent encoded.  nc is 8 hex"", ""    characters.  algorithm and qop with standard values only contain web-safe"", ""    chracters."", ""  */"", ""  userp_quoted = sasl_digest_string_quoted(userp);"", ""  if(!userp_quoted)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  if(digest->qop) {"", ""    response = aprintf(\""username=\\\""%s\\\"", \"""", ""                       \""realm=\\\""%s\\\"", \"""", ""                       \""nonce=\\\""%s\\\"", \"""", ""                       \""uri=\\\""%s\\\"", \"""", ""                       \""cnonce=\\\""%s\\\"", \"""", ""                       \""nc=%08x, \"""", ""                       \""qop=%s, \"""", ""                       \""response=\\\""%s\\\""\"","", ""                       userp_quoted,"", ""                       digest->realm,"", ""                       digest->nonce,"", ""                       uripath,"", ""                       digest->cnonce,"", ""                       digest->nc,"", ""                       digest->qop,"", ""                       request_digest);"", """", ""    if(Curl_raw_equal(digest->qop, \""auth\""))"", ""      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0"", ""                       padded which tells to the server how many times you are"", ""                       using the same nonce in the qop=auth mode */"", ""  }"", ""  else {"", ""    response = aprintf(\""username=\\\""%s\\\"", \"""", ""                       \""realm=\\\""%s\\\"", \"""", ""                       \""nonce=\\\""%s\\\"", \"""", ""                       \""uri=\\\""%s\\\"", \"""", ""                       \""response=\\\""%s\\\""\"","", ""                       userp_quoted,"", ""                       digest->realm,"", ""                       digest->nonce,"", ""                       uripath,"", ""                       request_digest);"", ""  }"", ""  free(userp_quoted);"", ""  if(!response)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Add the optional fields */"", ""  if(digest->opaque) {"", ""    /* Append the opaque */"", ""    tmp = aprintf(\""%s, opaque=\\\""%s\\\""\"", response, digest->opaque);"", ""    free(response);"", ""    if(!tmp)"", ""      return CURLE_OUT_OF_MEMORY;"", """", ""    response = tmp;"", ""  }"", """", ""  if(digest->algorithm) {"", ""    /* Append the algorithm */"", ""    tmp = aprintf(\""%s, algorithm=\\\""%s\\\""\"", response, digest->algorithm);"", ""    free(response);"", ""    if(!tmp)"", ""      return CURLE_OUT_OF_MEMORY;"", """", ""    response = tmp;"", ""  }"", """", ""  /* Return the output */"", ""  *outptr = response;"", ""  *outlen = strlen(response);"", """", ""  return CURLE_OK;"", ""}"", """", ""/*"", "" * Curl_sasl_digest_cleanup()"", "" *"", "" * This is used to clean up the digest specific data."", "" *"", "" * Parameters:"", "" *"", "" * digest    [in/out] - The digest data struct being cleaned up."", "" *"", "" */"", ""void Curl_sasl_digest_cleanup(struct digestdata *digest)"", ""{"", ""  Curl_safefree(digest->nonce);"", ""  Curl_safefree(digest->cnonce);"", ""  Curl_safefree(digest->realm);"", ""  Curl_safefree(digest->opaque);"", ""  Curl_safefree(digest->qop);"", ""  Curl_safefree(digest->algorithm);"", """", ""  digest->nc = 0;"", ""  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */"", ""  digest->stale = FALSE; /* default means normal, not stale */"", ""}"", ""#endif  /* !USE_WINDOWS_SSPI */"", """", ""#endif  /* CURL_DISABLE_CRYPTO_AUTH */"", """", ""#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)"", ""/*"", "" * Curl_sasl_ntlm_cleanup()"", "" *"", "" * This is used to clean up the ntlm specific data."", "" *"", "" * Parameters:"", "" *"", "" * ntlm    [in/out] - The ntlm data struct being cleaned up."", "" *"", "" */"", ""void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)"", ""{"", ""  /* Free the target info */"", ""  Curl_safefree(ntlm->target_info);"", """", ""  /* Reset any variables */"", ""  ntlm->target_info_len = 0;"", ""}"", ""#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/"", """", ""/*"", "" * sasl_create_xoauth2_message()"", "" *"", "" * This is used to generate an already encoded OAuth 2.0 message ready for"", "" * sending to the recipient."", "" *"", "" * Parameters:"", "" *"", "" * data    [in]     - The session handle."", "" * user    [in]     - The user name."", "" * bearer  [in]     - The bearer token."", "" * outptr  [in/out] - The address where a pointer to newly allocated memory"", "" *                    holding the result will be stored upon completion."", "" * outlen  [out]    - The length of the output message."", "" *"", "" * Returns CURLE_OK on success."", "" */"", ""static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,"", ""                                            const char *user,"", ""                                            const char *bearer,"", ""                                            char **outptr, size_t *outlen)"", ""{"", ""  CURLcode result = CURLE_OK;"", ""  char *xoauth = NULL;"", """", ""  /* Generate the message */"", ""  xoauth = aprintf(\""user=%s\\1auth=Bearer %s\\1\\1\"", user, bearer);"", ""  if(!xoauth)"", ""    return CURLE_OUT_OF_MEMORY;"", """", ""  /* Base64 encode the reply */"", ""  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);"", """", ""  free(xoauth);"", """", ""  return result;"", ""}"", """", ""/*"", "" * Curl_sasl_cleanup()"", "" *""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0]","[[123, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""snprintf((char *)&dest[i*2], 3, \""%02x\"", source[i]);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [232, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""return aprintf(\""%s/%s\"", service, host);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [429, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""response = aprintf("", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [591, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""snprintf(cnonce, sizeof(cnonce), \""%08x%08x%08x%08x\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [624, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""snprintf(&HA1_hex[2 * i], 3, \""%02x\"", digest[i]);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [647, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""snprintf(&HA2_hex[2 * i], 3, \""%02x\"", digest[i]);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [677, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""snprintf(&resp_hash_hex[2 * i], 3, \""%02x\"", digest[i]);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [680, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""response = aprintf(\""username=\\\""%s\\\"",realm=\\\""%s\\\"",nonce=\\\""%s\\\"",\"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [876, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""snprintf(cnoncebuf, sizeof(cnoncebuf), \""%08x%08x%08x%08x\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [900, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""aprintf(\""%s:%s:%s\"", userp, digest->realm, passwdp);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [911, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""tmp = aprintf(\""%s:%s:%s\"", ha1, digest->nonce, digest->cnonce);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [934, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""md5this = (unsigned char *)aprintf(\""%s:%s\"", request, uripath);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [940, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""aprintf(\""%s:%s\"", md5this, \""d41d8cd98f00b204e9800998ecf8427e\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [954, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""md5this = (unsigned char *)aprintf(\""%s:%s:%08x:%s:%s:%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [963, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""md5this = (unsigned char *)aprintf(\""%s:%s:%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [995, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""response = aprintf(\""username=\\\""%s\\\"", \"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [1018, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""response = aprintf(\""username=\\\""%s\\\"", \"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [1036, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""tmp = aprintf(\""%s, opaque=\\\""%s\\\""\"", response, digest->opaque);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [1046, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""tmp = aprintf(\""%s, algorithm=\\\""%s\\\""\"", response, digest->algorithm);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""], [1135, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/curl_sasl.c"", ""-"", ""xoauth = aprintf(\""user=%s\\1auth=Bearer %s\\1\\1\"", user, bearer);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_140_new.cpp""]]",56,57
"[""    if(result)"", ""      return result;"", """", ""    if(fstated) {"", ""      time_t filetime = (time_t)statbuf.st_mtime;"", ""      struct tm buffer;"", ""      const struct tm *tm = &buffer;"", ""      result = Curl_gmtime(filetime, &buffer);"", ""      if(result)"", ""        return result;"", """", ""      /* format: \""Tue, 15 Nov 1994 12:45:26 GMT\"" */"", ""      snprintf(buf, BUFSIZE-1,"", ""               \""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\\r\\n\"","", ""               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],"", ""               tm->tm_mday,"", ""               Curl_month[tm->tm_mon],"", ""               tm->tm_year + 1900,"", ""               tm->tm_hour,"", ""               tm->tm_min,"", ""               tm->tm_sec);"", ""      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);"", ""    }"", ""    /* if we fstat()ed the file, set the file size to make it available post-"", ""       transfer */"", ""    if(fstated)"", ""    filetime = (time_t)statbuf.st_mtime;"", ""    result = Curl_gmtime(filetime, &buffer);"", ""    if(result)"", ""      return result;"", """", ""    /* format: \""Tue, 15 Nov 1994 12:45:26 GMT\"" */"", ""    snprintf(buf, BUFSIZE-1,"", ""             \""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\\r\\n\"","", ""             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],"", ""             tm->tm_mday,"", ""             Curl_month[tm->tm_mon],"", ""             tm->tm_year + 1900,"", ""             tm->tm_hour,"", ""             tm->tm_min,"", ""             tm->tm_sec);"", ""    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);"", ""    if(!result)"", ""      /* set the file size to make it available post transfer */"", ""      Curl_pgrsSetDownloadSize(data, expected_size);"", ""    return result;"", ""  }""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[12, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/file.c"", ""-"", ""snprintf(buf, BUFSIZE-1,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_141_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_141_new.cpp""], [32, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/file.c"", ""+"", ""snprintf(buf, BUFSIZE-1,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_141_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_141_new.cpp""]]",479,486
"[""    }"", ""  }"", """", ""  cmd = aprintf( \""%s%s%s\"","", ""                 data->set.str[STRING_CUSTOMREQUEST]?"", ""                 data->set.str[STRING_CUSTOMREQUEST]:"", ""                 (data->set.ftp_list_only?\""NLST\"":\""LIST\""),"", ""                 lstArg? \"" \"": \""\"","", ""                 lstArg? lstArg: \""\"" );"", ""  cmd = aprintf(\""%s%s%s\"","", ""                data->set.str[STRING_CUSTOMREQUEST]?"", ""                data->set.str[STRING_CUSTOMREQUEST]:"", ""                (data->set.ftp_list_only?\""NLST\"":\""LIST\""),"", ""                lstArg? \"" \"": \""\"","", ""                lstArg? lstArg: \""\"");"", """", ""  if(!cmd) {"", ""    free(lstArg);""]","[0, 0, 0, -2, -1, -1, -1, -1, -1, 2, 1, 1, 1, 1, 1, 0, 0, 0]","[[3, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/ftp.c"", ""-"", ""cmd = aprintf( \""%s%s%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_142_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_142_new.cpp""], [9, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/ftp.c"", ""+"", ""cmd = aprintf(\""%s%s%s\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_142_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_142_new.cpp""]]",1513,1524
"["""", ""      if(!result) {"", ""        char *host=(char *)\""\"";"", ""        const char *proxyconn=\""\"";"", ""        const char *useragent=\""\"";"", ""        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?"", ""          \""1.0\"" : \""1.1\"";"", ""        char *hostheader= /* host:port with IPv6 support */"", ""          aprintf(\""%s%s%s:%hu\"", conn->bits.ipv6_ip?\""[\"":\""\"","", ""                  hostname, conn->bits.ipv6_ip?\""]\"":\""\"","", ""        bool ipv6_ip = conn->bits.ipv6_ip;"", ""        char *hostheader;"", """", ""        /* the hostname may be different */"", ""        if(hostname != conn->host.name)"", ""          ipv6_ip = (strchr(hostname, ':') != NULL);"", ""        hostheader= /* host:port with IPv6 support */"", ""          aprintf(\""%s%s%s:%hu\"", ipv6_ip?\""[\"":\""\"", hostname, ipv6_ip?\""]\"":\""\"","", ""                  remote_port);"", ""        if(!hostheader) {"", ""          Curl_add_buffer_free(req_buffer);""]","[0, 0, 0, -1, 0, 0, 0, -1, -2, -1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0]","[[8, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/http_proxy.c"", ""-"", ""aprintf(\""%s%s%s:%hu\"", conn->bits.ipv6_ip?\""[\"":\""\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_143_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_143_new.cpp""], [17, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/http_proxy.c"", ""+"", ""aprintf(\""%s%s%s:%hu\"", ipv6_ip?\""[\"":\""\"", hostname, ipv6_ip?\""]\"":\""\"","", 0, ""/data/download/CMake/CMake/Kitware_CMake_143_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_143_new.cpp""]]",150,160
"["" * The message SHALL NOT include any LF or CR."", "" */"", """", ""void Curl_failf(struct SessionHandle *data, const char *fmt, ...)"", ""void Curl_failf(struct Curl_easy *data, const char *fmt, ...)"", ""{"", ""  va_list ap;"", ""  size_t len;""]","[0, 0, 0, -2, 2, 0, 0, 0]","[[3, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/sendf.c"", ""-"", ""void Curl_failf(struct SessionHandle *data, const char *fmt, ...)"", 0, ""/data/download/CMake/CMake/Kitware_CMake_144_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_144_new.cpp""], [4, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/sendf.c"", ""+"", ""void Curl_failf(struct Curl_easy *data, const char *fmt, ...)"", 0, ""/data/download/CMake/CMake/Kitware_CMake_144_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_144_new.cpp""]]",140,225
"["""", ""CURLcode Curl_sendf(curl_socket_t sockfd, struct connectdata *,"", ""                    const char *fmt, ...);"", ""void Curl_infof(struct SessionHandle *, const char *fmt, ...);"", ""void Curl_failf(struct SessionHandle *, const char *fmt, ...);"", ""void Curl_infof(struct Curl_easy *, const char *fmt, ...);"", ""void Curl_failf(struct Curl_easy *, const char *fmt, ...);"", """", ""#if defined(CURL_DISABLE_VERBOSE_STRINGS)"", """"]","[0, 0, 0, -1, -2, 1, 2, 0, 0, 0]","[[4, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/sendf.h"", ""-"", ""void Curl_failf(struct SessionHandle *, const char *fmt, ...);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_145_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_145_new.cpp""], [6, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/sendf.h"", ""+"", ""void Curl_failf(struct Curl_easy *, const char *fmt, ...);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_145_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_145_new.cpp""]]",26,26
"[""      state(conn, SSH_SFTP_NEXT_QUOTE);"", ""      break;"", """", ""#ifdef HAS_STATVFS_SUPPORT"", ""    case SSH_SFTP_QUOTE_STATVFS:"", ""    {"", ""      LIBSSH2_SFTP_STATVFS statvfs;"", ""      rc = libssh2_sftp_statvfs(sshc->sftp_session, sshc->quote_path1,"", ""                                curlx_uztoui(strlen(sshc->quote_path1)),"", ""                                &statvfs);"", """", ""      if(rc == LIBSSH2_ERROR_EAGAIN) {"", ""        break;"", ""      }"", ""      else if(rc != 0 && !sshc->acceptfail) {"", ""        err = sftp_libssh2_last_error(sshc->sftp_session);"", ""        Curl_safefree(sshc->quote_path1);"", ""        failf(data, \""statvfs command failed: %s\"", sftp_libssh2_strerror(err));"", ""        state(conn, SSH_SFTP_CLOSE);"", ""        sshc->nextstate = SSH_NO_STATE;"", ""        sshc->actualcode = CURLE_QUOTE_ERROR;"", ""        break;"", ""      }"", ""      else if(rc == 0) {"", ""        char *tmp = aprintf(\""statvfs:\\n\"""", ""                            \""f_bsize: %llu\\n\"" \""f_frsize: %llu\\n\"""", ""                            \""f_blocks: %llu\\n\"" \""f_bfree: %llu\\n\"""", ""                            \""f_bavail: %llu\\n\"" \""f_files: %llu\\n\"""", ""                            \""f_ffree: %llu\\n\"" \""f_favail: %llu\\n\"""", ""                            \""f_fsid: %llu\\n\"" \""f_flag: %llu\\n\"""", ""                            \""f_namemax: %llu\\n\"","", ""                            statvfs.f_bsize, statvfs.f_frsize,"", ""                            statvfs.f_blocks, statvfs.f_bfree,"", ""                            statvfs.f_bavail, statvfs.f_files,"", ""                            statvfs.f_ffree, statvfs.f_favail,"", ""                            statvfs.f_fsid, statvfs.f_flag,"", ""                            statvfs.f_namemax);"", ""        if(!tmp) {"", ""          result = CURLE_OUT_OF_MEMORY;"", ""          state(conn, SSH_SFTP_CLOSE);"", ""          sshc->nextstate = SSH_NO_STATE;"", ""          break;"", ""        }"", """", ""        result = Curl_client_write(conn, CLIENTWRITE_HEADER, tmp, strlen(tmp));"", ""        free(tmp);"", ""        if(result) {"", ""          state(conn, SSH_SFTP_CLOSE);"", ""          sshc->nextstate = SSH_NO_STATE;"", ""          sshc->actualcode = result;"", ""        }"", ""      }"", ""      state(conn, SSH_SFTP_NEXT_QUOTE);"", ""      break;"", ""    }"", ""#endif"", ""    case SSH_SFTP_GETINFO:"", ""    {"", ""      if(data->set.get_filetime) {"", ""        state(conn, SSH_SFTP_FILETIME);"", ""      }"", ""      else {"", ""        state(conn, SSH_SFTP_TRANS_INIT);"", ""      }"", ""      break;"", ""    }"", """", ""    case SSH_SFTP_FILETIME:"", ""    {"", ""      LIBSSH2_SFTP_ATTRIBUTES attrs;"", """", ""      rc = libssh2_sftp_stat_ex(sshc->sftp_session, sftp_scp->path,"", ""                                curlx_uztoui(strlen(sftp_scp->path)),"", ""                                LIBSSH2_SFTP_STAT, &attrs);"", ""      if(rc == LIBSSH2_ERROR_EAGAIN) {"", ""        break;"", ""      }"", ""      else if(rc == 0) {"", ""        data->info.filetime = (long)attrs.mtime;"", ""      }"", """", ""      state(conn, SSH_SFTP_TRANS_INIT);"", ""      break;"", ""    }"", """", ""    case SSH_SFTP_TRANS_INIT:"", ""      if(data->set.upload)"", ""        state(conn, SSH_SFTP_UPLOAD_INIT);""]","[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[24, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/ssh.c"", ""+"", ""char *tmp = aprintf(\""statvfs:\\n\"""", 0, ""/data/download/CMake/CMake/Kitware_CMake_146_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_146_new.cpp""]]",1608,1631
"[""             \""%s%c%s%c\"", filename, '\\0',  mode, '\\0');"", ""    sbytes = 4 + strlen(filename) + strlen(mode);"", """", ""    /* add tsize option */"", ""    if(data->set.upload && (data->state.infilesize != -1))"", ""      snprintf(buf, sizeof(buf), \""%\"" CURL_FORMAT_CURL_OFF_T,"", ""               data->state.infilesize);"", ""    else"", ""      strcpy(buf, \""0\""); /* the destination is large enough */"", """", ""    sbytes += tftp_option_add(state, sbytes,"", ""                              (char *)state->spacket.data+sbytes,"", ""                              TFTP_OPTION_TSIZE);"", ""    sbytes += tftp_option_add(state, sbytes,"", ""                              (char *)state->spacket.data+sbytes, buf);"", ""    /* add blksize option */"", ""    snprintf( buf, sizeof(buf), \""%d\"", state->requested_blksize );"", ""    sbytes += tftp_option_add(state, sbytes,"", ""                              (char *)state->spacket.data+sbytes,"", ""                              TFTP_OPTION_BLKSIZE);"", ""    sbytes += tftp_option_add(state, sbytes,"", ""                              (char *)state->spacket.data+sbytes, buf );"", """", ""    /* add timeout option */"", ""    snprintf( buf, sizeof(buf), \""%d\"", state->retry_time);"", ""    sbytes += tftp_option_add(state, sbytes,"", ""                              (char *)state->spacket.data+sbytes,"", ""                              TFTP_OPTION_INTERVAL);"", ""    sbytes += tftp_option_add(state, sbytes,"", ""                              (char *)state->spacket.data+sbytes, buf );"", ""    /* optional addition of TFTP options */"", ""    if(!data->set.tftp_no_options) {"", ""      /* add tsize option */"", ""      if(data->set.upload && (data->state.infilesize != -1))"", ""        snprintf(buf, sizeof(buf), \""%\"" CURL_FORMAT_CURL_OFF_T,"", ""                 data->state.infilesize);"", ""      else"", ""        strcpy(buf, \""0\""); /* the destination is large enough */"", """", ""      sbytes += tftp_option_add(state, sbytes,"", ""                                (char *)state->spacket.data+sbytes,"", ""                                TFTP_OPTION_TSIZE);"", ""      sbytes += tftp_option_add(state, sbytes,"", ""                                (char *)state->spacket.data+sbytes, buf);"", ""      /* add blksize option */"", ""      snprintf(buf, sizeof(buf), \""%d\"", state->requested_blksize);"", ""      sbytes += tftp_option_add(state, sbytes,"", ""                                (char *)state->spacket.data+sbytes,"", ""                                TFTP_OPTION_BLKSIZE);"", ""      sbytes += tftp_option_add(state, sbytes,"", ""                                (char *)state->spacket.data+sbytes, buf);"", """", ""      /* add timeout option */"", ""      snprintf(buf, sizeof(buf), \""%d\"", state->retry_time);"", ""      sbytes += tftp_option_add(state, sbytes,"", ""                                (char *)state->spacket.data+sbytes,"", ""                                TFTP_OPTION_INTERVAL);"", ""      sbytes += tftp_option_add(state, sbytes,"", ""                                (char *)state->spacket.data+sbytes, buf);"", ""    }"", """", ""    /* the typecase for the 3rd argument is mostly for systems that do"", ""       not have a size_t argument, like older unixes that want an 'int' */""]","[0, 0, 0, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[5, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/tftp.c"", ""-"", ""snprintf(buf, sizeof(buf), \""%\"" CURL_FORMAT_CURL_OFF_T,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_147_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_147_new.cpp""], [16, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/tftp.c"", ""-"", ""snprintf( buf, sizeof(buf), \""%d\"", state->requested_blksize );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_147_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_147_new.cpp""], [24, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/tftp.c"", ""-"", ""snprintf( buf, sizeof(buf), \""%d\"", state->retry_time);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_147_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_147_new.cpp""], [34, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/tftp.c"", ""+"", ""snprintf(buf, sizeof(buf), \""%\"" CURL_FORMAT_CURL_OFF_T,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_147_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_147_new.cpp""], [45, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/tftp.c"", ""+"", ""snprintf(buf, sizeof(buf), \""%d\"", state->requested_blksize);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_147_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_147_new.cpp""], [53, ""202adcfe056681109fe61569ecdb3bd69f0b4f97"", ""curl 2016-08-03 (f2cb3a01)\n\nCode extracted from:\n\n    https://github.com/bagder/curl.git\n\nat commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1)."", ""lib/tftp.c"", ""+"", ""snprintf(buf, sizeof(buf), \""%d\"", state->retry_time);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_147_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_147_new.cpp""]]",494,494
"[""      rar->range_dec.Stream = &rar->bytein;"", ""      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);"", """", ""      if (rar->dictionary_size == 0) {"", ""\t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""                          \""Invalid zero dictionary size\"");"", ""\t      return (ARCHIVE_FATAL);"", ""      }"", """", ""      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,"", ""        rar->dictionary_size, &g_szalloc))"", ""      {""]","[0, 0, 0, 1, 2, 1, 1, 1, 1, 0, 0, 0]","[[4, ""9cb685505ad86ecb560d1c71e7314f0ef98971f2"", ""Merge topic 'update-libarchive'\n\n52f58267 Merge branch 'upstream-LibArchive' into update-libarchive\n2b94d71d LibArchive 2016-06-19 (139d0576)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_rar.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_148_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_148_new.cpp""]]",2127,2127
"[""      rar->range_dec.Stream = &rar->bytein;"", ""      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);"", """", ""      if (rar->dictionary_size == 0) {"", ""\t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""                          \""Invalid zero dictionary size\"");"", ""\t      return (ARCHIVE_FATAL);"", ""      }"", """", ""      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,"", ""        rar->dictionary_size, &g_szalloc))"", ""      {""]","[0, 0, 0, 1, 2, 1, 1, 1, 1, 0, 0, 0]","[[4, ""d38fc22132db1b82fad1ef5b8a7f5e030c71a90f"", ""Merge branch 'update-libarchive' into release"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_rar.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_149_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_149_new.cpp""]]",2127,2127
"[""      rar->range_dec.Stream = &rar->bytein;"", ""      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);"", """", ""      if (rar->dictionary_size == 0) {"", ""\t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""                          \""Invalid zero dictionary size\"");"", ""\t      return (ARCHIVE_FATAL);"", ""      }"", """", ""      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,"", ""        rar->dictionary_size, &g_szalloc))"", ""      {""]","[0, 0, 0, 1, 2, 1, 1, 1, 1, 0, 0, 0]","[[4, ""52f58267c311550db83f4a9430f378e730bd3d6b"", ""Merge branch 'upstream-LibArchive' into update-libarchive\n\n* upstream-LibArchive:\n  LibArchive 2016-06-19 (139d0576)"", ""Utilities/cmlibarchive/libarchive/archive_read_support_format_rar.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_150_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_150_new.cpp""]]",2127,2127
"[""      rar->range_dec.Stream = &rar->bytein;"", ""      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);"", """", ""      if (rar->dictionary_size == 0) {"", ""\t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", ""                          \""Invalid zero dictionary size\"");"", ""\t      return (ARCHIVE_FATAL);"", ""      }"", """", ""      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,"", ""        rar->dictionary_size, &g_szalloc))"", ""      {""]","[0, 0, 0, 1, 2, 1, 1, 1, 1, 0, 0, 0]","[[4, ""2b94d71d8850d68b677d5653c698371528344a10"", ""LibArchive 2016-06-19 (139d0576)\n\nCode extracted from:\n\n    https://github.com/libarchive/libarchive.git\n\nat commit 139d0576b51a253732a5ab1f66805dffbf8b00af (master)."", ""libarchive/archive_read_support_format_rar.c"", ""+"", ""archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_151_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_151_new.cpp""]]",2127,2127
"[""              fname.c_str());"", ""    }"", """", ""    /* for the TRY_COMPILEs we want to be able to specify the architecture."", ""      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set"", ""      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to"", ""      have the tests run for each specific architecture. Since"", ""      cmLocalGenerator doesn't allow building for \""the other\"""", ""      architecture only via CMAKE_OSX_ARCHITECTURES."", ""      */"", ""    if (this->Makefile->GetDefinition(\""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES\"") !="", ""        0) {"", ""      std::string flag = \""-DCMAKE_OSX_ARCHITECTURES=\"";"", ""      flag += this->Makefile->GetSafeDefinition("", ""        \""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES\"");"", ""      cmakeFlags.push_back(flag);"", ""    } else if (this->Makefile->GetDefinition(\""CMAKE_OSX_ARCHITECTURES\"") != 0) {"", ""      std::string flag = \""-DCMAKE_OSX_ARCHITECTURES=\"";"", ""      flag += this->Makefile->GetSafeDefinition(\""CMAKE_OSX_ARCHITECTURES\"");"", ""      cmakeFlags.push_back(flag);"", ""    }"", ""    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */"", ""    if (this->Makefile->GetDefinition(\""CMAKE_OSX_SYSROOT\"") != 0) {"", ""      std::string flag = \""-DCMAKE_OSX_SYSROOT=\"";"", ""      flag += this->Makefile->GetSafeDefinition(\""CMAKE_OSX_SYSROOT\"");"", ""      cmakeFlags.push_back(flag);"", ""    }"", ""    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */"", ""    if (this->Makefile->GetDefinition(\""CMAKE_OSX_DEPLOYMENT_TARGET\"") != 0) {"", ""      std::string flag = \""-DCMAKE_OSX_DEPLOYMENT_TARGET=\"";"", ""      flag += this->Makefile->GetSafeDefinition(\""CMAKE_OSX_DEPLOYMENT_TARGET\"");"", ""      cmakeFlags.push_back(flag);"", ""    }"", ""    if (const char* cxxDef ="", ""          this->Makefile->GetDefinition(\""CMAKE_CXX_COMPILER_TARGET\"")) {"", ""      std::string flag = \""-DCMAKE_CXX_COMPILER_TARGET=\"";"", ""      flag += cxxDef;"", ""      cmakeFlags.push_back(flag);"", ""    }"", ""    if (const char* cDef ="", ""          this->Makefile->GetDefinition(\""CMAKE_C_COMPILER_TARGET\"")) {"", ""      std::string flag = \""-DCMAKE_C_COMPILER_TARGET=\"";"", ""      flag += cDef;"", ""      cmakeFlags.push_back(flag);"", ""    }"", ""    if (const char* tcxxDef = this->Makefile->GetDefinition("", ""          \""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN\"")) {"", ""      std::string flag = \""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN=\"";"", ""      flag += tcxxDef;"", ""      cmakeFlags.push_back(flag);"", ""    }"", ""    if (const char* tcDef = this->Makefile->GetDefinition("", ""          \""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN\"")) {"", ""      std::string flag = \""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN=\"";"", ""      flag += tcDef;"", ""      cmakeFlags.push_back(flag);"", ""    }"", ""    if (const char* rootDef = this->Makefile->GetDefinition(\""CMAKE_SYSROOT\"")) {"", ""      std::string flag = \""-DCMAKE_SYSROOT=\"";"", ""      flag += rootDef;"", ""      cmakeFlags.push_back(flag);"", ""    }"", ""    if (this->Makefile->GetDefinition(\""CMAKE_POSITION_INDEPENDENT_CODE\"") !="", ""        0) {"", ""      fprintf(fout, \""set(CMAKE_POSITION_INDEPENDENT_CODE \\\""ON\\\"")\\n\"");"", ""    }"", ""    if (const char* lssDef ="", ""          this->Makefile->GetDefinition(\""CMAKE_LINK_SEARCH_START_STATIC\"")) {"", ""      fprintf(fout, \""set(CMAKE_LINK_SEARCH_START_STATIC \\\""%s\\\"")\\n\"", lssDef);"", ""    }"", ""    if (const char* lssDef ="", ""          this->Makefile->GetDefinition(\""CMAKE_LINK_SEARCH_END_STATIC\"")) {"", ""      fprintf(fout, \""set(CMAKE_LINK_SEARCH_END_STATIC \\\""%s\\\"")\\n\"", lssDef);"", ""    // Forward a set of variables to the inner project cache."", ""    {"", ""      std::set<std::string> vars;"", ""      vars.insert(kCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN);"", ""      vars.insert(kCMAKE_C_COMPILER_TARGET);"", ""      vars.insert(kCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN);"", ""      vars.insert(kCMAKE_CXX_COMPILER_TARGET);"", ""      vars.insert(kCMAKE_ENABLE_EXPORTS);"", ""      vars.insert(kCMAKE_LINK_SEARCH_END_STATIC);"", ""      vars.insert(kCMAKE_LINK_SEARCH_START_STATIC);"", ""      vars.insert(kCMAKE_OSX_ARCHITECTURES);"", ""      vars.insert(kCMAKE_OSX_DEPLOYMENT_TARGET);"", ""      vars.insert(kCMAKE_OSX_SYSROOT);"", ""      vars.insert(kCMAKE_POSITION_INDEPENDENT_CODE);"", ""      vars.insert(kCMAKE_SYSROOT);"", """", ""      if (const char* varListStr = this->Makefile->GetDefinition("", ""            kCMAKE_TRY_COMPILE_PLATFORM_VARIABLES)) {"", ""        std::vector<std::string> varList;"", ""        cmSystemTools::ExpandListArgument(varListStr, varList);"", ""        vars.insert(varList.begin(), varList.end());"", ""      }"", """", ""      /* for the TRY_COMPILEs we want to be able to specify the architecture."", ""         So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set"", ""         CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to"", ""         have the tests run for each specific architecture. Since"", ""         cmLocalGenerator doesn't allow building for \""the other\"""", ""         architecture only via CMAKE_OSX_ARCHITECTURES."", ""         */"", ""      if (const char* tcArchs = this->Makefile->GetDefinition("", ""            kCMAKE_TRY_COMPILE_OSX_ARCHITECTURES)) {"", ""        vars.erase(kCMAKE_OSX_ARCHITECTURES);"", ""        std::string flag = \""-DCMAKE_OSX_ARCHITECTURES=\"" + std::string(tcArchs);"", ""        cmakeFlags.push_back(flag);"", ""      }"", """", ""      for (std::set<std::string>::iterator vi = vars.begin(); vi != vars.end();"", ""           ++vi) {"", ""        std::string const& var = *vi;"", ""        if (const char* val = this->Makefile->GetDefinition(var)) {"", ""          std::string flag = \""-D\"" + var + \""=\"" + val;"", ""          cmakeFlags.push_back(flag);"", ""        }"", ""      }"", ""    }"", """", ""    /* Set the appropriate policy information for ENABLE_EXPORTS */""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -2, -1, -1, -1, -2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[64, ""36d9a01a31560ff3eb66e914c0a36a5d6a09844a"", ""Merge topic 'try_compile-custom-variables'\n\nd256ba07 try_compile: Optionally forward custom platform variables to test project\nfb4791b3 cmCoreTryCompile: Refactor forwarding of variables to test project"", ""Source/cmCoreTryCompile.cxx"", ""-"", ""fprintf(fout, \""set(CMAKE_POSITION_INDEPENDENT_CODE \\\""ON\\\"")\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_152_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_152_new.cpp""], [68, ""36d9a01a31560ff3eb66e914c0a36a5d6a09844a"", ""Merge topic 'try_compile-custom-variables'\n\nd256ba07 try_compile: Optionally forward custom platform variables to test project\nfb4791b3 cmCoreTryCompile: Refactor forwarding of variables to test project"", ""Source/cmCoreTryCompile.cxx"", ""-"", ""fprintf(fout, \""set(CMAKE_LINK_SEARCH_START_STATIC \\\""%s\\\"")\\n\"", lssDef);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_152_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_152_new.cpp""], [72, ""36d9a01a31560ff3eb66e914c0a36a5d6a09844a"", ""Merge topic 'try_compile-custom-variables'\n\nd256ba07 try_compile: Optionally forward custom platform variables to test project\nfb4791b3 cmCoreTryCompile: Refactor forwarding of variables to test project"", ""Source/cmCoreTryCompile.cxx"", ""-"", ""fprintf(fout, \""set(CMAKE_LINK_SEARCH_END_STATIC \\\""%s\\\"")\\n\"", lssDef);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_152_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_152_new.cpp""]]",383,407
"[""              fname.c_str());"", ""    }"", """", ""    /* for the TRY_COMPILEs we want to be able to specify the architecture."", ""      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set"", ""      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to"", ""      have the tests run for each specific architecture. Since"", ""      cmLocalGenerator doesn't allow building for \""the other\"""", ""      architecture only via CMAKE_OSX_ARCHITECTURES."", ""      */"", ""    if (this->Makefile->GetDefinition(\""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES\"") !="", ""        0) {"", ""      std::string flag = \""-DCMAKE_OSX_ARCHITECTURES=\"";"", ""      flag += this->Makefile->GetSafeDefinition("", ""        \""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES\"");"", ""      cmakeFlags.push_back(flag);"", ""    } else if (this->Makefile->GetDefinition(\""CMAKE_OSX_ARCHITECTURES\"") != 0) {"", ""      std::string flag = \""-DCMAKE_OSX_ARCHITECTURES=\"";"", ""      flag += this->Makefile->GetSafeDefinition(\""CMAKE_OSX_ARCHITECTURES\"");"", ""      cmakeFlags.push_back(flag);"", ""    }"", ""    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */"", ""    if (this->Makefile->GetDefinition(\""CMAKE_OSX_SYSROOT\"") != 0) {"", ""      std::string flag = \""-DCMAKE_OSX_SYSROOT=\"";"", ""      flag += this->Makefile->GetSafeDefinition(\""CMAKE_OSX_SYSROOT\"");"", ""      cmakeFlags.push_back(flag);"", ""    }"", ""    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */"", ""    if (this->Makefile->GetDefinition(\""CMAKE_OSX_DEPLOYMENT_TARGET\"") != 0) {"", ""      std::string flag = \""-DCMAKE_OSX_DEPLOYMENT_TARGET=\"";"", ""      flag += this->Makefile->GetSafeDefinition(\""CMAKE_OSX_DEPLOYMENT_TARGET\"");"", ""      cmakeFlags.push_back(flag);"", ""    }"", ""    if (const char* cxxDef ="", ""          this->Makefile->GetDefinition(\""CMAKE_CXX_COMPILER_TARGET\"")) {"", ""      std::string flag = \""-DCMAKE_CXX_COMPILER_TARGET=\"";"", ""      flag += cxxDef;"", ""      cmakeFlags.push_back(flag);"", ""    }"", ""    if (const char* cDef ="", ""          this->Makefile->GetDefinition(\""CMAKE_C_COMPILER_TARGET\"")) {"", ""      std::string flag = \""-DCMAKE_C_COMPILER_TARGET=\"";"", ""      flag += cDef;"", ""      cmakeFlags.push_back(flag);"", ""    }"", ""    if (const char* tcxxDef = this->Makefile->GetDefinition("", ""          \""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN\"")) {"", ""      std::string flag = \""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN=\"";"", ""      flag += tcxxDef;"", ""      cmakeFlags.push_back(flag);"", ""    }"", ""    if (const char* tcDef = this->Makefile->GetDefinition("", ""          \""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN\"")) {"", ""      std::string flag = \""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN=\"";"", ""      flag += tcDef;"", ""      cmakeFlags.push_back(flag);"", ""    }"", ""    if (const char* rootDef = this->Makefile->GetDefinition(\""CMAKE_SYSROOT\"")) {"", ""      std::string flag = \""-DCMAKE_SYSROOT=\"";"", ""      flag += rootDef;"", ""      cmakeFlags.push_back(flag);"", ""    }"", ""    if (this->Makefile->GetDefinition(\""CMAKE_POSITION_INDEPENDENT_CODE\"") !="", ""        0) {"", ""      fprintf(fout, \""set(CMAKE_POSITION_INDEPENDENT_CODE \\\""ON\\\"")\\n\"");"", ""    }"", ""    if (const char* lssDef ="", ""          this->Makefile->GetDefinition(\""CMAKE_LINK_SEARCH_START_STATIC\"")) {"", ""      fprintf(fout, \""set(CMAKE_LINK_SEARCH_START_STATIC \\\""%s\\\"")\\n\"", lssDef);"", ""    }"", ""    if (const char* lssDef ="", ""          this->Makefile->GetDefinition(\""CMAKE_LINK_SEARCH_END_STATIC\"")) {"", ""      fprintf(fout, \""set(CMAKE_LINK_SEARCH_END_STATIC \\\""%s\\\"")\\n\"", lssDef);"", ""    // Forward a set of variables to the inner project cache."", ""    {"", ""      std::set<std::string> vars;"", ""      vars.insert(kCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN);"", ""      vars.insert(kCMAKE_C_COMPILER_TARGET);"", ""      vars.insert(kCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN);"", ""      vars.insert(kCMAKE_CXX_COMPILER_TARGET);"", ""      vars.insert(kCMAKE_ENABLE_EXPORTS);"", ""      vars.insert(kCMAKE_LINK_SEARCH_END_STATIC);"", ""      vars.insert(kCMAKE_LINK_SEARCH_START_STATIC);"", ""      vars.insert(kCMAKE_OSX_ARCHITECTURES);"", ""      vars.insert(kCMAKE_OSX_DEPLOYMENT_TARGET);"", ""      vars.insert(kCMAKE_OSX_SYSROOT);"", ""      vars.insert(kCMAKE_POSITION_INDEPENDENT_CODE);"", ""      vars.insert(kCMAKE_SYSROOT);"", """", ""      /* for the TRY_COMPILEs we want to be able to specify the architecture."", ""         So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set"", ""         CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to"", ""         have the tests run for each specific architecture. Since"", ""         cmLocalGenerator doesn't allow building for \""the other\"""", ""         architecture only via CMAKE_OSX_ARCHITECTURES."", ""         */"", ""      if (const char* tcArchs = this->Makefile->GetDefinition("", ""            kCMAKE_TRY_COMPILE_OSX_ARCHITECTURES)) {"", ""        vars.erase(kCMAKE_OSX_ARCHITECTURES);"", ""        std::string flag = \""-DCMAKE_OSX_ARCHITECTURES=\"" + std::string(tcArchs);"", ""        cmakeFlags.push_back(flag);"", ""      }"", """", ""      for (std::set<std::string>::iterator vi = vars.begin(); vi != vars.end();"", ""           ++vi) {"", ""        std::string const& var = *vi;"", ""        if (const char* val = this->Makefile->GetDefinition(var)) {"", ""          std::string flag = \""-D\"" + var + \""=\"" + val;"", ""          cmakeFlags.push_back(flag);"", ""        }"", ""      }"", ""    }"", """", ""    /* Set the appropriate policy information for ENABLE_EXPORTS */""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -2, -1, -1, -1, -2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[64, ""fb4791b37ccea1f38b8625b31df952408ab942f3"", ""cmCoreTryCompile: Refactor forwarding of variables to test project\n\nDe-duplicate the logic that constructs the cmake `-D` flag used to pass\nvariables into the test project cache.  Also subsume variables that were\npropagated by generating `set()` commands in the project and pass them\nas cache entries instead."", ""Source/cmCoreTryCompile.cxx"", ""-"", ""fprintf(fout, \""set(CMAKE_POSITION_INDEPENDENT_CODE \\\""ON\\\"")\\n\"");"", 0, ""/data/download/CMake/CMake/Kitware_CMake_153_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_153_new.cpp""], [68, ""fb4791b37ccea1f38b8625b31df952408ab942f3"", ""cmCoreTryCompile: Refactor forwarding of variables to test project\n\nDe-duplicate the logic that constructs the cmake `-D` flag used to pass\nvariables into the test project cache.  Also subsume variables that were\npropagated by generating `set()` commands in the project and pass them\nas cache entries instead."", ""Source/cmCoreTryCompile.cxx"", ""-"", ""fprintf(fout, \""set(CMAKE_LINK_SEARCH_START_STATIC \\\""%s\\\"")\\n\"", lssDef);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_153_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_153_new.cpp""], [72, ""fb4791b37ccea1f38b8625b31df952408ab942f3"", ""cmCoreTryCompile: Refactor forwarding of variables to test project\n\nDe-duplicate the logic that constructs the cmake `-D` flag used to pass\nvariables into the test project cache.  Also subsume variables that were\npropagated by generating `set()` commands in the project and pass them\nas cache entries instead."", ""Source/cmCoreTryCompile.cxx"", ""-"", ""fprintf(fout, \""set(CMAKE_LINK_SEARCH_END_STATIC \\\""%s\\\"")\\n\"", lssDef);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_153_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_153_new.cpp""]]",383,405
"["" */"", ""#ifndef YY_INPUT"", ""#define YY_INPUT(buf,result,max_size) \\"", ""        if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\"", ""                { \\"", ""                int c = '*'; \\"", ""                size_t n; \\"", ""                for ( n = 0; n < max_size && \\"", ""                             (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\"", ""                        buf[n] = (char) c; \\"", ""                if ( c == '\\n' ) \\"", ""                        buf[n++] = (char) c; \\"", ""                if ( c == EOF && ferror( yyin ) ) \\"", ""                        YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""                result = n; \\"", ""                } \\"", ""        else \\"", ""                { \\"", ""                errno=0; \\"", ""                while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\"", ""                        { \\"", ""                        if( errno != EINTR) \\"", ""                                { \\"", ""                                YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""                                break; \\"", ""                                } \\"", ""                        errno=0; \\"", ""                        clearerr(yyin); \\"", ""                        } \\"", ""                }\\"", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\"", ""\t\t{ \\"", ""\t\tint c = '*'; \\"", ""\t\tsize_t n; \\"", ""\t\tfor ( n = 0; n < max_size && \\"", ""\t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\"", ""\t\t\tbuf[n] = (char) c; \\"", ""\t\tif ( c == '\\n' ) \\"", ""\t\t\tbuf[n++] = (char) c; \\"", ""\t\tif ( c == EOF && ferror( yyin ) ) \\"", ""\t\t\tYY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""\t\tresult = n; \\"", ""\t\t} \\"", ""\telse \\"", ""\t\t{ \\"", ""\t\terrno=0; \\"", ""\t\twhile ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\"", ""\t\t\t{ \\"", ""\t\t\tif( errno != EINTR) \\"", ""\t\t\t\t{ \\"", ""\t\t\t\tYY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""\t\t\t\tbreak; \\"", ""\t\t\t\t} \\"", ""\t\t\terrno=0; \\"", ""\t\t\tclearerr(yyin); \\"", ""\t\t\t} \\"", ""\t\t}\\"", ""\\"", """", ""#endif""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[13, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [23, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [40, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [50, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""]]",761,776
"[""}"", ""case YY_STATE_EOF(INITIAL):"", ""case YY_STATE_EOF(COMMENT):"", ""#line 277 \""cmListFileLexer.in.l\"""", ""#line 267 \""cmListFileLexer.in.l\"""", ""{"", ""  lexer->token.type = cmListFileLexer_Token_None;"", ""  cmListFileLexerSetToken(lexer, 0, 0);"", ""  return 0;"", ""}"", ""case 24:"", ""YY_RULE_SETUP"", ""#line 283 \""cmListFileLexer.in.l\"""", ""#line 273 \""cmListFileLexer.in.l\"""", ""ECHO;"", ""        YY_BREAK"", ""#line 1238 \""cmListFileLexer.c\"""", """", ""        case YY_END_OF_BUFFER:"", ""                {"", ""                /* Amount of text matched not including the EOB char. */"", ""                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;"", """", ""                /* Undo the effects of YY_DO_BEFORE_ACTION. */"", ""                *yy_cp = yyg->yy_hold_char;"", ""                YY_RESTORE_YY_MORE_OFFSET"", """", ""                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )"", ""                        {"", ""                        /* We're scanning a new file or input source.  It's"", ""                         * possible that this happened because the user"", ""                         * just pointed yyin at a new source and called"", ""                         * cmListFileLexer_yylex().  If so, then we have to assure"", ""                         * consistency between YY_CURRENT_BUFFER and our"", ""                         * globals.  Here is the right place to do so, because"", ""                         * this is the first action (other than possibly a"", ""                         * back-up) that will match for the new input source."", ""                         */"", ""                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;"", ""                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;"", ""                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;"", ""                        }"", """", ""                /* Note that here we test for yy_c_buf_p \""<=\"" to the position"", ""                 * of the first EOB in the buffer, since yy_c_buf_p will"", ""                 * already have been incremented past the NUL character"", ""                 * (since all states make transitions on EOB to the"", ""                 * end-of-buffer state).  Contrast this with the test"", ""                 * in input()."", ""                 */"", ""                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )"", ""                        { /* This was really a NUL. */"", ""                        yy_state_type yy_next_state;"", """", ""                        yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""                        yy_current_state = yy_get_previous_state( yyscanner );"", """", ""                        /* Okay, we're now positioned to make the NUL"", ""                         * transition.  We couldn't have"", ""                         * yy_get_previous_state() go ahead and do it"", ""                         * for us because it doesn't know how to deal"", ""                         * with the possibility of jamming (and we don't"", ""                         * want to build jamming into it because then it"", ""                         * will run more slowly)."", ""                         */"", """", ""                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);"", """", ""                        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""                        if ( yy_next_state )"", ""                                {"", ""                                /* Consume the NUL. */"", ""                                yy_cp = ++yyg->yy_c_buf_p;"", ""                                yy_current_state = yy_next_state;"", ""                                goto yy_match;"", ""                                }"", """", ""                        else"", ""                                {"", ""                                yy_cp = yyg->yy_c_buf_p;"", ""                                goto yy_find_action;"", ""                                }"", ""                        }"", """", ""                else switch ( yy_get_next_buffer( yyscanner ) )"", ""                        {"", ""                        case EOB_ACT_END_OF_FILE:"", ""                                {"", ""                                yyg->yy_did_buffer_switch_on_eof = 0;"", """", ""                                if ( cmListFileLexer_yywrap(yyscanner ) )"", ""                                        {"", ""                                        /* Note: because we've taken care in"", ""                                         * yy_get_next_buffer() to have set up"", ""                                         * yytext, we can now set up"", ""                                         * yy_c_buf_p so that if some total"", ""                                         * hoser (like flex itself) wants to"", ""                                         * call the scanner after we return the"", ""                                         * YY_NULL, it'll still work - another"", ""                                         * YY_NULL will get returned."", ""                                         */"", ""                                        yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""                                        yy_act = YY_STATE_EOF(YY_START);"", ""                                        goto do_action;"", ""                                        }"", """", ""                                else"", ""                                        {"", ""                                        if ( ! yyg->yy_did_buffer_switch_on_eof )"", ""                                                YY_NEW_FILE;"", ""                                        }"", ""                                break;"", ""                                }"", """", ""                        case EOB_ACT_CONTINUE_SCAN:"", ""                                yyg->yy_c_buf_p ="", ""                                        yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""                                yy_current_state = yy_get_previous_state( yyscanner );"", """", ""                                yy_cp = yyg->yy_c_buf_p;"", ""                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""                                goto yy_match;"", """", ""                        case EOB_ACT_LAST_MATCH:"", ""                                yyg->yy_c_buf_p ="", ""                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];"", """", ""                                yy_current_state = yy_get_previous_state( yyscanner );"", """", ""                                yy_cp = yyg->yy_c_buf_p;"", ""                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""                                goto yy_find_action;"", ""                        }"", ""                break;"", ""                }"", """", ""        default:"", ""                YY_FATAL_ERROR("", ""                        \""fatal flex scanner internal error--no action found\"" );"", ""        } /* end of action switch */"", ""                } /* end of scanning one token */"", ""\tYY_BREAK"", ""#line 1235 \""cmListFileLexer.c\"""", """", ""\tcase YY_END_OF_BUFFER:"", ""\t\t{"", ""\t\t/* Amount of text matched not including the EOB char. */"", ""\t\tint yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;"", """", ""\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */"", ""\t\t*yy_cp = yyg->yy_hold_char;"", ""\t\tYY_RESTORE_YY_MORE_OFFSET"", """", ""\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )"", ""\t\t\t{"", ""\t\t\t/* We're scanning a new file or input source.  It's"", ""\t\t\t * possible that this happened because the user"", ""\t\t\t * just pointed yyin at a new source and called"", ""\t\t\t * cmListFileLexer_yylex().  If so, then we have to assure"", ""\t\t\t * consistency between YY_CURRENT_BUFFER and our"", ""\t\t\t * globals.  Here is the right place to do so, because"", ""\t\t\t * this is the first action (other than possibly a"", ""\t\t\t * back-up) that will match for the new input source."", ""\t\t\t */"", ""\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;"", ""\t\t\t}"", """", ""\t\t/* Note that here we test for yy_c_buf_p \""<=\"" to the position"", ""\t\t * of the first EOB in the buffer, since yy_c_buf_p will"", ""\t\t * already have been incremented past the NUL character"", ""\t\t * (since all states make transitions on EOB to the"", ""\t\t * end-of-buffer state).  Contrast this with the test"", ""\t\t * in input()."", ""\t\t */"", ""\t\tif ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )"", ""\t\t\t{ /* This was really a NUL. */"", ""\t\t\tyy_state_type yy_next_state;"", """", ""\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t/* Okay, we're now positioned to make the NUL"", ""\t\t\t * transition.  We couldn't have"", ""\t\t\t * yy_get_previous_state() go ahead and do it"", ""\t\t\t * for us because it doesn't know how to deal"", ""\t\t\t * with the possibility of jamming (and we don't"", ""\t\t\t * want to build jamming into it because then it"", ""\t\t\t * will run more slowly)."", ""\t\t\t */"", """", ""\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);"", """", ""\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""\t\t\tif ( yy_next_state )"", ""\t\t\t\t{"", ""\t\t\t\t/* Consume the NUL. */"", ""\t\t\t\tyy_cp = ++yyg->yy_c_buf_p;"", ""\t\t\t\tyy_current_state = yy_next_state;"", ""\t\t\t\tgoto yy_match;"", ""\t\t\t\t}"", """", ""\t\t\telse"", ""\t\t\t\t{"", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tgoto yy_find_action;"", ""\t\t\t\t}"", ""\t\t\t}"", """", ""\t\telse switch ( yy_get_next_buffer( yyscanner ) )"", ""\t\t\t{"", ""\t\t\tcase EOB_ACT_END_OF_FILE:"", ""\t\t\t\t{"", ""\t\t\t\tyyg->yy_did_buffer_switch_on_eof = 0;"", """", ""\t\t\t\tif ( cmListFileLexer_yywrap(yyscanner ) )"", ""\t\t\t\t\t{"", ""\t\t\t\t\t/* Note: because we've taken care in"", ""\t\t\t\t\t * yy_get_next_buffer() to have set up"", ""\t\t\t\t\t * yytext, we can now set up"", ""\t\t\t\t\t * yy_c_buf_p so that if some total"", ""\t\t\t\t\t * hoser (like flex itself) wants to"", ""\t\t\t\t\t * call the scanner after we return the"", ""\t\t\t\t\t * YY_NULL, it'll still work - another"", ""\t\t\t\t\t * YY_NULL will get returned."", ""\t\t\t\t\t */"", ""\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);"", ""\t\t\t\t\tgoto do_action;"", ""\t\t\t\t\t}"", """", ""\t\t\t\telse"", ""\t\t\t\t\t{"", ""\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )"", ""\t\t\t\t\t\tYY_NEW_FILE;"", ""\t\t\t\t\t}"", ""\t\t\t\tbreak;"", ""\t\t\t\t}"", """", ""\t\t\tcase EOB_ACT_CONTINUE_SCAN:"", ""\t\t\t\tyyg->yy_c_buf_p ="", ""\t\t\t\t\tyyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""\t\t\t\tgoto yy_match;"", """", ""\t\t\tcase EOB_ACT_LAST_MATCH:"", ""\t\t\t\tyyg->yy_c_buf_p ="", ""\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];"", """", ""\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""\t\t\t\tgoto yy_find_action;"", ""\t\t\t}"", ""\t\tbreak;"", ""\t\t}"", """", ""\tdefault:"", ""\t\tYY_FATAL_ERROR("", ""\t\t\t\""fatal flex scanner internal error--no action found\"" );"", ""\t} /* end of action switch */"", ""\t\t} /* end of scanning one token */"", ""\t} /* end of user's declarations */"", ""} /* end of cmListFileLexer_yylex */"", """", ""/* yy_get_next_buffer - try to read in a new buffer"", "" *"", "" * Returns a code representing an action:"", "" *      EOB_ACT_LAST_MATCH -"", "" *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position"", "" *      EOB_ACT_END_OF_FILE - end of file"", "" *\tEOB_ACT_LAST_MATCH -"", "" *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position"", "" *\tEOB_ACT_END_OF_FILE - end of file"", "" */"", ""static int yy_get_next_buffer (yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;"", ""        char *source = yyg->yytext_ptr;"", ""        int number_to_move, i;"", ""        int ret_val;"", """", ""        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )"", ""                YY_FATAL_ERROR("", ""                \""fatal flex scanner internal error--end of buffer missed\"" );"", """", ""        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )"", ""                { /* Don't try to fill the buffer, so this is an EOF. */"", ""                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )"", ""                        {"", ""                        /* We matched a single character, the EOB, so"", ""                         * treat this as a final EOF."", ""                         */"", ""                        return EOB_ACT_END_OF_FILE;"", ""                        }"", """", ""                else"", ""                        {"", ""                        /* We matched some text prior to the EOB, first"", ""                         * process it."", ""                         */"", ""                        return EOB_ACT_LAST_MATCH;"", ""                        }"", ""                }"", """", ""        /* Try to read more data. */"", """", ""        /* First move last chars to start of buffer. */"", ""        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;"", """", ""        for ( i = 0; i < number_to_move; ++i )"", ""                *(dest++) = *(source++);"", """", ""        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )"", ""                /* don't do the read, it's not guaranteed to return an EOF,"", ""                 * just force an EOF"", ""                 */"", ""                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;"", """", ""        else"", ""                {"", ""                        int num_to_read ="", ""                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;"", """", ""                while ( num_to_read <= 0 )"", ""                        { /* Not enough room in the buffer - grow it. */"", """", ""                        /* just a shorter name for the current buffer */"", ""                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;"", """", ""                        int yy_c_buf_p_offset ="", ""                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);"", """", ""                        if ( b->yy_is_our_buffer )"", ""                                {"", ""                                int new_size = b->yy_buf_size * 2;"", """", ""                                if ( new_size <= 0 )"", ""                                        b->yy_buf_size += b->yy_buf_size / 8;"", ""                                else"", ""                                        b->yy_buf_size *= 2;"", """", ""                                b->yy_ch_buf = (char *)"", ""                                        /* Include room in for 2 EOB chars. */"", ""                                        cmListFileLexer_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );"", ""                                }"", ""                        else"", ""                                /* Can't grow it, we don't own it. */"", ""                                b->yy_ch_buf = 0;"", """", ""                        if ( ! b->yy_ch_buf )"", ""                                YY_FATAL_ERROR("", ""                                \""fatal error - scanner input buffer overflow\"" );"", """", ""                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];"", """", ""                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -"", ""                                                number_to_move - 1;"", """", ""                        }"", """", ""                if ( num_to_read > YY_READ_BUF_SIZE )"", ""                        num_to_read = YY_READ_BUF_SIZE;"", """", ""                /* Read in more data. */"", ""                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),"", ""                        yyg->yy_n_chars, (size_t) num_to_read );"", """", ""                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;"", ""                }"", """", ""        if ( yyg->yy_n_chars == 0 )"", ""                {"", ""                if ( number_to_move == YY_MORE_ADJ )"", ""                        {"", ""                        ret_val = EOB_ACT_END_OF_FILE;"", ""                        cmListFileLexer_yyrestart(yyin  ,yyscanner);"", ""                        }"", """", ""                else"", ""                        {"", ""                        ret_val = EOB_ACT_LAST_MATCH;"", ""                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status ="", ""                                YY_BUFFER_EOF_PENDING;"", ""                        }"", ""                }"", """", ""        else"", ""                ret_val = EOB_ACT_CONTINUE_SCAN;"", """", ""        if ((yy_size_t) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {"", ""                /* Extend the array by 50%, plus the number we really need. */"", ""                yy_size_t new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);"", ""                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmListFileLexer_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );"", ""                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""                        YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", ""        }"", ""\tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;"", ""\tchar *source = yyg->yytext_ptr;"", ""\tyy_size_t number_to_move, i;"", ""\tint ret_val;"", """", ""\tif ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )"", ""\t\tYY_FATAL_ERROR("", ""\t\t\""fatal flex scanner internal error--end of buffer missed\"" );"", """", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )"", ""\t\t{ /* Don't try to fill the buffer, so this is an EOF. */"", ""\t\tif ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )"", ""\t\t\t{"", ""\t\t\t/* We matched a single character, the EOB, so"", ""\t\t\t * treat this as a final EOF."", ""\t\t\t */"", ""\t\t\treturn EOB_ACT_END_OF_FILE;"", ""\t\t\t}"", """", ""\t\telse"", ""\t\t\t{"", ""\t\t\t/* We matched some text prior to the EOB, first"", ""\t\t\t * process it."", ""\t\t\t */"", ""\t\t\treturn EOB_ACT_LAST_MATCH;"", ""\t\t\t}"", ""\t\t}"", """", ""\t/* Try to read more data. */"", """", ""\t/* First move last chars to start of buffer. */"", ""\tnumber_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;"", """", ""\tfor ( i = 0; i < number_to_move; ++i )"", ""\t\t*(dest++) = *(source++);"", """", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )"", ""\t\t/* don't do the read, it's not guaranteed to return an EOF,"", ""\t\t * just force an EOF"", ""\t\t */"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;"", """", ""\telse"", ""\t\t{"", ""\t\t\tyy_size_t num_to_read ="", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;"", """", ""\t\twhile ( num_to_read <= 0 )"", ""\t\t\t{ /* Not enough room in the buffer - grow it. */"", """", ""\t\t\t/* just a shorter name for the current buffer */"", ""\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;"", """", ""\t\t\tint yy_c_buf_p_offset ="", ""\t\t\t\t(int) (yyg->yy_c_buf_p - b->yy_ch_buf);"", """", ""\t\t\tif ( b->yy_is_our_buffer )"", ""\t\t\t\t{"", ""\t\t\t\tyy_size_t new_size = b->yy_buf_size * 2;"", """", ""\t\t\t\tif ( new_size <= 0 )"", ""\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;"", ""\t\t\t\telse"", ""\t\t\t\t\tb->yy_buf_size *= 2;"", """", ""\t\t\t\tb->yy_ch_buf = (char *)"", ""\t\t\t\t\t/* Include room in for 2 EOB chars. */"", ""\t\t\t\t\tcmListFileLexer_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );"", ""\t\t\t\t}"", ""\t\t\telse"", ""\t\t\t\t/* Can't grow it, we don't own it. */"", ""\t\t\t\tb->yy_ch_buf = 0;"", """", ""\t\t\tif ( ! b->yy_ch_buf )"", ""\t\t\t\tYY_FATAL_ERROR("", ""\t\t\t\t\""fatal error - scanner input buffer overflow\"" );"", """", ""\t\t\tyyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];"", """", ""\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -"", ""\t\t\t\t\t\tnumber_to_move - 1;"", """", ""\t\t\t}"", """", ""\t\tif ( num_to_read > YY_READ_BUF_SIZE )"", ""\t\t\tnum_to_read = YY_READ_BUF_SIZE;"", """", ""\t\t/* Read in more data. */"", ""\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),"", ""\t\t\tyyg->yy_n_chars, num_to_read );"", """", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;"", ""\t\t}"", """", ""\tif ( yyg->yy_n_chars == 0 )"", ""\t\t{"", ""\t\tif ( number_to_move == YY_MORE_ADJ )"", ""\t\t\t{"", ""\t\t\tret_val = EOB_ACT_END_OF_FILE;"", ""\t\t\tcmListFileLexer_yyrestart(yyin  ,yyscanner);"", ""\t\t\t}"", """", ""\t\telse"", ""\t\t\t{"", ""\t\t\tret_val = EOB_ACT_LAST_MATCH;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status ="", ""\t\t\t\tYY_BUFFER_EOF_PENDING;"", ""\t\t\t}"", ""\t\t}"", """", ""\telse"", ""\t\tret_val = EOB_ACT_CONTINUE_SCAN;"", """", ""\tif ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {"", ""\t\t/* Extend the array by 50%, plus the number we really need. */"", ""\t\tint new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmListFileLexer_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );"", ""\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", ""\t}"", """", ""        yyg->yy_n_chars += number_to_move;"", ""        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;"", ""        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;"", ""\tyyg->yy_n_chars += number_to_move;"", ""\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;"", ""\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;"", """", ""        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];"", ""\tyyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];"", """", ""        return ret_val;"", ""\treturn ret_val;"", ""}"", """", ""/* yy_get_previous_state - get the state just before the EOB char was reached */"", """", ""    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)"", ""{"", ""        yy_state_type yy_current_state;"", ""        char *yy_cp;"", ""\tyy_state_type yy_current_state;"", ""\tchar *yy_cp;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        yy_current_state = yyg->yy_start;"", ""\tyy_current_state = yyg->yy_start;"", """", ""        for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )"", ""                {"", ""                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);"", ""                if ( yy_accept[yy_current_state] )"", ""                        {"", ""                        yyg->yy_last_accepting_state = yy_current_state;"", ""                        yyg->yy_last_accepting_cpos = yy_cp;"", ""                        }"", ""                while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""                        {"", ""                        yy_current_state = (int) yy_def[yy_current_state];"", ""                        if ( yy_current_state >= 77 )"", ""                                yy_c = yy_meta[(unsigned int) yy_c];"", ""                        }"", ""                yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""                }"", ""\tfor ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )"", ""\t\t{"", ""\t\tYY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);"", ""\t\tif ( yy_accept[yy_current_state] )"", ""\t\t\t{"", ""\t\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t\t}"", ""\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t\t{"", ""\t\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\t\tif ( yy_current_state >= 77 )"", ""\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t\t}"", ""\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""\t\t}"", """", ""        return yy_current_state;"", ""\treturn yy_current_state;"", ""}"", """", ""/* yy_try_NUL_trans - try to make a transition on the NUL character"", "" *"", "" * synopsis"", "" *      next_state = yy_try_NUL_trans( current_state );"", "" *\tnext_state = yy_try_NUL_trans( current_state );"", "" */"", ""    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)"", ""{"", ""        int yy_is_jam;"", ""\tint yy_is_jam;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */"", ""        char *yy_cp = yyg->yy_c_buf_p;"", """", ""        YY_CHAR yy_c = 1;"", ""        if ( yy_accept[yy_current_state] )"", ""                {"", ""                yyg->yy_last_accepting_state = yy_current_state;"", ""                yyg->yy_last_accepting_cpos = yy_cp;"", ""                }"", ""        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""                {"", ""                yy_current_state = (int) yy_def[yy_current_state];"", ""                if ( yy_current_state >= 77 )"", ""                        yy_c = yy_meta[(unsigned int) yy_c];"", ""                }"", ""        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""        yy_is_jam = (yy_current_state == 76);"", """", ""        return yy_is_jam ? 0 : yy_current_state;"", ""\tchar *yy_cp = yyg->yy_c_buf_p;"", """", ""\tYY_CHAR yy_c = 1;"", ""\tif ( yy_accept[yy_current_state] )"", ""\t\t{"", ""\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t}"", ""\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t{"", ""\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\tif ( yy_current_state >= 77 )"", ""\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t}"", ""\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""\tyy_is_jam = (yy_current_state == 76);"", """", ""\t(void)yyg;"", ""\treturn yy_is_jam ? 0 : yy_current_state;"", ""}"", """", ""#ifndef YY_NO_UNPUT"", """", ""    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)"", ""{"", ""\tchar *yy_cp;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""    yy_cp = yyg->yy_c_buf_p;"", """", ""\t/* undo effects of setting up yytext */"", ""\t*yy_cp = yyg->yy_hold_char;"", """", ""\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )"", ""\t\t{ /* need to shift things up to make room */"", ""\t\t/* +2 for EOB chars. */"", ""\t\tyy_size_t number_to_move = yyg->yy_n_chars + 2;"", ""\t\tchar *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf["", ""\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];"", ""\t\tchar *source ="", ""\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];"", """", ""\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""\t\t\t*--dest = *--source;"", """", ""\t\tyy_cp += (int) (dest - source);"", ""\t\tyy_bp += (int) (dest - source);"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars ="", ""\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;"", """", ""\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )"", ""\t\t\tYY_FATAL_ERROR( \""flex scanner push-back overflow\"" );"", ""\t\t}"", """", ""\t*--yy_cp = (char) c;"", """", ""    if ( c == '\\n' ){"", ""        --yylineno;"", ""    }"", """", ""\tyyg->yytext_ptr = yy_bp;"", ""\tyyg->yy_hold_char = *yy_cp;"", ""\tyyg->yy_c_buf_p = yy_cp;"", ""}"", """", ""#endif"", """", ""#ifndef YY_NO_INPUT"", ""#ifdef __cplusplus"", ""    static int yyinput (yyscan_t yyscanner)""]","[0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, 1, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, -1, 1, 1, 0, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0]","[[141, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [271, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [297, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [365, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [409, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [417, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [485, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [529, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [676, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""flex scanner push-back overflow\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""]]",1197,1206
"["" */"", ""    YY_BUFFER_STATE cmListFileLexer_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)"", ""{"", ""        YY_BUFFER_STATE b;"", ""\tYY_BUFFER_STATE b;"", """", ""        b = (YY_BUFFER_STATE) cmListFileLexer_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""        if ( ! b )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_create_buffer()\"" );"", ""\tb = (YY_BUFFER_STATE) cmListFileLexer_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_create_buffer()\"" );"", """", ""        b->yy_buf_size = size;"", ""\tb->yy_buf_size = (yy_size_t)size;"", """", ""        /* yy_ch_buf has to be 2 characters longer than the size given because"", ""         * we need to put in 2 end-of-buffer characters."", ""         */"", ""        b->yy_ch_buf = (char *) cmListFileLexer_yyalloc(b->yy_buf_size + 2 ,yyscanner );"", ""        if ( ! b->yy_ch_buf )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_create_buffer()\"" );"", ""\t/* yy_ch_buf has to be 2 characters longer than the size given because"", ""\t * we need to put in 2 end-of-buffer characters."", ""\t */"", ""\tb->yy_ch_buf = (char *) cmListFileLexer_yyalloc(b->yy_buf_size + 2 ,yyscanner );"", ""\tif ( ! b->yy_ch_buf )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_create_buffer()\"" );"", """", ""        b->yy_is_our_buffer = 1;"", ""\tb->yy_is_our_buffer = 1;"", """", ""        cmListFileLexer_yy_init_buffer(b,file ,yyscanner);"", ""\tcmListFileLexer_yy_init_buffer(b,file ,yyscanner);"", """", ""        return b;"", ""\treturn b;"", ""}"", """", ""/** Destroy the buffer.""]","[0, 0, 0, -1, 1, 0, -1, -1, -2, 1, 1, 2, 0, -1, 1, 0, -1, -1, -1, -1, -1, -2, 1, 1, 1, 1, 1, 2, 0, -1, 1, 0, -1, 1, 0, -1, 1, 0, 0, 0]","[[8, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [11, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [21, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [27, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""]]",1692,1749
"[""void cmListFileLexer_yypop_buffer_state (yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""        if (!YY_CURRENT_BUFFER)"", ""                return;"", ""\tif (!YY_CURRENT_BUFFER)"", ""\t\treturn;"", """", ""        cmListFileLexer_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);"", ""        YY_CURRENT_BUFFER_LVALUE = NULL;"", ""        if (yyg->yy_buffer_stack_top > 0)"", ""                --yyg->yy_buffer_stack_top;"", ""\tcmListFileLexer_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);"", ""\tYY_CURRENT_BUFFER_LVALUE = NULL;"", ""\tif (yyg->yy_buffer_stack_top > 0)"", ""\t\t--yyg->yy_buffer_stack_top;"", """", ""        if (YY_CURRENT_BUFFER) {"", ""                cmListFileLexer_yy_load_buffer_state(yyscanner );"", ""                yyg->yy_did_buffer_switch_on_eof = 1;"", ""        }"", ""\tif (YY_CURRENT_BUFFER) {"", ""\t\tcmListFileLexer_yy_load_buffer_state(yyscanner );"", ""\t\tyyg->yy_did_buffer_switch_on_eof = 1;"", ""\t}"", ""}"", """", ""/* Allocates the stack if it does not exist."", "" *  Guarantees space for at least one push."", "" */"", ""static void cmListFileLexer_yyensure_buffer_stack (yyscan_t yyscanner)"", ""{"", ""        int num_to_alloc;"", ""\tyy_size_t num_to_alloc;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        if (!yyg->yy_buffer_stack) {"", ""\tif (!yyg->yy_buffer_stack) {"", """", ""                /* First allocation is just for 2 elements, since we don't know if this"", ""                 * scanner will even need a stack. We use 2 instead of 1 to avoid an"", ""                 * immediate realloc on the next call."", ""\t\t/* First allocation is just for 2 elements, since we don't know if this"", ""\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an"", ""\t\t * immediate realloc on the next call."", ""         */"", ""                num_to_alloc = 1;"", ""                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyalloc"", ""                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)"", ""                                                                , yyscanner);"", ""                if ( ! yyg->yy_buffer_stack )"", ""                        YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()\"" );"", """", ""                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));"", """", ""                yyg->yy_buffer_stack_max = num_to_alloc;"", ""                yyg->yy_buffer_stack_top = 0;"", ""                return;"", ""        }"", ""\t\tnum_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */"", ""\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyalloc"", ""\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)"", ""\t\t\t\t\t\t\t\t, yyscanner);"", ""\t\tif ( ! yyg->yy_buffer_stack )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()\"" );"", """", ""        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){"", ""\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));"", """", ""                /* Increase the buffer to prepare for a possible push. */"", ""                int grow_size = 8 /* arbitrary grow size */;"", ""\t\tyyg->yy_buffer_stack_max = num_to_alloc;"", ""\t\tyyg->yy_buffer_stack_top = 0;"", ""\t\treturn;"", ""\t}"", """", ""                num_to_alloc = yyg->yy_buffer_stack_max + grow_size;"", ""                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyrealloc"", ""                                                                (yyg->yy_buffer_stack,"", ""                                                                num_to_alloc * sizeof(struct yy_buffer_state*)"", ""                                                                , yyscanner);"", ""                if ( ! yyg->yy_buffer_stack )"", ""                        YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()\"" );"", ""\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){"", """", ""                /* zero only the new slots.*/"", ""                memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));"", ""                yyg->yy_buffer_stack_max = num_to_alloc;"", ""        }"", ""\t\t/* Increase the buffer to prepare for a possible push. */"", ""\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;"", """", ""\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;"", ""\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyrealloc"", ""\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,"", ""\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)"", ""\t\t\t\t\t\t\t\t, yyscanner);"", ""\t\tif ( ! yyg->yy_buffer_stack )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()\"" );"", """", ""\t\t/* zero only the new slots.*/"", ""\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));"", ""\t\tyyg->yy_buffer_stack_max = num_to_alloc;"", ""\t}"", ""}"", """", ""/** Setup the input buffer state to scan directly from a user-specified character buffer.""]","[0, 0, 0, -1, -1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 2, 0, -1, 1, 0, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -2, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 0, 0]","[[51, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [64, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [82, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [98, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""]]",1831,1888
"["" */"", ""YY_BUFFER_STATE cmListFileLexer_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)"", ""{"", ""        YY_BUFFER_STATE b;"", ""\tYY_BUFFER_STATE b;"", """", ""        if ( size < 2 ||"", ""             base[size-2] != YY_END_OF_BUFFER_CHAR ||"", ""             base[size-1] != YY_END_OF_BUFFER_CHAR )"", ""                /* They forgot to leave room for the EOB's. */"", ""                return 0;"", ""\tif ( size < 2 ||"", ""\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||"", ""\t     base[size-1] != YY_END_OF_BUFFER_CHAR )"", ""\t\t/* They forgot to leave room for the EOB's. */"", ""\t\treturn 0;"", """", ""        b = (YY_BUFFER_STATE) cmListFileLexer_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""        if ( ! b )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_scan_buffer()\"" );"", ""\tb = (YY_BUFFER_STATE) cmListFileLexer_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_scan_buffer()\"" );"", """", ""        b->yy_buf_size = size - 2;      /* \""- 2\"" to take care of EOB's */"", ""        b->yy_buf_pos = b->yy_ch_buf = base;"", ""        b->yy_is_our_buffer = 0;"", ""        b->yy_input_file = 0;"", ""        b->yy_n_chars = b->yy_buf_size;"", ""        b->yy_is_interactive = 0;"", ""        b->yy_at_bol = 1;"", ""        b->yy_fill_buffer = 0;"", ""        b->yy_buffer_status = YY_BUFFER_NEW;"", ""\tb->yy_buf_size = size - 2;\t/* \""- 2\"" to take care of EOB's */"", ""\tb->yy_buf_pos = b->yy_ch_buf = base;"", ""\tb->yy_is_our_buffer = 0;"", ""\tb->yy_input_file = 0;"", ""\tb->yy_n_chars = b->yy_buf_size;"", ""\tb->yy_is_interactive = 0;"", ""\tb->yy_at_bol = 1;"", ""\tb->yy_fill_buffer = 0;"", ""\tb->yy_buffer_status = YY_BUFFER_NEW;"", """", ""        cmListFileLexer_yy_switch_to_buffer(b ,yyscanner );"", ""\tcmListFileLexer_yy_switch_to_buffer(b ,yyscanner );"", """", ""        return b;"", ""\treturn b;"", ""}"", """", ""/** Setup the input buffer state to scan a string. The next call to cmListFileLexer_yylex() will""]","[0, 0, 0, -1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 0, -1, -1, -2, 1, 1, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, -1, 1, 0, 0, 0]","[[19, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_scan_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [22, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_scan_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""]]",1900,1957
"["" * @param yyscanner The scanner object."", "" * @return the newly allocated buffer state object."", "" */"", ""YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)"", ""YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)"", ""{"", ""        YY_BUFFER_STATE b;"", ""        char *buf;"", ""        yy_size_t n;"", ""        int i;"", ""\tYY_BUFFER_STATE b;"", ""\tchar *buf;"", ""\tyy_size_t n;"", ""\tyy_size_t i;"", """", ""        /* Get memory for full buffer, including space for trailing EOB's. */"", ""        n = _yybytes_len + 2;"", ""        buf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );"", ""        if ( ! buf )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_scan_bytes()\"" );"", ""\t/* Get memory for full buffer, including space for trailing EOB's. */"", ""\tn = _yybytes_len + 2;"", ""\tbuf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );"", ""\tif ( ! buf )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_scan_bytes()\"" );"", """", ""        for ( i = 0; i < _yybytes_len; ++i )"", ""                buf[i] = yybytes[i];"", ""\tfor ( i = 0; i < _yybytes_len; ++i )"", ""\t\tbuf[i] = yybytes[i];"", """", ""        buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;"", ""\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;"", """", ""        b = cmListFileLexer_yy_scan_buffer(buf,n ,yyscanner);"", ""        if ( ! b )"", ""                YY_FATAL_ERROR( \""bad buffer in cmListFileLexer_yy_scan_bytes()\"" );"", ""\tb = cmListFileLexer_yy_scan_buffer(buf,n ,yyscanner);"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""bad buffer in cmListFileLexer_yy_scan_bytes()\"" );"", """", ""        /* It's okay to grow etc. this buffer, and we should throw it"", ""         * away when we're done."", ""         */"", ""        b->yy_is_our_buffer = 1;"", ""\t/* It's okay to grow etc. this buffer, and we should throw it"", ""\t * away when we're done."", ""\t */"", ""\tb->yy_is_our_buffer = 1;"", """", ""        return b;"", ""\treturn b;"", ""}"", """", ""#ifndef YY_EXIT_FAILURE""]","[0, 0, 0, -1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -2, 1, 1, 1, 1, 2, 0, -1, -1, 1, 1, 0, -1, 1, 0, -1, -1, -2, 1, 1, 2, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, 1, 0, 0, 0]","[[19, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [24, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [36, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""bad buffer in cmListFileLexer_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [39, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""bad buffer in cmListFileLexer_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""]]",1948,2005
"["""", ""static void yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)"", ""{"", ""        (void)yyscanner;"", ""        (void) fprintf( stderr, \""%s\\n\"", msg );"", ""        exit( YY_EXIT_FAILURE );"", ""\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""\t(void)yyg;"", ""\t(void) fprintf( stderr, \""%s\\n\"", msg );"", ""\texit( YY_EXIT_FAILURE );"", ""}"", """", ""/* Redefine yyless() so it works in section 3 code. */"", """", ""#undef yyless"", ""#define yyless(n) \\"", ""        do \\"", ""                { \\"", ""                /* Undo effects of setting up yytext. */ \\"", ""\tdo \\"", ""\t\t{ \\"", ""\t\t/* Undo effects of setting up yytext. */ \\"", ""        int yyless_macro_arg = (n); \\"", ""        YY_LESS_LINENO(yyless_macro_arg);\\"", ""                yytext[yyleng] = yyg->yy_hold_char; \\"", ""                yyg->yy_c_buf_p = yytext + yyless_macro_arg; \\"", ""                yyg->yy_hold_char = *yyg->yy_c_buf_p; \\"", ""                *yyg->yy_c_buf_p = '\\0'; \\"", ""                yyleng = yyless_macro_arg; \\"", ""                } \\"", ""        while ( 0 )"", ""\t\tyytext[yyleng] = yyg->yy_hold_char; \\"", ""\t\tyyg->yy_c_buf_p = yytext + yyless_macro_arg; \\"", ""\t\tyyg->yy_hold_char = *yyg->yy_c_buf_p; \\"", ""\t\t*yyg->yy_c_buf_p = '\\0'; \\"", ""\t\tyyleng = yyless_macro_arg; \\"", ""\t\t} \\"", ""\twhile ( 0 )"", """", ""/* Accessor  methods (get/set functions) to struct members. */"", """"]","[0, 0, 0, -1, -2, -1, 1, 1, 2, 1, 0, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[4, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""-"", ""(void) fprintf( stderr, \""%s\\n\"", msg );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [8, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""+"", ""(void) fprintf( stderr, \""%s\\n\"", msg );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""]]",1984,2041
"[""}"", """", ""/** Set the current line number."", "" * @param line_number"", "" * @param _line_number line number"", "" * @param yyscanner The scanner object."", "" */"", ""void cmListFileLexer_yyset_lineno (int  line_number , yyscan_t yyscanner)"", ""void cmListFileLexer_yyset_lineno (int  _line_number , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        /* lineno is only valid if an input buffer exists. */"", ""        if (! YY_CURRENT_BUFFER )"", ""           yy_fatal_error( \""cmListFileLexer_yyset_lineno called with no buffer\"" , yyscanner);"", ""           YY_FATAL_ERROR( \""cmListFileLexer_yyset_lineno called with no buffer\"" );"", """", ""    yylineno = line_number;"", ""    yylineno = _line_number;"", ""}"", """", ""/** Set the current column."", "" * @param line_number"", "" * @param _column_no column number"", "" * @param yyscanner The scanner object."", "" */"", ""void cmListFileLexer_yyset_column (int  column_no , yyscan_t yyscanner)"", ""void cmListFileLexer_yyset_column (int  _column_no , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        /* column is only valid if an input buffer exists. */"", ""        if (! YY_CURRENT_BUFFER )"", ""           yy_fatal_error( \""cmListFileLexer_yyset_column called with no buffer\"" , yyscanner);"", ""           YY_FATAL_ERROR( \""cmListFileLexer_yyset_column called with no buffer\"" );"", """", ""    yycolumn = column_no;"", ""    yycolumn = _column_no;"", ""}"", """", ""/** Set the input stream. This does not discard the current"", "" * input buffer."", "" * @param in_str A readable stream."", "" * @param _in_str A readable stream."", "" * @param yyscanner The scanner object."", "" * @see cmListFileLexer_yy_switch_to_buffer"", "" */"", ""void cmListFileLexer_yyset_in (FILE *  in_str , yyscan_t yyscanner)"", ""void cmListFileLexer_yyset_in (FILE *  _in_str , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""    yyin = in_str ;"", ""    yyin = _in_str ;"", ""}"", """", ""void cmListFileLexer_yyset_out (FILE *  out_str , yyscan_t yyscanner)"", ""void cmListFileLexer_yyset_out (FILE *  _out_str , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""    yyout = out_str ;"", ""    yyout = _out_str ;"", ""}"", """", ""int cmListFileLexer_yyget_debug  (yyscan_t yyscanner)""]","[0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, -2, 2, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, -2, 2, 0, -1, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0]","[[14, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""-"", ""yy_fatal_error( \""cmListFileLexer_yyset_lineno called with no buffer\"" , yyscanner);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [15, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""cmListFileLexer_yyset_lineno called with no buffer\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [33, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""-"", ""yy_fatal_error( \""cmListFileLexer_yyset_column called with no buffer\"" , yyscanner);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""], [34, ""1e876b46911928b614ba89e234375f7f8a45d0e2"", ""Merge topic 'clang-format-lexer'\n\n030556b7 cmListFileLexer: Revise C++ coding style using clang-format\ne4a92dab cmListFileLexer: Update to flex 2.6"", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""cmListFileLexer_yyset_column called with no buffer\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_154_new.cpp""]]",2091,2149
"["" */"", ""#ifndef YY_INPUT"", ""#define YY_INPUT(buf,result,max_size) \\"", ""        if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\"", ""                { \\"", ""                int c = '*'; \\"", ""                size_t n; \\"", ""                for ( n = 0; n < max_size && \\"", ""                             (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\"", ""                        buf[n] = (char) c; \\"", ""                if ( c == '\\n' ) \\"", ""                        buf[n++] = (char) c; \\"", ""                if ( c == EOF && ferror( yyin ) ) \\"", ""                        YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""                result = n; \\"", ""                } \\"", ""        else \\"", ""                { \\"", ""                errno=0; \\"", ""                while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\"", ""                        { \\"", ""                        if( errno != EINTR) \\"", ""                                { \\"", ""                                YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""                                break; \\"", ""                                } \\"", ""                        errno=0; \\"", ""                        clearerr(yyin); \\"", ""                        } \\"", ""                }\\"", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\"", ""\t\t{ \\"", ""\t\tint c = '*'; \\"", ""\t\tsize_t n; \\"", ""\t\tfor ( n = 0; n < max_size && \\"", ""\t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\"", ""\t\t\tbuf[n] = (char) c; \\"", ""\t\tif ( c == '\\n' ) \\"", ""\t\t\tbuf[n++] = (char) c; \\"", ""\t\tif ( c == EOF && ferror( yyin ) ) \\"", ""\t\t\tYY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""\t\tresult = n; \\"", ""\t\t} \\"", ""\telse \\"", ""\t\t{ \\"", ""\t\terrno=0; \\"", ""\t\twhile ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\"", ""\t\t\t{ \\"", ""\t\t\tif( errno != EINTR) \\"", ""\t\t\t\t{ \\"", ""\t\t\t\tYY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", ""\t\t\t\tbreak; \\"", ""\t\t\t\t} \\"", ""\t\t\terrno=0; \\"", ""\t\t\tclearerr(yyin); \\"", ""\t\t\t} \\"", ""\t\t}\\"", ""\\"", """", ""#endif""]","[0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[13, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [23, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [40, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [50, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""input in flex scanner failed\"" ); \\"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""]]",761,776
"[""}"", ""case YY_STATE_EOF(INITIAL):"", ""case YY_STATE_EOF(COMMENT):"", ""#line 277 \""cmListFileLexer.in.l\"""", ""#line 274 \""cmListFileLexer.in.l\"""", ""{"", ""  lexer->token.type = cmListFileLexer_Token_None;"", ""  cmListFileLexerSetToken(lexer, 0, 0);"", ""  return 0;"", ""}"", ""case 24:"", ""YY_RULE_SETUP"", ""#line 283 \""cmListFileLexer.in.l\"""", ""#line 280 \""cmListFileLexer.in.l\"""", ""ECHO;"", ""        YY_BREAK"", ""#line 1238 \""cmListFileLexer.c\"""", """", ""        case YY_END_OF_BUFFER:"", ""                {"", ""                /* Amount of text matched not including the EOB char. */"", ""                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;"", """", ""                /* Undo the effects of YY_DO_BEFORE_ACTION. */"", ""                *yy_cp = yyg->yy_hold_char;"", ""                YY_RESTORE_YY_MORE_OFFSET"", """", ""                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )"", ""                        {"", ""                        /* We're scanning a new file or input source.  It's"", ""                         * possible that this happened because the user"", ""                         * just pointed yyin at a new source and called"", ""                         * cmListFileLexer_yylex().  If so, then we have to assure"", ""                         * consistency between YY_CURRENT_BUFFER and our"", ""                         * globals.  Here is the right place to do so, because"", ""                         * this is the first action (other than possibly a"", ""                         * back-up) that will match for the new input source."", ""                         */"", ""                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;"", ""                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;"", ""                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;"", ""                        }"", """", ""                /* Note that here we test for yy_c_buf_p \""<=\"" to the position"", ""                 * of the first EOB in the buffer, since yy_c_buf_p will"", ""                 * already have been incremented past the NUL character"", ""                 * (since all states make transitions on EOB to the"", ""                 * end-of-buffer state).  Contrast this with the test"", ""                 * in input()."", ""                 */"", ""                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )"", ""                        { /* This was really a NUL. */"", ""                        yy_state_type yy_next_state;"", """", ""                        yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""                        yy_current_state = yy_get_previous_state( yyscanner );"", """", ""                        /* Okay, we're now positioned to make the NUL"", ""                         * transition.  We couldn't have"", ""                         * yy_get_previous_state() go ahead and do it"", ""                         * for us because it doesn't know how to deal"", ""                         * with the possibility of jamming (and we don't"", ""                         * want to build jamming into it because then it"", ""                         * will run more slowly)."", ""                         */"", """", ""                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);"", """", ""                        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""                        if ( yy_next_state )"", ""                                {"", ""                                /* Consume the NUL. */"", ""                                yy_cp = ++yyg->yy_c_buf_p;"", ""                                yy_current_state = yy_next_state;"", ""                                goto yy_match;"", ""                                }"", """", ""                        else"", ""                                {"", ""                                yy_cp = yyg->yy_c_buf_p;"", ""                                goto yy_find_action;"", ""                                }"", ""                        }"", """", ""                else switch ( yy_get_next_buffer( yyscanner ) )"", ""                        {"", ""                        case EOB_ACT_END_OF_FILE:"", ""                                {"", ""                                yyg->yy_did_buffer_switch_on_eof = 0;"", """", ""                                if ( cmListFileLexer_yywrap(yyscanner ) )"", ""                                        {"", ""                                        /* Note: because we've taken care in"", ""                                         * yy_get_next_buffer() to have set up"", ""                                         * yytext, we can now set up"", ""                                         * yy_c_buf_p so that if some total"", ""                                         * hoser (like flex itself) wants to"", ""                                         * call the scanner after we return the"", ""                                         * YY_NULL, it'll still work - another"", ""                                         * YY_NULL will get returned."", ""                                         */"", ""                                        yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""                                        yy_act = YY_STATE_EOF(YY_START);"", ""                                        goto do_action;"", ""                                        }"", """", ""                                else"", ""                                        {"", ""                                        if ( ! yyg->yy_did_buffer_switch_on_eof )"", ""                                                YY_NEW_FILE;"", ""                                        }"", ""                                break;"", ""                                }"", """", ""                        case EOB_ACT_CONTINUE_SCAN:"", ""                                yyg->yy_c_buf_p ="", ""                                        yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""                                yy_current_state = yy_get_previous_state( yyscanner );"", """", ""                                yy_cp = yyg->yy_c_buf_p;"", ""                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""                                goto yy_match;"", """", ""                        case EOB_ACT_LAST_MATCH:"", ""                                yyg->yy_c_buf_p ="", ""                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];"", """", ""                                yy_current_state = yy_get_previous_state( yyscanner );"", """", ""                                yy_cp = yyg->yy_c_buf_p;"", ""                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""                                goto yy_find_action;"", ""                        }"", ""                break;"", ""                }"", """", ""        default:"", ""                YY_FATAL_ERROR("", ""                        \""fatal flex scanner internal error--no action found\"" );"", ""        } /* end of action switch */"", ""                } /* end of scanning one token */"", ""\tYY_BREAK"", ""#line 1242 \""cmListFileLexer.c\"""", """", ""\tcase YY_END_OF_BUFFER:"", ""\t\t{"", ""\t\t/* Amount of text matched not including the EOB char. */"", ""\t\tint yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;"", """", ""\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */"", ""\t\t*yy_cp = yyg->yy_hold_char;"", ""\t\tYY_RESTORE_YY_MORE_OFFSET"", """", ""\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )"", ""\t\t\t{"", ""\t\t\t/* We're scanning a new file or input source.  It's"", ""\t\t\t * possible that this happened because the user"", ""\t\t\t * just pointed yyin at a new source and called"", ""\t\t\t * cmListFileLexer_yylex().  If so, then we have to assure"", ""\t\t\t * consistency between YY_CURRENT_BUFFER and our"", ""\t\t\t * globals.  Here is the right place to do so, because"", ""\t\t\t * this is the first action (other than possibly a"", ""\t\t\t * back-up) that will match for the new input source."", ""\t\t\t */"", ""\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;"", ""\t\t\t}"", """", ""\t\t/* Note that here we test for yy_c_buf_p \""<=\"" to the position"", ""\t\t * of the first EOB in the buffer, since yy_c_buf_p will"", ""\t\t * already have been incremented past the NUL character"", ""\t\t * (since all states make transitions on EOB to the"", ""\t\t * end-of-buffer state).  Contrast this with the test"", ""\t\t * in input()."", ""\t\t */"", ""\t\tif ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )"", ""\t\t\t{ /* This was really a NUL. */"", ""\t\t\tyy_state_type yy_next_state;"", """", ""\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t/* Okay, we're now positioned to make the NUL"", ""\t\t\t * transition.  We couldn't have"", ""\t\t\t * yy_get_previous_state() go ahead and do it"", ""\t\t\t * for us because it doesn't know how to deal"", ""\t\t\t * with the possibility of jamming (and we don't"", ""\t\t\t * want to build jamming into it because then it"", ""\t\t\t * will run more slowly)."", ""\t\t\t */"", """", ""\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);"", """", ""\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""\t\t\tif ( yy_next_state )"", ""\t\t\t\t{"", ""\t\t\t\t/* Consume the NUL. */"", ""\t\t\t\tyy_cp = ++yyg->yy_c_buf_p;"", ""\t\t\t\tyy_current_state = yy_next_state;"", ""\t\t\t\tgoto yy_match;"", ""\t\t\t\t}"", """", ""\t\t\telse"", ""\t\t\t\t{"", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tgoto yy_find_action;"", ""\t\t\t\t}"", ""\t\t\t}"", """", ""\t\telse switch ( yy_get_next_buffer( yyscanner ) )"", ""\t\t\t{"", ""\t\t\tcase EOB_ACT_END_OF_FILE:"", ""\t\t\t\t{"", ""\t\t\t\tyyg->yy_did_buffer_switch_on_eof = 0;"", """", ""\t\t\t\tif ( cmListFileLexer_yywrap(yyscanner ) )"", ""\t\t\t\t\t{"", ""\t\t\t\t\t/* Note: because we've taken care in"", ""\t\t\t\t\t * yy_get_next_buffer() to have set up"", ""\t\t\t\t\t * yytext, we can now set up"", ""\t\t\t\t\t * yy_c_buf_p so that if some total"", ""\t\t\t\t\t * hoser (like flex itself) wants to"", ""\t\t\t\t\t * call the scanner after we return the"", ""\t\t\t\t\t * YY_NULL, it'll still work - another"", ""\t\t\t\t\t * YY_NULL will get returned."", ""\t\t\t\t\t */"", ""\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;"", """", ""\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);"", ""\t\t\t\t\tgoto do_action;"", ""\t\t\t\t\t}"", """", ""\t\t\t\telse"", ""\t\t\t\t\t{"", ""\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )"", ""\t\t\t\t\t\tYY_NEW_FILE;"", ""\t\t\t\t\t}"", ""\t\t\t\tbreak;"", ""\t\t\t\t}"", """", ""\t\t\tcase EOB_ACT_CONTINUE_SCAN:"", ""\t\t\t\tyyg->yy_c_buf_p ="", ""\t\t\t\t\tyyg->yytext_ptr + yy_amount_of_matched_text;"", """", ""\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""\t\t\t\tgoto yy_match;"", """", ""\t\t\tcase EOB_ACT_LAST_MATCH:"", ""\t\t\t\tyyg->yy_c_buf_p ="", ""\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];"", """", ""\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );"", """", ""\t\t\t\tyy_cp = yyg->yy_c_buf_p;"", ""\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;"", ""\t\t\t\tgoto yy_find_action;"", ""\t\t\t}"", ""\t\tbreak;"", ""\t\t}"", """", ""\tdefault:"", ""\t\tYY_FATAL_ERROR("", ""\t\t\t\""fatal flex scanner internal error--no action found\"" );"", ""\t} /* end of action switch */"", ""\t\t} /* end of scanning one token */"", ""\t} /* end of user's declarations */"", ""} /* end of cmListFileLexer_yylex */"", """", ""/* yy_get_next_buffer - try to read in a new buffer"", "" *"", "" * Returns a code representing an action:"", "" *      EOB_ACT_LAST_MATCH -"", "" *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position"", "" *      EOB_ACT_END_OF_FILE - end of file"", "" *\tEOB_ACT_LAST_MATCH -"", "" *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position"", "" *\tEOB_ACT_END_OF_FILE - end of file"", "" */"", ""static int yy_get_next_buffer (yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;"", ""        char *source = yyg->yytext_ptr;"", ""        int number_to_move, i;"", ""        int ret_val;"", """", ""        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )"", ""                YY_FATAL_ERROR("", ""                \""fatal flex scanner internal error--end of buffer missed\"" );"", """", ""        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )"", ""                { /* Don't try to fill the buffer, so this is an EOF. */"", ""                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )"", ""                        {"", ""                        /* We matched a single character, the EOB, so"", ""                         * treat this as a final EOF."", ""                         */"", ""                        return EOB_ACT_END_OF_FILE;"", ""                        }"", """", ""                else"", ""                        {"", ""                        /* We matched some text prior to the EOB, first"", ""                         * process it."", ""                         */"", ""                        return EOB_ACT_LAST_MATCH;"", ""                        }"", ""                }"", """", ""        /* Try to read more data. */"", """", ""        /* First move last chars to start of buffer. */"", ""        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;"", """", ""        for ( i = 0; i < number_to_move; ++i )"", ""                *(dest++) = *(source++);"", """", ""        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )"", ""                /* don't do the read, it's not guaranteed to return an EOF,"", ""                 * just force an EOF"", ""                 */"", ""                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;"", """", ""        else"", ""                {"", ""                        int num_to_read ="", ""                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;"", """", ""                while ( num_to_read <= 0 )"", ""                        { /* Not enough room in the buffer - grow it. */"", """", ""                        /* just a shorter name for the current buffer */"", ""                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;"", """", ""                        int yy_c_buf_p_offset ="", ""                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);"", """", ""                        if ( b->yy_is_our_buffer )"", ""                                {"", ""                                int new_size = b->yy_buf_size * 2;"", """", ""                                if ( new_size <= 0 )"", ""                                        b->yy_buf_size += b->yy_buf_size / 8;"", ""                                else"", ""                                        b->yy_buf_size *= 2;"", """", ""                                b->yy_ch_buf = (char *)"", ""                                        /* Include room in for 2 EOB chars. */"", ""                                        cmListFileLexer_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );"", ""                                }"", ""                        else"", ""                                /* Can't grow it, we don't own it. */"", ""                                b->yy_ch_buf = 0;"", """", ""                        if ( ! b->yy_ch_buf )"", ""                                YY_FATAL_ERROR("", ""                                \""fatal error - scanner input buffer overflow\"" );"", """", ""                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];"", """", ""                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -"", ""                                                number_to_move - 1;"", """", ""                        }"", """", ""                if ( num_to_read > YY_READ_BUF_SIZE )"", ""                        num_to_read = YY_READ_BUF_SIZE;"", """", ""                /* Read in more data. */"", ""                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),"", ""                        yyg->yy_n_chars, (size_t) num_to_read );"", """", ""                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;"", ""                }"", """", ""        if ( yyg->yy_n_chars == 0 )"", ""                {"", ""                if ( number_to_move == YY_MORE_ADJ )"", ""                        {"", ""                        ret_val = EOB_ACT_END_OF_FILE;"", ""                        cmListFileLexer_yyrestart(yyin  ,yyscanner);"", ""                        }"", """", ""                else"", ""                        {"", ""                        ret_val = EOB_ACT_LAST_MATCH;"", ""                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status ="", ""                                YY_BUFFER_EOF_PENDING;"", ""                        }"", ""                }"", """", ""        else"", ""                ret_val = EOB_ACT_CONTINUE_SCAN;"", """", ""        if ((yy_size_t) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {"", ""                /* Extend the array by 50%, plus the number we really need. */"", ""                yy_size_t new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);"", ""                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmListFileLexer_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );"", ""                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""                        YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", ""        }"", ""\tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;"", ""\tchar *source = yyg->yytext_ptr;"", ""\tyy_size_t number_to_move, i;"", ""\tint ret_val;"", """", ""\tif ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )"", ""\t\tYY_FATAL_ERROR("", ""\t\t\""fatal flex scanner internal error--end of buffer missed\"" );"", """", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )"", ""\t\t{ /* Don't try to fill the buffer, so this is an EOF. */"", ""\t\tif ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )"", ""\t\t\t{"", ""\t\t\t/* We matched a single character, the EOB, so"", ""\t\t\t * treat this as a final EOF."", ""\t\t\t */"", ""\t\t\treturn EOB_ACT_END_OF_FILE;"", ""\t\t\t}"", """", ""\t\telse"", ""\t\t\t{"", ""\t\t\t/* We matched some text prior to the EOB, first"", ""\t\t\t * process it."", ""\t\t\t */"", ""\t\t\treturn EOB_ACT_LAST_MATCH;"", ""\t\t\t}"", ""\t\t}"", """", ""\t/* Try to read more data. */"", """", ""\t/* First move last chars to start of buffer. */"", ""\tnumber_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;"", """", ""\tfor ( i = 0; i < number_to_move; ++i )"", ""\t\t*(dest++) = *(source++);"", """", ""\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )"", ""\t\t/* don't do the read, it's not guaranteed to return an EOF,"", ""\t\t * just force an EOF"", ""\t\t */"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;"", """", ""\telse"", ""\t\t{"", ""\t\t\tyy_size_t num_to_read ="", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;"", """", ""\t\twhile ( num_to_read <= 0 )"", ""\t\t\t{ /* Not enough room in the buffer - grow it. */"", """", ""\t\t\t/* just a shorter name for the current buffer */"", ""\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;"", """", ""\t\t\tint yy_c_buf_p_offset ="", ""\t\t\t\t(int) (yyg->yy_c_buf_p - b->yy_ch_buf);"", """", ""\t\t\tif ( b->yy_is_our_buffer )"", ""\t\t\t\t{"", ""\t\t\t\tyy_size_t new_size = b->yy_buf_size * 2;"", """", ""\t\t\t\tif ( new_size <= 0 )"", ""\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;"", ""\t\t\t\telse"", ""\t\t\t\t\tb->yy_buf_size *= 2;"", """", ""\t\t\t\tb->yy_ch_buf = (char *)"", ""\t\t\t\t\t/* Include room in for 2 EOB chars. */"", ""\t\t\t\t\tcmListFileLexer_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );"", ""\t\t\t\t}"", ""\t\t\telse"", ""\t\t\t\t/* Can't grow it, we don't own it. */"", ""\t\t\t\tb->yy_ch_buf = 0;"", """", ""\t\t\tif ( ! b->yy_ch_buf )"", ""\t\t\t\tYY_FATAL_ERROR("", ""\t\t\t\t\""fatal error - scanner input buffer overflow\"" );"", """", ""\t\t\tyyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];"", """", ""\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -"", ""\t\t\t\t\t\tnumber_to_move - 1;"", """", ""\t\t\t}"", """", ""\t\tif ( num_to_read > YY_READ_BUF_SIZE )"", ""\t\t\tnum_to_read = YY_READ_BUF_SIZE;"", """", ""\t\t/* Read in more data. */"", ""\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),"", ""\t\t\tyyg->yy_n_chars, num_to_read );"", """", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;"", ""\t\t}"", """", ""\tif ( yyg->yy_n_chars == 0 )"", ""\t\t{"", ""\t\tif ( number_to_move == YY_MORE_ADJ )"", ""\t\t\t{"", ""\t\t\tret_val = EOB_ACT_END_OF_FILE;"", ""\t\t\tcmListFileLexer_yyrestart(yyin  ,yyscanner);"", ""\t\t\t}"", """", ""\t\telse"", ""\t\t\t{"", ""\t\t\tret_val = EOB_ACT_LAST_MATCH;"", ""\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status ="", ""\t\t\t\tYY_BUFFER_EOF_PENDING;"", ""\t\t\t}"", ""\t\t}"", """", ""\telse"", ""\t\tret_val = EOB_ACT_CONTINUE_SCAN;"", """", ""\tif ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {"", ""\t\t/* Extend the array by 50%, plus the number we really need. */"", ""\t\tint new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmListFileLexer_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );"", ""\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", ""\t}"", """", ""        yyg->yy_n_chars += number_to_move;"", ""        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;"", ""        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;"", ""\tyyg->yy_n_chars += number_to_move;"", ""\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;"", ""\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;"", """", ""        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];"", ""\tyyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];"", """", ""        return ret_val;"", ""\treturn ret_val;"", ""}"", """", ""/* yy_get_previous_state - get the state just before the EOB char was reached */"", """", ""    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)"", ""{"", ""        yy_state_type yy_current_state;"", ""        char *yy_cp;"", ""\tyy_state_type yy_current_state;"", ""\tchar *yy_cp;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        yy_current_state = yyg->yy_start;"", ""\tyy_current_state = yyg->yy_start;"", """", ""        for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )"", ""                {"", ""                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);"", ""                if ( yy_accept[yy_current_state] )"", ""                        {"", ""                        yyg->yy_last_accepting_state = yy_current_state;"", ""                        yyg->yy_last_accepting_cpos = yy_cp;"", ""                        }"", ""                while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""                        {"", ""                        yy_current_state = (int) yy_def[yy_current_state];"", ""                        if ( yy_current_state >= 77 )"", ""                                yy_c = yy_meta[(unsigned int) yy_c];"", ""                        }"", ""                yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""                }"", ""\tfor ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )"", ""\t\t{"", ""\t\tYY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);"", ""\t\tif ( yy_accept[yy_current_state] )"", ""\t\t\t{"", ""\t\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t\t}"", ""\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t\t{"", ""\t\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\t\tif ( yy_current_state >= 77 )"", ""\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t\t}"", ""\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""\t\t}"", """", ""        return yy_current_state;"", ""\treturn yy_current_state;"", ""}"", """", ""/* yy_try_NUL_trans - try to make a transition on the NUL character"", "" *"", "" * synopsis"", "" *      next_state = yy_try_NUL_trans( current_state );"", "" *\tnext_state = yy_try_NUL_trans( current_state );"", "" */"", ""    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)"", ""{"", ""        int yy_is_jam;"", ""\tint yy_is_jam;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */"", ""        char *yy_cp = yyg->yy_c_buf_p;"", """", ""        YY_CHAR yy_c = 1;"", ""        if ( yy_accept[yy_current_state] )"", ""                {"", ""                yyg->yy_last_accepting_state = yy_current_state;"", ""                yyg->yy_last_accepting_cpos = yy_cp;"", ""                }"", ""        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""                {"", ""                yy_current_state = (int) yy_def[yy_current_state];"", ""                if ( yy_current_state >= 77 )"", ""                        yy_c = yy_meta[(unsigned int) yy_c];"", ""                }"", ""        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""        yy_is_jam = (yy_current_state == 76);"", """", ""        return yy_is_jam ? 0 : yy_current_state;"", ""\tchar *yy_cp = yyg->yy_c_buf_p;"", """", ""\tYY_CHAR yy_c = 1;"", ""\tif ( yy_accept[yy_current_state] )"", ""\t\t{"", ""\t\tyyg->yy_last_accepting_state = yy_current_state;"", ""\t\tyyg->yy_last_accepting_cpos = yy_cp;"", ""\t\t}"", ""\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"", ""\t\t{"", ""\t\tyy_current_state = (int) yy_def[yy_current_state];"", ""\t\tif ( yy_current_state >= 77 )"", ""\t\t\tyy_c = yy_meta[(unsigned int) yy_c];"", ""\t\t}"", ""\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"", ""\tyy_is_jam = (yy_current_state == 76);"", """", ""\t(void)yyg;"", ""\treturn yy_is_jam ? 0 : yy_current_state;"", ""}"", """", ""#ifndef YY_NO_UNPUT"", """", ""    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)"", ""{"", ""\tchar *yy_cp;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""    yy_cp = yyg->yy_c_buf_p;"", """", ""\t/* undo effects of setting up yytext */"", ""\t*yy_cp = yyg->yy_hold_char;"", """", ""\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )"", ""\t\t{ /* need to shift things up to make room */"", ""\t\t/* +2 for EOB chars. */"", ""\t\tyy_size_t number_to_move = yyg->yy_n_chars + 2;"", ""\t\tchar *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf["", ""\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];"", ""\t\tchar *source ="", ""\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];"", """", ""\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"", ""\t\t\t*--dest = *--source;"", """", ""\t\tyy_cp += (int) (dest - source);"", ""\t\tyy_bp += (int) (dest - source);"", ""\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars ="", ""\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;"", """", ""\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )"", ""\t\t\tYY_FATAL_ERROR( \""flex scanner push-back overflow\"" );"", ""\t\t}"", """", ""\t*--yy_cp = (char) c;"", """", ""    if ( c == '\\n' ){"", ""        --yylineno;"", ""    }"", """", ""\tyyg->yytext_ptr = yy_bp;"", ""\tyyg->yy_hold_char = *yy_cp;"", ""\tyyg->yy_c_buf_p = yy_cp;"", ""}"", """", ""#endif"", """", ""#ifndef YY_NO_INPUT"", ""#ifdef __cplusplus"", ""    static int yyinput (yyscan_t yyscanner)""]","[0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, 1, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, -1, 1, 1, 0, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[141, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [271, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [297, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [365, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [409, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [417, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [485, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR("", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [529, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in yy_get_next_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [676, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""flex scanner push-back overflow\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""]]",1197,1213
"["" */"", ""    YY_BUFFER_STATE cmListFileLexer_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)"", ""{"", ""        YY_BUFFER_STATE b;"", ""\tYY_BUFFER_STATE b;"", """", ""        b = (YY_BUFFER_STATE) cmListFileLexer_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""        if ( ! b )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_create_buffer()\"" );"", ""\tb = (YY_BUFFER_STATE) cmListFileLexer_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_create_buffer()\"" );"", """", ""        b->yy_buf_size = size;"", ""\tb->yy_buf_size = (yy_size_t)size;"", """", ""        /* yy_ch_buf has to be 2 characters longer than the size given because"", ""         * we need to put in 2 end-of-buffer characters."", ""         */"", ""        b->yy_ch_buf = (char *) cmListFileLexer_yyalloc(b->yy_buf_size + 2 ,yyscanner );"", ""        if ( ! b->yy_ch_buf )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_create_buffer()\"" );"", ""\t/* yy_ch_buf has to be 2 characters longer than the size given because"", ""\t * we need to put in 2 end-of-buffer characters."", ""\t */"", ""\tb->yy_ch_buf = (char *) cmListFileLexer_yyalloc(b->yy_buf_size + 2 ,yyscanner );"", ""\tif ( ! b->yy_ch_buf )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_create_buffer()\"" );"", """", ""        b->yy_is_our_buffer = 1;"", ""\tb->yy_is_our_buffer = 1;"", """", ""        cmListFileLexer_yy_init_buffer(b,file ,yyscanner);"", ""\tcmListFileLexer_yy_init_buffer(b,file ,yyscanner);"", """", ""        return b;"", ""\treturn b;"", ""}"", """", ""/** Destroy the buffer.""]","[0, 0, 0, -1, 1, 0, -1, -1, -2, 1, 1, 2, 0, -1, 1, 0, -1, -1, -1, -1, -1, -2, 1, 1, 1, 1, 1, 2, 0, -1, 1, 0, -1, 1, 0, -1, 1, 0, 0, 0]","[[8, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [11, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [21, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [27, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_create_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""]]",1692,1756
"[""void cmListFileLexer_yypop_buffer_state (yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""        if (!YY_CURRENT_BUFFER)"", ""                return;"", ""\tif (!YY_CURRENT_BUFFER)"", ""\t\treturn;"", """", ""        cmListFileLexer_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);"", ""        YY_CURRENT_BUFFER_LVALUE = NULL;"", ""        if (yyg->yy_buffer_stack_top > 0)"", ""                --yyg->yy_buffer_stack_top;"", ""\tcmListFileLexer_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);"", ""\tYY_CURRENT_BUFFER_LVALUE = NULL;"", ""\tif (yyg->yy_buffer_stack_top > 0)"", ""\t\t--yyg->yy_buffer_stack_top;"", """", ""        if (YY_CURRENT_BUFFER) {"", ""                cmListFileLexer_yy_load_buffer_state(yyscanner );"", ""                yyg->yy_did_buffer_switch_on_eof = 1;"", ""        }"", ""\tif (YY_CURRENT_BUFFER) {"", ""\t\tcmListFileLexer_yy_load_buffer_state(yyscanner );"", ""\t\tyyg->yy_did_buffer_switch_on_eof = 1;"", ""\t}"", ""}"", """", ""/* Allocates the stack if it does not exist."", "" *  Guarantees space for at least one push."", "" */"", ""static void cmListFileLexer_yyensure_buffer_stack (yyscan_t yyscanner)"", ""{"", ""        int num_to_alloc;"", ""\tyy_size_t num_to_alloc;"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        if (!yyg->yy_buffer_stack) {"", ""\tif (!yyg->yy_buffer_stack) {"", """", ""                /* First allocation is just for 2 elements, since we don't know if this"", ""                 * scanner will even need a stack. We use 2 instead of 1 to avoid an"", ""                 * immediate realloc on the next call."", ""\t\t/* First allocation is just for 2 elements, since we don't know if this"", ""\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an"", ""\t\t * immediate realloc on the next call."", ""         */"", ""                num_to_alloc = 1;"", ""                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyalloc"", ""                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)"", ""                                                                , yyscanner);"", ""                if ( ! yyg->yy_buffer_stack )"", ""                        YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()\"" );"", """", ""                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));"", """", ""                yyg->yy_buffer_stack_max = num_to_alloc;"", ""                yyg->yy_buffer_stack_top = 0;"", ""                return;"", ""        }"", ""\t\tnum_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */"", ""\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyalloc"", ""\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)"", ""\t\t\t\t\t\t\t\t, yyscanner);"", ""\t\tif ( ! yyg->yy_buffer_stack )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()\"" );"", """", ""        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){"", ""\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));"", """", ""                /* Increase the buffer to prepare for a possible push. */"", ""                int grow_size = 8 /* arbitrary grow size */;"", ""\t\tyyg->yy_buffer_stack_max = num_to_alloc;"", ""\t\tyyg->yy_buffer_stack_top = 0;"", ""\t\treturn;"", ""\t}"", """", ""                num_to_alloc = yyg->yy_buffer_stack_max + grow_size;"", ""                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyrealloc"", ""                                                                (yyg->yy_buffer_stack,"", ""                                                                num_to_alloc * sizeof(struct yy_buffer_state*)"", ""                                                                , yyscanner);"", ""                if ( ! yyg->yy_buffer_stack )"", ""                        YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()\"" );"", ""\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){"", """", ""                /* zero only the new slots.*/"", ""                memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));"", ""                yyg->yy_buffer_stack_max = num_to_alloc;"", ""        }"", ""\t\t/* Increase the buffer to prepare for a possible push. */"", ""\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;"", """", ""\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;"", ""\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyrealloc"", ""\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,"", ""\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)"", ""\t\t\t\t\t\t\t\t, yyscanner);"", ""\t\tif ( ! yyg->yy_buffer_stack )"", ""\t\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()\"" );"", """", ""\t\t/* zero only the new slots.*/"", ""\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));"", ""\t\tyyg->yy_buffer_stack_max = num_to_alloc;"", ""\t}"", ""}"", """", ""/** Setup the input buffer state to scan directly from a user-specified character buffer.""]","[0, 0, 0, -1, -1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, -1, -1, -1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 2, 0, -1, 1, 0, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -2, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 0, 0]","[[51, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [64, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [82, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [98, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""]]",1831,1895
"["" */"", ""YY_BUFFER_STATE cmListFileLexer_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)"", ""{"", ""        YY_BUFFER_STATE b;"", ""\tYY_BUFFER_STATE b;"", """", ""        if ( size < 2 ||"", ""             base[size-2] != YY_END_OF_BUFFER_CHAR ||"", ""             base[size-1] != YY_END_OF_BUFFER_CHAR )"", ""                /* They forgot to leave room for the EOB's. */"", ""                return 0;"", ""\tif ( size < 2 ||"", ""\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||"", ""\t     base[size-1] != YY_END_OF_BUFFER_CHAR )"", ""\t\t/* They forgot to leave room for the EOB's. */"", ""\t\treturn 0;"", """", ""        b = (YY_BUFFER_STATE) cmListFileLexer_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""        if ( ! b )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_scan_buffer()\"" );"", ""\tb = (YY_BUFFER_STATE) cmListFileLexer_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_scan_buffer()\"" );"", """", ""        b->yy_buf_size = size - 2;      /* \""- 2\"" to take care of EOB's */"", ""        b->yy_buf_pos = b->yy_ch_buf = base;"", ""        b->yy_is_our_buffer = 0;"", ""        b->yy_input_file = 0;"", ""        b->yy_n_chars = b->yy_buf_size;"", ""        b->yy_is_interactive = 0;"", ""        b->yy_at_bol = 1;"", ""        b->yy_fill_buffer = 0;"", ""        b->yy_buffer_status = YY_BUFFER_NEW;"", ""\tb->yy_buf_size = size - 2;\t/* \""- 2\"" to take care of EOB's */"", ""\tb->yy_buf_pos = b->yy_ch_buf = base;"", ""\tb->yy_is_our_buffer = 0;"", ""\tb->yy_input_file = 0;"", ""\tb->yy_n_chars = b->yy_buf_size;"", ""\tb->yy_is_interactive = 0;"", ""\tb->yy_at_bol = 1;"", ""\tb->yy_fill_buffer = 0;"", ""\tb->yy_buffer_status = YY_BUFFER_NEW;"", """", ""        cmListFileLexer_yy_switch_to_buffer(b ,yyscanner );"", ""\tcmListFileLexer_yy_switch_to_buffer(b ,yyscanner );"", """", ""        return b;"", ""\treturn b;"", ""}"", """", ""/** Setup the input buffer state to scan a string. The next call to cmListFileLexer_yylex() will""]","[0, 0, 0, -1, 1, 0, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 0, -1, -1, -2, 1, 1, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, 1, 0, -1, 1, 0, 0, 0]","[[19, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_scan_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [22, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_scan_buffer()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""]]",1900,1964
"["" * @param yyscanner The scanner object."", "" * @return the newly allocated buffer state object."", "" */"", ""YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)"", ""YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)"", ""{"", ""        YY_BUFFER_STATE b;"", ""        char *buf;"", ""        yy_size_t n;"", ""        int i;"", ""\tYY_BUFFER_STATE b;"", ""\tchar *buf;"", ""\tyy_size_t n;"", ""\tyy_size_t i;"", """", ""        /* Get memory for full buffer, including space for trailing EOB's. */"", ""        n = _yybytes_len + 2;"", ""        buf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );"", ""        if ( ! buf )"", ""                YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_scan_bytes()\"" );"", ""\t/* Get memory for full buffer, including space for trailing EOB's. */"", ""\tn = _yybytes_len + 2;"", ""\tbuf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );"", ""\tif ( ! buf )"", ""\t\tYY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_scan_bytes()\"" );"", """", ""        for ( i = 0; i < _yybytes_len; ++i )"", ""                buf[i] = yybytes[i];"", ""\tfor ( i = 0; i < _yybytes_len; ++i )"", ""\t\tbuf[i] = yybytes[i];"", """", ""        buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;"", ""\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;"", """", ""        b = cmListFileLexer_yy_scan_buffer(buf,n ,yyscanner);"", ""        if ( ! b )"", ""                YY_FATAL_ERROR( \""bad buffer in cmListFileLexer_yy_scan_bytes()\"" );"", ""\tb = cmListFileLexer_yy_scan_buffer(buf,n ,yyscanner);"", ""\tif ( ! b )"", ""\t\tYY_FATAL_ERROR( \""bad buffer in cmListFileLexer_yy_scan_bytes()\"" );"", """", ""        /* It's okay to grow etc. this buffer, and we should throw it"", ""         * away when we're done."", ""         */"", ""        b->yy_is_our_buffer = 1;"", ""\t/* It's okay to grow etc. this buffer, and we should throw it"", ""\t * away when we're done."", ""\t */"", ""\tb->yy_is_our_buffer = 1;"", """", ""        return b;"", ""\treturn b;"", ""}"", """", ""#ifndef YY_EXIT_FAILURE""]","[0, 0, 0, -1, 1, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -2, 1, 1, 1, 1, 2, 0, -1, -1, 1, 1, 0, -1, 1, 0, -1, -1, -2, 1, 1, 2, 0, -1, -1, -1, -1, 1, 1, 1, 1, 0, -1, 1, 0, 0, 0]","[[19, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [24, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""out of dynamic memory in cmListFileLexer_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [36, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""-"", ""YY_FATAL_ERROR( \""bad buffer in cmListFileLexer_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [39, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""bad buffer in cmListFileLexer_yy_scan_bytes()\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""]]",1948,2012
"["""", ""static void yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)"", ""{"", ""        (void)yyscanner;"", ""        (void) fprintf( stderr, \""%s\\n\"", msg );"", ""        exit( YY_EXIT_FAILURE );"", ""\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""\t(void)yyg;"", ""\t(void) fprintf( stderr, \""%s\\n\"", msg );"", ""\texit( YY_EXIT_FAILURE );"", ""}"", """", ""/* Redefine yyless() so it works in section 3 code. */"", """", ""#undef yyless"", ""#define yyless(n) \\"", ""        do \\"", ""                { \\"", ""                /* Undo effects of setting up yytext. */ \\"", ""\tdo \\"", ""\t\t{ \\"", ""\t\t/* Undo effects of setting up yytext. */ \\"", ""        int yyless_macro_arg = (n); \\"", ""        YY_LESS_LINENO(yyless_macro_arg);\\"", ""                yytext[yyleng] = yyg->yy_hold_char; \\"", ""                yyg->yy_c_buf_p = yytext + yyless_macro_arg; \\"", ""                yyg->yy_hold_char = *yyg->yy_c_buf_p; \\"", ""                *yyg->yy_c_buf_p = '\\0'; \\"", ""                yyleng = yyless_macro_arg; \\"", ""                } \\"", ""        while ( 0 )"", ""\t\tyytext[yyleng] = yyg->yy_hold_char; \\"", ""\t\tyyg->yy_c_buf_p = yytext + yyless_macro_arg; \\"", ""\t\tyyg->yy_hold_char = *yyg->yy_c_buf_p; \\"", ""\t\t*yyg->yy_c_buf_p = '\\0'; \\"", ""\t\tyyleng = yyless_macro_arg; \\"", ""\t\t} \\"", ""\twhile ( 0 )"", """", ""/* Accessor  methods (get/set functions) to struct members. */"", """"]","[0, 0, 0, -1, -2, -1, 1, 1, 2, 1, 0, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]","[[4, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""-"", ""(void) fprintf( stderr, \""%s\\n\"", msg );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [8, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""+"", ""(void) fprintf( stderr, \""%s\\n\"", msg );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""]]",1984,2048
"[""}"", """", ""/** Set the current line number."", "" * @param line_number"", "" * @param _line_number line number"", "" * @param yyscanner The scanner object."", "" */"", ""void cmListFileLexer_yyset_lineno (int  line_number , yyscan_t yyscanner)"", ""void cmListFileLexer_yyset_lineno (int  _line_number , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        /* lineno is only valid if an input buffer exists. */"", ""        if (! YY_CURRENT_BUFFER )"", ""           yy_fatal_error( \""cmListFileLexer_yyset_lineno called with no buffer\"" , yyscanner);"", ""           YY_FATAL_ERROR( \""cmListFileLexer_yyset_lineno called with no buffer\"" );"", """", ""    yylineno = line_number;"", ""    yylineno = _line_number;"", ""}"", """", ""/** Set the current column."", "" * @param line_number"", "" * @param _column_no column number"", "" * @param yyscanner The scanner object."", "" */"", ""void cmListFileLexer_yyset_column (int  column_no , yyscan_t yyscanner)"", ""void cmListFileLexer_yyset_column (int  _column_no , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", """", ""        /* column is only valid if an input buffer exists. */"", ""        if (! YY_CURRENT_BUFFER )"", ""           yy_fatal_error( \""cmListFileLexer_yyset_column called with no buffer\"" , yyscanner);"", ""           YY_FATAL_ERROR( \""cmListFileLexer_yyset_column called with no buffer\"" );"", """", ""    yycolumn = column_no;"", ""    yycolumn = _column_no;"", ""}"", """", ""/** Set the input stream. This does not discard the current"", "" * input buffer."", "" * @param in_str A readable stream."", "" * @param _in_str A readable stream."", "" * @param yyscanner The scanner object."", "" * @see cmListFileLexer_yy_switch_to_buffer"", "" */"", ""void cmListFileLexer_yyset_in (FILE *  in_str , yyscan_t yyscanner)"", ""void cmListFileLexer_yyset_in (FILE *  _in_str , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""    yyin = in_str ;"", ""    yyin = _in_str ;"", ""}"", """", ""void cmListFileLexer_yyset_out (FILE *  out_str , yyscan_t yyscanner)"", ""void cmListFileLexer_yyset_out (FILE *  _out_str , yyscan_t yyscanner)"", ""{"", ""    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;"", ""    yyout = out_str ;"", ""    yyout = _out_str ;"", ""}"", """", ""int cmListFileLexer_yyget_debug  (yyscan_t yyscanner)""]","[0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, -2, 2, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, -2, 2, 0, -1, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 0]","[[14, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""-"", ""yy_fatal_error( \""cmListFileLexer_yyset_lineno called with no buffer\"" , yyscanner);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [15, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""cmListFileLexer_yyset_lineno called with no buffer\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [33, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""-"", ""yy_fatal_error( \""cmListFileLexer_yyset_column called with no buffer\"" , yyscanner);"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""], [34, ""e4a92dab3fa81a893a52dd1a774db79c4363fda6"", ""cmListFileLexer: Update to flex 2.6\n\nRevise the documented modifications we need to make to the\nflex-generated source file according to the needs of the new version.\nUpdate our own implementation to avoid warnings with flex types."", ""Source/cmListFileLexer.c"", ""+"", ""YY_FATAL_ERROR( \""cmListFileLexer_yyset_column called with no buffer\"" );"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_155_new.cpp""]]",2091,2156
"["" *      because 16-bit word addressed copies were faster?)  Anyhow, it should"", "" *      have been ripped out long ago."", "" */"", ""static int copy_ar(CF *cfp, off_t size)"", ""static int copy_ar(CF* cfp, off_t size)"", ""{"", ""  static char pad = '\\n';"", ""  off_t sz = size;"", ""  size_t nr, nw;"", ""  char buf[8*1024];"", ""  char buf[8 * 1024];"", """", ""  if (sz == 0)"", ""    return 0;"", """", ""  FILE* from = cfp->rFile;"", ""  FILE* to = cfp->wFile;"", ""  while (sz &&"", ""        (nr = fread(buf, 1, sz < static_cast<off_t>(sizeof(buf))"", ""                    ? static_cast<size_t>(sz) : sizeof(buf), from ))"", ""               > 0) {"", ""         (nr = fread(buf, 1, sz < static_cast<off_t>(sizeof(buf))"", ""                       ? static_cast<size_t>(sz)"", ""                       : sizeof(buf),"", ""                     from)) > 0) {"", ""    sz -= nr;"", ""    for (size_t off = 0; off < nr; nr -= off, off += nw)"", ""      if ((nw = fwrite(buf + off, 1, nr, to)) < nr)"", ""        return -1;"", ""    }"", ""  }"", ""  if (sz)"", ""    return -2;"", """", ""  if (cfp->flags & WPAD && (size + ar_already_written) & 1"", ""      && fwrite(&pad, 1, 1, to) != 1)"", ""  if (cfp->flags & WPAD && (size + ar_already_written) & 1 &&"", ""      fwrite(&pad, 1, 1, to) != 1)"", ""    return -4;"", """", ""  return 0;"", ""}"", """", ""/* put_arobj --  Write an archive member to a file. */"", ""static int put_arobj(CF *cfp, struct stat *sb)"", ""static int put_arobj(CF* cfp, struct stat* sb)"", ""{"", ""  int result = 0;"", ""  struct ar_hdr *hdr;"", ""  struct ar_hdr* hdr;"", """", "" /* If passed an sb structure, reading a file from disk.  Get stat(2)"", ""  * information, build a name and construct a header.  (Files are named"", ""  * by their last component in the archive.) */"", ""  /* If passed an sb structure, reading a file from disk.  Get stat(2)"", ""   * information, build a name and construct a header.  (Files are named"", ""   * by their last component in the archive.) */"", ""  const char* name = ar_rname(cfp->rname);"", ""  (void)stat(cfp->rname, sb);"", """", "" /* If not truncating names and the name is too long or contains"", ""  * a space, use extended format 1.   */"", ""  /* If not truncating names and the name is too long or contains"", ""   * a space, use extended format 1.   */"", ""  size_t lname = strlen(name);"", ""  uid_t uid = sb->st_uid;"", ""  gid_t gid = sb->st_gid;"", ""  if (uid > USHRT_MAX) {"", ""    uid = USHRT_MAX;"", ""    }"", ""  }"", ""  if (gid > USHRT_MAX) {"", ""    gid = USHRT_MAX;"", ""    }"", ""  }"", ""  if (lname > sizeof(hdr->ar_name) || strchr(name, ' '))"", ""    (void)sprintf(ar_hb, HDR1, AR_EFMT1, (int)lname,"", ""                  (long int)sb->st_mtime, (unsigned)uid, (unsigned)gid,"", ""                  (unsigned)sb->st_mode, (long long)sb->st_size + lname,"", ""    (void)sprintf(ar_hb, HDR1, AR_EFMT1, (int)lname, (long int)sb->st_mtime,"", ""                  (unsigned)uid, (unsigned)gid, (unsigned)sb->st_mode,"", ""                  (long long)sb->st_size + lname, ARFMAG);"", ""  else {"", ""    lname = 0;"", ""    (void)sprintf(ar_hb, HDR2, name, (long int)sb->st_mtime, (unsigned)uid,"", ""                  (unsigned)gid, (unsigned)sb->st_mode, (long long)sb->st_size,"", ""                  ARFMAG);"", ""    else {"", ""      lname = 0;"", ""      (void)sprintf(ar_hb, HDR2, name,"", ""                    (long int)sb->st_mtime, (unsigned)uid, (unsigned)gid,"", ""                    (unsigned)sb->st_mode, (long long)sb->st_size,"", ""                    ARFMAG);"", ""      }"", ""    off_t size = sb->st_size;"", ""  }"", ""  off_t size = sb->st_size;"", """", ""  if (fwrite(ar_hb, 1, sizeof(HDR), cfp->wFile) != sizeof(HDR))"", ""    return -1;""]","[0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, -1, 1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, -1, -1, -1, 1, 1, 1, 0, 0, 0, -1, -1, 1, 1, 0, 0, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, -2, -1, -1, 2, 1, 1, 1, 1, 2, 1, 0, -1, -1, -2, -1, -1, -1, -1, -1, 1, 1, 0, 0, 0]","[[76, ""7d2a0aa76c25d92f1e2a03778f5666bdd7e56b92"", ""Merge topic 'clang-format-source'\n\nd9fd2f54 Revise C++ coding style using clang-format\n82df6dea Empty commit at end of history preceding clang-format style transition\n6a13f43f CONTRIBUTING: Add a section on coding style\nbf451d9f Add a script to run clang-format on the entire source tree\n1e90d78f Configure clang-format for CMake source tree\nda60adc3 Tell Git to use a distinct conflict marker size in `.rst` files"", ""Source/CPack/cmCPackDebGenerator.cxx"", ""-"", ""(void)sprintf(ar_hb, HDR1, AR_EFMT1, (int)lname,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_156_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_156_new.cpp""], [79, ""7d2a0aa76c25d92f1e2a03778f5666bdd7e56b92"", ""Merge topic 'clang-format-source'\n\nd9fd2f54 Revise C++ coding style using clang-format\n82df6dea Empty commit at end of history preceding clang-format style transition\n6a13f43f CONTRIBUTING: Add a section on coding style\nbf451d9f Add a script to run clang-format on the entire source tree\n1e90d78f Configure clang-format for CMake source tree\nda60adc3 Tell Git to use a distinct conflict marker size in `.rst` files"", ""Source/CPack/cmCPackDebGenerator.cxx"", ""+"", ""(void)sprintf(ar_hb, HDR1, AR_EFMT1, (int)lname, (long int)sb->st_mtime,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_156_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_156_new.cpp""], [84, ""7d2a0aa76c25d92f1e2a03778f5666bdd7e56b92"", ""Merge topic 'clang-format-source'\n\nd9fd2f54 Revise C++ coding style using clang-format\n82df6dea Empty commit at end of history preceding clang-format style transition\n6a13f43f CONTRIBUTING: Add a section on coding style\nbf451d9f Add a script to run clang-format on the entire source tree\n1e90d78f Configure clang-format for CMake source tree\nda60adc3 Tell Git to use a distinct conflict marker size in `.rst` files"", ""Source/CPack/cmCPackDebGenerator.cxx"", ""+"", ""(void)sprintf(ar_hb, HDR2, name, (long int)sb->st_mtime, (unsigned)uid,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_156_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_156_new.cpp""], [89, ""7d2a0aa76c25d92f1e2a03778f5666bdd7e56b92"", ""Merge topic 'clang-format-source'\n\nd9fd2f54 Revise C++ coding style using clang-format\n82df6dea Empty commit at end of history preceding clang-format style transition\n6a13f43f CONTRIBUTING: Add a section on coding style\nbf451d9f Add a script to run clang-format on the entire source tree\n1e90d78f Configure clang-format for CMake source tree\nda60adc3 Tell Git to use a distinct conflict marker size in `.rst` files"", ""Source/CPack/cmCPackDebGenerator.cxx"", ""-"", ""(void)sprintf(ar_hb, HDR2, name,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_156_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_156_new.cpp""]]",908,823
"["" *      because 16-bit word addressed copies were faster?)  Anyhow, it should"", "" *      have been ripped out long ago."", "" */"", ""static int copy_ar(CF *cfp, off_t size)"", ""static int copy_ar(CF* cfp, off_t size)"", ""{"", ""  static char pad = '\\n';"", ""  off_t sz = size;"", ""  size_t nr, nw;"", ""  char buf[8*1024];"", ""  char buf[8 * 1024];"", """", ""  if (sz == 0)"", ""    return 0;"", """", ""  FILE* from = cfp->rFile;"", ""  FILE* to = cfp->wFile;"", ""  while (sz &&"", ""        (nr = fread(buf, 1, sz < static_cast<off_t>(sizeof(buf))"", ""                    ? static_cast<size_t>(sz) : sizeof(buf), from ))"", ""               > 0) {"", ""         (nr = fread(buf, 1, sz < static_cast<off_t>(sizeof(buf))"", ""                       ? static_cast<size_t>(sz)"", ""                       : sizeof(buf),"", ""                     from)) > 0) {"", ""    sz -= nr;"", ""    for (size_t off = 0; off < nr; nr -= off, off += nw)"", ""      if ((nw = fwrite(buf + off, 1, nr, to)) < nr)"", ""        return -1;"", ""    }"", ""  }"", ""  if (sz)"", ""    return -2;"", """", ""  if (cfp->flags & WPAD && (size + ar_already_written) & 1"", ""      && fwrite(&pad, 1, 1, to) != 1)"", ""  if (cfp->flags & WPAD && (size + ar_already_written) & 1 &&"", ""      fwrite(&pad, 1, 1, to) != 1)"", ""    return -4;"", """", ""  return 0;"", ""}"", """", ""/* put_arobj --  Write an archive member to a file. */"", ""static int put_arobj(CF *cfp, struct stat *sb)"", ""static int put_arobj(CF* cfp, struct stat* sb)"", ""{"", ""  int result = 0;"", ""  struct ar_hdr *hdr;"", ""  struct ar_hdr* hdr;"", """", "" /* If passed an sb structure, reading a file from disk.  Get stat(2)"", ""  * information, build a name and construct a header.  (Files are named"", ""  * by their last component in the archive.) */"", ""  /* If passed an sb structure, reading a file from disk.  Get stat(2)"", ""   * information, build a name and construct a header.  (Files are named"", ""   * by their last component in the archive.) */"", ""  const char* name = ar_rname(cfp->rname);"", ""  (void)stat(cfp->rname, sb);"", """", "" /* If not truncating names and the name is too long or contains"", ""  * a space, use extended format 1.   */"", ""  /* If not truncating names and the name is too long or contains"", ""   * a space, use extended format 1.   */"", ""  size_t lname = strlen(name);"", ""  uid_t uid = sb->st_uid;"", ""  gid_t gid = sb->st_gid;"", ""  if (uid > USHRT_MAX) {"", ""    uid = USHRT_MAX;"", ""    }"", ""  }"", ""  if (gid > USHRT_MAX) {"", ""    gid = USHRT_MAX;"", ""    }"", ""  }"", ""  if (lname > sizeof(hdr->ar_name) || strchr(name, ' '))"", ""    (void)sprintf(ar_hb, HDR1, AR_EFMT1, (int)lname,"", ""                  (long int)sb->st_mtime, (unsigned)uid, (unsigned)gid,"", ""                  (unsigned)sb->st_mode, (long long)sb->st_size + lname,"", ""    (void)sprintf(ar_hb, HDR1, AR_EFMT1, (int)lname, (long int)sb->st_mtime,"", ""                  (unsigned)uid, (unsigned)gid, (unsigned)sb->st_mode,"", ""                  (long long)sb->st_size + lname, ARFMAG);"", ""  else {"", ""    lname = 0;"", ""    (void)sprintf(ar_hb, HDR2, name, (long int)sb->st_mtime, (unsigned)uid,"", ""                  (unsigned)gid, (unsigned)sb->st_mode, (long long)sb->st_size,"", ""                  ARFMAG);"", ""    else {"", ""      lname = 0;"", ""      (void)sprintf(ar_hb, HDR2, name,"", ""                    (long int)sb->st_mtime, (unsigned)uid, (unsigned)gid,"", ""                    (unsigned)sb->st_mode, (long long)sb->st_size,"", ""                    ARFMAG);"", ""      }"", ""    off_t size = sb->st_size;"", ""  }"", ""  off_t size = sb->st_size;"", """", ""  if (fwrite(ar_hb, 1, sizeof(HDR), cfp->wFile) != sizeof(HDR))"", ""    return -1;""]","[0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, -1, 1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, -1, -1, -1, 1, 1, 1, 0, 0, 0, -1, -1, 1, 1, 0, 0, 0, 0, 0, -1, 1, 0, 0, -1, 1, 0, -2, -1, -1, 2, 1, 1, 1, 1, 2, 1, 0, -1, -1, -2, -1, -1, -1, -1, -1, 1, 1, 0, 0, 0]","[[76, ""d9fd2f5402eeaa345691313658e02b51038f570b"", ""Revise C++ coding style using clang-format\n\nRun the `Utilities/Scripts/clang-format.bash` script to update\nall our C++ code to a new style defined by `.clang-format`.\nUse `clang-format` version 3.8.\n\n* If you reached this commit for a line in `git blame`, re-run the blame\n  operation starting at the parent of this commit to see older history\n  for the content.\n\n* See the parent commit for instructions to rebase a change across this\n  style transition commit."", ""Source/CPack/cmCPackDebGenerator.cxx"", ""-"", ""(void)sprintf(ar_hb, HDR1, AR_EFMT1, (int)lname,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_157_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_157_new.cpp""], [79, ""d9fd2f5402eeaa345691313658e02b51038f570b"", ""Revise C++ coding style using clang-format\n\nRun the `Utilities/Scripts/clang-format.bash` script to update\nall our C++ code to a new style defined by `.clang-format`.\nUse `clang-format` version 3.8.\n\n* If you reached this commit for a line in `git blame`, re-run the blame\n  operation starting at the parent of this commit to see older history\n  for the content.\n\n* See the parent commit for instructions to rebase a change across this\n  style transition commit."", ""Source/CPack/cmCPackDebGenerator.cxx"", ""+"", ""(void)sprintf(ar_hb, HDR1, AR_EFMT1, (int)lname, (long int)sb->st_mtime,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_157_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_157_new.cpp""], [84, ""d9fd2f5402eeaa345691313658e02b51038f570b"", ""Revise C++ coding style using clang-format\n\nRun the `Utilities/Scripts/clang-format.bash` script to update\nall our C++ code to a new style defined by `.clang-format`.\nUse `clang-format` version 3.8.\n\n* If you reached this commit for a line in `git blame`, re-run the blame\n  operation starting at the parent of this commit to see older history\n  for the content.\n\n* See the parent commit for instructions to rebase a change across this\n  style transition commit."", ""Source/CPack/cmCPackDebGenerator.cxx"", ""+"", ""(void)sprintf(ar_hb, HDR2, name, (long int)sb->st_mtime, (unsigned)uid,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_157_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_157_new.cpp""], [89, ""d9fd2f5402eeaa345691313658e02b51038f570b"", ""Revise C++ coding style using clang-format\n\nRun the `Utilities/Scripts/clang-format.bash` script to update\nall our C++ code to a new style defined by `.clang-format`.\nUse `clang-format` version 3.8.\n\n* If you reached this commit for a line in `git blame`, re-run the blame\n  operation starting at the parent of this commit to see older history\n  for the content.\n\n* See the parent commit for instructions to rebase a change across this\n  style transition commit."", ""Source/CPack/cmCPackDebGenerator.cxx"", ""-"", ""(void)sprintf(ar_hb, HDR2, name,"", 0, ""/data/download/CMake/CMake/Kitware_CMake_157_old.cpp"", 0, ""/data/download/CMake/CMake/Kitware_CMake_157_new.cpp""]]",908,823
