sha,message,issue,file_name,old_file,new_file,old_hunk_file,new_hunk_file,old_hunk,new_hunk,old_hunk_loc,new_hunk_loc,old_log_loc,new_log_loc
47b3a57c9bc5c7db608bc3b59b139a902535255f,"Display subproject timing summary

Use the '--no-subproject-summary' option to disable timing summary.",[],Source/CTest/cmCTestTestHandler.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_0.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_0.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_1.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_1.cpp,"                 << static_cast<int>(percent  .5f) << ""% tests passed, ""
                 << failed.size() << "" tests failed out of "" << total
                 << std::endl);
    if (this->CTest->GetLabelSummary()) {
      this->PrintLabelSummary();
    }
    char realBuf[1024];
    sprintf(realBuf, ""%6.2f sec"", (double)(clock_finish - clock_start));
    cmCTestOptionalLog(this->CTest, HANDLER_OUTPUT,
","                 << static_cast<int>(percent  .5f) << ""% tests passed, ""
                 << failed.size() << "" tests failed out of "" << total
                 << std::endl);

    if (!this->CTest->GetLabelsForSubprojects().empty() &&
        this->CTest->GetSubprojectSummary()) {
      this->PrintSubprojectSummary();
    } else if (this->CTest->GetLabelSummary()) {
      this->PrintLabelSummary();
    }

    char realBuf[1024];
    sprintf(realBuf, ""%6.2f sec"", (double)(clock_finish - clock_start));
    cmCTestOptionalLog(this->CTest, HANDLER_OUTPUT,
",536,536,[7],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_1.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_1.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_2.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    char header[80];
    snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, header, 0);
    if(result)
      return result;

",475,473,[3],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_1.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_1.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_3.cpp,"      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
","      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(header, sizeof(header),
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
",492,491,[3],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_4.cpp,"      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      char *buf = data->state.buffer;
      if(6 == sscanf(buf�, ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
","      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      if(6 == sscanf(&data->state.buffer[4], ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        char timebuf[24];
        time_t secs=time(NULL);

        snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(timebuf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
",2101,2100,[9],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_5.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_5.cpp,"          return result;

        /* format: ""Tue, 15 Nov 1994 12:45:26"" */
        snprintf(buf, BUFSIZE-1,
                 ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
                 Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
                 tm->tm_mday,
","          return result;

        /* format: ""Tue, 15 Nov 1994 12:45:26"" */
        snprintf(headerbuf, sizeof(headerbuf),
                 ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
                 Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
                 tm->tm_mday,
",2131,2131,[3],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_6.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_6.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      char clbuf[128];
      snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, clbuf, 0);
      if(result)
        return result;
    }
",2318,2318,[3],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_7.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_7.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,"[3, 16]",[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_8.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_8.cpp,"   */

  /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
  snprintf(buf, BUFSIZE-1,
           ""%s, %02d %s %4d %02d:%02d:%02d GMT"",
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
           tm->tm_mday,
           Curl_month[tm->tm_mon],
","   */

  /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
  snprintf(datestr, sizeof(datestr),
           ""%s: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
           condp,
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
           tm->tm_mday,
           Curl_month[tm->tm_mon],
",1712,1732,[3],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_9.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[練�] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[練�] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,"[5, 8]",[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_10.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE  1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(READBUFFER_SIZE  1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
",644,658,[5],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_11.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_11.cpp,"     * The application kindly asks for a differently sized receive buffer.
     * If it seems reasonable, we'll use it.
     */
    data->set.buffer_size = va_arg(param, long);

    if(data->set.buffer_size > MAX_BUFSIZE)
      data->set.buffer_size = MAX_BUFSIZE; /* huge internal default */
    else if(data->set.buffer_size < 1)
      data->set.buffer_size = BUFSIZE;

    /* Resize only if larger than default buffer size. */
    if(data->set.buffer_size > BUFSIZE) {
      data->state.buffer = realloc(data->state.buffer,
                                   data->set.buffer_size  1);
      if(!data->state.buffer) {
        DEBUGF(fprintf(stderr, ""Error: realloc of buffer failed\n""));
        result = CURLE_OUT_OF_MEMORY;
      }
    }

    break;

","     * The application kindly asks for a differently sized receive buffer.
     * If it seems reasonable, we'll use it.
     */
    arg = va_arg(param, long);

    if(arg > READBUFFER_MAX)
      arg = READBUFFER_MAX;
    else if(arg < 1)
      arg = READBUFFER_SIZE;
    else if(arg < READBUFFER_MIN)
      arg = READBUFFER_MIN;

    /* Resize if new size */
    if(arg != data->set.buffer_size) {
      char *newbuff = realloc(data->state.buffer, arg  1);
      if(!newbuff) {
        DEBUGF(fprintf(stderr, ""Error: realloc of buffer failed\n""));
        result = CURLE_OUT_OF_MEMORY;
      }
      else
        data->state.buffer = newbuff;
    }
    data->set.buffer_size = arg;

    break;

",2284,2304,[15],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_6.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_6.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_12.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_12.cpp,"  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
","  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 32 random hex chars, 32 bytes  1 zero termination */
  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  if(result)
    return result;

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
",387,386,[9],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/vtls/gtls.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_7.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_7.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_13.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_13.cpp,"  return 1;
}

static void showtime(struct Curl_easy *data,
                     const char *text,
                     time_t stamp)
{
  struct tm buffer;
  const struct tm *tm = &buffer;
  CURLcode result = Curl_gmtime(stamp, &buffer);
  if(result)
    return;

  snprintf(data->state.buffer,
           BUFSIZE,
           ""\t %s: %s, %02d %s %4d %02d:%02d:%02d GMT"",
           text,
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
","  return 1;
}

#ifndef CURL_DISABLE_VERBOSE_STRINGS
static void showtime(struct Curl_easy *data,
                     const char *text,
                     time_t stamp)
{
  struct tm buffer;
  const struct tm *tm = &buffer;
  char str[96];
  CURLcode result = Curl_gmtime(stamp, &buffer);
  if(result)
    return;

  snprintf(str,
           sizeof(str),
           ""\t %s: %s, %02d %s %4d %02d:%02d:%02d GMT"",
           text,
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
",211,211,[13],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_8.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_8.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_14.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_14.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    char header[80];
    snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, header, 0);
    if(result)
      return result;

",475,473,[3],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_8.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_8.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_15.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_15.cpp,"      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
","      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(header, sizeof(header),
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
",492,491,[3],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_16.cpp,"      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      char *buf = data->state.buffer;
      if(6 == sscanf(buf�, ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
","      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      if(6 == sscanf(&data->state.buffer[4], ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        char timebuf[24];
        time_t secs=time(NULL);

        snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(timebuf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
",2101,2100,[9],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_17.cpp,"          return result;

        /* format: ""Tue, 15 Nov 1994 12:45:26"" */
        snprintf(buf, BUFSIZE-1,
                 ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
                 Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
                 tm->tm_mday,
","          return result;

        /* format: ""Tue, 15 Nov 1994 12:45:26"" */
        snprintf(headerbuf, sizeof(headerbuf),
                 ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
                 Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
                 tm->tm_mday,
",2131,2131,[3],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_18.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      char clbuf[128];
      snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, clbuf, 0);
      if(result)
        return result;
    }
",2318,2318,[3],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_19.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,"[3, 16]",[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_20.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_20.cpp,"   */

  /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
  snprintf(buf, BUFSIZE-1,
           ""%s, %02d %s %4d %02d:%02d:%02d GMT"",
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
           tm->tm_mday,
           Curl_month[tm->tm_mon],
","   */

  /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
  snprintf(datestr, sizeof(datestr),
           ""%s: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
           condp,
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
           tm->tm_mday,
           Curl_month[tm->tm_mon],
",1712,1732,[3],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_11.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_11.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_21.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_21.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[練�] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[練�] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,"[5, 8]",[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_12.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_12.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_22.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_22.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE  1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(READBUFFER_SIZE  1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
",644,658,[5],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_12.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_12.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_23.cpp,"     * The application kindly asks for a differently sized receive buffer.
     * If it seems reasonable, we'll use it.
     */
    data->set.buffer_size = va_arg(param, long);

    if(data->set.buffer_size > MAX_BUFSIZE)
      data->set.buffer_size = MAX_BUFSIZE; /* huge internal default */
    else if(data->set.buffer_size < 1)
      data->set.buffer_size = BUFSIZE;

    /* Resize only if larger than default buffer size. */
    if(data->set.buffer_size > BUFSIZE) {
      data->state.buffer = realloc(data->state.buffer,
                                   data->set.buffer_size  1);
      if(!data->state.buffer) {
        DEBUGF(fprintf(stderr, ""Error: realloc of buffer failed\n""));
        result = CURLE_OUT_OF_MEMORY;
      }
    }

    break;

","     * The application kindly asks for a differently sized receive buffer.
     * If it seems reasonable, we'll use it.
     */
    arg = va_arg(param, long);

    if(arg > READBUFFER_MAX)
      arg = READBUFFER_MAX;
    else if(arg < 1)
      arg = READBUFFER_SIZE;
    else if(arg < READBUFFER_MIN)
      arg = READBUFFER_MIN;

    /* Resize if new size */
    if(arg != data->set.buffer_size) {
      char *newbuff = realloc(data->state.buffer, arg  1);
      if(!newbuff) {
        DEBUGF(fprintf(stderr, ""Error: realloc of buffer failed\n""));
        result = CURLE_OUT_OF_MEMORY;
      }
      else
        data->state.buffer = newbuff;
    }
    data->set.buffer_size = arg;

    break;

",2284,2304,[15],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_13.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_13.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_24.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_24.cpp,"  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
","  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 32 random hex chars, 32 bytes  1 zero termination */
  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  if(result)
    return result;

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
",387,386,[9],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/vtls/gtls.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_14.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_14.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_25.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_25.cpp,"  return 1;
}

static void showtime(struct Curl_easy *data,
                     const char *text,
                     time_t stamp)
{
  struct tm buffer;
  const struct tm *tm = &buffer;
  CURLcode result = Curl_gmtime(stamp, &buffer);
  if(result)
    return;

  snprintf(data->state.buffer,
           BUFSIZE,
           ""\t %s: %s, %02d %s %4d %02d:%02d:%02d GMT"",
           text,
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
","  return 1;
}

#ifndef CURL_DISABLE_VERBOSE_STRINGS
static void showtime(struct Curl_easy *data,
                     const char *text,
                     time_t stamp)
{
  struct tm buffer;
  const struct tm *tm = &buffer;
  char str[96];
  CURLcode result = Curl_gmtime(stamp, &buffer);
  if(result)
    return;

  snprintf(str,
           sizeof(str),
           ""\t %s: %s, %02d %s %4d %02d:%02d:%02d GMT"",
           text,
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
",211,211,[13],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_15.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_15.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_26.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_26.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    char header[80];
    snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, header, 0);
    if(result)
      return result;

",475,473,[3],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_15.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_15.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_27.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_27.cpp,"      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
","      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(header, sizeof(header),
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
",492,491,[3],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_28.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_28.cpp,"      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      char *buf = data->state.buffer;
      if(6 == sscanf(buf�, ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
","      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      if(6 == sscanf(&data->state.buffer[4], ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        char timebuf[24];
        time_t secs=time(NULL);

        snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(timebuf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
",2101,2100,[9],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_29.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_29.cpp,"          return result;

        /* format: ""Tue, 15 Nov 1994 12:45:26"" */
        snprintf(buf, BUFSIZE-1,
                 ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
                 Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
                 tm->tm_mday,
","          return result;

        /* format: ""Tue, 15 Nov 1994 12:45:26"" */
        snprintf(headerbuf, sizeof(headerbuf),
                 ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
                 Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
                 tm->tm_mday,
",2131,2131,[3],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_30.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_30.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      char clbuf[128];
      snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, clbuf, 0);
      if(result)
        return result;
    }
",2318,2318,[3],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_31.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,"[3, 16]",[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_32.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_32.cpp,"   */

  /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
  snprintf(buf, BUFSIZE-1,
           ""%s, %02d %s %4d %02d:%02d:%02d GMT"",
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
           tm->tm_mday,
           Curl_month[tm->tm_mon],
","   */

  /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
  snprintf(datestr, sizeof(datestr),
           ""%s: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
           condp,
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
           tm->tm_mday,
           Curl_month[tm->tm_mon],
",1712,1732,[3],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_33.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_33.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[練�] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[練�] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,"[5, 8]",[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_34.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_34.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE  1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(READBUFFER_SIZE  1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
",644,658,[5],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_35.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_35.cpp,"     * The application kindly asks for a differently sized receive buffer.
     * If it seems reasonable, we'll use it.
     */
    data->set.buffer_size = va_arg(param, long);

    if(data->set.buffer_size > MAX_BUFSIZE)
      data->set.buffer_size = MAX_BUFSIZE; /* huge internal default */
    else if(data->set.buffer_size < 1)
      data->set.buffer_size = BUFSIZE;

    /* Resize only if larger than default buffer size. */
    if(data->set.buffer_size > BUFSIZE) {
      data->state.buffer = realloc(data->state.buffer,
                                   data->set.buffer_size  1);
      if(!data->state.buffer) {
        DEBUGF(fprintf(stderr, ""Error: realloc of buffer failed\n""));
        result = CURLE_OUT_OF_MEMORY;
      }
    }

    break;

","     * The application kindly asks for a differently sized receive buffer.
     * If it seems reasonable, we'll use it.
     */
    arg = va_arg(param, long);

    if(arg > READBUFFER_MAX)
      arg = READBUFFER_MAX;
    else if(arg < 1)
      arg = READBUFFER_SIZE;
    else if(arg < READBUFFER_MIN)
      arg = READBUFFER_MIN;

    /* Resize if new size */
    if(arg != data->set.buffer_size) {
      char *newbuff = realloc(data->state.buffer, arg  1);
      if(!newbuff) {
        DEBUGF(fprintf(stderr, ""Error: realloc of buffer failed\n""));
        result = CURLE_OUT_OF_MEMORY;
      }
      else
        data->state.buffer = newbuff;
    }
    data->set.buffer_size = arg;

    break;

",2284,2304,[15],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_20.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_20.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_36.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_36.cpp,"  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
","  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 32 random hex chars, 32 bytes  1 zero termination */
  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  if(result)
    return result;

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
",387,386,[9],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/vtls/gtls.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_21.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_21.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_37.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_37.cpp,"  return 1;
}

static void showtime(struct Curl_easy *data,
                     const char *text,
                     time_t stamp)
{
  struct tm buffer;
  const struct tm *tm = &buffer;
  CURLcode result = Curl_gmtime(stamp, &buffer);
  if(result)
    return;

  snprintf(data->state.buffer,
           BUFSIZE,
           ""\t %s: %s, %02d %s %4d %02d:%02d:%02d GMT"",
           text,
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
","  return 1;
}

#ifndef CURL_DISABLE_VERBOSE_STRINGS
static void showtime(struct Curl_easy *data,
                     const char *text,
                     time_t stamp)
{
  struct tm buffer;
  const struct tm *tm = &buffer;
  char str[96];
  CURLcode result = Curl_gmtime(stamp, &buffer);
  if(result)
    return;

  snprintf(str,
           sizeof(str),
           ""\t %s: %s, %02d %s %4d %02d:%02d:%02d GMT"",
           text,
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
",211,211,[13],[]
d6051ca39e2ac8e5afc8f6308fd1bda7d1e8c17b,"execute_process: Add option to get results of every child

Add a `RESULTS_VARIABLE` option to get the results of all children
in a pipeline of one or more `COMMAND`s.",[],Source/cmExecuteProcessCommand.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_22.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_22.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_38.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_38.cpp,"    switch (cmsysProcess_GetState(cp)) {
      case cmsysProcess_State_Exited: {
        int v = cmsysProcess_GetExitValue(cp);
        char buf[100];
        sprintf(buf, ""%d"", v);
        this->Makefile->AddDefinition(result_variable, buf);
      } break;
","    switch (cmsysProcess_GetState(cp)) {
      case cmsysProcess_State_Exited: {
        int v = cmsysProcess_GetExitValue(cp);
        char buf[16];
        sprintf(buf, ""%d"", v);
        this->Makefile->AddDefinition(result_variable, buf);
      } break;
",287,297,[4],[]
16ebd9f6152fedd1804f13c91ed14e8963e53d3f,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2017-05-16 (fe1f22ce)",[],Source/kwsys/ProcessUNIX.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_23.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_23.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_39.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_39.cpp,"#endif
#endif
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/*--------------------------------------------------------------------------*/
/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
","#endif
#endif
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
",2243,2273,[4],[]
16ebd9f6152fedd1804f13c91ed14e8963e53d3f,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2017-05-16 (fe1f22ce)",[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_24.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_24.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_40.cpp,"
    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);
      break;
  }
}
","
    case STATUS_NO_MEMORY:
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);
      break;
  }
}
",2120,2142,[4],[]
16ebd9f6152fedd1804f13c91ed14e8963e53d3f,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2017-05-16 (fe1f22ce)",[],Source/kwsys/Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_25.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_25.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_41.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_41.cpp,"                                         FILE* stream, int color);
#endif

/*--------------------------------------------------------------------------*/
void kwsysTerminal_cfprintf(int color, FILE* stream, const char* format, ...)
{
  /* Setup the stream with the given color if possible.  */
","                                         FILE* stream, int color);
#endif

void kwsysTerminal_cfprintf(int color, FILE* stream, const char* format, ...)
{
  /* Setup the stream with the given color if possible.  */
",47,44,[4],[]
7be70ca6cc888df532d2f1560e74d13642730ee5,"KWSys 2017-05-16 (fe1f22ce)

Code extracted from:

    https://gitlab.kitware.com/utils/kwsys.git

at commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).

Upstream Shortlog
-----------------

Adam Weisi (3):
      8a799e36 Process: Improve definition ordering in header file
      7d56ef24 Process: Save results from all children internally
      b7eba998 Process: Add APIs to get results of individual processes

Ben Boeckel (2):
      cea71543 style: remove separator comments
      874dc559 style: help clang-format near macros",[],ProcessUNIX.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_26.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_26.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_42.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_42.cpp,"#endif
#endif
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/*--------------------------------------------------------------------------*/
/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
","#endif
#endif
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
",2243,2273,[4],[]
7be70ca6cc888df532d2f1560e74d13642730ee5,"KWSys 2017-05-16 (fe1f22ce)

Code extracted from:

    https://gitlab.kitware.com/utils/kwsys.git

at commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).

Upstream Shortlog
-----------------

Adam Weisi (3):
      8a799e36 Process: Improve definition ordering in header file
      7d56ef24 Process: Save results from all children internally
      b7eba998 Process: Add APIs to get results of individual processes

Ben Boeckel (2):
      cea71543 style: remove separator comments
      874dc559 style: help clang-format near macros",[],ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_27.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_27.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_43.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_43.cpp,"
    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);
      break;
  }
}
","
    case STATUS_NO_MEMORY:
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);
      break;
  }
}
",2120,2142,[4],[]
7be70ca6cc888df532d2f1560e74d13642730ee5,"KWSys 2017-05-16 (fe1f22ce)

Code extracted from:

    https://gitlab.kitware.com/utils/kwsys.git

at commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).

Upstream Shortlog
-----------------

Adam Weisi (3):
      8a799e36 Process: Improve definition ordering in header file
      7d56ef24 Process: Save results from all children internally
      b7eba998 Process: Add APIs to get results of individual processes

Ben Boeckel (2):
      cea71543 style: remove separator comments
      874dc559 style: help clang-format near macros",[],Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_28.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_28.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_44.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_44.cpp,"                                         FILE* stream, int color);
#endif

/*--------------------------------------------------------------------------*/
void kwsysTerminal_cfprintf(int color, FILE* stream, const char* format, ...)
{
  /* Setup the stream with the given color if possible.  */
","                                         FILE* stream, int color);
#endif

void kwsysTerminal_cfprintf(int color, FILE* stream, const char* format, ...)
{
  /* Setup the stream with the given color if possible.  */
",47,44,[4],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/conncache.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_29.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_29.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_45.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_45.cpp,"  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}

/* Look up the bundle with all the connections to the same host this
","  else
    hostname = conn->host.name;

  DEBUGASSERT(len > 32);

  /* put the number first so that the hostname gets cut off if too long */
  snprintf(buf, len, ""%ld%s"", conn->port, hostname);
}

/* Look up the bundle with all the connections to the same host this
",141,136,[3],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_30.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_30.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_46.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_46.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
",476,475,[3],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_47.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_47.cpp,"        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
","        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
",2107,2107,[3],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_48.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
",2318,2318,[3],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_49.cpp,"  case CURLWC_DOWNLOADING: {
    /* filelist has at least one file, lets get first one */
    struct ftp_conn *ftpc = &conn->proto.ftpc;
    struct curl_fileinfo *finfo = wildcard->filelist->head->ptr;

    char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename);
    if(!tmp_path)
","  case CURLWC_DOWNLOADING: {
    /* filelist has at least one file, lets get first one */
    struct ftp_conn *ftpc = &conn->proto.ftpc;
    struct curl_fileinfo *finfo = wildcard->filelist.head->ptr;

    char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename);
    if(!tmp_path)
",3916,3912,[5],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_32.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_32.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_50.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_50.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
","    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
",297,297,[3],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_33.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_33.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_51.cpp,"    info.buffer[info.len] = 0; /* we terminate this with a zero byte */
    return info.buffer;
  }
  else
    return strdup("""");
}

char *curl_mvaprintf(const char *format, va_list ap_save)
","    info.buffer[info.len] = 0; /* we terminate this with a zero byte */
    return info.buffer;
  }
  return strdup("""");
}

char *curl_mvaprintf(const char *format, va_list ap_save)
",1092,1092,[7],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_34.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_34.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_52.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_52.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.headerbuff = malloc(HEADERSIZE);
  if(!data->state.headerbuff) {
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE  1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }

  data->state.headerbuff = malloc(HEADERSIZE);
  if(!data->state.headerbuff) {
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
",641,644,[5],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/vtls/axtls.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_35.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_35.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_53.cpp,"  return snprintf(buffer, size, ""axTLS/%s"", ssl_version());
}

int Curl_axtls_random(struct Curl_easy *data,
                      unsigned char *entropy,
                      size_t length)
{
  static bool ssl_seeded = FALSE;
  (void)data;
","  return snprintf(buffer, size, ""axTLS/%s"", ssl_version());
}

CURLcode Curl_axtls_random(struct Curl_easy *data,
                           unsigned char *entropy,
                           size_t length)
{
  static bool ssl_seeded = FALSE;
  (void)data;
",680,686,[0],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/vtls/cyassl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_36.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_36.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_54.cpp,"
size_t Curl_cyassl_version(char *buffer, size_t size)
{
#ifdef WOLFSSL_VERSION
  return snprintf(buffer, size, ""wolfSSL/%s"", WOLFSSL_VERSION);
#elif defined(CYASSL_VERSION)
  return snprintf(buffer, size, ""CyaSSL/%s"", CYASSL_VERSION);
","
size_t Curl_cyassl_version(char *buffer, size_t size)
{
#if LIBCYASSL_VERSION_HEX >= 0x03006000
  return snprintf(buffer, size, ""wolfSSL/%s"", wolfSSL_lib_version());
#elif defined(WOLFSSL_VERSION)
  return snprintf(buffer, size, ""wolfSSL/%s"", WOLFSSL_VERSION);
#elif defined(CYASSL_VERSION)
  return snprintf(buffer, size, ""CyaSSL/%s"", CYASSL_VERSION);
",720,741,"[4, 6]",[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_37.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_37.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_55.cpp,"        {
          const BIGNUM *n;
          const BIGNUM *e;
          const BIGNUM *d;
          const BIGNUM *p;
          const BIGNUM *q;
          const BIGNUM *dmp1;
          const BIGNUM *dmq1;
          const BIGNUM *iqmp;

          RSA_get0_key(rsa, &n, &e, &d);
          RSA_get0_factors(rsa, &p, &q);
          RSA_get0_crt_params(rsa, &dmp1, &dmq1, &iqmp);
          BN_print(mem, n);
          push_certinfo(""RSA Public Key"", i);
          print_pubkey_BN(rsa, n, i);
          print_pubkey_BN(rsa, e, i);
          print_pubkey_BN(rsa, d, i);
          print_pubkey_BN(rsa, p, i);
          print_pubkey_BN(rsa, q, i);
          print_pubkey_BN(rsa, dmp1, i);
          print_pubkey_BN(rsa, dmq1, i);
          print_pubkey_BN(rsa, iqmp, i);
        }
#else
        BIO_printf(mem, ""%d"", BN_num_bits(rsa->n));
        push_certinfo(""RSA Public Key"", i);
        print_pubkey_BN(rsa, n, i);
        print_pubkey_BN(rsa, e, i);
        print_pubkey_BN(rsa, d, i);
        print_pubkey_BN(rsa, p, i);
        print_pubkey_BN(rsa, q, i);
        print_pubkey_BN(rsa, dmp1, i);
        print_pubkey_BN(rsa, dmq1, i);
        print_pubkey_BN(rsa, iqmp, i);
#endif

        break;
      }
      case EVP_PKEY_DSA:
      {
        DSA *dsa;
#ifdef HAVE_OPAQUE_EVP_PKEY
        dsa = EVP_PKEY_get0_DSA(pubkey);
","        {
          const BIGNUM *n;
          const BIGNUM *e;

          RSA_get0_key(rsa, &n, &e, NULL);
          BN_print(mem, n);
          push_certinfo(""RSA Public Key"", i);
          print_pubkey_BN(rsa, n, i);
          print_pubkey_BN(rsa, e, i);
        }
#else
        BIO_printf(mem, ""%d"", BN_num_bits(rsa->n));
        push_certinfo(""RSA Public Key"", i);
        print_pubkey_BN(rsa, n, i);
        print_pubkey_BN(rsa, e, i);
#endif

        break;
      }
      case EVP_PKEY_DSA:
      {
#ifndef OPENSSL_NO_DSA
        DSA *dsa;
#ifdef HAVE_OPAQUE_EVP_PKEY
        dsa = EVP_PKEY_get0_DSA(pubkey);
",2554,2628,[25],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/conncache.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_38.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_38.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_56.cpp,"  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}

/* Look up the bundle with all the connections to the same host this
","  else
    hostname = conn->host.name;

  DEBUGASSERT(len > 32);

  /* put the number first so that the hostname gets cut off if too long */
  snprintf(buf, len, ""%ld%s"", conn->port, hostname);
}

/* Look up the bundle with all the connections to the same host this
",141,136,[3],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_39.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_39.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_57.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_57.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
",476,475,[3],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_58.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_58.cpp,"        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
","        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
",2107,2107,[3],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_59.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
",2318,2318,[3],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_60.cpp,"  case CURLWC_DOWNLOADING: {
    /* filelist has at least one file, lets get first one */
    struct ftp_conn *ftpc = &conn->proto.ftpc;
    struct curl_fileinfo *finfo = wildcard->filelist->head->ptr;

    char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename);
    if(!tmp_path)
","  case CURLWC_DOWNLOADING: {
    /* filelist has at least one file, lets get first one */
    struct ftp_conn *ftpc = &conn->proto.ftpc;
    struct curl_fileinfo *finfo = wildcard->filelist.head->ptr;

    char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename);
    if(!tmp_path)
",3915,3911,[5],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_41.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_41.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_61.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_61.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
","    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
",297,297,[3],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_42.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_42.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_62.cpp,"    info.buffer[info.len] = 0; /* we terminate this with a zero byte */
    return info.buffer;
  }
  else
    return strdup("""");
}

char *curl_mvaprintf(const char *format, va_list ap_save)
","    info.buffer[info.len] = 0; /* we terminate this with a zero byte */
    return info.buffer;
  }
  return strdup("""");
}

char *curl_mvaprintf(const char *format, va_list ap_save)
",1096,1096,[7],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_43.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_43.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_63.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_63.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.headerbuff = malloc(HEADERSIZE);
  if(!data->state.headerbuff) {
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE  1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }

  data->state.headerbuff = malloc(HEADERSIZE);
  if(!data->state.headerbuff) {
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
",641,644,[5],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/vtls/axtls.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_44.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_44.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_64.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_64.cpp,"  return snprintf(buffer, size, ""axTLS/%s"", ssl_version());
}

int Curl_axtls_random(struct Curl_easy *data,
                      unsigned char *entropy,
                      size_t length)
{
  static bool ssl_seeded = FALSE;
  (void)data;
","  return snprintf(buffer, size, ""axTLS/%s"", ssl_version());
}

CURLcode Curl_axtls_random(struct Curl_easy *data,
                           unsigned char *entropy,
                           size_t length)
{
  static bool ssl_seeded = FALSE;
  (void)data;
",680,686,[0],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/vtls/cyassl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_45.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_45.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_65.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_65.cpp,"
size_t Curl_cyassl_version(char *buffer, size_t size)
{
#ifdef WOLFSSL_VERSION
  return snprintf(buffer, size, ""wolfSSL/%s"", WOLFSSL_VERSION);
#elif defined(CYASSL_VERSION)
  return snprintf(buffer, size, ""CyaSSL/%s"", CYASSL_VERSION);
","
size_t Curl_cyassl_version(char *buffer, size_t size)
{
#if LIBCYASSL_VERSION_HEX >= 0x03006000
  return snprintf(buffer, size, ""wolfSSL/%s"", wolfSSL_lib_version());
#elif defined(WOLFSSL_VERSION)
  return snprintf(buffer, size, ""wolfSSL/%s"", WOLFSSL_VERSION);
#elif defined(CYASSL_VERSION)
  return snprintf(buffer, size, ""CyaSSL/%s"", CYASSL_VERSION);
",720,741,"[4, 6]",[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_46.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_46.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_66.cpp,"        {
          const BIGNUM *n;
          const BIGNUM *e;
          const BIGNUM *d;
          const BIGNUM *p;
          const BIGNUM *q;
          const BIGNUM *dmp1;
          const BIGNUM *dmq1;
          const BIGNUM *iqmp;

          RSA_get0_key(rsa, &n, &e, &d);
          RSA_get0_factors(rsa, &p, &q);
          RSA_get0_crt_params(rsa, &dmp1, &dmq1, &iqmp);
          BN_print(mem, n);
          push_certinfo(""RSA Public Key"", i);
          print_pubkey_BN(rsa, n, i);
          print_pubkey_BN(rsa, e, i);
          print_pubkey_BN(rsa, d, i);
          print_pubkey_BN(rsa, p, i);
          print_pubkey_BN(rsa, q, i);
          print_pubkey_BN(rsa, dmp1, i);
          print_pubkey_BN(rsa, dmq1, i);
          print_pubkey_BN(rsa, iqmp, i);
        }
#else
        BIO_printf(mem, ""%d"", BN_num_bits(rsa->n));
        push_certinfo(""RSA Public Key"", i);
        print_pubkey_BN(rsa, n, i);
        print_pubkey_BN(rsa, e, i);
        print_pubkey_BN(rsa, d, i);
        print_pubkey_BN(rsa, p, i);
        print_pubkey_BN(rsa, q, i);
        print_pubkey_BN(rsa, dmp1, i);
        print_pubkey_BN(rsa, dmq1, i);
        print_pubkey_BN(rsa, iqmp, i);
#endif

        break;
      }
      case EVP_PKEY_DSA:
      {
        DSA *dsa;
#ifdef HAVE_OPAQUE_EVP_PKEY
        dsa = EVP_PKEY_get0_DSA(pubkey);
","        {
          const BIGNUM *n;
          const BIGNUM *e;

          RSA_get0_key(rsa, &n, &e, NULL);
          BN_print(mem, n);
          push_certinfo(""RSA Public Key"", i);
          print_pubkey_BN(rsa, n, i);
          print_pubkey_BN(rsa, e, i);
        }
#else
        BIO_printf(mem, ""%d"", BN_num_bits(rsa->n));
        push_certinfo(""RSA Public Key"", i);
        print_pubkey_BN(rsa, n, i);
        print_pubkey_BN(rsa, e, i);
#endif

        break;
      }
      case EVP_PKEY_DSA:
      {
#ifndef OPENSSL_NO_DSA
        DSA *dsa;
#ifdef HAVE_OPAQUE_EVP_PKEY
        dsa = EVP_PKEY_get0_DSA(pubkey);
",2554,2628,[25],[]
48fa291469e5e8b3ae88fb846750df72468eb58a,"bindexplib: add ARM support

Fixes: #16728",[u'https://gitlab.kitware.com/cmake/cmake/issues/16728'],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_47.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_47.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_67.cpp,"    fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
    return false;
  }
  /* Does it look like a i386 COFF OBJ file??? */
  else if (((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64)) &&
           (dosHeader->e_sp == 0)) {
    /*
    * The two tests above aren't what they look like.  They're
","    fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
    return false;
  }
  /* Does it look like a COFF OBJ file??? */
  else if (((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_ARMNT)) &&
           (dosHeader->e_sp == 0)) {
    /*
    * The two tests above aren't what they look like.  They're
",323,326,[0],[]
7a8860afbc614f2215e083adadb25963fe8f4dfe,bindexplib: clang-format,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_68.cpp,"   *      Dumps a COFF symbol table from an OBJ.
   *----------------------------------------------------------------------
   */
  void DumpExternalsObjects() {
    unsigned i;
    PSTR stringTable;
    std::string symbol;
    DWORD SectChar;
    /*
     * The string table apparently starts right after the symbol table
     */
    stringTable = (PSTR)&this->SymbolTable[this->SymbolCount];
    SymbolTableType* pSymbolTable = this->SymbolTable;
    for ( i=0; i < this->SymbolCount; i� ) {
      if (pSymbolTable->SectionNumber > 0 &&
          ( pSymbolTable->Type == 0x20 || pSymbolTable->Type == 0x0)) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            /*
            *    The name of the Function entry points
            */
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)pSymbolTable->N.ShortName, 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }

            // clear out any leading spaces
            while (isspace(symbol[0])) symbol.erase(0,1);
            // if it starts with _ and has an @ then it is a __cdecl
            // so remove the @ stuff for the export
            if(symbol[0] == '_') {
               std::string::size_type posAt = symbol.find('@');
               if (posAt != std::string::npos) {
                  symbol.erase(posAt);
               }
            }
            // For 64 bit builds we don't need to remove _
            if(!this->Is64Bit)
              {
              if (symbol[0] == '_')
                {
                symbol.erase(0,1);
                }
              }
            /*
            Check whether it is ""Scalar deleting destructor"" and
            ""Vector deleting destructor""
            */
            const char *scalarPrefix = ""??_G"";
            const char *vectorPrefix = ""??_E"";
            // original code had a check for
            // symbol.find(""real@"") == std::string::npos)
            // but if this disallows memmber functions with the name real
            // if scalarPrefix and vectorPrefix are not found then print
            // the symbol
            if (symbol.compare(0, 4, scalarPrefix) &&
                symbol.compare(0, 4, vectorPrefix) )
            {
               SectChar =
                 this->
                 SectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  this->DataSymbols.insert(symbol);
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ) ||
                       (SectChar & IMAGE_SCN_MEM_EXECUTE)) {
                     this->Symbols.insert(symbol);
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
               }
            }
         }
      }
      else if (pSymbolTable->SectionNumber == IMAGE_SYM_UNDEFINED &&
               !pSymbolTable->Type && 0) {
         /*
         *    The IMPORT global variable entry points
         */
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            this->DataSymbols.insert(symbol);
         }
      }

      /*
","   *      Dumps a COFF symbol table from an OBJ.
   *----------------------------------------------------------------------
   */
  void DumpExternalsObjects()
  {
    unsigned i;
    PSTR stringTable;
    std::string symbol;
    DWORD SectChar;
    /*
     * The string table apparently starts right after the symbol table
     */
    stringTable = (PSTR) & this->SymbolTable[this->SymbolCount];
    SymbolTableType* pSymbolTable = this->SymbolTable;
    for (i = 0; i < this->SymbolCount; i�) {
      if (pSymbolTable->SectionNumber > 0 &&
          (pSymbolTable->Type == 0x20 || pSymbolTable->Type == 0x0)) {
        if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
          /*
          *    The name of the Function entry points
          */
          if (pSymbolTable->N.Name.Short != 0) {
            symbol = """";
            symbol.insert(0, (const char*)pSymbolTable->N.ShortName, 8);
          } else {
            symbol = stringTable  pSymbolTable->N.Name.Long;
          }

          // clear out any leading spaces
          while (isspace(symbol[0]))
            symbol.erase(0, 1);
          // if it starts with _ and has an @ then it is a __cdecl
          // so remove the @ stuff for the export
          if (symbol[0] == '_') {
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) {
              symbol.erase(posAt);
            }
          }
          // For 64 bit builds we don't need to remove _
          if (!this->Is64Bit) {
            if (symbol[0] == '_') {
              symbol.erase(0, 1);
            }
          }
          /*
          Check whether it is ""Scalar deleting destructor"" and
          ""Vector deleting destructor""
          */
          const char* scalarPrefix = ""??_G"";
          const char* vectorPrefix = ""??_E"";
          // original code had a check for
          // symbol.find(""real@"") == std::string::npos)
          // but if this disallows memmber functions with the name real
          // if scalarPrefix and vectorPrefix are not found then print
          // the symbol
          if (symbol.compare(0, 4, scalarPrefix) &&
              symbol.compare(0, 4, vectorPrefix)) {
            SectChar = this->SectionHeaders[pSymbolTable->SectionNumber - 1]
                         .Characteristics;
            if (!pSymbolTable->Type && (SectChar & IMAGE_SCN_MEM_WRITE)) {
              // Read only (i.e. constants) must be excluded
              this->DataSymbols.insert(symbol);
            } else {
              if (pSymbolTable->Type || !(SectChar & IMAGE_SCN_MEM_READ) ||
                  (SectChar & IMAGE_SCN_MEM_EXECUTE)) {
                this->Symbols.insert(symbol);
              } else {
                // printf("" strange symbol: %s \n"",symbol.c_str());
              }
            }
          }
        }
      } else if (pSymbolTable->SectionNumber == IMAGE_SYM_UNDEFINED &&
                 !pSymbolTable->Type && 0) {
        /*
        *    The IMPORT global variable entry points
        */
        if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
          symbol = stringTable  pSymbolTable->N.Name.Long;
          while (isspace(symbol[0]))
            symbol.erase(0, 1);
          if (symbol[0] == '_')
            symbol.erase(0, 1);
          this->DataSymbols.insert(symbol);
        }
      }

      /*
",244,249,[71],[]
7a8860afbc614f2215e083adadb25963fe8f4dfe,bindexplib: clang-format,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_69.cpp,"      pSymbolTable�;
    }
  }
private:
  std::set<std::string>& Symbols;
  std::set<std::string>& DataSymbols;
  DWORD_PTR SymbolCount;
  PIMAGE_SECTION_HEADER SectionHeaders;
  ObjectHeaderType* ObjectImageHeader;
  SymbolTableType*  SymbolTable;
  bool Is64Bit;
};

bool
DumpFile(const char* filename,
         std::set<std::string>& symbols,
         std::set<std::string>& dataSymbols)
{
   HANDLE hFile;
   HANDLE hFileMapping;
   LPVOID lpFileBase;
   PIMAGE_DOS_HEADER dosHeader;

   hFile = CreateFileW(cmsys::Encoding::ToWide(filename).c_str(),
                       GENERIC_READ, FILE_SHARE_READ, NULL,
      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
      return false;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return false;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return false;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return false;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
           ((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64))
           && (dosHeader->e_sp == 0)
           ) {
      /*
      * The two tests above aren't what they look like.  They're
      * really checking for IMAGE_FILE_HEADER.Machine == i386 (0x14C)
      * and IMAGE_FILE_HEADER.SizeOfOptionalHeader == 0;
      */
      DumpSymbols<IMAGE_FILE_HEADER, IMAGE_SYMBOL>
        symbolDumper((PIMAGE_FILE_HEADER) lpFileBase, symbols, dataSymbols,
                     (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64));
      symbolDumper.DumpObjFile();
   } else {
      // check for /bigobj format
      cmANON_OBJECT_HEADER_BIGOBJ* h =
        (cmANON_OBJECT_HEADER_BIGOBJ*) lpFileBase;
      if(h->Sig1 == 0x0 && h->Sig2 == 0xffff) {
         DumpSymbols<cmANON_OBJECT_HEADER_BIGOBJ, cmIMAGE_SYMBOL_EX>
           symbolDumper((cmANON_OBJECT_HEADER_BIGOBJ*) lpFileBase, symbols,
                        dataSymbols,
                        (h->Machine == IMAGE_FILE_MACHINE_AMD64));
         symbolDumper.DumpObjFile();
      } else {
         printf(""unrecognized file format in '%s'\n"", filename);
         return false;
      }
   }
   UnmapViewOfFile(lpFileBase);
   CloseHandle(hFileMapping);
   CloseHandle(hFile);
   return true;
}

bool bindexplib::AddObjectFile(const char* filename)
","      pSymbolTable�;
    }
  }

private:
  std::set<std::string>& Symbols;
  std::set<std::string>& DataSymbols;
  DWORD_PTR SymbolCount;
  PIMAGE_SECTION_HEADER SectionHeaders;
  ObjectHeaderType* ObjectImageHeader;
  SymbolTableType* SymbolTable;
  bool Is64Bit;
};

bool DumpFile(const char* filename, std::set<std::string>& symbols,
              std::set<std::string>& dataSymbols)
{
  HANDLE hFile;
  HANDLE hFileMapping;
  LPVOID lpFileBase;
  PIMAGE_DOS_HEADER dosHeader;

  hFile = CreateFileW(cmsys::Encoding::ToWide(filename).c_str(), GENERIC_READ,
                      FILE_SHARE_READ, NULL, OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL, 0);

  if (hFile == INVALID_HANDLE_VALUE) {
    fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
    return false;
  }

  hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
  if (hFileMapping == 0) {
    CloseHandle(hFile);
    fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
    return false;
  }

  lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
  if (lpFileBase == 0) {
    CloseHandle(hFileMapping);
    CloseHandle(hFile);
    fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
    return false;
  }

  dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
  if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
    fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
    return false;
  }
  /* Does it look like a i386 COFF OBJ file??? */
  else if (((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64)) &&
           (dosHeader->e_sp == 0)) {
    /*
    * The two tests above aren't what they look like.  They're
    * really checking for IMAGE_FILE_HEADER.Machine == i386 (0x14C)
    * and IMAGE_FILE_HEADER.SizeOfOptionalHeader == 0;
    */
    DumpSymbols<IMAGE_FILE_HEADER, IMAGE_SYMBOL> symbolDumper(
      (PIMAGE_FILE_HEADER)lpFileBase, symbols, dataSymbols,
      (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64));
    symbolDumper.DumpObjFile();
  } else {
    // check for /bigobj format
    cmANON_OBJECT_HEADER_BIGOBJ* h = (cmANON_OBJECT_HEADER_BIGOBJ*)lpFileBase;
    if (h->Sig1 == 0x0 && h->Sig2 == 0xffff) {
      DumpSymbols<cmANON_OBJECT_HEADER_BIGOBJ, cmIMAGE_SYMBOL_EX> symbolDumper(
        (cmANON_OBJECT_HEADER_BIGOBJ*)lpFileBase, symbols, dataSymbols,
        (h->Machine == IMAGE_FILE_MACHINE_AMD64));
      symbolDumper.DumpObjFile();
    } else {
      printf(""unrecognized file format in '%s'\n"", filename);
      return false;
    }
  }
  UnmapViewOfFile(lpFileBase);
  CloseHandle(hFileMapping);
  CloseHandle(hFile);
  return true;
}

bool bindexplib::AddObjectFile(const char* filename)
",339,342,"[28, 35, 43, 49, 78]",[]
62d0e22325d36e5f9d61ccfbef0d68cfe1935f1b,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-25 (d6b1bb9f)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_70.cpp,"int
archive_read_disk_set_atime_restored(struct archive *_a)
{
#ifndef HAVE_UTIMES
static int warning_done = 0;
#endif
struct archive_read_disk *a = (struct archive_read_disk *)_a;
archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
a->restore_time = 1;
if (a->tree != NULL)
a->tree->flags |= needsRestoreTimes;
return (ARCHIVE_OK);
#else
if (warning_done)
/* Warning was already emitted; suppress further warnings. */
return (ARCHIVE_OK);

archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Cannot restore access time on this system"");
warning_done = 1;
return (ARCHIVE_WARN);
#endif
}
","int
archive_read_disk_set_atime_restored(struct archive *_a)
{
struct archive_read_disk *a = (struct archive_read_disk *)_a;
archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
a->flags |= ARCHIVE_READDISK_RESTORE_ATIME;
if (a->tree != NULL)
a->tree->flags |= needsRestoreTimes;
return (ARCHIVE_OK);
#else
/* Display warning and unset flag */
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Cannot restore access time on this system"");
a->flags &= ~ARCHIVE_READDISK_RESTORE_ATIME;
return (ARCHIVE_WARN);
#endif
}
",563,562,[19],[]
62d0e22325d36e5f9d61ccfbef0d68cfe1935f1b,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-25 (d6b1bb9f)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_71.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_71.cpp,"struct archive_read_disk *a = (struct archive_read_disk *)_a;

if (a->tree != NULL)
a->tree = tree_reopen(a->tree, pathname, a->restore_time);
else
a->tree = tree_open(pathname, a->symlink_mode,
    a->restore_time);
if (a->tree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate tar data"");
","struct archive_read_disk *a = (struct archive_read_disk *)_a;

if (a->tree != NULL)
a->tree = tree_reopen(a->tree, pathname,
    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
else
a->tree = tree_open(pathname, a->symlink_mode,
    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
if (a->tree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate tar data"");
",1340,1329,[8],[]
62d0e22325d36e5f9d61ccfbef0d68cfe1935f1b,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-25 (d6b1bb9f)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_50.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_50.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_72.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_72.cpp,"struct archive_read_disk *a = (struct archive_read_disk *)_a;

if (a->tree != NULL)
a->tree = tree_reopen(a->tree, pathname, a->restore_time);
else
a->tree = tree_open(pathname, a->symlink_mode, a->restore_time);
if (a->tree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate directory traversal data"");
","struct archive_read_disk *a = (struct archive_read_disk *)_a;

if (a->tree != NULL)
a->tree = tree_reopen(a->tree, pathname,
    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
else
a->tree = tree_open(pathname, a->symlink_mode,
    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
if (a->tree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate directory traversal data"");
",1219,1207,[7],[]
059aa805c9c0cb34c92eb69abf66febc40ab62db,"LibArchive 2017-02-25 (d6b1bb9f)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit d6b1bb9f7ea7bc153b7356e8e345c9e48005821a (v3.3.1).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_73.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_73.cpp,"int
archive_read_disk_set_atime_restored(struct archive *_a)
{
#ifndef HAVE_UTIMES
static int warning_done = 0;
#endif
struct archive_read_disk *a = (struct archive_read_disk *)_a;
archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
a->restore_time = 1;
if (a->tree != NULL)
a->tree->flags |= needsRestoreTimes;
return (ARCHIVE_OK);
#else
if (warning_done)
/* Warning was already emitted; suppress further warnings. */
return (ARCHIVE_OK);

archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Cannot restore access time on this system"");
warning_done = 1;
return (ARCHIVE_WARN);
#endif
}
","int
archive_read_disk_set_atime_restored(struct archive *_a)
{
struct archive_read_disk *a = (struct archive_read_disk *)_a;
archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
a->flags |= ARCHIVE_READDISK_RESTORE_ATIME;
if (a->tree != NULL)
a->tree->flags |= needsRestoreTimes;
return (ARCHIVE_OK);
#else
/* Display warning and unset flag */
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Cannot restore access time on this system"");
a->flags &= ~ARCHIVE_READDISK_RESTORE_ATIME;
return (ARCHIVE_WARN);
#endif
}
",563,562,[19],[]
059aa805c9c0cb34c92eb69abf66febc40ab62db,"LibArchive 2017-02-25 (d6b1bb9f)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit d6b1bb9f7ea7bc153b7356e8e345c9e48005821a (v3.3.1).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_74.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_74.cpp,"struct archive_read_disk *a = (struct archive_read_disk *)_a;

if (a->tree != NULL)
a->tree = tree_reopen(a->tree, pathname, a->restore_time);
else
a->tree = tree_open(pathname, a->symlink_mode,
    a->restore_time);
if (a->tree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate tar data"");
","struct archive_read_disk *a = (struct archive_read_disk *)_a;

if (a->tree != NULL)
a->tree = tree_reopen(a->tree, pathname,
    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
else
a->tree = tree_open(pathname, a->symlink_mode,
    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
if (a->tree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate tar data"");
",1340,1329,[8],[]
059aa805c9c0cb34c92eb69abf66febc40ab62db,"LibArchive 2017-02-25 (d6b1bb9f)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit d6b1bb9f7ea7bc153b7356e8e345c9e48005821a (v3.3.1).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_52.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_52.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_75.cpp,"struct archive_read_disk *a = (struct archive_read_disk *)_a;

if (a->tree != NULL)
a->tree = tree_reopen(a->tree, pathname, a->restore_time);
else
a->tree = tree_open(pathname, a->symlink_mode, a->restore_time);
if (a->tree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate directory traversal data"");
","struct archive_read_disk *a = (struct archive_read_disk *)_a;

if (a->tree != NULL)
a->tree = tree_reopen(a->tree, pathname,
    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
else
a->tree = tree_open(pathname, a->symlink_mode,
    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
if (a->tree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate directory traversal data"");
",1219,1207,[7],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_76.cpp,"name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

if (a->tree != NULL) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't change dir"");
return (ARCHIVE_FAILED);
}
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
","name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
else if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't change dir to read extended attributes"");
return (ARCHIVE_FAILED);
}
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
",302,321,"[4, 11]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_77.cpp,"const char *path;
ssize_t list_size;

path = archive_entry_sourcepath(entry);
if (path == NULL)
path = archive_entry_pathname(entry);

if (*fd < 0 && a->tree != NULL) {
if (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)
*fd = a->open_on_current_dir(a->tree, path,
O_RDONLY | O_NONBLOCK);
if (*fd < 0) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't access %s"", path);
return (ARCHIVE_FAILED);
}
}
}

","const char *path;
ssize_t list_size;

path = NULL;

if (*fd < 0) {
path = archive_entry_sourcepath(entry);
if (path == NULL || (a->tree != NULL &&
    a->tree_enter_working_dir(a->tree) != 0))
path = archive_entry_pathname(entry);
if (path == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Couldn't determine file path to read ""
    ""extended attributes"");
return (ARCHIVE_WARN);
}
if (a->tree != NULL && (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)) {
*fd = a->open_on_current_dir(a->tree,
    path, O_RDONLY | O_NONBLOCK);
}
}

",772,1486,[14],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_78.cpp,"const char *path;
int namespace = EXTATTR_NAMESPACE_USER;

path = archive_entry_sourcepath(entry);
if (path == NULL)
path = archive_entry_pathname(entry);

if (*fd < 0 && a->tree != NULL) {
if (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)
*fd = a->open_on_current_dir(a->tree, path,
O_RDONLY | O_NONBLOCK);
if (*fd < 0) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't access %s"", path);
return (ARCHIVE_FAILED);
}
}
}

","const char *path;
int namespace = EXTATTR_NAMESPACE_USER;

path = NULL;

if (*fd < 0) {
path = archive_entry_sourcepath(entry);
if (path == NULL || (a->tree != NULL &&
    a->tree_enter_working_dir(a->tree) != 0))
path = archive_entry_pathname(entry);
if (path == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Couldn't determine file path to read ""
    ""extended attributes"");
return (ARCHIVE_WARN);
}
if (a->tree != NULL && (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)) {
*fd = a->open_on_current_dir(a->tree,
    path, O_RDONLY | O_NONBLOCK);
}
}

",932,1645,[14],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_79.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_79.cpp,"if (path == NULL)
path = archive_entry_pathname(entry);

if (pathconf(path, _PC_MIN_HOLE_SIZE) <= 0)
return (ARCHIVE_OK);
*fd = open(path, O_RDONLY | O_NONBLOCK | O_CLOEXEC);
if (*fd < 0) {
archive_set_error(&a->archive, errno,
","if (path == NULL)
path = archive_entry_pathname(entry);

#ifdef _PC_MIN_HOLE_SIZE
if (pathconf(path, _PC_MIN_HOLE_SIZE) <= 0)
return (ARCHIVE_OK);
#endif
*fd = open(path, O_RDONLY | O_NONBLOCK | O_CLOEXEC);
if (*fd < 0) {
archive_set_error(&a->archive, errno,
",1180,1907,[7],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_80.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_80.cpp,"r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",938,938,[2],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_81.cpp,"r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",1041,1041,[2],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_82.cpp,"r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",1067,1067,[2],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_83.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_83.cpp,"archive_set_error(&a->archive, errno, ""statvfs failed"");
return (ARCHIVE_FAILED);
} else if (xr == 1) {
/* Usuall come here unless NetBSD supports _PC_REC_XFER_ALIGN
 * for pathconf() function. */
t->current_filesystem->xfer_align = sfs.f_frsize;
t->current_filesystem->max_xfer_size = -1;
","archive_set_error(&a->archive, errno, ""statvfs failed"");
return (ARCHIVE_FAILED);
} else if (xr == 1) {
/* Usually come here unless NetBSD supports _PC_REC_XFER_ALIGN
 * for pathconf() function. */
t->current_filesystem->xfer_align = sfs.f_frsize;
t->current_filesystem->max_xfer_size = -1;
",1643,1656,[0],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_84.cpp,"r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",803,802,[2],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_85.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_85.cpp,"r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",875,874,[2],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_86.cpp,"r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",901,900,[2],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_87.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_87.cpp,"#else
archive_set_error(a, ARCHIVE_ERRNO_MISC,
    ""Unexpedted operation in archive_read_open_filename"");
return (ARCHIVE_FATAL);
#endif
}
if (fstat(fd, &st) != 0) {
","#else
archive_set_error(a, ARCHIVE_ERRNO_MISC,
    ""Unexpedted operation in archive_read_open_filename"");
goto fail;
#endif
}
if (fstat(fd, &st) != 0) {
",277,277,[1],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_88.cpp,"else
archive_set_error(a, errno, ""Can't stat '%s'"",
    filename);
return (ARCHIVE_FATAL);
}

/*
","else
archive_set_error(a, errno, ""Can't stat '%s'"",
    filename);
goto fail;
}

/*
",287,287,[1],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_89.cpp,"mine->block_size = new_block_size;
}
buffer = malloc(mine->block_size);
if (mine == NULL || buffer == NULL) {
archive_set_error(a, ENOMEM, ""No memory"");
free(mine);
free(buffer);
return (ARCHIVE_FATAL);
}
mine->buffer = buffer;
mine->fd = fd;
","mine->block_size = new_block_size;
}
buffer = malloc(mine->block_size);
if (buffer == NULL) {
archive_set_error(a, ENOMEM, ""No memory"");
goto fail;
}
mine->buffer = buffer;
mine->fd = fd;
",356,356,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_lz4.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_57.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_57.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_90.cpp,"#endif
}

/* Check if an error happend in decompression process. */
if (uncompressed_size < 0) {
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC, ""lz4 decompression failed"");
","#endif
}

/* Check if an error occurred in the decompression process. */
if (uncompressed_size < 0) {
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC, ""lz4 decompression failed"");
",595,595,[5],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_58.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_58.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_91.cpp,"    &state->child_stdout);
if (child == -1) {
free(state->out_buf);
free(state);
archive_set_error(&self->archive->archive, EINVAL,
    ""Can't initialize filter; unable to run program \""%s\"""",
","    &state->child_stdout);
if (child == -1) {
free(state->out_buf);
archive_string_free(&state->description);
free(state);
archive_set_error(&self->archive->archive, EINVAL,
    ""Can't initialize filter; unable to run program \""%s\"""",
",430,430,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_92.cpp,"bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
return (ARCHIVE_OK);
#elif HAVE_LZMADEC_H && HAVE_LIBLZMADEC
return (ARCHIVE_OK);
#else
archive_set_error(_a, ARCHIVE_ERRNO_MISC,
    ""Using external lzma program for lzma decompression"");
","bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
return (ARCHIVE_OK);
#else
archive_set_error(_a, ARCHIVE_ERRNO_MISC,
    ""Using external lzma program for lzma decompression"");
",178,163,[6],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,"[27, 58, 64, 70, 103, 121, 127, 158]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_94.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_94.cpp,"archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_ar"");

ar = (struct ar *)malloc(sizeof(*ar));
if (ar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate ar data"");
return (ARCHIVE_FATAL);
}
memset(ar, 0, sizeof(*ar));
ar->strtab = NULL;

r = __archive_read_register_format(a,
","archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_ar"");

ar = (struct ar *)calloc(1, sizeof(*ar));
if (ar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate ar data"");
return (ARCHIVE_FATAL);
}
ar->strtab = NULL;

r = __archive_read_register_format(a,
",104,104,[5],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_95.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_95.cpp,"archive_entry_set_filetype(entry, AE_IFREG);
/* Get the size of the filename table. */
number = ar_atol10(h  AR_size_offset, AR_size_size);
if (number > SIZE_MAX) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Filename table too large"");
return (ARCHIVE_FATAL);
","archive_entry_set_filetype(entry, AE_IFREG);
/* Get the size of the filename table. */
number = ar_atol10(h  AR_size_offset, AR_size_size);
if (number > SIZE_MAX || number > 1024 * 1024 * 1024) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Filename table too large"");
return (ARCHIVE_FATAL);
",260,259,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_96.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_96.cpp," * If we can't look up the real name, warn and return
 * the entry with the wrong name.
 */
if (ar->strtab == NULL || number > ar->strtab_size) {
archive_set_error(&a->archive, EINVAL,
    ""Can't find long filename for GNU/SVR4 archive entry"");
archive_entry_copy_pathname(entry, filename);
"," * If we can't look up the real name, warn and return
 * the entry with the wrong name.
 */
if (ar->strtab == NULL || number >= ar->strtab_size) {
archive_set_error(&a->archive, EINVAL,
    ""Can't find long filename for GNU/SVR4 archive entry"");
archive_entry_copy_pathname(entry, filename);
",316,315,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_cpio.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_61.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_61.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_97.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_97.cpp,"    ""Rejecting malformed cpio archive: symlink contents exceed 1 megabyte"");
return (ARCHIVE_FATAL);
}
h = __archive_read_ahead(a,
(size_t)cpio->entry_bytes_remaining, NULL);
if (h == NULL)
return (ARCHIVE_FATAL);
if (archive_entry_copy_symlink_l(entry, (const char *)h,
    (size_t)cpio->entry_bytes_remaining, sconv) != 0) {
if (errno == ENOMEM) {
archive_set_error(&a->archive, ENOMEM,
","    ""Rejecting malformed cpio archive: symlink contents exceed 1 megabyte"");
return (ARCHIVE_FATAL);
}
hl = __archive_read_ahead(a,
(size_t)cpio->entry_bytes_remaining, NULL);
if (hl == NULL)
return (ARCHIVE_FATAL);
if (archive_entry_copy_symlink_l(entry, (const char *)hl,
    (size_t)cpio->entry_bytes_remaining, sconv) != 0) {
if (errno == ENOMEM) {
archive_set_error(&a->archive, ENOMEM,
",406,406,[10],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_98.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_98.cpp,"if ((file->utf16be_name = malloc(name_len)) == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""No memory for file name"");
return (NULL);
}
memcpy(file->utf16be_name, p, name_len);
file->utf16be_bytes = name_len;
","if ((file->utf16be_name = malloc(name_len)) == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""No memory for file name"");
goto fail;
}
memcpy(file->utf16be_name, p, name_len);
file->utf16be_bytes = name_len;
",1864,1864,[1],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_99.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_99.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE"");
return (NULL);
}
/*
 * Sanity check: file does not have ""CL"" extension.
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE"");
goto fail;
}
/*
 * Sanity check: file does not have ""CL"" extension.
",1990,1988,[0],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_100.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_100.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE and CL"");
return (NULL);
}
/*
 * Sanity check: The file type must be a directory.
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE and CL"");
goto fail;
}
/*
 * Sanity check: The file type must be a directory.
",1999,1997,[0],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_101.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_101.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE"");
return (NULL);
}
} else if (parent != NULL && parent->rr_moved)
file->rr_moved_has_re_only = 0;
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE"");
goto fail;
}
} else if (parent != NULL && parent->rr_moved)
file->rr_moved_has_re_only = 0;
",2008,2006,[0],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_102.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_102.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
/*
 * Sanity check: The file type must be a regular file.
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
/*
 * Sanity check: The file type must be a regular file.
",2022,2020,[0],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_103.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_103.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
parent->subdirs�;
/* Overwrite an offset and a number of this ""CL"" entry
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
parent->subdirs�;
/* Overwrite an offset and a number of this ""CL"" entry
",2031,2029,[0],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_104.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_104.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
}
if (file->cl_offset == file->offset ||
    parent->rr_moved) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
}
}
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
}
if (file->cl_offset == file->offset ||
    parent->rr_moved) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
}
}
",2049,2047,"[0, 8]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_63.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_63.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_105.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_105.cpp,"/* Get a real compressed file size. */
lha->compsize -= extdsize - 2;

if (sum_calculated != headersum) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""LHa header sum error"");
","/* Get a real compressed file size. */
lha->compsize -= extdsize - 2;

if (lha->compsize < 0)
goto invalid;/* Invalid compressed file size */

if (sum_calculated != headersum) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""LHa header sum error"");
",924,924,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_64.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_64.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_106.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_106.cpp,"archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_mtree"");

mtree = (struct mtree *)malloc(sizeof(*mtree));
if (mtree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate mtree data"");
return (ARCHIVE_FATAL);
}
memset(mtree, 0, sizeof(*mtree));
mtree->fd = -1;

r = __archive_read_register_format(a, mtree, ""mtree"",
","archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_mtree"");

mtree = (struct mtree *)calloc(1, sizeof(*mtree));
if (mtree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate mtree data"");
return (ARCHIVE_FATAL);
}
mtree->fd = -1;

r = __archive_read_register_format(a, mtree, ""mtree"",
",223,229,[5],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_64.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_64.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_107.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_107.cpp,"    struct mtree_option **global, const char *line, ssize_t line_len,
    struct mtree_entry **last_entry, int is_form_d)
{
struct mtree_entry *entry;
struct mtree_option *iter;
const char *next, *eq, *name, *end;
size_t name_len, len;
int r, i;

if ((entry = malloc(sizeof(*entry))) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
","    struct mtree_option **global, const char *line, ssize_t line_len,
    struct mtree_entry **last_entry, int is_form_d)
{
struct mtree_entry *entry, *ht_iter;
struct mtree_option *iter;
const char *next, *eq, *name, *end;
size_t name_len, len;
int r, i;
unsigned int ht_idx;

if ((entry = malloc(sizeof(*entry))) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
",853,867,[10],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_65.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_65.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_108.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_108.cpp,"  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,
                      ""archive_read_support_format_rar"");

  rar = (struct rar *)malloc(sizeof(*rar));
  if (rar == NULL)
  {
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }
  memset(rar, 0, sizeof(*rar));

/*
 * Until enough data has been read, we cannot tell about
","  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,
                      ""archive_read_support_format_rar"");

  rar = (struct rar *)calloc(sizeof(*rar), 1);
  if (rar == NULL)
  {
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }

/*
 * Until enough data has been read, we cannot tell about
",647,647,[6],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_109.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_109.cpp,"tar->sparse_gnu_pending = 0;
/* Read initial sparse map. */
bytes_read = gnu_sparse_10_read(a, tar, unconsumed);
tar->entry_bytes_remaining -= bytes_read;
if (bytes_read < 0)
return ((int)bytes_read);
} else {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
","tar->sparse_gnu_pending = 0;
/* Read initial sparse map. */
bytes_read = gnu_sparse_10_read(a, tar, unconsumed);
if (bytes_read < 0)
return ((int)bytes_read);
tar->entry_bytes_remaining -= bytes_read;
} else {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
",793,847,[7],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_110.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_110.cpp,"switch ((int)type & ~0777777) {
case 01000000:
/* POSIX.1e ACL */
break;
case 03000000:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Solaris NFSv4 ACLs not supported"");
return (ARCHIVE_WARN);
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Malformed Solaris ACL attribute (unsupported type %o)"",
","switch ((int)type & ~0777777) {
case 01000000:
/* POSIX.1e ACL */
acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;
break;
case 03000000:
/* NFSv4 ACL */
acl_type = ARCHIVE_ENTRY_ACL_TYPE_NFS4;
break;
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Malformed Solaris ACL attribute (unsupported type %o)"",
",935,989,"[5, 9]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_111.cpp,"return (ARCHIVE_FATAL);
}
archive_strncpy(&(tar->localname), acl, p - acl);
err = archive_acl_parse_l(archive_entry_acl(entry),
    tar->localname.s, ARCHIVE_ENTRY_ACL_TYPE_ACCESS, tar->sconv_acl);
if (err != ARCHIVE_OK) {
if (errno == ENOMEM) {
archive_set_error(&a->archive, ENOMEM,
","return (ARCHIVE_FATAL);
}
archive_strncpy(&(tar->localname), acl, p - acl);
err = archive_acl_from_text_l(archive_entry_acl(entry),
    tar->localname.s, acl_type, tar->sconv_acl);
if (err != ARCHIVE_OK) {
if (errno == ENOMEM) {
archive_set_error(&a->archive, ENOMEM,
",968,1023,[7],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_112.cpp,"if (tar->entry_bytes_remaining < 0) {
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry has negative size?"");
err = ARCHIVE_WARN;
}
tar->realsize = tar->entry_bytes_remaining;
archive_entry_set_size(entry, tar->entry_bytes_remaining);
","if (tar->entry_bytes_remaining < 0) {
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry has negative size"");
return (ARCHIVE_FATAL);
}
if (tar->entry_bytes_remaining == INT64_MAX) {
/* Note: tar_atol returns INT64_MAX on overflow */
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry size overflow"");
return (ARCHIVE_FATAL);
}
tar->realsize = tar->entry_bytes_remaining;
archive_entry_set_size(entry, tar->entry_bytes_remaining);
",1128,1183,[2],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_113.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,"[17, 22, 41, 46]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_114.cpp,"{
struct sparse_block *p;

p = (struct sparse_block *)malloc(sizeof(*p));
if (p == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
return (ARCHIVE_FATAL);
}
memset(p, 0, sizeof(*p));
if (tar->sparse_last != NULL)
tar->sparse_last->next = p;
else
","{
struct sparse_block *p;

p = (struct sparse_block *)calloc(1, sizeof(*p));
if (p == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
return (ARCHIVE_FATAL);
}
if (tar->sparse_last != NULL)
tar->sparse_last->next = p;
else
",2116,2227,[5],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_115.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_115.cpp,"archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_warc"");

if ((w = malloc(sizeof(*w))) == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate warc data"");
return (ARCHIVE_FATAL);
}
memset(w, 0, sizeof(*w));

r = __archive_read_register_format(
a, w, ""warc"",
","archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_warc"");

if ((w = calloc(1, sizeof(*w))) == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate warc data"");
return (ARCHIVE_FATAL);
}

r = __archive_read_register_format(
a, w, ""warc"",
",146,146,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_116.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_116.cpp,"&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {
/* nawww, I wish they promised backward compatibility
 * anyhoo, in their infinite wisdom the 28500 guys might
 * come up with something we can't possibly handle so
 * best end things here */
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version"");
return (ARCHIVE_FATAL);
} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
","&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
}
ver = _warc_rdver(buf, eoh - buf);
/* we currently support WARC 0.12 to 1.0 */
if (ver == 0U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Invalid record version"");
return (ARCHIVE_FATAL);
} else if (ver < 1200U || ver > 10000U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version: %u.%u"",
ver / 10000, (ver % 10000) / 100);
return (ARCHIVE_FATAL);
}
cntlen = _warc_rdlen(buf, eoh - buf);
if (cntlen < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
}
rtime = _warc_rdrtm(buf, eoh - buf);
if (rtime == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
",255,254,"[8, 15, 22]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_117.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_117.cpp,"if (ver != w->pver) {
/* stringify this entry's version */
archive_string_sprintf(&w->sver,
""WARC/%u.%u"", ver / 10000, ver % 10000);
/* remember the version */
w->pver = ver;
}
","if (ver != w->pver) {
/* stringify this entry's version */
archive_string_sprintf(&w->sver,
""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100);
/* remember the version */
w->pver = ver;
}
",285,293,[2],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_118.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_118.cpp,"xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
if (xar->lzstream_valid)
lzmadec_end(&(xar->lzstream));
r = lzmadec_init(&(xar->lzstream));
if (r != LZMADEC_OK) {
switch (r) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing ""
    ""compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&a->archive,
    ENOMEM,
    ""Internal error initializing ""
    ""compression library: ""
    ""out of memory"");
break;
}
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 1;
xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
","xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
",1526,1524,"[11, 18]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_119.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_119.cpp,"*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
xar->lzstream.avail_in = avail_in;
xar->lzstream.next_out = (unsigned char *)outbuff;
xar->lzstream.avail_out = avail_out;
r = lzmadec_decode(&(xar->lzstream), 0);
switch (r) {
case LZMADEC_STREAM_END: /* Found end of stream. */
switch (lzmadec_end(&(xar->lzstream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up lzmadec decompressor"");
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 0;
/* FALLTHROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""lzmadec decompression failed(%d)"",
    r);
return (ARCHIVE_FATAL);
}
*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
case LZMA:
#endif
case XZ:
#endif
case NONE:
","*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
case LZMA:
case XZ:
#endif
case NONE:
",1685,1653,"[16, 26]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_120.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_120.cpp," *id1눬떭�  id2눬떭� ...
 *  triplets.  id and size are 2 bytes each.
 */
static void
process_extra(const char *p, size_t extra_length, struct zip_entry* zip_entry)
{
unsigned offset = 0;

while (offset < extra_length - 4) {
unsigned short headerid = archive_le16dec(p  offset);
unsigned short datasize = archive_le16dec(p  offset  2);

offset = 4;
if (offset  datasize > extra_length) {
break;
}
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%04x, length %d\n"",
"," *id1눬떭�  id2눬떭� ...
 *  triplets.  id and size are 2 bytes each.
 */
static int
process_extra(struct archive_read *a, const char *p, size_t extra_length, struct zip_entry* zip_entry)
{
unsigned offset = 0;

if (extra_length == 0) {
return ARCHIVE_OK;
}

if (extra_length < 4) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Too-small extra data: Need at least 4 bytes, but only found %d bytes"", (int)extra_length);
return ARCHIVE_FAILED;
}
while (offset <= extra_length - 4) {
unsigned short headerid = archive_le16dec(p  offset);
unsigned short datasize = archive_le16dec(p  offset  2);

offset = 4;
if (offset  datasize > extra_length) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Extra data overflow: Need %d bytes but only found %d bytes"",
    (int)datasize, (int)(extra_length - offset));
return ARCHIVE_FAILED;
}
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%04x, length %d\n"",
",418,418,[17],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_121.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_121.cpp,"}
offset = datasize;
}
#ifdef DEBUG
if (offset != extra_length)
{
fprintf(stderr,
    ""Extra data field contents do not match reported size!\n"");
}
#endif
}

/*
","}
offset = datasize;
}
if (offset != extra_length) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Malformed extra data: Consumed %d bytes of %d bytes"",
    (int)offset, (int)extra_length);
return ARCHIVE_FAILED;
}
return ARCHIVE_OK;
}

/*
",715,739,[6],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_122.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_122.cpp,"    && bytes_avail > zip->entry_bytes_remaining) {
bytes_avail = (ssize_t)zip->entry_bytes_remaining;
}
if (bytes_avail <= 0) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file body"");
return (ARCHIVE_FATAL);
","    && bytes_avail > zip->entry_bytes_remaining) {
bytes_avail = (ssize_t)zip->entry_bytes_remaining;
}
if (bytes_avail < 0) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file body"");
return (ARCHIVE_FATAL);
",1293,1332,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_123.cpp,"case 0x6720:/* Blowfish */
case 0x6721:/* Twofish */
case 0x6801:/* RC4 */
/* Suuported encryption algorithm. */
break;
default:
archive_set_error(&a->archive,
","case 0x6720:/* Blowfish */
case 0x6721:/* Twofish */
case 0x6801:/* RC4 */
/* Supported encryption algorithm. */
break;
default:
archive_set_error(&a->archive,
",1500,1548,[6],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_124.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_124.cpp,"__archive_read_consume(a, 4);

/*return (ARCHIVE_OK);
 * This is not fully implemnted yet.*/
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Encrypted file is unsupported"");
return (ARCHIVE_FAILED);
","__archive_read_consume(a, 4);

/*return (ARCHIVE_OK);
 * This is not fully implemented yet.*/
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Encrypted file is unsupported"");
return (ARCHIVE_FAILED);
",1609,1657,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_125.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_125.cpp,"if (a->restore_pwd >= 0) {
r = fchdir(a->restore_pwd);
if (r != 0) {
archive_set_error(&a->archive, errno, ""chdir() failure"");
ret = ARCHIVE_FATAL;
}
close(a->restore_pwd);
","if (a->restore_pwd >= 0) {
r = fchdir(a->restore_pwd);
if (r != 0) {
archive_set_error(&a->archive, errno,
    ""chdir() failure"");
ret = ARCHIVE_FATAL;
}
close(a->restore_pwd);
",637,669,[3],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_126.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_126.cpp,"bytes_to_write = size;
/* Seek if necessary to the specified offset. */
if (a->offset < a->fd_offset) {
/* Can't support backword move. */
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Seek failed"");
return (ARCHIVE_FATAL);
","bytes_to_write = size;
/* Seek if necessary to the specified offset. */
if (a->offset < a->fd_offset) {
/* Can't support backward move. */
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Seek failed"");
return (ARCHIVE_FATAL);
",1402,1437,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_127.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_127.cpp,"return (r);
if ((size_t)r < size) {
archive_set_error(&a->archive, 0,
    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);
return (ARCHIVE_WARN);
}
#if ARCHIVE_VERSION_NUMBER < 3999000
","return (r);
if ((size_t)r < size) {
archive_set_error(&a->archive, 0,
    ""Too much data: Truncating file at %ju bytes"",
    (uintmax_t)a->filesize);
return (ARCHIVE_WARN);
}
#if ARCHIVE_VERSION_NUMBER < 3999000
",1468,1503,[2],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_128.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_128.cpp,"
if (en) {
/* Everything failed; give up here. */
archive_set_error(&a->archive, en, ""Can't create '%s'"",
    a->name);
return (ARCHIVE_FAILED);
}

","
if (en) {
/* Everything failed; give up here. */
if ((&a->archive)->error == NULL)
archive_set_error(&a->archive, en, ""Can't create '%s'"",
    a->name);
return (ARCHIVE_FAILED);
}

",1993,2043,[3],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_129.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
�, 滋�;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
滋�;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
滋�;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pn�; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
𥳐�;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    𥳐�;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
𥳐�;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tail�; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,"[63, 77, 87, 95]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_130.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_130.cpp," * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
char *dest, *src;
char separator = '\0';

dest = src = a->name;
if (*src == '\0') {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Invalid empty pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(a);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
                  ""Path is absolute"");
return (ARCHIVE_FAILED);
}

"," * is set) if the path is absolute.
 */
static int
cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
char *dest, *src;
char separator = '\0';

dest = src = path;
if (*src == '\0') {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Invalid empty "", ""pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(path);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Path is "", ""absolute"");
return (ARCHIVE_FAILED);
}

",2534,2807,"[10, 21]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_131.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_131.cpp,"} else if (src[1] == '.') {
if (src[2] == '/' || src[2] == '\0') {
/* Conditionally warn about '..' */
if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Path contains '..'"");
return (ARCHIVE_FAILED);
}
}
","} else if (src[1] == '.') {
if (src[2] == '/' || src[2] == '\0') {
/* Conditionally warn about '..' */
if (flags
    & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
fsobj_error(a_eno, a_estr,
    ARCHIVE_ERRNO_MISC,
    ""Path contains "", ""'..'"");
return (ARCHIVE_FAILED);
}
}
",2580,2854,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_132.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_132.cpp,"}
} else if (errno != ENOENT && errno != ENOTDIR) {
/* Stat failed? */
archive_set_error(&a->archive, errno, ""Can't test directory '%s'"", path);
return (ARCHIVE_FAILED);
} else if (slash != NULL) {
*slash = '\0';
","}
} else if (errno != ENOENT && errno != ENOTDIR) {
/* Stat failed? */
archive_set_error(&a->archive, errno,
    ""Can't test directory '%s'"", path);
return (ARCHIVE_FAILED);
} else if (slash != NULL) {
*slash = '\0';
",2707,2999,[3],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_133.cpp,"if (errno == ENOTSUP || errno == ENOSYS) {
if (!warning_done) {
warning_done = 1;
archive_set_error(&a->archive, errno,
    ""Cannot restore extended ""
    ""attributes on this file ""
    ""system"");
","if (errno == ENOTSUP || errno == ENOSYS) {
if (!warning_done) {
warning_done = 1;
archive_set_error(&a->archive,
    errno,
    ""Cannot restore extended ""
    ""attributes on this file ""
    ""system"");
",3753,4051,[3],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_134.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_134.cpp,"ret = ARCHIVE_WARN;
}
} else {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Invalid extended attribute encountered"");
ret = ARCHIVE_WARN;
}
","ret = ARCHIVE_WARN;
}
} else {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Invalid extended attribute encountered"");
ret = ARCHIVE_WARN;
}
",3764,4063,[3],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_135.cpp,"errno = 0;
#if HAVE_EXTATTR_SET_FD
if (a->fd >= 0)
e = extattr_set_fd(a->fd, namespace, name, value, size);
else
#endif
/* TODO: should we use extattr_set_link() instead? */
{
e = extattr_set_file(archive_entry_pathname(entry),
    namespace, name, value, size);
}
if (e != (int)size) {
if (errno == ENOTSUP || errno == ENOSYS) {
if (!warning_done) {
warning_done = 1;
archive_set_error(&a->archive, errno,
    ""Cannot restore extended ""
    ""attributes on this file ""
    ""system"");
","errno = 0;
#if HAVE_EXTATTR_SET_FD
if (a->fd >= 0)
e = extattr_set_fd(a->fd, namespace, name,
    value, size);
else
#endif
/* TODO: should we use extattr_set_link() instead? */
{
e = extattr_set_file(
    archive_entry_pathname(entry), namespace,
    name, value, size);
}
if (e != (int)size) {
if (errno == ENOTSUP || errno == ENOSYS) {
if (!warning_done) {
warning_done = 1;
archive_set_error(&a->archive,
    errno,
    ""Cannot restore extended ""
    ""attributes on this file ""
    ""system"");
",3808,4108,[15],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_cpio_newc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_71.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_71.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_136.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_136.cpp,"if (a->format_free != NULL)
(a->format_free)(a);

cpio = (struct cpio *)malloc(sizeof(*cpio));
if (cpio == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
return (ARCHIVE_FATAL);
}
memset(cpio, 0, sizeof(*cpio));
a->format_data = cpio;
a->format_name = ""cpio"";
a->format_options = archive_write_newc_options;
","if (a->format_free != NULL)
(a->format_free)(a);

cpio = (struct cpio *)calloc(1, sizeof(*cpio));
if (cpio == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
return (ARCHIVE_FATAL);
}
a->format_data = cpio;
a->format_name = ""cpio"";
a->format_options = archive_write_newc_options;
",116,116,[5],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_pax.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_72.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_72.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_137.cpp,"if (a->format_free != NULL)
(a->format_free)(a);

pax = (struct pax *)malloc(sizeof(*pax));
if (pax == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate pax data"");
return (ARCHIVE_FATAL);
}
memset(pax, 0, sizeof(*pax));
a->format_data = pax;
a->format_name = ""pax"";
a->format_options = archive_write_pax_options;
","if (a->format_free != NULL)
(a->format_free)(a);

pax = (struct pax *)calloc(1, sizeof(*pax));
if (pax == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate pax data"");
return (ARCHIVE_FATAL);
}
pax->flags = WRITE_LIBARCHIVE_XATTR | WRITE_SCHILY_XATTR;

a->format_data = pax;
a->format_name = ""pax"";
a->format_options = archive_write_pax_options;
",127,137,[5],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_ustar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_73.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_73.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_138.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_138.cpp,"return (ARCHIVE_FATAL);
}

ustar = (struct ustar *)malloc(sizeof(*ustar));
if (ustar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate ustar data"");
return (ARCHIVE_FATAL);
}
memset(ustar, 0, sizeof(*ustar));
a->format_data = ustar;
a->format_name = ""ustar"";
a->format_options = archive_write_ustar_options;
","return (ARCHIVE_FATAL);
}

ustar = (struct ustar *)calloc(1, sizeof(*ustar));
if (ustar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate ustar data"");
return (ARCHIVE_FATAL);
}
a->format_data = ustar;
a->format_name = ""ustar"";
a->format_options = archive_write_ustar_options;
",184,184,[5],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_v7tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_74.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_74.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_139.cpp,"return (ARCHIVE_FATAL);
}

v7tar = (struct v7tar *)malloc(sizeof(*v7tar));
if (v7tar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate v7tar data"");
return (ARCHIVE_FATAL);
}
memset(v7tar, 0, sizeof(*v7tar));
a->format_data = v7tar;
a->format_name = ""tar (non-POSIX)"";
a->format_options = archive_write_v7tar_options;
","return (ARCHIVE_FATAL);
}

v7tar = (struct v7tar *)calloc(1, sizeof(*v7tar));
if (v7tar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate v7tar data"");
return (ARCHIVE_FATAL);
}
a->format_data = v7tar;
a->format_name = ""tar (non-POSIX)"";
a->format_options = archive_write_v7tar_options;
",161,161,[5],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_140.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_140.cpp,"name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

if (a->tree != NULL) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't change dir"");
return (ARCHIVE_FAILED);
}
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
","name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
else if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't change dir to read extended attributes"");
return (ARCHIVE_FAILED);
}
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
",302,321,"[4, 11]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_141.cpp,"const char *path;
ssize_t list_size;

path = archive_entry_sourcepath(entry);
if (path == NULL)
path = archive_entry_pathname(entry);

if (*fd < 0 && a->tree != NULL) {
if (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)
*fd = a->open_on_current_dir(a->tree, path,
O_RDONLY | O_NONBLOCK);
if (*fd < 0) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't access %s"", path);
return (ARCHIVE_FAILED);
}
}
}

","const char *path;
ssize_t list_size;

path = NULL;

if (*fd < 0) {
path = archive_entry_sourcepath(entry);
if (path == NULL || (a->tree != NULL &&
    a->tree_enter_working_dir(a->tree) != 0))
path = archive_entry_pathname(entry);
if (path == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Couldn't determine file path to read ""
    ""extended attributes"");
return (ARCHIVE_WARN);
}
if (a->tree != NULL && (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)) {
*fd = a->open_on_current_dir(a->tree,
    path, O_RDONLY | O_NONBLOCK);
}
}

",772,1486,[14],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_142.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_142.cpp,"const char *path;
int namespace = EXTATTR_NAMESPACE_USER;

path = archive_entry_sourcepath(entry);
if (path == NULL)
path = archive_entry_pathname(entry);

if (*fd < 0 && a->tree != NULL) {
if (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)
*fd = a->open_on_current_dir(a->tree, path,
O_RDONLY | O_NONBLOCK);
if (*fd < 0) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't access %s"", path);
return (ARCHIVE_FAILED);
}
}
}

","const char *path;
int namespace = EXTATTR_NAMESPACE_USER;

path = NULL;

if (*fd < 0) {
path = archive_entry_sourcepath(entry);
if (path == NULL || (a->tree != NULL &&
    a->tree_enter_working_dir(a->tree) != 0))
path = archive_entry_pathname(entry);
if (path == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Couldn't determine file path to read ""
    ""extended attributes"");
return (ARCHIVE_WARN);
}
if (a->tree != NULL && (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)) {
*fd = a->open_on_current_dir(a->tree,
    path, O_RDONLY | O_NONBLOCK);
}
}

",932,1645,[14],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_143.cpp,"if (path == NULL)
path = archive_entry_pathname(entry);

if (pathconf(path, _PC_MIN_HOLE_SIZE) <= 0)
return (ARCHIVE_OK);
*fd = open(path, O_RDONLY | O_NONBLOCK | O_CLOEXEC);
if (*fd < 0) {
archive_set_error(&a->archive, errno,
","if (path == NULL)
path = archive_entry_pathname(entry);

#ifdef _PC_MIN_HOLE_SIZE
if (pathconf(path, _PC_MIN_HOLE_SIZE) <= 0)
return (ARCHIVE_OK);
#endif
*fd = open(path, O_RDONLY | O_NONBLOCK | O_CLOEXEC);
if (*fd < 0) {
archive_set_error(&a->archive, errno,
",1180,1907,[7],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_144.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_144.cpp,"r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",938,938,[2],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_145.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_145.cpp,"r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",1041,1041,[2],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_146.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_146.cpp,"r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",1067,1067,[2],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_147.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_147.cpp,"archive_set_error(&a->archive, errno, ""statvfs failed"");
return (ARCHIVE_FAILED);
} else if (xr == 1) {
/* Usuall come here unless NetBSD supports _PC_REC_XFER_ALIGN
 * for pathconf() function. */
t->current_filesystem->xfer_align = sfs.f_frsize;
t->current_filesystem->max_xfer_size = -1;
","archive_set_error(&a->archive, errno, ""statvfs failed"");
return (ARCHIVE_FAILED);
} else if (xr == 1) {
/* Usually come here unless NetBSD supports _PC_REC_XFER_ALIGN
 * for pathconf() function. */
t->current_filesystem->xfer_align = sfs.f_frsize;
t->current_filesystem->max_xfer_size = -1;
",1643,1656,[0],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_148.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_148.cpp,"r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",803,802,[2],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_149.cpp,"r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",875,874,[2],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_150.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_150.cpp,"r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",901,900,[2],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_151.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_151.cpp,"#else
archive_set_error(a, ARCHIVE_ERRNO_MISC,
    ""Unexpedted operation in archive_read_open_filename"");
return (ARCHIVE_FATAL);
#endif
}
if (fstat(fd, &st) != 0) {
","#else
archive_set_error(a, ARCHIVE_ERRNO_MISC,
    ""Unexpedted operation in archive_read_open_filename"");
goto fail;
#endif
}
if (fstat(fd, &st) != 0) {
",277,277,[1],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_152.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_152.cpp,"else
archive_set_error(a, errno, ""Can't stat '%s'"",
    filename);
return (ARCHIVE_FATAL);
}

/*
","else
archive_set_error(a, errno, ""Can't stat '%s'"",
    filename);
goto fail;
}

/*
",287,287,[1],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_153.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_153.cpp,"mine->block_size = new_block_size;
}
buffer = malloc(mine->block_size);
if (mine == NULL || buffer == NULL) {
archive_set_error(a, ENOMEM, ""No memory"");
free(mine);
free(buffer);
return (ARCHIVE_FATAL);
}
mine->buffer = buffer;
mine->fd = fd;
","mine->block_size = new_block_size;
}
buffer = malloc(mine->block_size);
if (buffer == NULL) {
archive_set_error(a, ENOMEM, ""No memory"");
goto fail;
}
mine->buffer = buffer;
mine->fd = fd;
",356,356,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_lz4.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_79.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_79.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_154.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_154.cpp,"#endif
}

/* Check if an error happend in decompression process. */
if (uncompressed_size < 0) {
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC, ""lz4 decompression failed"");
","#endif
}

/* Check if an error occurred in the decompression process. */
if (uncompressed_size < 0) {
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC, ""lz4 decompression failed"");
",595,595,[5],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_80.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_80.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_155.cpp,"    &state->child_stdout);
if (child == -1) {
free(state->out_buf);
free(state);
archive_set_error(&self->archive->archive, EINVAL,
    ""Can't initialize filter; unable to run program \""%s\"""",
","    &state->child_stdout);
if (child == -1) {
free(state->out_buf);
archive_string_free(&state->description);
free(state);
archive_set_error(&self->archive->archive, EINVAL,
    ""Can't initialize filter; unable to run program \""%s\"""",
",430,430,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_156.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_156.cpp,"bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
return (ARCHIVE_OK);
#elif HAVE_LZMADEC_H && HAVE_LIBLZMADEC
return (ARCHIVE_OK);
#else
archive_set_error(_a, ARCHIVE_ERRNO_MISC,
    ""Using external lzma program for lzma decompression"");
","bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
return (ARCHIVE_OK);
#else
archive_set_error(_a, ARCHIVE_ERRNO_MISC,
    ""Using external lzma program for lzma decompression"");
",178,163,[6],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,"[27, 58, 64, 70, 103, 121, 127, 158]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_158.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_158.cpp,"archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_ar"");

ar = (struct ar *)malloc(sizeof(*ar));
if (ar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate ar data"");
return (ARCHIVE_FATAL);
}
memset(ar, 0, sizeof(*ar));
ar->strtab = NULL;

r = __archive_read_register_format(a,
","archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_ar"");

ar = (struct ar *)calloc(1, sizeof(*ar));
if (ar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate ar data"");
return (ARCHIVE_FATAL);
}
ar->strtab = NULL;

r = __archive_read_register_format(a,
",104,104,[5],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_159.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_159.cpp,"archive_entry_set_filetype(entry, AE_IFREG);
/* Get the size of the filename table. */
number = ar_atol10(h  AR_size_offset, AR_size_size);
if (number > SIZE_MAX) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Filename table too large"");
return (ARCHIVE_FATAL);
","archive_entry_set_filetype(entry, AE_IFREG);
/* Get the size of the filename table. */
number = ar_atol10(h  AR_size_offset, AR_size_size);
if (number > SIZE_MAX || number > 1024 * 1024 * 1024) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Filename table too large"");
return (ARCHIVE_FATAL);
",260,259,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_160.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_160.cpp," * If we can't look up the real name, warn and return
 * the entry with the wrong name.
 */
if (ar->strtab == NULL || number > ar->strtab_size) {
archive_set_error(&a->archive, EINVAL,
    ""Can't find long filename for GNU/SVR4 archive entry"");
archive_entry_copy_pathname(entry, filename);
"," * If we can't look up the real name, warn and return
 * the entry with the wrong name.
 */
if (ar->strtab == NULL || number >= ar->strtab_size) {
archive_set_error(&a->archive, EINVAL,
    ""Can't find long filename for GNU/SVR4 archive entry"");
archive_entry_copy_pathname(entry, filename);
",316,315,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_cpio.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_83.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_83.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_161.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_161.cpp,"    ""Rejecting malformed cpio archive: symlink contents exceed 1 megabyte"");
return (ARCHIVE_FATAL);
}
h = __archive_read_ahead(a,
(size_t)cpio->entry_bytes_remaining, NULL);
if (h == NULL)
return (ARCHIVE_FATAL);
if (archive_entry_copy_symlink_l(entry, (const char *)h,
    (size_t)cpio->entry_bytes_remaining, sconv) != 0) {
if (errno == ENOMEM) {
archive_set_error(&a->archive, ENOMEM,
","    ""Rejecting malformed cpio archive: symlink contents exceed 1 megabyte"");
return (ARCHIVE_FATAL);
}
hl = __archive_read_ahead(a,
(size_t)cpio->entry_bytes_remaining, NULL);
if (hl == NULL)
return (ARCHIVE_FATAL);
if (archive_entry_copy_symlink_l(entry, (const char *)hl,
    (size_t)cpio->entry_bytes_remaining, sconv) != 0) {
if (errno == ENOMEM) {
archive_set_error(&a->archive, ENOMEM,
",406,406,[10],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_162.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_162.cpp,"if ((file->utf16be_name = malloc(name_len)) == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""No memory for file name"");
return (NULL);
}
memcpy(file->utf16be_name, p, name_len);
file->utf16be_bytes = name_len;
","if ((file->utf16be_name = malloc(name_len)) == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""No memory for file name"");
goto fail;
}
memcpy(file->utf16be_name, p, name_len);
file->utf16be_bytes = name_len;
",1864,1864,[1],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_163.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_163.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE"");
return (NULL);
}
/*
 * Sanity check: file does not have ""CL"" extension.
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE"");
goto fail;
}
/*
 * Sanity check: file does not have ""CL"" extension.
",1990,1988,[0],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_164.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_164.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE and CL"");
return (NULL);
}
/*
 * Sanity check: The file type must be a directory.
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE and CL"");
goto fail;
}
/*
 * Sanity check: The file type must be a directory.
",1999,1997,[0],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_165.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_165.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE"");
return (NULL);
}
} else if (parent != NULL && parent->rr_moved)
file->rr_moved_has_re_only = 0;
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE"");
goto fail;
}
} else if (parent != NULL && parent->rr_moved)
file->rr_moved_has_re_only = 0;
",2008,2006,[0],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_166.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_166.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
/*
 * Sanity check: The file type must be a regular file.
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
/*
 * Sanity check: The file type must be a regular file.
",2022,2020,[0],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_167.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_167.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
parent->subdirs�;
/* Overwrite an offset and a number of this ""CL"" entry
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
parent->subdirs�;
/* Overwrite an offset and a number of this ""CL"" entry
",2031,2029,[0],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_168.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_168.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
}
if (file->cl_offset == file->offset ||
    parent->rr_moved) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
}
}
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
}
if (file->cl_offset == file->offset ||
    parent->rr_moved) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
}
}
",2049,2047,"[0, 8]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_85.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_85.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_169.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_169.cpp,"/* Get a real compressed file size. */
lha->compsize -= extdsize - 2;

if (sum_calculated != headersum) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""LHa header sum error"");
","/* Get a real compressed file size. */
lha->compsize -= extdsize - 2;

if (lha->compsize < 0)
goto invalid;/* Invalid compressed file size */

if (sum_calculated != headersum) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""LHa header sum error"");
",924,924,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_170.cpp,"archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_mtree"");

mtree = (struct mtree *)malloc(sizeof(*mtree));
if (mtree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate mtree data"");
return (ARCHIVE_FATAL);
}
memset(mtree, 0, sizeof(*mtree));
mtree->fd = -1;

r = __archive_read_register_format(a, mtree, ""mtree"",
","archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_mtree"");

mtree = (struct mtree *)calloc(1, sizeof(*mtree));
if (mtree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate mtree data"");
return (ARCHIVE_FATAL);
}
mtree->fd = -1;

r = __archive_read_register_format(a, mtree, ""mtree"",
",223,229,[5],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_171.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_171.cpp,"    struct mtree_option **global, const char *line, ssize_t line_len,
    struct mtree_entry **last_entry, int is_form_d)
{
struct mtree_entry *entry;
struct mtree_option *iter;
const char *next, *eq, *name, *end;
size_t name_len, len;
int r, i;

if ((entry = malloc(sizeof(*entry))) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
","    struct mtree_option **global, const char *line, ssize_t line_len,
    struct mtree_entry **last_entry, int is_form_d)
{
struct mtree_entry *entry, *ht_iter;
struct mtree_option *iter;
const char *next, *eq, *name, *end;
size_t name_len, len;
int r, i;
unsigned int ht_idx;

if ((entry = malloc(sizeof(*entry))) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
",853,867,[10],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_87.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_87.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_172.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_172.cpp,"  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,
                      ""archive_read_support_format_rar"");

  rar = (struct rar *)malloc(sizeof(*rar));
  if (rar == NULL)
  {
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }
  memset(rar, 0, sizeof(*rar));

/*
 * Until enough data has been read, we cannot tell about
","  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,
                      ""archive_read_support_format_rar"");

  rar = (struct rar *)calloc(sizeof(*rar), 1);
  if (rar == NULL)
  {
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }

/*
 * Until enough data has been read, we cannot tell about
",647,647,[6],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_173.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_173.cpp,"tar->sparse_gnu_pending = 0;
/* Read initial sparse map. */
bytes_read = gnu_sparse_10_read(a, tar, unconsumed);
tar->entry_bytes_remaining -= bytes_read;
if (bytes_read < 0)
return ((int)bytes_read);
} else {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
","tar->sparse_gnu_pending = 0;
/* Read initial sparse map. */
bytes_read = gnu_sparse_10_read(a, tar, unconsumed);
if (bytes_read < 0)
return ((int)bytes_read);
tar->entry_bytes_remaining -= bytes_read;
} else {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
",793,847,[7],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_174.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_174.cpp,"switch ((int)type & ~0777777) {
case 01000000:
/* POSIX.1e ACL */
break;
case 03000000:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Solaris NFSv4 ACLs not supported"");
return (ARCHIVE_WARN);
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Malformed Solaris ACL attribute (unsupported type %o)"",
","switch ((int)type & ~0777777) {
case 01000000:
/* POSIX.1e ACL */
acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;
break;
case 03000000:
/* NFSv4 ACL */
acl_type = ARCHIVE_ENTRY_ACL_TYPE_NFS4;
break;
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Malformed Solaris ACL attribute (unsupported type %o)"",
",935,989,"[5, 9]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_175.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_175.cpp,"return (ARCHIVE_FATAL);
}
archive_strncpy(&(tar->localname), acl, p - acl);
err = archive_acl_parse_l(archive_entry_acl(entry),
    tar->localname.s, ARCHIVE_ENTRY_ACL_TYPE_ACCESS, tar->sconv_acl);
if (err != ARCHIVE_OK) {
if (errno == ENOMEM) {
archive_set_error(&a->archive, ENOMEM,
","return (ARCHIVE_FATAL);
}
archive_strncpy(&(tar->localname), acl, p - acl);
err = archive_acl_from_text_l(archive_entry_acl(entry),
    tar->localname.s, acl_type, tar->sconv_acl);
if (err != ARCHIVE_OK) {
if (errno == ENOMEM) {
archive_set_error(&a->archive, ENOMEM,
",968,1023,[7],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_176.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_176.cpp,"if (tar->entry_bytes_remaining < 0) {
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry has negative size?"");
err = ARCHIVE_WARN;
}
tar->realsize = tar->entry_bytes_remaining;
archive_entry_set_size(entry, tar->entry_bytes_remaining);
","if (tar->entry_bytes_remaining < 0) {
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry has negative size"");
return (ARCHIVE_FATAL);
}
if (tar->entry_bytes_remaining == INT64_MAX) {
/* Note: tar_atol returns INT64_MAX on overflow */
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry size overflow"");
return (ARCHIVE_FATAL);
}
tar->realsize = tar->entry_bytes_remaining;
archive_entry_set_size(entry, tar->entry_bytes_remaining);
",1128,1183,[2],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_177.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_177.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,"[17, 22, 41, 46]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_178.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_178.cpp,"{
struct sparse_block *p;

p = (struct sparse_block *)malloc(sizeof(*p));
if (p == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
return (ARCHIVE_FATAL);
}
memset(p, 0, sizeof(*p));
if (tar->sparse_last != NULL)
tar->sparse_last->next = p;
else
","{
struct sparse_block *p;

p = (struct sparse_block *)calloc(1, sizeof(*p));
if (p == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
return (ARCHIVE_FATAL);
}
if (tar->sparse_last != NULL)
tar->sparse_last->next = p;
else
",2116,2227,[5],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_179.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_179.cpp,"archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_warc"");

if ((w = malloc(sizeof(*w))) == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate warc data"");
return (ARCHIVE_FATAL);
}
memset(w, 0, sizeof(*w));

r = __archive_read_register_format(
a, w, ""warc"",
","archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_warc"");

if ((w = calloc(1, sizeof(*w))) == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate warc data"");
return (ARCHIVE_FATAL);
}

r = __archive_read_register_format(
a, w, ""warc"",
",146,146,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_180.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_180.cpp,"&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {
/* nawww, I wish they promised backward compatibility
 * anyhoo, in their infinite wisdom the 28500 guys might
 * come up with something we can't possibly handle so
 * best end things here */
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version"");
return (ARCHIVE_FATAL);
} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
","&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
}
ver = _warc_rdver(buf, eoh - buf);
/* we currently support WARC 0.12 to 1.0 */
if (ver == 0U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Invalid record version"");
return (ARCHIVE_FATAL);
} else if (ver < 1200U || ver > 10000U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version: %u.%u"",
ver / 10000, (ver % 10000) / 100);
return (ARCHIVE_FATAL);
}
cntlen = _warc_rdlen(buf, eoh - buf);
if (cntlen < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
}
rtime = _warc_rdrtm(buf, eoh - buf);
if (rtime == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
",255,254,"[8, 15, 22]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_181.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_181.cpp,"if (ver != w->pver) {
/* stringify this entry's version */
archive_string_sprintf(&w->sver,
""WARC/%u.%u"", ver / 10000, ver % 10000);
/* remember the version */
w->pver = ver;
}
","if (ver != w->pver) {
/* stringify this entry's version */
archive_string_sprintf(&w->sver,
""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100);
/* remember the version */
w->pver = ver;
}
",285,293,[2],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_182.cpp,"xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
if (xar->lzstream_valid)
lzmadec_end(&(xar->lzstream));
r = lzmadec_init(&(xar->lzstream));
if (r != LZMADEC_OK) {
switch (r) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing ""
    ""compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&a->archive,
    ENOMEM,
    ""Internal error initializing ""
    ""compression library: ""
    ""out of memory"");
break;
}
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 1;
xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
","xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
",1526,1524,"[11, 18]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_183.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_183.cpp,"*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
xar->lzstream.avail_in = avail_in;
xar->lzstream.next_out = (unsigned char *)outbuff;
xar->lzstream.avail_out = avail_out;
r = lzmadec_decode(&(xar->lzstream), 0);
switch (r) {
case LZMADEC_STREAM_END: /* Found end of stream. */
switch (lzmadec_end(&(xar->lzstream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up lzmadec decompressor"");
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 0;
/* FALLTHROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""lzmadec decompression failed(%d)"",
    r);
return (ARCHIVE_FATAL);
}
*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
case LZMA:
#endif
case XZ:
#endif
case NONE:
","*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
case LZMA:
case XZ:
#endif
case NONE:
",1685,1653,"[16, 26]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_184.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_184.cpp," *id1눬떭�  id2눬떭� ...
 *  triplets.  id and size are 2 bytes each.
 */
static void
process_extra(const char *p, size_t extra_length, struct zip_entry* zip_entry)
{
unsigned offset = 0;

while (offset < extra_length - 4) {
unsigned short headerid = archive_le16dec(p  offset);
unsigned short datasize = archive_le16dec(p  offset  2);

offset = 4;
if (offset  datasize > extra_length) {
break;
}
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%04x, length %d\n"",
"," *id1눬떭�  id2눬떭� ...
 *  triplets.  id and size are 2 bytes each.
 */
static int
process_extra(struct archive_read *a, const char *p, size_t extra_length, struct zip_entry* zip_entry)
{
unsigned offset = 0;

if (extra_length == 0) {
return ARCHIVE_OK;
}

if (extra_length < 4) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Too-small extra data: Need at least 4 bytes, but only found %d bytes"", (int)extra_length);
return ARCHIVE_FAILED;
}
while (offset <= extra_length - 4) {
unsigned short headerid = archive_le16dec(p  offset);
unsigned short datasize = archive_le16dec(p  offset  2);

offset = 4;
if (offset  datasize > extra_length) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Extra data overflow: Need %d bytes but only found %d bytes"",
    (int)datasize, (int)(extra_length - offset));
return ARCHIVE_FAILED;
}
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%04x, length %d\n"",
",418,418,[17],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_185.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_185.cpp,"}
offset = datasize;
}
#ifdef DEBUG
if (offset != extra_length)
{
fprintf(stderr,
    ""Extra data field contents do not match reported size!\n"");
}
#endif
}

/*
","}
offset = datasize;
}
if (offset != extra_length) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Malformed extra data: Consumed %d bytes of %d bytes"",
    (int)offset, (int)extra_length);
return ARCHIVE_FAILED;
}
return ARCHIVE_OK;
}

/*
",715,739,[6],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_186.cpp,"    && bytes_avail > zip->entry_bytes_remaining) {
bytes_avail = (ssize_t)zip->entry_bytes_remaining;
}
if (bytes_avail <= 0) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file body"");
return (ARCHIVE_FATAL);
","    && bytes_avail > zip->entry_bytes_remaining) {
bytes_avail = (ssize_t)zip->entry_bytes_remaining;
}
if (bytes_avail < 0) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file body"");
return (ARCHIVE_FATAL);
",1293,1332,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_187.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_187.cpp,"case 0x6720:/* Blowfish */
case 0x6721:/* Twofish */
case 0x6801:/* RC4 */
/* Suuported encryption algorithm. */
break;
default:
archive_set_error(&a->archive,
","case 0x6720:/* Blowfish */
case 0x6721:/* Twofish */
case 0x6801:/* RC4 */
/* Supported encryption algorithm. */
break;
default:
archive_set_error(&a->archive,
",1500,1548,[6],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_188.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_188.cpp,"__archive_read_consume(a, 4);

/*return (ARCHIVE_OK);
 * This is not fully implemnted yet.*/
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Encrypted file is unsupported"");
return (ARCHIVE_FAILED);
","__archive_read_consume(a, 4);

/*return (ARCHIVE_OK);
 * This is not fully implemented yet.*/
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Encrypted file is unsupported"");
return (ARCHIVE_FAILED);
",1609,1657,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_189.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_189.cpp,"if (a->restore_pwd >= 0) {
r = fchdir(a->restore_pwd);
if (r != 0) {
archive_set_error(&a->archive, errno, ""chdir() failure"");
ret = ARCHIVE_FATAL;
}
close(a->restore_pwd);
","if (a->restore_pwd >= 0) {
r = fchdir(a->restore_pwd);
if (r != 0) {
archive_set_error(&a->archive, errno,
    ""chdir() failure"");
ret = ARCHIVE_FATAL;
}
close(a->restore_pwd);
",637,669,[3],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_190.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_190.cpp,"bytes_to_write = size;
/* Seek if necessary to the specified offset. */
if (a->offset < a->fd_offset) {
/* Can't support backword move. */
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Seek failed"");
return (ARCHIVE_FATAL);
","bytes_to_write = size;
/* Seek if necessary to the specified offset. */
if (a->offset < a->fd_offset) {
/* Can't support backward move. */
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Seek failed"");
return (ARCHIVE_FATAL);
",1402,1437,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_191.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_191.cpp,"return (r);
if ((size_t)r < size) {
archive_set_error(&a->archive, 0,
    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);
return (ARCHIVE_WARN);
}
#if ARCHIVE_VERSION_NUMBER < 3999000
","return (r);
if ((size_t)r < size) {
archive_set_error(&a->archive, 0,
    ""Too much data: Truncating file at %ju bytes"",
    (uintmax_t)a->filesize);
return (ARCHIVE_WARN);
}
#if ARCHIVE_VERSION_NUMBER < 3999000
",1468,1503,[2],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_192.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_192.cpp,"
if (en) {
/* Everything failed; give up here. */
archive_set_error(&a->archive, en, ""Can't create '%s'"",
    a->name);
return (ARCHIVE_FAILED);
}

","
if (en) {
/* Everything failed; give up here. */
if ((&a->archive)->error == NULL)
archive_set_error(&a->archive, en, ""Can't create '%s'"",
    a->name);
return (ARCHIVE_FAILED);
}

",1993,2043,[3],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_193.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_193.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
�, 滋�;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
滋�;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
滋�;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pn�; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
𥳐�;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    𥳐�;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
𥳐�;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tail�; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,"[63, 77, 87, 95]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_194.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_194.cpp," * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
char *dest, *src;
char separator = '\0';

dest = src = a->name;
if (*src == '\0') {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Invalid empty pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(a);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
                  ""Path is absolute"");
return (ARCHIVE_FAILED);
}

"," * is set) if the path is absolute.
 */
static int
cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
char *dest, *src;
char separator = '\0';

dest = src = path;
if (*src == '\0') {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Invalid empty "", ""pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(path);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Path is "", ""absolute"");
return (ARCHIVE_FAILED);
}

",2534,2807,"[10, 21]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_195.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_195.cpp,"} else if (src[1] == '.') {
if (src[2] == '/' || src[2] == '\0') {
/* Conditionally warn about '..' */
if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Path contains '..'"");
return (ARCHIVE_FAILED);
}
}
","} else if (src[1] == '.') {
if (src[2] == '/' || src[2] == '\0') {
/* Conditionally warn about '..' */
if (flags
    & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
fsobj_error(a_eno, a_estr,
    ARCHIVE_ERRNO_MISC,
    ""Path contains "", ""'..'"");
return (ARCHIVE_FAILED);
}
}
",2580,2854,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_196.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_196.cpp,"}
} else if (errno != ENOENT && errno != ENOTDIR) {
/* Stat failed? */
archive_set_error(&a->archive, errno, ""Can't test directory '%s'"", path);
return (ARCHIVE_FAILED);
} else if (slash != NULL) {
*slash = '\0';
","}
} else if (errno != ENOENT && errno != ENOTDIR) {
/* Stat failed? */
archive_set_error(&a->archive, errno,
    ""Can't test directory '%s'"", path);
return (ARCHIVE_FAILED);
} else if (slash != NULL) {
*slash = '\0';
",2707,2999,[3],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_197.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_197.cpp,"if (errno == ENOTSUP || errno == ENOSYS) {
if (!warning_done) {
warning_done = 1;
archive_set_error(&a->archive, errno,
    ""Cannot restore extended ""
    ""attributes on this file ""
    ""system"");
","if (errno == ENOTSUP || errno == ENOSYS) {
if (!warning_done) {
warning_done = 1;
archive_set_error(&a->archive,
    errno,
    ""Cannot restore extended ""
    ""attributes on this file ""
    ""system"");
",3753,4051,[3],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_198.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_198.cpp,"ret = ARCHIVE_WARN;
}
} else {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Invalid extended attribute encountered"");
ret = ARCHIVE_WARN;
}
","ret = ARCHIVE_WARN;
}
} else {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Invalid extended attribute encountered"");
ret = ARCHIVE_WARN;
}
",3764,4063,[3],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_199.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_199.cpp,"errno = 0;
#if HAVE_EXTATTR_SET_FD
if (a->fd >= 0)
e = extattr_set_fd(a->fd, namespace, name, value, size);
else
#endif
/* TODO: should we use extattr_set_link() instead? */
{
e = extattr_set_file(archive_entry_pathname(entry),
    namespace, name, value, size);
}
if (e != (int)size) {
if (errno == ENOTSUP || errno == ENOSYS) {
if (!warning_done) {
warning_done = 1;
archive_set_error(&a->archive, errno,
    ""Cannot restore extended ""
    ""attributes on this file ""
    ""system"");
","errno = 0;
#if HAVE_EXTATTR_SET_FD
if (a->fd >= 0)
e = extattr_set_fd(a->fd, namespace, name,
    value, size);
else
#endif
/* TODO: should we use extattr_set_link() instead? */
{
e = extattr_set_file(
    archive_entry_pathname(entry), namespace,
    name, value, size);
}
if (e != (int)size) {
if (errno == ENOTSUP || errno == ENOSYS) {
if (!warning_done) {
warning_done = 1;
archive_set_error(&a->archive,
    errno,
    ""Cannot restore extended ""
    ""attributes on this file ""
    ""system"");
",3808,4108,[15],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_set_format_cpio_newc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_200.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_200.cpp,"if (a->format_free != NULL)
(a->format_free)(a);

cpio = (struct cpio *)malloc(sizeof(*cpio));
if (cpio == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
return (ARCHIVE_FATAL);
}
memset(cpio, 0, sizeof(*cpio));
a->format_data = cpio;
a->format_name = ""cpio"";
a->format_options = archive_write_newc_options;
","if (a->format_free != NULL)
(a->format_free)(a);

cpio = (struct cpio *)calloc(1, sizeof(*cpio));
if (cpio == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
return (ARCHIVE_FATAL);
}
a->format_data = cpio;
a->format_name = ""cpio"";
a->format_options = archive_write_newc_options;
",116,116,[5],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_set_format_pax.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_94.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_94.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_201.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_201.cpp,"if (a->format_free != NULL)
(a->format_free)(a);

pax = (struct pax *)malloc(sizeof(*pax));
if (pax == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate pax data"");
return (ARCHIVE_FATAL);
}
memset(pax, 0, sizeof(*pax));
a->format_data = pax;
a->format_name = ""pax"";
a->format_options = archive_write_pax_options;
","if (a->format_free != NULL)
(a->format_free)(a);

pax = (struct pax *)calloc(1, sizeof(*pax));
if (pax == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate pax data"");
return (ARCHIVE_FATAL);
}
pax->flags = WRITE_LIBARCHIVE_XATTR | WRITE_SCHILY_XATTR;

a->format_data = pax;
a->format_name = ""pax"";
a->format_options = archive_write_pax_options;
",127,137,[5],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_set_format_ustar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_95.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_95.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_202.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_202.cpp,"return (ARCHIVE_FATAL);
}

ustar = (struct ustar *)malloc(sizeof(*ustar));
if (ustar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate ustar data"");
return (ARCHIVE_FATAL);
}
memset(ustar, 0, sizeof(*ustar));
a->format_data = ustar;
a->format_name = ""ustar"";
a->format_options = archive_write_ustar_options;
","return (ARCHIVE_FATAL);
}

ustar = (struct ustar *)calloc(1, sizeof(*ustar));
if (ustar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate ustar data"");
return (ARCHIVE_FATAL);
}
a->format_data = ustar;
a->format_name = ""ustar"";
a->format_options = archive_write_ustar_options;
",184,184,[5],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_set_format_v7tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_96.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_96.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_203.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_203.cpp,"return (ARCHIVE_FATAL);
}

v7tar = (struct v7tar *)malloc(sizeof(*v7tar));
if (v7tar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate v7tar data"");
return (ARCHIVE_FATAL);
}
memset(v7tar, 0, sizeof(*v7tar));
a->format_data = v7tar;
a->format_name = ""tar (non-POSIX)"";
a->format_options = archive_write_v7tar_options;
","return (ARCHIVE_FATAL);
}

v7tar = (struct v7tar *)calloc(1, sizeof(*v7tar));
if (v7tar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate v7tar data"");
return (ARCHIVE_FATAL);
}
a->format_data = v7tar;
a->format_name = ""tar (non-POSIX)"";
a->format_options = archive_write_v7tar_options;
",161,161,[5],[]
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_97.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_97.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_204.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_204.cpp,"        *fptr = 0;

        if(width >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr = len;
          left -= len;
        }
        if(prec >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr = len;
","        *fptr = 0;

        if(width >= 0) {
          if(width >= (long)sizeof(work))
            width = sizeof(work)-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr = len;
          left -= len;
        }
        if(prec >= 0) {
          /* for each digit in the integer part, we can have one less
             precision */
          size_t maxprec = sizeof(work) - 2;
          double val = p->data.dnum;
          while(val >= 10.0) {
            val /= 10;
            maxprec--;
          }

          if(prec > (long)maxprec)
            prec = (long)maxprec-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr = len;
",913,913,"[4, 10]",[]
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/socks_gssapi.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_205.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_205.cpp,"
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.value = malloc(strlen(serviceptr));
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr);
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(strlen(serviceptr) 닚�(conn->proxy.name)�);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr) 닚�(conn->proxy.name)�;
    snprintf(service.value, service.length�, ""%s@%s"",
             serviceptr, conn->proxy.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
","
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.length = serviceptr_length;
    service.value = malloc(service.length);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(serviceptr_length 
                           strlen(conn->socks_proxy.host.name)�);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = serviceptr_length  strlen(conn->socks_proxy.host.name)�;
    snprintf(service.value, service.length�, ""%s@%s"",
             serviceptr, conn->socks_proxy.host.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
",134,135,[17],[]
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/telnet.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_99.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_99.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_206.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_206.cpp,"  struct TELNET *tn = (struct TELNET *)data->req.protop;

  printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn)�);
  switch (CURL_SB_GET(tn)) {
    case CURL_TELOPT_TTYPE:
      len = strlen(tn->subopt_ttype)  4  2;
      snprintf((char *)temp, sizeof(temp),
","  struct TELNET *tn = (struct TELNET *)data->req.protop;

  printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn)�);
  switch(CURL_SB_GET(tn)) {
    case CURL_TELOPT_TTYPE:
      len = strlen(tn->subopt_ttype)  4  2;
      snprintf((char *)temp, sizeof(temp),
",935,935,[6],[]
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_100.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_100.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_207.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_207.cpp,"    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
","    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
",387,388,[9],[]
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/vtls/darwinssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_101.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_101.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_208.cpp,"    else {
      CURLcode result;
      ssl_sessionid =
        aprintf(""%s:%d:%d:%s:%hu"", data->set.str[STRING_SSL_CAFILE],
                data->set.ssl.verifypeer, data->set.ssl.verifyhost,
                conn->host.name, conn->remote_port);
      ssl_sessionid_len = strlen(ssl_sessionid);

      err = SSLSetPeerID(connssl->ssl_ctx, ssl_sessionid, ssl_sessionid_len);
","    else {
      CURLcode result;
      ssl_sessionid =
        aprintf(""%s:%d:%d:%s:%hu"", ssl_cafile,
                verifypeer, SSL_CONN_CONFIG(verifyhost), hostname, port);
      ssl_sessionid_len = strlen(ssl_sessionid);

      err = SSLSetPeerID(connssl->ssl_ctx, ssl_sessionid, ssl_sessionid_len);
",1504,1563,[3],[]
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_102.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_102.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_209.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_209.cpp,"    else
      tls_rt_name = """";

    msg_type = *(char*)buf;
    msg_name = ssl_msg_type(ssl_ver, msg_type);

    txt_len = snprintf(ssl_buf, sizeof(ssl_buf), ""%s (%s), %s, %s (%d):\n"",
","    else
      tls_rt_name = """";

    msg_type = *(char *)buf;
    msg_name = ssl_msg_type(ssl_ver, msg_type);

    txt_len = snprintf(ssl_buf, sizeof(ssl_buf), ""%s (%s), %s, %s (%d):\n"",
",1571,1567,[6],[]
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_102.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_102.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_210.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_210.cpp,"
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
","
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          *certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
",2198,2255,[4],[]
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/x509asn1.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_103.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_103.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_211.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_211.cpp,"  return strdup(*beg? ""TRUE"": ""FALSE"");
}

static const char * octet2str(const char * beg, const char * end)
{
  size_t n = end - beg;
  char * buf;

  /* Convert an ASN.1 octet string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */

  buf = malloc(3 * n  1);
  if(buf)
    for(n = 0; beg < end; n = 3)
      snprintf(buf  n, 4, ""%02x:"", *(const unsigned char *) beg�);
  return buf;
}

static const char * bit2str(const char * beg, const char * end)
{
  /* Convert an ASN.1 bit string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */
","  return strdup(*beg? ""TRUE"": ""FALSE"");
}

static const char *octet2str(const char *beg, const char *end)
{
  size_t n = end - beg;
  char *buf = NULL;

  /* Convert an ASN.1 octet string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */

  if(n <= (CURL_SIZE_T_MAX - 1) / 3) {
    buf = malloc(3 * n  1);
    if(buf)
      for(n = 0; beg < end; n = 3)
        snprintf(buf  n, 4, ""%02x:"", *(const unsigned char *) beg�);
  }
  return buf;
}

static const char *bit2str(const char *beg, const char *end)
{
  /* Convert an ASN.1 bit string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */
",195,198,[14],[]
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_104.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_104.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_212.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_212.cpp,"        *fptr = 0;

        if(width >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr = len;
          left -= len;
        }
        if(prec >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr = len;
","        *fptr = 0;

        if(width >= 0) {
          if(width >= (long)sizeof(work))
            width = sizeof(work)-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr = len;
          left -= len;
        }
        if(prec >= 0) {
          /* for each digit in the integer part, we can have one less
             precision */
          size_t maxprec = sizeof(work) - 2;
          double val = p->data.dnum;
          while(val >= 10.0) {
            val /= 10;
            maxprec--;
          }

          if(prec > (long)maxprec)
            prec = (long)maxprec-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr = len;
",917,917,"[4, 10]",[]
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/socks_gssapi.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_105.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_105.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_213.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_213.cpp,"
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.value = malloc(strlen(serviceptr));
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr);
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(strlen(serviceptr) 닚�(conn->proxy.name)�);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr) 닚�(conn->proxy.name)�;
    snprintf(service.value, service.length�, ""%s@%s"",
             serviceptr, conn->proxy.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
","
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.length = serviceptr_length;
    service.value = malloc(service.length);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(serviceptr_length 
                           strlen(conn->socks_proxy.host.name)�);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = serviceptr_length  strlen(conn->socks_proxy.host.name)�;
    snprintf(service.value, service.length�, ""%s@%s"",
             serviceptr, conn->socks_proxy.host.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
",134,135,[17],[]
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/telnet.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_106.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_106.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_214.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_214.cpp,"  struct TELNET *tn = (struct TELNET *)data->req.protop;

  printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn)�);
  switch (CURL_SB_GET(tn)) {
    case CURL_TELOPT_TTYPE:
      len = strlen(tn->subopt_ttype)  4  2;
      snprintf((char *)temp, sizeof(temp),
","  struct TELNET *tn = (struct TELNET *)data->req.protop;

  printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn)�);
  switch(CURL_SB_GET(tn)) {
    case CURL_TELOPT_TTYPE:
      len = strlen(tn->subopt_ttype)  4  2;
      snprintf((char *)temp, sizeof(temp),
",935,935,[6],[]
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_107.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_107.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_215.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_215.cpp,"    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
","    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
",387,388,[9],[]
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/vtls/darwinssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_108.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_108.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_216.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_216.cpp,"    else {
      CURLcode result;
      ssl_sessionid =
        aprintf(""%s:%d:%d:%s:%hu"", data->set.str[STRING_SSL_CAFILE],
                data->set.ssl.verifypeer, data->set.ssl.verifyhost,
                conn->host.name, conn->remote_port);
      ssl_sessionid_len = strlen(ssl_sessionid);

      err = SSLSetPeerID(connssl->ssl_ctx, ssl_sessionid, ssl_sessionid_len);
","    else {
      CURLcode result;
      ssl_sessionid =
        aprintf(""%s:%d:%d:%s:%hu"", ssl_cafile,
                verifypeer, SSL_CONN_CONFIG(verifyhost), hostname, port);
      ssl_sessionid_len = strlen(ssl_sessionid);

      err = SSLSetPeerID(connssl->ssl_ctx, ssl_sessionid, ssl_sessionid_len);
",1504,1563,[3],[]
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_109.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_109.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_217.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_217.cpp,"    else
      tls_rt_name = """";

    msg_type = *(char*)buf;
    msg_name = ssl_msg_type(ssl_ver, msg_type);

    txt_len = snprintf(ssl_buf, sizeof(ssl_buf), ""%s (%s), %s, %s (%d):\n"",
","    else
      tls_rt_name = """";

    msg_type = *(char *)buf;
    msg_name = ssl_msg_type(ssl_ver, msg_type);

    txt_len = snprintf(ssl_buf, sizeof(ssl_buf), ""%s (%s), %s, %s (%d):\n"",
",1571,1567,[6],[]
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_109.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_109.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_218.cpp,"
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
","
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          *certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
",2198,2255,[4],[]
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/x509asn1.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_110.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_110.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_219.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_219.cpp,"  return strdup(*beg? ""TRUE"": ""FALSE"");
}

static const char * octet2str(const char * beg, const char * end)
{
  size_t n = end - beg;
  char * buf;

  /* Convert an ASN.1 octet string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */

  buf = malloc(3 * n  1);
  if(buf)
    for(n = 0; beg < end; n = 3)
      snprintf(buf  n, 4, ""%02x:"", *(const unsigned char *) beg�);
  return buf;
}

static const char * bit2str(const char * beg, const char * end)
{
  /* Convert an ASN.1 bit string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */
","  return strdup(*beg? ""TRUE"": ""FALSE"");
}

static const char *octet2str(const char *beg, const char *end)
{
  size_t n = end - beg;
  char *buf = NULL;

  /* Convert an ASN.1 octet string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */

  if(n <= (CURL_SIZE_T_MAX - 1) / 3) {
    buf = malloc(3 * n  1);
    if(buf)
      for(n = 0; beg < end; n = 3)
        snprintf(buf  n, 4, ""%02x:"", *(const unsigned char *) beg�);
  }
  return buf;
}

static const char *bit2str(const char *beg, const char *end)
{
  /* Convert an ASN.1 bit string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */
",195,198,[14],[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_220.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_220.cpp,"
/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO fwrite( yytext, yyleng, 1, yyout )
#endif

/* Gets input and stuffs it into ""buf"".  number of characters read, or YY_NULL,
 * is returned in ""result"".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
        if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
                { \
                int c = '*'; \
                size_t n; \
                for ( n = 0; n < max_size && \
                             (c = getc( yyin )) != EOF && c != '\n'; � ) \
                        buf[n] = (char) c; \
                if ( c == '\n' ) \
                        buf[n�] = (char) c; \
                if ( c == EOF && ferror( yyin ) ) \
                        YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
                result = n; \
                } \
        else \
                { \
                errno=0; \
                while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
                        { \
                        if( errno != EINTR) \
                                { \
                                YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
                                break; \
                                } \
                        errno=0; \
                        clearerr(yyin); \
                        } \
                }\
\

#endif
","
/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
#endif

/* Gets input and stuffs it into ""buf"".  number of characters read, or YY_NULL,
 * is returned in ""result"".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
{ \
int c = '*'; \
size_t n; \
for ( n = 0; n < max_size && \
     (c = getc( yyin )) != EOF && c != '\n'; � ) \
buf[n] = (char) c; \
if ( c == '\n' ) \
buf[n�] = (char) c; \
if ( c == EOF && ferror( yyin ) ) \
YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
result = n; \
} \
else \
{ \
errno=0; \
while ( (result = (int) fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
{ \
if( errno != EINTR) \
{ \
YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
break; \
} \
errno=0; \
clearerr(yyin); \
} \
}\
\

#endif
",615,600,"[29, 39]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_221.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_221.cpp,"
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
        YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
        yy_state_type yy_current_state;
        char *yy_cp, *yy_bp;
        int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 64 ""cmCommandArgumentLexer.in.l""


#line 732 ""cmCommandArgumentLexer.cxx""

        if ( !yyg->yy_init )
                {
                yyg->yy_init = 1;

#ifdef YY_USER_INIT
                YY_USER_INIT;
#endif

                if ( ! yyg->yy_start )
                        yyg->yy_start = 1;      /* first start state */

                if ( ! yyin )
                        yyin = stdin;

                if ( ! yyout )
                        yyout = stdout;

                if ( ! YY_CURRENT_BUFFER ) {
                        cmCommandArgument_yyensure_buffer_stack (yyscanner);
                        YY_CURRENT_BUFFER_LVALUE =
                                cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
                }

                cmCommandArgument_yy_load_buffer_state(yyscanner );
                }

        for(;;)             /* loops until end-of-file is reached */
                {
                yy_cp = yyg->yy_c_buf_p;

                /* Support of yytext. */
                *yy_cp = yyg->yy_hold_char;

                /* yy_bp points to the position in yy_ch_buf of the start of
                 * the current run.
                 */
                yy_bp = yy_cp;

                yy_current_state = yyg->yy_start;
yy_match:
                do
                        {
                        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
                        if ( yy_accept[yy_current_state] )
                                {
                                yyg->yy_last_accepting_state = yy_current_state;
                                yyg->yy_last_accepting_cpos = yy_cp;
                                }
                        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                                {
                                yy_current_state = (int) yy_def[yy_current_state];
                                if ( yy_current_state >= 30 )
                                        yy_c = yy_meta[(unsigned int) yy_c];
                                }
                        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                        שּׁ�_cp;
                        }
                while ( yy_base[yy_current_state] != 41 );

yy_find_action:
                yy_act = yy_accept[yy_current_state];
                if ( yy_act == 0 )
                        { /* have to back up */
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        yy_act = yy_accept[yy_current_state];
                        }

                YY_DO_BEFORE_ACTION;

do_action:      /* This label is used only to access EOF actions. */

                switch ( yy_act )
        { /* beginning of action switch */
                        case 0: /* must back up */
                        /* undo the effects of YY_DO_BEFORE_ACTION */
                        *yy_cp = yyg->yy_hold_char;
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 66 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext�, strlen(yytext)-2);
  return cal_ENVCURLY;
}
case 2:
YY_RULE_SETUP
#line 72 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext�, strlen(yytext)-2);
  return cal_NCURLY;
}
case 3:
YY_RULE_SETUP
#line 78 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext�, strlen(yytext)-2);
  return cal_ATNAME;
}
case 4:
YY_RULE_SETUP
#line 84 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
case 5:
YY_RULE_SETUP
#line 91 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
case 6:
YY_RULE_SETUP
#line 98 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
case 7:
YY_RULE_SETUP
#line 105 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
case 8:
YY_RULE_SETUP
#line 111 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytext�)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 119 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
case 10:
YY_RULE_SETUP
#line 125 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
case 11:
YY_RULE_SETUP
#line 131 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
case 12:
YY_RULE_SETUP
#line 137 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
case 13:
YY_RULE_SETUP
#line 143 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
case 14:
YY_RULE_SETUP
#line 149 ""cmCommandArgumentLexer.in.l""
ECHO;
        YY_BREAK
#line 943 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
        yyterminate();

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmCommandArgument_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = שּׁ�>yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmCommandArgument_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr  yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
return 0; /* this should not happen but it quiets some compilers */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; � )
                *(dest�) = *(source�);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        int num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size = b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, (size_t) num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmCommandArgument_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars = number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;

        for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; שּׁ�_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 30 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 30 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 29);

        return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
yy_state_type yy_current_state;
char *yy_cp, *yy_bp;
int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

if ( !yyg->yy_init )
{
yyg->yy_init = 1;

#ifdef YY_USER_INIT
YY_USER_INIT;
#endif

if ( ! yyg->yy_start )
yyg->yy_start = 1;/* first start state */

if ( ! yyin )
yyin = stdin;

if ( ! yyout )
yyout = stdout;

if ( ! YY_CURRENT_BUFFER ) {
cmCommandArgument_yyensure_buffer_stack (yyscanner);
YY_CURRENT_BUFFER_LVALUE =
cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
}

cmCommandArgument_yy_load_buffer_state(yyscanner );
}

{
#line 42 ""cmCommandArgumentLexer.in.l""


#line 740 ""cmCommandArgumentLexer.cxx""

while ( /*CONSTCOND*/1 )/* loops until end-of-file is reached */
{
yy_cp = yyg->yy_c_buf_p;

/* Support of yytext. */
*yy_cp = yyg->yy_hold_char;

/* yy_bp points to the position in yy_ch_buf of the start of
 * the current run.
 */
yy_bp = yy_cp;

yy_current_state = yyg->yy_start;
yy_match:
do
{
YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 30 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
שּׁ�_cp;
}
while ( yy_base[yy_current_state] != 41 );

yy_find_action:
yy_act = yy_accept[yy_current_state];
if ( yy_act == 0 )
{ /* have to back up */
yy_cp = yyg->yy_last_accepting_cpos;
yy_current_state = yyg->yy_last_accepting_state;
yy_act = yy_accept[yy_current_state];
}

YY_DO_BEFORE_ACTION;

do_action:/* This label is used only to access EOF actions. */

switch ( yy_act )
{ /* beginning of action switch */
case 0: /* must back up */
/* undo the effects of YY_DO_BEFORE_ACTION */
*yy_cp = yyg->yy_hold_char;
yy_cp = yyg->yy_last_accepting_cpos;
yy_current_state = yyg->yy_last_accepting_state;
goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 44 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext�, strlen(yytext)-2);
  return cal_ENVCURLY;
}
YY_BREAK
case 2:
YY_RULE_SETUP
#line 50 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext�, strlen(yytext)-2);
  return cal_NCURLY;
}
YY_BREAK
case 3:
YY_RULE_SETUP
#line 56 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext�, strlen(yytext)-2);
  return cal_ATNAME;
}
YY_BREAK
case 4:
YY_RULE_SETUP
#line 62 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
YY_BREAK
case 5:
YY_RULE_SETUP
#line 69 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
YY_BREAK
case 6:
YY_RULE_SETUP
#line 76 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
YY_BREAK
case 7:
YY_RULE_SETUP
#line 83 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
YY_BREAK
case 8:
YY_RULE_SETUP
#line 89 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytext�)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
YY_BREAK
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 97 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
YY_BREAK
case 10:
YY_RULE_SETUP
#line 103 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
YY_BREAK
case 11:
YY_RULE_SETUP
#line 109 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
YY_BREAK
case 12:
YY_RULE_SETUP
#line 115 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
YY_BREAK
case 13:
YY_RULE_SETUP
#line 121 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
YY_BREAK
case 14:
YY_RULE_SETUP
#line 127 ""cmCommandArgumentLexer.in.l""
ECHO;
YY_BREAK
#line 925 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
yyterminate();

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmCommandArgument_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = שּׁ�>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmCommandArgument_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; � )
*(dest�) = *(source�);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
int num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
int new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = NULL;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmCommandArgument_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((int) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; שּׁ�_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 30 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 30 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
yy_is_jam = (yy_current_state == 29);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",702,692,"[348, 371, 439, 483]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_222.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_222.cpp," */
    YY_BUFFER_STATE cmCommandArgument_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

        b->yy_buf_size = size;

        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        b->yy_ch_buf = (char *) cmCommandArgument_yyalloc(b->yy_buf_size  2 ,yyscanner );
        if ( ! b->yy_ch_buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

        b->yy_is_our_buffer = 1;

        cmCommandArgument_yy_init_buffer(b,file ,yyscanner);

        return b;
}

/** Destroy the buffer.
"," */
    YY_BUFFER_STATE cmCommandArgument_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

b->yy_buf_size = (yy_size_t)size;

/* yy_ch_buf has to be 2 characters longer than the size given because
 * we need to put in 2 end-of-buffer characters.
 */
b->yy_ch_buf = (char *) cmCommandArgument_yyalloc(b->yy_buf_size  2 ,yyscanner );
if ( ! b->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

b->yy_is_our_buffer = 1;

cmCommandArgument_yy_init_buffer(b,file ,yyscanner);

return b;
}

/** Destroy the buffer.
",1400,1409,"[7, 16]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_223.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_223.cpp,"void cmCommandArgument_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        if (!YY_CURRENT_BUFFER)
                return;

        cmCommandArgument_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
        YY_CURRENT_BUFFER_LVALUE = NULL;
        if (yyg->yy_buffer_stack_top > 0)
                --yyg->yy_buffer_stack_top;

        if (YY_CURRENT_BUFFER) {
                cmCommandArgument_yy_load_buffer_state(yyscanner );
                yyg->yy_did_buffer_switch_on_eof = 1;
        }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmCommandArgument_yyensure_buffer_stack (yyscan_t yyscanner)
{
        int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (!yyg->yy_buffer_stack) {

                /* First allocation is just for 2 elements, since we don't know if this
                 * scanner will even need a stack. We use 2 instead of 1 to avoid an
                 * immediate realloc on the next call.
         */
                num_to_alloc = 1;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyalloc
                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

                yyg->yy_buffer_stack_max = num_to_alloc;
                yyg->yy_buffer_stack_top = 0;
                return;
        }

        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

                /* Increase the buffer to prepare for a possible push. */
                int grow_size = 8 /* arbitrary grow size */;

                num_to_alloc = yyg->yy_buffer_stack_max  grow_size;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyrealloc
                                                                (yyg->yy_buffer_stack,
                                                                num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

                /* zero only the new slots.*/
                memset(yyg->yy_buffer_stack  yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
                yyg->yy_buffer_stack_max = num_to_alloc;
        }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
","void cmCommandArgument_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
if (!YY_CURRENT_BUFFER)
return;

cmCommandArgument_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
YY_CURRENT_BUFFER_LVALUE = NULL;
if (yyg->yy_buffer_stack_top > 0)
--yyg->yy_buffer_stack_top;

if (YY_CURRENT_BUFFER) {
cmCommandArgument_yy_load_buffer_state(yyscanner );
yyg->yy_did_buffer_switch_on_eof = 1;
}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmCommandArgument_yyensure_buffer_stack (yyscan_t yyscanner)
{
int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

if (!yyg->yy_buffer_stack) {

/* First allocation is just for 2 elements, since we don't know if this
 * scanner will even need a stack. We use 2 instead of 1 to avoid an
 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyalloc
(num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

yyg->yy_buffer_stack_max = num_to_alloc;
yyg->yy_buffer_stack_top = 0;
return;
}

if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

/* Increase the buffer to prepare for a possible push. */
yy_size_t grow_size = 8 /* arbitrary grow size */;

num_to_alloc = yyg->yy_buffer_stack_max  grow_size;
yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyrealloc
(yyg->yy_buffer_stack,
num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

/* zero only the new slots.*/
memset(yyg->yy_buffer_stack  yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
yyg->yy_buffer_stack_max = num_to_alloc;
}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
",1543,1548,"[36, 56]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_224.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_224.cpp," */
YY_BUFFER_STATE cmCommandArgument_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        if ( size < 2 ||
             base[size-2] != YY_END_OF_BUFFER_CHAR ||
             base[size-1] != YY_END_OF_BUFFER_CHAR )
                /* They forgot to leave room for the EOB's. */
                return 0;

        b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_buffer()"" );

        b->yy_buf_size = size - 2;      /* ""- 2"" to take care of EOB's */
        b->yy_buf_pos = b->yy_ch_buf = base;
        b->yy_is_our_buffer = 0;
        b->yy_input_file = 0;
        b->yy_n_chars = b->yy_buf_size;
        b->yy_is_interactive = 0;
        b->yy_at_bol = 1;
        b->yy_fill_buffer = 0;
        b->yy_buffer_status = YY_BUFFER_NEW;

        cmCommandArgument_yy_switch_to_buffer(b ,yyscanner );

        return b;
}

/** Setup the input buffer state to scan a string. The next call to cmCommandArgument_yylex() will
"," */
YY_BUFFER_STATE cmCommandArgument_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

if ( size < 2 ||
     base[size-2] != YY_END_OF_BUFFER_CHAR ||
     base[size-1] != YY_END_OF_BUFFER_CHAR )
/* They forgot to leave room for the EOB's. */
return NULL;

b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_buffer()"" );

b->yy_buf_size = size - 2;/* ""- 2"" to take care of EOB's */
b->yy_buf_pos = b->yy_ch_buf = base;
b->yy_is_our_buffer = 0;
b->yy_input_file = NULL;
b->yy_n_chars = b->yy_buf_size;
b->yy_is_interactive = 0;
b->yy_at_bol = 1;
b->yy_fill_buffer = 0;
b->yy_buffer_status = YY_BUFFER_NEW;

cmCommandArgument_yy_switch_to_buffer(b ,yyscanner );

return b;
}

/** Setup the input buffer state to scan a string. The next call to cmCommandArgument_yylex() will
",1612,1617,[13],[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_225.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_225.cpp,"YY_BUFFER_STATE cmCommandArgument_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

        return cmCommandArgument_yy_scan_bytes(yystr,strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmCommandArgument_yylex() will
 * scan from a @e copy of @a yybytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmCommandArgument_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;
        char *buf;
        yy_size_t n;
        int i;

        /* Get memory for full buffer, including space for trailing EOB's. */
        n = _yybytes_len  2;
        buf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );
        if ( ! buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" );

        for ( i = 0; i < _yybytes_len; � )
                buf[i] = yybytes[i];

        buf[_yybytes_len] = buf[_yybytes_len�] = YY_END_OF_BUFFER_CHAR;

        b = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);
        if ( ! b )
                YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" );

        /* It's okay to grow etc. this buffer, and we should throw it
         * away when we're done.
         */
        b->yy_is_our_buffer = 1;

        return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
                yytext[yyleng] = yyg->yy_hold_char; \
                yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
                yyg->yy_hold_char = *yyg->yy_c_buf_p; \
                *yyg->yy_c_buf_p = '\0'; \
                yyleng = yyless_macro_arg; \
                } \
        while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

","YY_BUFFER_STATE cmCommandArgument_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

return cmCommandArgument_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmCommandArgument_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmCommandArgument_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = (yy_size_t) _yybytes_len  2;
buf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" );

for ( i = 0; i < (size_t)_yybytes_len; � )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_len�] = YY_END_OF_BUFFER_CHAR;

b = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);
if ( ! b )
YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" );

/* It's okay to grow etc. this buffer, and we should throw it
 * away when we're done.
 */
b->yy_is_our_buffer = 1;

return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
(void)yyg;
(void) fprintf( stderr, ""%s\n"", msg );
exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
do \
{ \
/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
yytext[yyleng] = yyg->yy_hold_char; \
yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
yyg->yy_hold_char = *yyg->yy_c_buf_p; \
*yyg->yy_c_buf_p = '\0'; \
yyleng = yyless_macro_arg; \
} \
while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1650,1655,"[24, 33, 49]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_226.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_226.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmCommandArgument_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmCommandArgument_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmCommandArgument_yy_switch_to_buffer
 */
void cmCommandArgument_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmCommandArgument_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmCommandArgument_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmCommandArgument_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmCommandArgument_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmCommandArgument_yy_switch_to_buffer
 */
void cmCommandArgument_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmCommandArgument_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmCommandArgument_yyget_debug  (yyscan_t yyscanner)
",1802,1809,"[12, 27]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_227.cpp,"
/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
#endif

/* Gets input and stuffs it into ""buf"".  number of characters read, or YY_NULL,
 * is returned in ""result"".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
  if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
    { \
    int c = '*'; \
    size_t n; \
    for ( n = 0; n < max_size && \
           (c = getc( yyin )) != EOF && c != '\n'; � ) \
      buf[n] = (char) c; \
    if ( c == '\n' ) \
      buf[n�] = (char) c; \
    if ( c == EOF && ferror( yyin ) ) \
      YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
    result = n; \
    } \
  else \
    { \
    errno=0; \
    while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
      { \
      if( errno != EINTR) \
        { \
        YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
        break; \
        } \
      errno=0; \
      clearerr(yyin); \
      } \
    }\
\

#endif
","
/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
#endif

/* Gets input and stuffs it into ""buf"".  number of characters read, or YY_NULL,
 * is returned in ""result"".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
{ \
int c = '*'; \
size_t n; \
for ( n = 0; n < max_size && \
     (c = getc( yyin )) != EOF && c != '\n'; � ) \
buf[n] = (char) c; \
if ( c == '\n' ) \
buf[n�] = (char) c; \
if ( c == EOF && ferror( yyin ) ) \
YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
result = n; \
} \
else \
{ \
errno=0; \
while ( (result = (int) fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
{ \
if( errno != EINTR) \
{ \
YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
break; \
} \
errno=0; \
clearerr(yyin); \
} \
}\
\

#endif
",589,592,"[29, 39]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_228.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_228.cpp,"
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
  YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
  yy_state_type yy_current_state;
  char *yy_cp, *yy_bp;
  int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 86 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""


#line 736 ""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx""

  if ( yyg->yy_init )
    {
    yyg->yy_init = 0;

#ifdef YY_USER_INIT
    YY_USER_INIT;
#endif

    if ( ! yyg->yy_start )
      yyg->yy_start = 1;  /* first start state */

    if ( ! yyin )
      yyin = stdin;

    if ( ! yyout )
      yyout = stdout;

    if ( ! YY_CURRENT_BUFFER ) {
      cmExpr_yyensure_buffer_stack (yyscanner);
      YY_CURRENT_BUFFER_LVALUE =
        cmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
    }

    cmExpr_yy_load_buffer_state(yyscanner );
    }

  for(;;)    /* loops until end-of-file is reached */
    {
    yy_cp = yyg->yy_c_buf_p;

    /* Support of yytext. */
    *yy_cp = yyg->yy_hold_char;

    /* yy_bp points to the position in yy_ch_buf of the start of
     * the current run.
     */
    yy_bp = yy_cp;

    yy_current_state = yyg->yy_start;
yy_match:
    do
      {
      YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
      if ( yy_accept[yy_current_state] )
        {
        yyg->yy_last_accepting_state = yy_current_state;
        yyg->yy_last_accepting_cpos = yy_cp;
        }
      while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
        {
        yy_current_state = (int) yy_def[yy_current_state];
        if ( yy_current_state >= 23 )
          yy_c = yy_meta[(unsigned int) yy_c];
        }
      yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
      שּׁ�_cp;
      }
    while ( yy_base[yy_current_state] != 21 );

yy_find_action:
    yy_act = yy_accept[yy_current_state];
    if ( yy_act == 0 )
      { /* have to back up */
      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;
      yy_act = yy_accept[yy_current_state];
      }

    YY_DO_BEFORE_ACTION;

do_action:  /* This label is used only to access EOF actions. */

    switch ( yy_act )
  { /* beginning of action switch */
      case 0: /* must back up */
      /* undo the effects of YY_DO_BEFORE_ACTION */
      *yy_cp = yyg->yy_hold_char;
      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;
      goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 88 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ yylvalp->Number = atoi(yytext); return exp_NUMBER; }
case 2:
YY_RULE_SETUP
#line 90 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_PLUS; }
case 3:
YY_RULE_SETUP
#line 91 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_MINUS; }
case 4:
YY_RULE_SETUP
#line 92 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_TIMES; }
case 5:
YY_RULE_SETUP
#line 93 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_DIVIDE; }
case 6:
YY_RULE_SETUP
#line 94 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_MOD; }
case 7:
YY_RULE_SETUP
#line 95 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_OR; }
case 8:
YY_RULE_SETUP
#line 96 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_AND; }
case 9:
YY_RULE_SETUP
#line 97 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_XOR; }
case 10:
YY_RULE_SETUP
#line 98 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_NOT; }
case 11:
YY_RULE_SETUP
#line 99 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_SHIFTLEFT; }
case 12:
YY_RULE_SETUP
#line 100 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_SHIFTRIGHT; }
case 13:
YY_RULE_SETUP
#line 101 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_OPENPARENT; }
case 14:
YY_RULE_SETUP
#line 102 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_CLOSEPARENT; }
case 15:
YY_RULE_SETUP
#line 104 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
ECHO;
  YY_BREAK
#line 894 ""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx""
case YY_STATE_EOF(INITIAL):
  yyterminate();

  case YY_END_OF_BUFFER:
    {
    /* Amount of text matched not including the EOB char. */
    int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

    /* Undo the effects of YY_DO_BEFORE_ACTION. */
    *yy_cp = yyg->yy_hold_char;
    YY_RESTORE_YY_MORE_OFFSET

    if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
      {
      /* We're scanning a new file or input source.  It's
       * possible that this happened because the user
       * just pointed yyin at a new source and called
       * cmExpr_yylex().  If so, then we have to assure
       * consistency between YY_CURRENT_BUFFER and our
       * globals.  Here is the right place to do so, because
       * this is the first action (other than possibly a
       * back-up) that will match for the new input source.
       */
      yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
      YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
      }

    /* Note that here we test for yy_c_buf_p ""<="" to the position
     * of the first EOB in the buffer, since yy_c_buf_p will
     * already have been incremented past the NUL character
     * (since all states make transitions on EOB to the
     * end-of-buffer state).  Contrast this with the test
     * in input().
     */
    if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
      { /* This was really a NUL. */
      yy_state_type yy_next_state;

      yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

      yy_current_state = yy_get_previous_state( yyscanner );

      /* Okay, we're now positioned to make the NUL
       * transition.  We couldn't have
       * yy_get_previous_state() go ahead and do it
       * for us because it doesn't know how to deal
       * with the possibility of jamming (and we don't
       * want to build jamming into it because then it
       * will run more slowly).
       */

      yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

      yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

      if ( yy_next_state )
        {
        /* Consume the NUL. */
        yy_cp = שּׁ�>yy_c_buf_p;
        yy_current_state = yy_next_state;
        goto yy_match;
        }

      else
        {
        yy_cp = yyg->yy_c_buf_p;
        goto yy_find_action;
        }
      }

    else switch ( yy_get_next_buffer( yyscanner ) )
      {
      case EOB_ACT_END_OF_FILE:
        {
        yyg->yy_did_buffer_switch_on_eof = 0;

        if ( cmExpr_yywrap(yyscanner ) )
          {
          /* Note: because we've taken care in
           * yy_get_next_buffer() to have set up
           * yytext, we can now set up
           * yy_c_buf_p so that if some total
           * hoser (like flex itself) wants to
           * call the scanner after we return the
           * YY_NULL, it'll still work - another
           * YY_NULL will get returned.
           */
          yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

          yy_act = YY_STATE_EOF(YY_START);
          goto do_action;
          }

        else
          {
          if ( ! yyg->yy_did_buffer_switch_on_eof )
            YY_NEW_FILE;
          }
        break;
        }

      case EOB_ACT_CONTINUE_SCAN:
        yyg->yy_c_buf_p =
          yyg->yytext_ptr  yy_amount_of_matched_text;

        yy_current_state = yy_get_previous_state( yyscanner );

        yy_cp = yyg->yy_c_buf_p;
        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
        goto yy_match;

      case EOB_ACT_LAST_MATCH:
        yyg->yy_c_buf_p =
        &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

        yy_current_state = yy_get_previous_state( yyscanner );

        yy_cp = yyg->yy_c_buf_p;
        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
        goto yy_find_action;
      }
    break;
    }

  default:
    YY_FATAL_ERROR(
      ""fatal flex scanner internal error--no action found"" );
  } /* end of action switch */
    } /* end of scanning one token */
return 0; /* this should not happen but it quiets some compilers */
} /* end of cmExpr_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  char *source = yyg->yytext_ptr;
  int number_to_move, i;
  int ret_val;

  if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
    YY_FATAL_ERROR(
    ""fatal flex scanner internal error--end of buffer missed"" );

  if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
    { /* Don't try to fill the buffer, so this is an EOF. */
    if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
      {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
      }

    else
      {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
      }
    }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

  for ( i = 0; i < number_to_move; � )
    *(dest�) = *(source�);

  if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

  else
    {
      size_t nuto_read =
      YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

    while ( nuto_read <= 0 )
      { /* Not enough room in the buffer - grow it. */

      /* just a shorter name for the current buffer */
      YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

      int yy_c_buf_p_offset =
        (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

      if ( b->yy_is_our_buffer )
        {
        int new_size = b->yy_buf_size * 2;

        if ( new_size <= 0 )
          b->yy_buf_size = b->yy_buf_size / 8;
        else
          b->yy_buf_size *= 2;

        b->yy_ch_buf = (char *)
          /* Include room in for 2 EOB chars. */
          cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
        }
      else
        /* Can't grow it, we don't own it. */
        b->yy_ch_buf = 0;

      if ( ! b->yy_ch_buf )
        YY_FATAL_ERROR(
        ""fatal error - scanner input buffer overflow"" );

      yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

      nuto_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
            number_to_move - 1;

      }

    if ( nuto_read > YY_READ_BUF_SIZE )
      nuto_read = YY_READ_BUF_SIZE;

    /* Read in more data. */
    YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
      yyg->yy_n_chars, nuto_read );

    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
    }

  if ( yyg->yy_n_chars == 0 )
    {
    if ( number_to_move == YY_MORE_ADJ )
      {
      ret_val = EOB_ACT_END_OF_FILE;
      cmExpr_yyrestart(yyin  ,yyscanner);
      }

    else
      {
      ret_val = EOB_ACT_LAST_MATCH;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
        YY_BUFFER_EOF_PENDING;
      }
    }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  yyg->yy_n_chars = number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

  yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was
   reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
  yy_state_type yy_current_state;
  char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

  yy_current_state = yyg->yy_start;

  for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; שּׁ�_cp )
    {
    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    if ( yy_accept[yy_current_state] )
      {
      yyg->yy_last_accepting_state = yy_current_state;
      yyg->yy_last_accepting_cpos = yy_cp;
      }
    while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
      {
      yy_current_state = (int) yy_def[yy_current_state];
      if ( yy_current_state >= 23 )
        yy_c = yy_meta[(unsigned int) yy_c];
      }
    yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
    }

  return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
  int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  char *yy_cp = yyg->yy_c_buf_p;

  YY_CHAR yy_c = 1;
  if ( yy_accept[yy_current_state] )
    {
    yyg->yy_last_accepting_state = yy_current_state;
    yyg->yy_last_accepting_cpos = yy_cp;
    }
  while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
    {
    yy_current_state = (int) yy_def[yy_current_state];
    if ( yy_current_state >= 23 )
      yy_c = yy_meta[(unsigned int) yy_c];
    }
  yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
  yy_is_jam = (yy_current_state == 22);

  return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
yy_state_type yy_current_state;
char *yy_cp, *yy_bp;
int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

if ( !yyg->yy_init )
{
yyg->yy_init = 1;

#ifdef YY_USER_INIT
YY_USER_INIT;
#endif

if ( ! yyg->yy_start )
yyg->yy_start = 1;/* first start state */

if ( ! yyin )
yyin = stdin;

if ( ! yyout )
yyout = stdout;

if ( ! YY_CURRENT_BUFFER ) {
cmExpr_yyensure_buffer_stack (yyscanner);
YY_CURRENT_BUFFER_LVALUE =
cmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
}

cmExpr_yy_load_buffer_state(yyscanner );
}

{
#line 39 ""cmExprLexer.in.l""


#line 732 ""cmExprLexer.cxx""

while ( /*CONSTCOND*/1 )/* loops until end-of-file is reached */
{
yy_cp = yyg->yy_c_buf_p;

/* Support of yytext. */
*yy_cp = yyg->yy_hold_char;

/* yy_bp points to the position in yy_ch_buf of the start of
 * the current run.
 */
yy_bp = yy_cp;

yy_current_state = yyg->yy_start;
yy_match:
do
{
YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 23 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
שּׁ�_cp;
}
while ( yy_base[yy_current_state] != 21 );

yy_find_action:
yy_act = yy_accept[yy_current_state];
if ( yy_act == 0 )
{ /* have to back up */
yy_cp = yyg->yy_last_accepting_cpos;
yy_current_state = yyg->yy_last_accepting_state;
yy_act = yy_accept[yy_current_state];
}

YY_DO_BEFORE_ACTION;

do_action:/* This label is used only to access EOF actions. */

switch ( yy_act )
{ /* beginning of action switch */
case 0: /* must back up */
/* undo the effects of YY_DO_BEFORE_ACTION */
*yy_cp = yyg->yy_hold_char;
yy_cp = yyg->yy_last_accepting_cpos;
yy_current_state = yyg->yy_last_accepting_state;
goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 41 ""cmExprLexer.in.l""
{ yylvalp->Number = atoi(yytext); return exp_NUMBER; }
YY_BREAK
case 2:
YY_RULE_SETUP
#line 43 ""cmExprLexer.in.l""
{ return exp_PLUS; }
YY_BREAK
case 3:
YY_RULE_SETUP
#line 44 ""cmExprLexer.in.l""
{ return exp_MINUS; }
YY_BREAK
case 4:
YY_RULE_SETUP
#line 45 ""cmExprLexer.in.l""
{ return exp_TIMES; }
YY_BREAK
case 5:
YY_RULE_SETUP
#line 46 ""cmExprLexer.in.l""
{ return exp_DIVIDE; }
YY_BREAK
case 6:
YY_RULE_SETUP
#line 47 ""cmExprLexer.in.l""
{ return exp_MOD; }
YY_BREAK
case 7:
YY_RULE_SETUP
#line 48 ""cmExprLexer.in.l""
{ return exp_OR; }
YY_BREAK
case 8:
YY_RULE_SETUP
#line 49 ""cmExprLexer.in.l""
{ return exp_AND; }
YY_BREAK
case 9:
YY_RULE_SETUP
#line 50 ""cmExprLexer.in.l""
{ return exp_XOR; }
YY_BREAK
case 10:
YY_RULE_SETUP
#line 51 ""cmExprLexer.in.l""
{ return exp_NOT; }
YY_BREAK
case 11:
YY_RULE_SETUP
#line 52 ""cmExprLexer.in.l""
{ return exp_SHIFTLEFT; }
YY_BREAK
case 12:
YY_RULE_SETUP
#line 53 ""cmExprLexer.in.l""
{ return exp_SHIFTRIGHT; }
YY_BREAK
case 13:
YY_RULE_SETUP
#line 54 ""cmExprLexer.in.l""
{ return exp_OPENPARENT; }
YY_BREAK
case 14:
YY_RULE_SETUP
#line 55 ""cmExprLexer.in.l""
{ return exp_CLOSEPARENT; }
YY_BREAK
case 15:
YY_RULE_SETUP
#line 57 ""cmExprLexer.in.l""
ECHO;
YY_BREAK
#line 864 ""cmExprLexer.cxx""
case YY_STATE_EOF(INITIAL):
yyterminate();

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmExpr_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = שּׁ�>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmExpr_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmExpr_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; � )
*(dest�) = *(source�);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
int num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
int new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = NULL;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmExpr_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((int) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmExpr_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; שּׁ�_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 23 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 23 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
yy_is_jam = (yy_current_state == 22);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

/* undo effects of setting up yytext */
*yy_cp = yyg->yy_hold_char;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
{ /* need to shift things up to make room */
/* � for EOB chars. */
int number_to_move = yyg->yy_n_chars  2;
char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
char *source =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
*--dest = *--source;

yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
}

*--yy_cp = (char) c;

yyg->yytext_ptr = yy_bp;
yyg->yy_hold_char = *yy_cp;
yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",676,684,"[292, 315, 383]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_229.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_229.cpp," */
    YY_BUFFER_STATE cmExpr_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;

  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
  if ( ! b )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->yy_ch_buf = (char *) cmExpr_yyalloc(b->yy_buf_size  2 ,yyscanner );
  if ( ! b->yy_ch_buf )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

  b->yy_is_our_buffer = 1;

  cmExpr_yy_init_buffer(b,file ,yyscanner);

  return b;
}

/** Destroy the buffer.
"," */
    YY_BUFFER_STATE cmExpr_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

b->yy_buf_size = (yy_size_t)size;

/* yy_ch_buf has to be 2 characters longer than the size given because
 * we need to put in 2 end-of-buffer characters.
 */
b->yy_ch_buf = (char *) cmExpr_yyalloc(b->yy_buf_size  2 ,yyscanner );
if ( ! b->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

b->yy_is_our_buffer = 1;

cmExpr_yy_init_buffer(b,file ,yyscanner);

return b;
}

/** Destroy the buffer.
",1311,1384,"[7, 16]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_230.cpp," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;

  if ( size < 2 ||
       base[size-2] != YY_END_OF_BUFFER_CHAR ||
       base[size-1] != YY_END_OF_BUFFER_CHAR )
    /* They forgot to leave room for the EOB's. */
    return 0;

  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
  if ( ! b )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

  b->yy_buf_size = size - 2;  /* ""- 2"" to take care of EOB's */
  b->yy_buf_pos = b->yy_ch_buf = base;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = 0;
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = YY_BUFFER_NEW;

  cmExpr_yy_switch_to_buffer(b ,yyscanner );

  return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a yy_str.
 * @param yy_str a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yy_str , yyscan_t yyscanner)
{

  return cmExpr_yy_scan_bytes(yy_str,strlen(yy_str) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param bytes the byte buffer to scan
 * @param len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * bytes, int  len , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;
  char *buf;
  yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = len  2;
  buf = (char *) cmExpr_yyalloc(n ,yyscanner );
  if ( ! buf )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

  for ( i = 0; i < len; � )
    buf[i] = bytes[i];

  buf[len] = buf[len�] = YY_END_OF_BUFFER_CHAR;

  b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
  if ( ! b )
    YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->yy_is_our_buffer = 1;

  return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
      (void) fprintf( stderr, ""%s\n"", msg );
  exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
  do \
    { \
    /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
    yytext[yyleng] = yyg->yy_hold_char; \
    yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
    yyg->yy_hold_char = *yyg->yy_c_buf_p; \
    *yyg->yy_c_buf_p = '\0'; \
    yyleng = yyless_macro_arg; \
    } \
  while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

"," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

if ( size < 2 ||
     base[size-2] != YY_END_OF_BUFFER_CHAR ||
     base[size-1] != YY_END_OF_BUFFER_CHAR )
/* They forgot to leave room for the EOB's. */
return NULL;

b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

b->yy_buf_size = size - 2;/* ""- 2"" to take care of EOB's */
b->yy_buf_pos = b->yy_ch_buf = base;
b->yy_is_our_buffer = 0;
b->yy_input_file = NULL;
b->yy_n_chars = b->yy_buf_size;
b->yy_is_interactive = 0;
b->yy_at_bol = 1;
b->yy_fill_buffer = 0;
b->yy_buffer_status = YY_BUFFER_NEW;

cmExpr_yy_switch_to_buffer(b ,yyscanner );

return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

return cmExpr_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = (yy_size_t) _yybytes_len  2;
buf = (char *) cmExpr_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

for ( i = 0; i < (size_t)_yybytes_len; � )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_len�] = YY_END_OF_BUFFER_CHAR;

b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
if ( ! b )
YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

/* It's okay to grow etc. this buffer, and we should throw it
 * away when we're done.
 */
b->yy_is_our_buffer = 1;

return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
(void)yyg;
(void) fprintf( stderr, ""%s\n"", msg );
exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
do \
{ \
/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
yytext[yyleng] = yyg->yy_hold_char; \
yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
yyg->yy_hold_char = *yyg->yy_c_buf_p; \
*yyg->yy_c_buf_p = '\0'; \
yyleng = yyless_macro_arg; \
} \
while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1519,1592,"[13, 62, 71, 87]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_231.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmExpr_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmExpr_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmExpr_yy_switch_to_buffer
 */
void cmExpr_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmExpr_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmExpr_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmExpr_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmExpr_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmExpr_yy_switch_to_buffer
 */
void cmExpr_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmExpr_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmExpr_yyget_debug  (yyscan_t yyscanner)
",1709,1784,"[12, 27]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_232.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_232.cpp,"}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = 0;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
","}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = NULL;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
",1421,1415,[6],[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_233.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_233.cpp,"yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
","yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
",1567,1561,[6],[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_234.cpp," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = _yybytes_len  2;
buf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" );

for ( i = 0; i < _yybytes_len; � )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_len�] = YY_END_OF_BUFFER_CHAR;
"," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = (yy_size_t) _yybytes_len  2;
buf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" );

for ( i = 0; i < (size_t)_yybytes_len; � )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_len�] = YY_END_OF_BUFFER_CHAR;
",1996,1990,[14],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_235.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_235.cpp,"  return CURLE_OK;
}

#ifdef USE_LIBIDN
/*
 * Initialise use of IDNA library.
 * It falls back to ASCII if $CHARSET isn't defined. This doesn't work for
 * idna_to_ascii_lz().
 */
static void idna_init (void)
{
#ifdef WIN32
  char buf[60];
  UINT cp = GetACP();

  if(!getenv(""CHARSET"") && cp > 0) {
    snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);
    putenv(buf);
  }
#else
  /* to do? */
#endif
}
#endif  /* USE_LIBIDN */

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
","  return CURLE_OK;
}

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
",144,143,[16],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_236.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_236.cpp,"  }
#endif

#ifdef USE_LIBIDN
  idna_init();
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
","  }
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
",262,239,[8],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/formdata.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_115.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_115.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_237.cpp,"                             curl_off_t *size,
                             const char *fmt, ...)
{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(s, sizeof(s), fmt, ap);
  va_end(ap);

  return AddFormData(formp, FORM_DATA, s, 0, size);
}

/*
","                             curl_off_t *size,
                             const char *fmt, ...)
{
  char *s;
  CURLcode result;
  va_list ap;
  va_start(ap, fmt);
  s = curl_mvaprintf(fmt, ap);
  va_end(ap);

  if(!s)
    return CURLE_OUT_OF_MEMORY;

  result = AddFormData(formp, FORM_DATAMEM, s, 0, size);
  if(result)
    free(s);

  return result;
}

/*
",906,914,[6],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_116.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_116.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_238.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_238.cpp,"  enum protection_level data_sec = conn->data_prot;
#endif

  va_list ap;
  va_start(ap, fmt);
  write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);
  va_end(ap);

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len =2;
","  enum protection_level data_sec = conn->data_prot;
#endif

  write_len = strlen(cmd);
  if(write_len > (sizeof(s) -3))
    return CURLE_BAD_FUNCTION_ARGUMENT;

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len =2;
",4107,4103,[5],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/security.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_117.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_117.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_239.cpp,"  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsendf(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
","  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsend(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
",122,122,[0],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/ssh.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_118.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_118.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_240.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_240.cpp,"        sshc->acceptfail = TRUE;
      }

      if(curl_strequal(""pwd"", cmd)) {
        /* output debug output if that is requested */
        char *tmp = aprintf(""257 \""%s\"" is current directory.\n"",
                            sftp_scp->path);
","        sshc->acceptfail = TRUE;
      }

      if(strcasecompare(""pwd"", cmd)) {
        /* output debug output if that is requested */
        char *tmp = aprintf(""257 \""%s\"" is current directory.\n"",
                            sftp_scp->path);
",1233,1233,[5],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/tftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_119.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_119.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_241.cpp,"    /* As RFC3617 describes the separator slash is not actually part of the
       file name so we skip the always-present first letter of the path
       string. */
    filename = curl_easy_unescape(data, &state->conn->data->state.path[1], 0,
                                  NULL);
    if(!filename)
      return CURLE_OUT_OF_MEMORY;

    snprintf((char *)state->spacket.data�,
             state->blksize,
","    /* As RFC3617 describes the separator slash is not actually part of the
       file name so we skip the always-present first letter of the path
       string. */
    result = Curl_urldecode(data, &state->conn->data->state.path[1], 0,
                            &filename, NULL, FALSE);
    if(result)
      return result;

    snprintf((char *)state->spacket.data�,
             state->blksize,
",484,485,[8],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_120.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_120.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_242.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_242.cpp,"
  md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
","
  md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath);

  if(digest->qop && strcasecompare(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
",730,744,[1],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/version.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_121.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_121.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_243.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_243.cpp,"  left -= len;
  ptr = len;
#endif
#ifdef USE_LIBIDN
  if(stringprep_check_version(LIBIDN_REQUIRED_VERSION)) {
    len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));
    left -= len;
    ptr = len;
  }
","  left -= len;
  ptr = len;
#endif
#ifdef USE_LIBIDN2
  if(idn2_check_version(IDN2_VERSION)) {
    len = snprintf(ptr, left, "" libidn2/%s"", idn2_check_version(NULL));
    left -= len;
    ptr = len;
  }
",111,111,[5],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_122.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_122.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_244.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_244.cpp,"
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
","
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
",2178,2198,[3],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_245.cpp,"  return CURLE_OK;
}

#ifdef USE_LIBIDN
/*
 * Initialise use of IDNA library.
 * It falls back to ASCII if $CHARSET isn't defined. This doesn't work for
 * idna_to_ascii_lz().
 */
static void idna_init (void)
{
#ifdef WIN32
  char buf[60];
  UINT cp = GetACP();

  if(!getenv(""CHARSET"") && cp > 0) {
    snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);
    putenv(buf);
  }
#else
  /* to do? */
#endif
}
#endif  /* USE_LIBIDN */

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
","  return CURLE_OK;
}

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
",144,143,[16],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_246.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_246.cpp,"  }
#endif

#ifdef USE_LIBIDN
  idna_init();
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
","  }
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
",262,239,[8],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/formdata.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_124.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_124.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_247.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_247.cpp,"                             curl_off_t *size,
                             const char *fmt, ...)
{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(s, sizeof(s), fmt, ap);
  va_end(ap);

  return AddFormData(formp, FORM_DATA, s, 0, size);
}

/*
","                             curl_off_t *size,
                             const char *fmt, ...)
{
  char *s;
  CURLcode result;
  va_list ap;
  va_start(ap, fmt);
  s = curl_mvaprintf(fmt, ap);
  va_end(ap);

  if(!s)
    return CURLE_OUT_OF_MEMORY;

  result = AddFormData(formp, FORM_DATAMEM, s, 0, size);
  if(result)
    free(s);

  return result;
}

/*
",906,914,[6],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_125.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_125.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_248.cpp,"  enum protection_level data_sec = conn->data_prot;
#endif

  va_list ap;
  va_start(ap, fmt);
  write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);
  va_end(ap);

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len =2;
","  enum protection_level data_sec = conn->data_prot;
#endif

  write_len = strlen(cmd);
  if(write_len > (sizeof(s) -3))
    return CURLE_BAD_FUNCTION_ARGUMENT;

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len =2;
",4106,4102,[5],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/security.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_126.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_126.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_249.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_249.cpp,"  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsendf(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
","  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsend(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
",122,122,[0],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/ssh.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_127.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_127.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_250.cpp,"        sshc->acceptfail = TRUE;
      }

      if(curl_strequal(""pwd"", cmd)) {
        /* output debug output if that is requested */
        char *tmp = aprintf(""257 \""%s\"" is current directory.\n"",
                            sftp_scp->path);
","        sshc->acceptfail = TRUE;
      }

      if(strcasecompare(""pwd"", cmd)) {
        /* output debug output if that is requested */
        char *tmp = aprintf(""257 \""%s\"" is current directory.\n"",
                            sftp_scp->path);
",1233,1233,[5],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/tftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_128.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_128.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_251.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_251.cpp,"    /* As RFC3617 describes the separator slash is not actually part of the
       file name so we skip the always-present first letter of the path
       string. */
    filename = curl_easy_unescape(data, &state->conn->data->state.path[1], 0,
                                  NULL);
    if(!filename)
      return CURLE_OUT_OF_MEMORY;

    snprintf((char *)state->spacket.data�,
             state->blksize,
","    /* As RFC3617 describes the separator slash is not actually part of the
       file name so we skip the always-present first letter of the path
       string. */
    result = Curl_urldecode(data, &state->conn->data->state.path[1], 0,
                            &filename, NULL, FALSE);
    if(result)
      return result;

    snprintf((char *)state->spacket.data�,
             state->blksize,
",484,485,[8],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_252.cpp,"
  md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
","
  md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath);

  if(digest->qop && strcasecompare(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
",730,744,[1],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/version.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_130.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_130.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_253.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_253.cpp,"  left -= len;
  ptr = len;
#endif
#ifdef USE_LIBIDN
  if(stringprep_check_version(LIBIDN_REQUIRED_VERSION)) {
    len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));
    left -= len;
    ptr = len;
  }
","  left -= len;
  ptr = len;
#endif
#ifdef USE_LIBIDN2
  if(idn2_check_version(IDN2_VERSION)) {
    len = snprintf(ptr, left, "" libidn2/%s"", idn2_check_version(NULL));
    left -= len;
    ptr = len;
  }
",111,111,[5],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_131.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_131.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_254.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_254.cpp,"
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
","
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
",2178,2198,[3],[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/CommandLineArguments.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_132.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_132.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_255.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_255.cpp,"  maxlen = 4; // For the space before and after the option

  // Print help for each option
  for ( mpit = mp.begin();
    mpit != mp.end();
    mpit � )
    {
    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for ( sit = mpit->second.begin(); sit != mpit->second.end(); sit� )
      {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
        {
        case CommandLineArguments::NO_ARGUMENT: break;
        case CommandLineArguments::CONCAT_ARGUMENT: strcat(argument, ""opt""); break;
        case CommandLineArguments::SPACE_ARGUMENT:  strcat(argument, "" opt""); break;
        case CommandLineArguments::EQUAL_ARGUMENT:  strcat(argument, ""=opt""); break;
        case CommandLineArguments::MULTI_ARGUMENT:  strcat(argument, "" opt opt ...""); break;
        }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
      }
    const char* ptr = this->Internals->Callbacks[mpit->first].Help;
    size_t len = strlen(ptr);
    int cnt = 0;
    while ( len > 0)
      {
      // If argument with help is longer than line length, split it on previous
      // space (or tab) and continue on the next line
      CommandLineArguments::Internal::String::size_type cc;
      for ( cc = 0; ptr[cc]; cc � )
        {
        if ( *ptr == ' ' || *ptr == '\t' )
          {
          ptr �;
          len --;
          }
        }
      if ( cnt > 0 )
        {
        for ( cc = 0; cc < maxlen; cc � )
          {
          str << "" "";
          }
        }
      CommandLineArguments::Internal::String::size_type skip = len;
      if ( skip > this->LineLength - maxlen )
        {
        skip = this->LineLength - maxlen;
        for ( cc = skip-1; cc > 0; cc -- )
          {
          if ( ptr[cc] == ' ' || ptr[cc] == '\t' )
            {
            break;
            }
          }
        if ( cc != 0 )
          {
          skip = cc;
          }
        }
      str.write(ptr, static_cast<std::streamsize>(skip));
      str << std::endl;
      ptr = skip;
      len -= skip;
      cnt �;
      }
    }
  /*
  // This can help debugging help string
  str << endl;
","  maxlen = 4; // For the space before and after the option

  // Print help for each option
  for (mpit = mp.begin(); mpit != mp.end(); mpit�) {
    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for (sit = mpit->second.begin(); sit != mpit->second.end(); sit�) {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch (this->Internals->Callbacks[*sit].ArgumentType) {
        case CommandLineArguments::NO_ARGUMENT:
          break;
        case CommandLineArguments::CONCAT_ARGUMENT:
          strcat(argument, ""opt"");
          break;
        case CommandLineArguments::SPACE_ARGUMENT:
          strcat(argument, "" opt"");
          break;
        case CommandLineArguments::EQUAL_ARGUMENT:
          strcat(argument, ""=opt"");
          break;
        case CommandLineArguments::MULTI_ARGUMENT:
          strcat(argument, "" opt opt ..."");
          break;
      }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
    }
    const char* ptr = this->Internals->Callbacks[mpit->first].Help;
    size_t len = strlen(ptr);
    int cnt = 0;
    while (len > 0) {
      // If argument with help is longer than line length, split it on previous
      // space (or tab) and continue on the next line
      CommandLineArguments::Internal::String::size_type cc;
      for (cc = 0; ptr[cc]; cc�) {
        if (*ptr == ' ' || *ptr == '\t') {
          ptr�;
          len--;
        }
      }
      if (cnt > 0) {
        for (cc = 0; cc < maxlen; cc�) {
          str << "" "";
        }
      }
      CommandLineArguments::Internal::String::size_type skip = len;
      if (skip > this->LineLength - maxlen) {
        skip = this->LineLength - maxlen;
        for (cc = skip - 1; cc > 0; cc--) {
          if (ptr[cc] == ' ' || ptr[cc] == '\t') {
            break;
          }
        }
        if (cc != 0) {
          skip = cc;
        }
      }
      str.write(ptr, static_cast<std::streamsize>(skip));
      str << std::endl;
      ptr = skip;
      len -= skip;
      cnt�;
    }
  }
  /*
  // This can help debugging help string
  str << endl;
",595,557,"[12, 22]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_256.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_256.cpp,"#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' || *name.rbegin() == '\\' )
    {
    buf = new char[n  1  1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n  2  1];
    if ( name.find('\\') != name.npos )
      {
      sprintf(buf, ""%s\\*"", name.c_str());
      }
    else
      {
      sprintf(buf, ""%s/*"", name.c_str());
      }
    }
  struct _wfinddata_t data;      // data of current file

  // Now put them into the file array
  srchHandle = _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete [] buf;

  if ( srchHandle == -1 )
    {
    return 0;
    }

  // Loop through names
  do
    {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
    }
  while ( _wfindnext_func(srchHandle, &data) != -1 );
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
","#endif
  char* buf;
  size_t n = name.size();
  if (*name.rbegin() == '/' || *name.rbegin() == '\\') {
    buf = new char[n  1  1];
    sprintf(buf, ""%s*"", name.c_str());
  } else {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n  2  1];
    if (name.find('\\') != name.npos) {
      sprintf(buf, ""%s\\*"", name.c_str());
    } else {
      sprintf(buf, ""%s/*"", name.c_str());
    }
  }
  struct _wfinddata_t data; // data of current file

  // Now put them into the file array
  srchHandle =
    _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete[] buf;

  if (srchHandle == -1) {
    return 0;
  }

  // Loop through names
  do {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
  } while (_wfindnext_func(srchHandle, &data) != -1);
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
",120,109,"[6, 15, 19]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_257.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_257.cpp,"#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' )
    {
    buf = new char[n  1  1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    buf = new char[n  2  1];
    sprintf(buf, ""%s/*"", name.c_str());
    }
  struct _wfinddata_t data;      // data of current file

  // Now put them into the file array
  srchHandle = _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete [] buf;

  if ( srchHandle == -1 )
    {
    return 0;
    }

  // Loop through names
  unsigned long count = 0;
  do
    {
    count�;
    }
  while ( _wfindnext_func(srchHandle, &data) != -1 );
  _findclose(srchHandle);
  return count;
}
","#endif
  char* buf;
  size_t n = name.size();
  if (*name.rbegin() == '/') {
    buf = new char[n  1  1];
    sprintf(buf, ""%s*"", name.c_str());
  } else {
    buf = new char[n  2  1];
    sprintf(buf, ""%s/*"", name.c_str());
  }
  struct _wfinddata_t data; // data of current file

  // Now put them into the file array
  srchHandle =
    _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete[] buf;

  if (srchHandle == -1) {
    return 0;
  }

  // Loop through names
  unsigned long count = 0;
  do {
    count�;
  } while (_wfindnext_func(srchHandle, &data) != -1);
  _findclose(srchHandle);
  return count;
}
",170,151,"[6, 11]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/IOStream.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_134.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_134.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_258.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_258.cpp,"
// Read an integer value from an input stream.
template <class T>
std::istream&
IOStreamScanTemplate(std::istream& is, T& value, char type)
{
  int state = std::ios_base::goodbit;

  // Skip leading whitespace.
  std::istream::sentry okay(is);

  if(okay)
    {
    try {
    // Copy the string to a buffer and construct the format string.
    char buffer[KWSYS_IOS_INT64_MAX_DIG];
#   if defined(_MSC_VER)
    char format[] = ""%I64_"";
    const int typeIndex = 4;
#   else
    char format[] = ""%ll_"";
    const int typeIndex = 3;
#   endif
    switch(IOStreamScanStream(is, buffer))
      {
      case 8: format[typeIndex] = 'o'; break;
      case 0: // Default to decimal if not told otherwise.
      case 10: format[typeIndex] = type; break;
      case 16: format[typeIndex] = 'x'; break;
      };

    // Use sscanf to parse the number from the buffer.
    T result;
    int success = (sscanf(buffer, format, &result) == 1)?1:0;

    // Set flags for resulting state.
    if(is.peek() == EOF) { state |= std::ios_base::eofbit; }
    if(!success) { state |= std::ios_base::failbit; }
    else { value = result; }
    } catch(...) { state |= std::ios_base::badbit; }
    }

  is.setstate(std::ios_base::iostate(state));
  return is;
}

// Print an integer value to an output stream.
template <class T>
std::ostream&
IOStreamPrintTemplate(std::ostream& os, T value, char type)
{
  std::ostream::sentry okay(os);
  if(okay)
    {
    try {
    // Construct the format string.
    char format[8];
    char* f = format;
    *f� = '%';
    if(os.flags() & std::ios_base::showpos) { *f� = ''; }
    if(os.flags() & std::ios_base::showbase) { *f� = '#'; }
#   if defined(_MSC_VER)
    *f� = 'I'; *f� = '6'; *f� = '4';
#   else
    *f� = 'l'; *f� = 'l';
#   endif
    long bflags = os.flags() & std::ios_base::basefield;
    if(bflags == std::ios_base::oct) { *f� = 'o'; }
    else if(bflags != std::ios_base::hex) { *f� = type; }
    else if(os.flags() & std::ios_base::uppercase) { *f� = 'X'; }
    else { *f� = 'x'; }
    *f = '\0';

    // Use sprintf to print to a buffer and then write the
    // buffer to the stream.
    char buffer[2*KWSYS_IOS_INT64_MAX_DIG];
    sprintf(buffer, format, value);
    os << buffer;
    } catch(...) { os.clear(os.rdstate() | std::ios_base::badbit); }
    }
  return os;
}

# if !KWSYS_IOS_HAS_ISTREAM_LONG_LONG
// Implement input stream operator for IOStreamSLL.
std::istream& IOStreamScan(std::istream& is, IOStreamSLL& value)
{
","
// Read an integer value from an input stream.
template <class T>
std::istream& IOStreamScanTemplate(std::istream& is, T& value, char type)
{
  int state = std::ios_base::goodbit;

  // Skip leading whitespace.
  std::istream::sentry okay(is);

  if (okay) {
    try {
      // Copy the string to a buffer and construct the format string.
      char buffer[KWSYS_IOS_INT64_MAX_DIG];
#if defined(_MSC_VER)
      char format[] = ""%I64_"";
      const int typeIndex = 4;
#else
      char format[] = ""%ll_"";
      const int typeIndex = 3;
#endif
      switch (IOStreamScanStream(is, buffer)) {
        case 8:
          format[typeIndex] = 'o';
          break;
        case 0: // Default to decimal if not told otherwise.
        case 10:
          format[typeIndex] = type;
          break;
        case 16:
          format[typeIndex] = 'x';
          break;
      };

      // Use sscanf to parse the number from the buffer.
      T result;
      int success = (sscanf(buffer, format, &result) == 1) ? 1 : 0;

      // Set flags for resulting state.
      if (is.peek() == EOF) {
        state |= std::ios_base::eofbit;
      }
      if (!success) {
        state |= std::ios_base::failbit;
      } else {
        value = result;
      }
    } catch (...) {
      state |= std::ios_base::badbit;
    }
  }

  is.setstate(std::ios_base::iostate(state));
  return is;
}

// Print an integer value to an output stream.
template <class T>
std::ostream& IOStreamPrintTemplate(std::ostream& os, T value, char type)
{
  std::ostream::sentry okay(os);
  if (okay) {
    try {
      // Construct the format string.
      char format[8];
      char* f = format;
      *f� = '%';
      if (os.flags() & std::ios_base::showpos) {
        *f� = '';
      }
      if (os.flags() & std::ios_base::showbase) {
        *f� = '#';
      }
#if defined(_MSC_VER)
      *f� = 'I';
      *f� = '6';
      *f� = '4';
#else
      *f� = 'l';
      *f� = 'l';
#endif
      long bflags = os.flags() & std::ios_base::basefield;
      if (bflags == std::ios_base::oct) {
        *f� = 'o';
      } else if (bflags != std::ios_base::hex) {
        *f� = type;
      } else if (os.flags() & std::ios_base::uppercase) {
        *f� = 'X';
      } else {
        *f� = 'x';
      }
      *f = '\0';

      // Use sprintf to print to a buffer and then write the
      // buffer to the stream.
      char buffer[2 * KWSYS_IOS_INT64_MAX_DIG];
      sprintf(buffer, format, value);
      os << buffer;
    } catch (...) {
      os.clear(os.rdstate() | std::ios_base::badbit);
    }
  }
  return os;
}

#if !KWSYS_IOS_HAS_ISTREAM_LONG_LONG
// Implement input stream operator for IOStreamSLL.
std::istream& IOStreamScan(std::istream& is, IOStreamSLL& value)
{
",123,107,[76],[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_259.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_259.cpp,"#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  CONSOLE_SCREEN_BUFFER_INFO hOutInfo;
  HANDLE hOut = kwsysTerminalGetStreamHandle(stream);
  if(GetConsoleScreenBufferInfo(hOut, &hOutInfo))
    {
    pipeIsConsole = 1;
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream, color);
    }
#endif
  if(!pipeIsConsole && kwsysTerminalStreamIsVT100(stream,
                                                  default_vt100, default_tty))
    {
    pipeIsVT100 = 1;
    kwsysTerminalSetVT100Color(stream, color);
    }

  /* Format the text into the stream.  */
  {
  va_list var_args;
  va_start(var_args, format);
  vfprintf(stream, format, var_args);
  va_end(var_args);
  }

  /* Restore the normal color state for the stream.  */
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  if(pipeIsConsole)
    {
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream,
                                 kwsysTerminal_Color_Normal);
    }
#endif
  if(pipeIsVT100)
    {
    kwsysTerminalSetVT100Color(stream, kwsysTerminal_Color_Normal);
    }
}

/*--------------------------------------------------------------------------*/
","#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  CONSOLE_SCREEN_BUFFER_INFO hOutInfo;
  HANDLE hOut = kwsysTerminalGetStreamHandle(stream);
  if (GetConsoleScreenBufferInfo(hOut, &hOutInfo)) {
    pipeIsConsole = 1;
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream, color);
  }
#endif
  if (!pipeIsConsole &&
      kwsysTerminalStreamIsVT100(stream, default_vt100, default_tty)) {
    pipeIsVT100 = 1;
    kwsysTerminalSetVT100Color(stream, color);
  }

  /* Format the text into the stream.  */
  {
    va_list var_args;
    va_start(var_args, format);
    vfprintf(stream, format, var_args);
    va_end(var_args);
  }

/* Restore the normal color state for the stream.  */
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  if (pipeIsConsole) {
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream,
                                 kwsysTerminal_Color_Normal);
  }
#endif
  if (pipeIsVT100) {
    kwsysTerminalSetVT100Color(stream, kwsysTerminal_Color_Normal);
  }
}

/*--------------------------------------------------------------------------*/
",68,58,[20],[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_260.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_260.cpp,"
/*--------------------------------------------------------------------------*/
/* VT100 escape sequence strings.  */
#define KWSYS_TERMINAL_VT100_NORMAL              ""\33[0m""
#define KWSYS_TERMINAL_VT100_BOLD                ""\33[1m""
#define KWSYS_TERMINAL_VT100_UNDERLINE           ""\33[4m""
#define KWSYS_TERMINAL_VT100_BLINK               ""\33[5m""
#define KWSYS_TERMINAL_VT100_INVERSE             ""\33[7m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLACK    ""\33[30m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_RED      ""\33[31m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_GREEN    ""\33[32m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_YELLOW   ""\33[33m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLUE     ""\33[34m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_MAGENTA  ""\33[35m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_CYAN     ""\33[36m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_WHITE    ""\33[37m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLACK    ""\33[40m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_RED      ""\33[41m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_GREEN    ""\33[42m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_YELLOW   ""\33[43m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLUE     ""\33[44m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_MAGENTA  ""\33[45m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_CYAN     ""\33[46m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_WHITE    ""\33[47m""

/*--------------------------------------------------------------------------*/
/* Write VT100 escape sequences to the stream for the given color.  */
static void kwsysTerminalSetVT100Color(FILE* stream, int color)
{
  if(color == kwsysTerminal_Color_Normal)
    {
    fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
    return;
    }

  switch(color & kwsysTerminal_Color_ForegroundMask)
    {
    case kwsysTerminal_Color_Normal:
      fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
      break;
","
/*--------------------------------------------------------------------------*/
/* VT100 escape sequence strings.  */
#define KWSYS_TERMINAL_VT100_NORMAL ""\33[0m""
#define KWSYS_TERMINAL_VT100_BOLD ""\33[1m""
#define KWSYS_TERMINAL_VT100_UNDERLINE ""\33[4m""
#define KWSYS_TERMINAL_VT100_BLINK ""\33[5m""
#define KWSYS_TERMINAL_VT100_INVERSE ""\33[7m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLACK ""\33[30m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_RED ""\33[31m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_GREEN ""\33[32m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_YELLOW ""\33[33m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLUE ""\33[34m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_MAGENTA ""\33[35m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_CYAN ""\33[36m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_WHITE ""\33[37m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLACK ""\33[40m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_RED ""\33[41m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_GREEN ""\33[42m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_YELLOW ""\33[43m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLUE ""\33[44m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_MAGENTA ""\33[45m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_CYAN ""\33[46m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_WHITE ""\33[47m""

/*--------------------------------------------------------------------------*/
/* Write VT100 escape sequences to the stream for the given color.  */
static void kwsysTerminalSetVT100Color(FILE* stream, int color)
{
  if (color == kwsysTerminal_Color_Normal) {
    fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
    return;
  }

  switch (color & kwsysTerminal_Color_ForegroundMask) {
    case kwsysTerminal_Color_Normal:
      fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
      break;
",237,214,"[31, 38]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_261.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_261.cpp,"    case kwsysTerminal_Color_ForegroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_FOREGROUND_WHITE);
      break;
    }
  switch(color & kwsysTerminal_Color_BackgroundMask)
    {
    case kwsysTerminal_Color_BackgroundBlack:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_BLACK);
      break;
","    case kwsysTerminal_Color_ForegroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_FOREGROUND_WHITE);
      break;
  }
  switch (color & kwsysTerminal_Color_BackgroundMask) {
    case kwsysTerminal_Color_BackgroundBlack:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_BLACK);
      break;
",298,273,"[1, 7]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_262.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_262.cpp,"    case kwsysTerminal_Color_BackgroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_WHITE);
      break;
    }
  if(color & kwsysTerminal_Color_ForegroundBold)
    {
    fprintf(stream, KWSYS_TERMINAL_VT100_BOLD);
    }
}

/*--------------------------------------------------------------------------*/
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)

# define KWSYS_TERMINAL_MASK_FOREGROUND \
  (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY)
# define KWSYS_TERMINAL_MASK_BACKGROUND \
  (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY)

/* Get the Windows handle for a FILE stream.  */
","    case kwsysTerminal_Color_BackgroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_WHITE);
      break;
  }
  if (color & kwsysTerminal_Color_ForegroundBold) {
    fprintf(stream, KWSYS_TERMINAL_VT100_BOLD);
  }
}

/*--------------------------------------------------------------------------*/
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)

#define KWSYS_TERMINAL_MASK_FOREGROUND                                        \
  (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY)
#define KWSYS_TERMINAL_MASK_BACKGROUND                                        \
  (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY)

/* Get the Windows handle for a FILE stream.  */
",325,299,"[1, 6]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testEncode.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_136.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_136.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_263.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_263.cpp,"  printf(""md5sum 1: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output1, md5out);
  return (strcmp(md5out, testMD5output1) != 0)? 1:0;
}

static int testMD5_2(kwsysMD5* md5)
","  printf(""md5sum 1: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output1, md5out);
  return (strcmp(md5out, testMD5output1) != 0) ? 1 : 0;
}

static int testMD5_2(kwsysMD5* md5)
",40,31,[0],[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testEncode.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_136.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_136.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_264.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_264.cpp,"  printf(""md5sum 2: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output2, md5out);
  return (strcmp(md5out, testMD5output2) != 0)? 1:0;
}

int testEncode(int argc, char* argv[])
","  printf(""md5sum 2: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output2, md5out);
  return (strcmp(md5out, testMD5output2) != 0) ? 1 : 0;
}

int testEncode(int argc, char* argv[])
",55,46,[0],[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_265.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_265.cpp,"     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
","     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
",85,75,"[4, 5, 12, 13, 20, 21]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_266.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_266.cpp,"  /* Avoid error diagnostic popups since we are crashing on purpose.  */
  disable_debugger(1);
#endif
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");
  fflush(stdout);
","  /* Avoid error diagnostic popups since we are crashing on purpose.  */
  disable_debugger(1);
#endif
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");
  fflush(stdout);
",129,122,"[4, 5]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_267.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_267.cpp,"  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096*2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE�];
  (void)argc; (void)argv;
  for(i=0;i < TEST6_SIZE;�)
    {
    runaway[i] = '.';
    }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for(;;)
    {
    fwrite(runaway, 1, TEST6_SIZE�, stdout);
    fflush(stdout);
    }
}

/* Define MINPOLL to be one more than the number of times output is
","  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception, kwsysProcess_Exception_Fault,
               1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096 * 2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE  1];
  (void)argc;
  (void)argv;
  for (i = 0; i < TEST6_SIZE; �) {
    runaway[i] = '.';
  }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for (;;) {
    fwrite(runaway, 1, TEST6_SIZE  1, stdout);
    fflush(stdout);
  }
}

/* Define MINPOLL to be one more than the number of times output is
",155,149,"[0, 5, 6]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_268.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_268.cpp,"#define MAXPOLL 20
static int test7(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
","#define MAXPOLL 20
static int test7(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
",191,184,"[4, 5]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_269.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_269.cpp,"
static int test8_grandchild(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
","
static int test8_grandchild(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
",231,225,"[4, 5]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_270.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_270.cpp,"  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exited,
               kwsysProcess_Exception_None,
               0, 1, 1, 0, 30, 0, 1, 0, 0, 0);
  /* This sleep will avoid a race condition between this function exiting
     normally and our Ctrl� handler exiting abnormally after the process
     exits.  */
","  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exited, kwsysProcess_Exception_None, 0,
               1, 1, 0, 30, 0, 1, 0, 0, 0);
  /* This sleep will avoid a race condition between this function exiting
     normally and our Ctrl� handler exiting abnormally after the process
     exits.  */
",266,261,[0],[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_271.cpp,"static int test9_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc; (void)argv;
#if defined(_WIN32)
  if(!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE))
    {
    return 1;
    }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if(sigaction(SIGINT, &sa, 0) < 0)
    {
    return 1;
    }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
","static int test9_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc;
  (void)argv;
#if defined(_WIN32)
  if (!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE)) {
    return 1;
  }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if (sigaction(SIGINT, &sa, 0) < 0) {
    return 1;
  }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
",294,288,"[19, 20]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_272.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_272.cpp,"  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Interrupt,
               0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
","  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r =
    runChild(cmd, kwsysProcess_State_Exception,
             kwsysProcess_Exception_Interrupt, 0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
",341,334,"[0, 6, 7]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_273.cpp,"static int test10_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
","static int test10_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
",354,347,"[4, 5]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_274.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(漢� >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (漢� >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,"[54, 61, 99, 101, 103, 105, 110, 112, 117, 119, 127, 133, 141, 151]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_275.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_275.cpp," *                  BEFORE any reading/polling of pipes occurs and before any
 *                  detachment occurs.
 */
int runChild(const char* cmd[], int state, int exception, int value,
             int share, int output, int delay, double timeout,
             int poll, int repeat, int disown, int createNewGroup,
             unsigned int interruptDelay)
{
  int result = 1;
  kwsysProcess* kp = kwsysProcess_New();
  if(!kp)
    {
    fprintf(stderr, ""kwsysProcess_New returned NULL!\n"");
    return 1;
    }
  while(repeat-- > 0)
    {
    result = runChild2(kp, cmd, state, exception, value, share,
                       output, delay, timeout, poll, disown, createNewGroup,
                       interruptDelay);
    if(result)
      {
      break;
      }
    }
  kwsysProcess_Delete(kp);
  return result;
}
"," *                  BEFORE any reading/polling of pipes occurs and before any
 *                  detachment occurs.
 */
int runChild(const char* cmd[], int state, int exception, int value, int share,
             int output, int delay, double timeout, int poll, int repeat,
             int disown, int createNewGroup, unsigned int interruptDelay)
{
  int result = 1;
  kwsysProcess* kp = kwsysProcess_New();
  if (!kp) {
    fprintf(stderr, ""kwsysProcess_New returned NULL!\n"");
    return 1;
  }
  while (repeat-- > 0) {
    result = runChild2(kp, cmd, state, exception, value, share, output, delay,
                       timeout, poll, disown, createNewGroup, interruptDelay);
    if (result) {
      break;
    }
  }
  kwsysProcess_Delete(kp);
  return result;
}
",551,526,[12],[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_276.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_276.cpp,"    SetStdHandle(STD_ERROR_HANDLE, out);
    }
#endif
  if(argc == 2)
    {
    n = atoi(argv[1]);
    }
  else if(argc == 3 && strcmp(argv[1], ""run"") == 0)
    {
    n = atoi(argv[2]);
    }
  /* Check arguments.  */
  if(((n >= 1 && n <= 10) || n == 108 || n == 109 || n == 110) && argc == 3)
    {
    /* This is the child process for a requested test number.  */
    switch (n)
      {
      case 1: return test1(argc, argv);
      case 2: return test2(argc, argv);
      case 3: return test3(argc, argv);
      case 4: return test4(argc, argv);
      case 5: return test5(argc, argv);
      case 6: test6(argc, argv); return 0;
      case 7: return test7(argc, argv);
      case 8: return test8(argc, argv);
      case 9: return test9(argc, argv);
      case 10: return test10(argc, argv);
      case 108: return test8_grandchild(argc, argv);
      case 109: return test9_grandchild(argc, argv);
      case 110: return test10_grandchild(argc, argv);
      }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
    }
  else if(n >= 1 && n <= 10)
    {
    /* This is the parent process for a requested test number.  */
    int states[10] =
    {
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,
      kwsysProcess_State_Exception,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Expired, /* Ctrl� handler test */
      kwsysProcess_State_Exception /* Process group test */
    };
    int exceptions[10] =
    {
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_Fault,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_Interrupt
    };
    int values[10] = {0, 123, 1, 1, 0, 0, 0, 0, 1, 1};
    int shares[10] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1};
    int outputs[10] = {1, 1, 1, 1, 1, 0, 1, 1, 1, 1};
    int delays[10] = {0, 0, 0, 0, 0, 1, 0, 0, 0, 0};
    double timeouts[10] = {10, 10, 10, 30, 30, 10, -1, 10, 6, 4};
    int polls[10] = {0, 0, 0, 0, 0, 0, 1, 0, 0, 0};
    int repeat[10] = {257, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    int createNewGroups[10] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1};
    unsigned int interruptDelays[10] = {0, 0, 0, 0, 0, 0, 0, 0, 3, 2};
    int r;
    const char* cmd[4];
#ifdef _WIN32
    char* argv0 = 0;
#endif
    char* test1IterationsStr = getenv(""KWSYS_TEST_PROCESS_1_COUNT"");
    if(test1IterationsStr)
      {
      long int test1Iterations = strtol(test1IterationsStr, 0, 10);
      if(test1Iterations > 10 && test1Iterations != LONG_MAX)
        {
        repeat[0] = (int)test1Iterations;
        }
      }
#ifdef _WIN32
    if(n == 0 && (argv0 = strdup(argv[0])))
      {
      /* Try converting to forward slashes to see if it works.  */
      char* c;
      for(c=argv0; *c; �)
        {
        if(*c == '\\')
          {
          *c = '/';
          }
        }
      cmd[0] = argv0;
      }
    else
      {
      cmd[0] = argv[0];
      }
#else
    cmd[0] = argv[0];
#endif
","    SetStdHandle(STD_ERROR_HANDLE, out);
    }
#endif
  if (argc == 2) {
    n = atoi(argv[1]);
  } else if (argc == 3 && strcmp(argv[1], ""run"") == 0) {
    n = atoi(argv[2]);
  }
  /* Check arguments.  */
  if (((n >= 1 && n <= 10) || n == 108 || n == 109 || n == 110) && argc == 3) {
    /* This is the child process for a requested test number.  */
    switch (n) {
      case 1:
        return test1(argc, argv);
      case 2:
        return test2(argc, argv);
      case 3:
        return test3(argc, argv);
      case 4:
        return test4(argc, argv);
      case 5:
        return test5(argc, argv);
      case 6:
        test6(argc, argv);
        return 0;
      case 7:
        return test7(argc, argv);
      case 8:
        return test8(argc, argv);
      case 9:
        return test9(argc, argv);
      case 10:
        return test10(argc, argv);
      case 108:
        return test8_grandchild(argc, argv);
      case 109:
        return test9_grandchild(argc, argv);
      case 110:
        return test10_grandchild(argc, argv);
    }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
  } else if (n >= 1 && n <= 10) {
    /* This is the parent process for a requested test number.  */
    int states[10] = {
      kwsysProcess_State_Exited,   kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,  kwsysProcess_State_Exception,
      kwsysProcess_State_Exited,   kwsysProcess_State_Expired,
      kwsysProcess_State_Exited,   kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,  /* Ctrl� handler test */
      kwsysProcess_State_Exception /* Process group test */
    };
    int exceptions[10] = {
      kwsysProcess_Exception_None, kwsysProcess_Exception_None,
      kwsysProcess_Exception_None, kwsysProcess_Exception_Fault,
      kwsysProcess_Exception_None, kwsysProcess_Exception_None,
      kwsysProcess_Exception_None, kwsysProcess_Exception_None,
      kwsysProcess_Exception_None, kwsysProcess_Exception_Interrupt
    };
    int values[10] = { 0, 123, 1, 1, 0, 0, 0, 0, 1, 1 };
    int shares[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1 };
    int outputs[10] = { 1, 1, 1, 1, 1, 0, 1, 1, 1, 1 };
    int delays[10] = { 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 };
    double timeouts[10] = { 10, 10, 10, 30, 30, 10, -1, 10, 6, 4 };
    int polls[10] = { 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 };
    int repeat[10] = { 257, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    int createNewGroups[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1 };
    unsigned int interruptDelays[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 2 };
    int r;
    const char* cmd[4];
#ifdef _WIN32
    char* argv0 = 0;
#endif
    char* test1IterationsStr = getenv(""KWSYS_TEST_PROCESS_1_COUNT"");
    if (test1IterationsStr) {
      long int test1Iterations = strtol(test1IterationsStr, 0, 10);
      if (test1Iterations > 10 && test1Iterations != LONG_MAX) {
        repeat[0] = (int)test1Iterations;
      }
    }
#ifdef _WIN32
    if (n == 0 && (argv0 = strdup(argv[0]))) {
      /* Try converting to forward slashes to see if it works.  */
      char* c;
      for (c = argv0; *c; �) {
        if (*c == '\\') {
          *c = '/';
        }
      }
      cmd[0] = argv0;
    } else {
      cmd[0] = argv[0];
    }
#else
    cmd[0] = argv[0];
#endif
",609,578,[31],[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],CommandLineArguments.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_138.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_138.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_277.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_277.cpp,"  maxlen = 4; // For the space before and after the option

  // Print help for each option
  for ( mpit = mp.begin();
    mpit != mp.end();
    mpit � )
    {
    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for ( sit = mpit->second.begin(); sit != mpit->second.end(); sit� )
      {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
        {
        case CommandLineArguments::NO_ARGUMENT: break;
        case CommandLineArguments::CONCAT_ARGUMENT: strcat(argument, ""opt""); break;
        case CommandLineArguments::SPACE_ARGUMENT:  strcat(argument, "" opt""); break;
        case CommandLineArguments::EQUAL_ARGUMENT:  strcat(argument, ""=opt""); break;
        case CommandLineArguments::MULTI_ARGUMENT:  strcat(argument, "" opt opt ...""); break;
        }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
      }
    const char* ptr = this->Internals->Callbacks[mpit->first].Help;
    size_t len = strlen(ptr);
    int cnt = 0;
    while ( len > 0)
      {
      // If argument with help is longer than line length, split it on previous
      // space (or tab) and continue on the next line
      CommandLineArguments::Internal::String::size_type cc;
      for ( cc = 0; ptr[cc]; cc � )
        {
        if ( *ptr == ' ' || *ptr == '\t' )
          {
          ptr �;
          len --;
          }
        }
      if ( cnt > 0 )
        {
        for ( cc = 0; cc < maxlen; cc � )
          {
          str << "" "";
          }
        }
      CommandLineArguments::Internal::String::size_type skip = len;
      if ( skip > this->LineLength - maxlen )
        {
        skip = this->LineLength - maxlen;
        for ( cc = skip-1; cc > 0; cc -- )
          {
          if ( ptr[cc] == ' ' || ptr[cc] == '\t' )
            {
            break;
            }
          }
        if ( cc != 0 )
          {
          skip = cc;
          }
        }
      str.write(ptr, static_cast<std::streamsize>(skip));
      str << std::endl;
      ptr = skip;
      len -= skip;
      cnt �;
      }
    }
  /*
  // This can help debugging help string
  str << endl;
","  maxlen = 4; // For the space before and after the option

  // Print help for each option
  for (mpit = mp.begin(); mpit != mp.end(); mpit�) {
    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for (sit = mpit->second.begin(); sit != mpit->second.end(); sit�) {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch (this->Internals->Callbacks[*sit].ArgumentType) {
        case CommandLineArguments::NO_ARGUMENT:
          break;
        case CommandLineArguments::CONCAT_ARGUMENT:
          strcat(argument, ""opt"");
          break;
        case CommandLineArguments::SPACE_ARGUMENT:
          strcat(argument, "" opt"");
          break;
        case CommandLineArguments::EQUAL_ARGUMENT:
          strcat(argument, ""=opt"");
          break;
        case CommandLineArguments::MULTI_ARGUMENT:
          strcat(argument, "" opt opt ..."");
          break;
      }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
    }
    const char* ptr = this->Internals->Callbacks[mpit->first].Help;
    size_t len = strlen(ptr);
    int cnt = 0;
    while (len > 0) {
      // If argument with help is longer than line length, split it on previous
      // space (or tab) and continue on the next line
      CommandLineArguments::Internal::String::size_type cc;
      for (cc = 0; ptr[cc]; cc�) {
        if (*ptr == ' ' || *ptr == '\t') {
          ptr�;
          len--;
        }
      }
      if (cnt > 0) {
        for (cc = 0; cc < maxlen; cc�) {
          str << "" "";
        }
      }
      CommandLineArguments::Internal::String::size_type skip = len;
      if (skip > this->LineLength - maxlen) {
        skip = this->LineLength - maxlen;
        for (cc = skip - 1; cc > 0; cc--) {
          if (ptr[cc] == ' ' || ptr[cc] == '\t') {
            break;
          }
        }
        if (cc != 0) {
          skip = cc;
        }
      }
      str.write(ptr, static_cast<std::streamsize>(skip));
      str << std::endl;
      ptr = skip;
      len -= skip;
      cnt�;
    }
  }
  /*
  // This can help debugging help string
  str << endl;
",595,557,"[12, 22]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_278.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_278.cpp,"#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' || *name.rbegin() == '\\' )
    {
    buf = new char[n  1  1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n  2  1];
    if ( name.find('\\') != name.npos )
      {
      sprintf(buf, ""%s\\*"", name.c_str());
      }
    else
      {
      sprintf(buf, ""%s/*"", name.c_str());
      }
    }
  struct _wfinddata_t data;      // data of current file

  // Now put them into the file array
  srchHandle = _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete [] buf;

  if ( srchHandle == -1 )
    {
    return 0;
    }

  // Loop through names
  do
    {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
    }
  while ( _wfindnext_func(srchHandle, &data) != -1 );
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
","#endif
  char* buf;
  size_t n = name.size();
  if (*name.rbegin() == '/' || *name.rbegin() == '\\') {
    buf = new char[n  1  1];
    sprintf(buf, ""%s*"", name.c_str());
  } else {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n  2  1];
    if (name.find('\\') != name.npos) {
      sprintf(buf, ""%s\\*"", name.c_str());
    } else {
      sprintf(buf, ""%s/*"", name.c_str());
    }
  }
  struct _wfinddata_t data; // data of current file

  // Now put them into the file array
  srchHandle =
    _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete[] buf;

  if (srchHandle == -1) {
    return 0;
  }

  // Loop through names
  do {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
  } while (_wfindnext_func(srchHandle, &data) != -1);
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
",120,109,"[6, 15, 19]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_279.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_279.cpp,"#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' )
    {
    buf = new char[n  1  1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    buf = new char[n  2  1];
    sprintf(buf, ""%s/*"", name.c_str());
    }
  struct _wfinddata_t data;      // data of current file

  // Now put them into the file array
  srchHandle = _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete [] buf;

  if ( srchHandle == -1 )
    {
    return 0;
    }

  // Loop through names
  unsigned long count = 0;
  do
    {
    count�;
    }
  while ( _wfindnext_func(srchHandle, &data) != -1 );
  _findclose(srchHandle);
  return count;
}
","#endif
  char* buf;
  size_t n = name.size();
  if (*name.rbegin() == '/') {
    buf = new char[n  1  1];
    sprintf(buf, ""%s*"", name.c_str());
  } else {
    buf = new char[n  2  1];
    sprintf(buf, ""%s/*"", name.c_str());
  }
  struct _wfinddata_t data; // data of current file

  // Now put them into the file array
  srchHandle =
    _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete[] buf;

  if (srchHandle == -1) {
    return 0;
  }

  // Loop through names
  unsigned long count = 0;
  do {
    count�;
  } while (_wfindnext_func(srchHandle, &data) != -1);
  _findclose(srchHandle);
  return count;
}
",170,151,"[6, 11]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],IOStream.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_140.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_140.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_280.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_280.cpp,"
// Read an integer value from an input stream.
template <class T>
std::istream&
IOStreamScanTemplate(std::istream& is, T& value, char type)
{
  int state = std::ios_base::goodbit;

  // Skip leading whitespace.
  std::istream::sentry okay(is);

  if(okay)
    {
    try {
    // Copy the string to a buffer and construct the format string.
    char buffer[KWSYS_IOS_INT64_MAX_DIG];
#   if defined(_MSC_VER)
    char format[] = ""%I64_"";
    const int typeIndex = 4;
#   else
    char format[] = ""%ll_"";
    const int typeIndex = 3;
#   endif
    switch(IOStreamScanStream(is, buffer))
      {
      case 8: format[typeIndex] = 'o'; break;
      case 0: // Default to decimal if not told otherwise.
      case 10: format[typeIndex] = type; break;
      case 16: format[typeIndex] = 'x'; break;
      };

    // Use sscanf to parse the number from the buffer.
    T result;
    int success = (sscanf(buffer, format, &result) == 1)?1:0;

    // Set flags for resulting state.
    if(is.peek() == EOF) { state |= std::ios_base::eofbit; }
    if(!success) { state |= std::ios_base::failbit; }
    else { value = result; }
    } catch(...) { state |= std::ios_base::badbit; }
    }

  is.setstate(std::ios_base::iostate(state));
  return is;
}

// Print an integer value to an output stream.
template <class T>
std::ostream&
IOStreamPrintTemplate(std::ostream& os, T value, char type)
{
  std::ostream::sentry okay(os);
  if(okay)
    {
    try {
    // Construct the format string.
    char format[8];
    char* f = format;
    *f� = '%';
    if(os.flags() & std::ios_base::showpos) { *f� = ''; }
    if(os.flags() & std::ios_base::showbase) { *f� = '#'; }
#   if defined(_MSC_VER)
    *f� = 'I'; *f� = '6'; *f� = '4';
#   else
    *f� = 'l'; *f� = 'l';
#   endif
    long bflags = os.flags() & std::ios_base::basefield;
    if(bflags == std::ios_base::oct) { *f� = 'o'; }
    else if(bflags != std::ios_base::hex) { *f� = type; }
    else if(os.flags() & std::ios_base::uppercase) { *f� = 'X'; }
    else { *f� = 'x'; }
    *f = '\0';

    // Use sprintf to print to a buffer and then write the
    // buffer to the stream.
    char buffer[2*KWSYS_IOS_INT64_MAX_DIG];
    sprintf(buffer, format, value);
    os << buffer;
    } catch(...) { os.clear(os.rdstate() | std::ios_base::badbit); }
    }
  return os;
}

# if !KWSYS_IOS_HAS_ISTREAM_LONG_LONG
// Implement input stream operator for IOStreamSLL.
std::istream& IOStreamScan(std::istream& is, IOStreamSLL& value)
{
","
// Read an integer value from an input stream.
template <class T>
std::istream& IOStreamScanTemplate(std::istream& is, T& value, char type)
{
  int state = std::ios_base::goodbit;

  // Skip leading whitespace.
  std::istream::sentry okay(is);

  if (okay) {
    try {
      // Copy the string to a buffer and construct the format string.
      char buffer[KWSYS_IOS_INT64_MAX_DIG];
#if defined(_MSC_VER)
      char format[] = ""%I64_"";
      const int typeIndex = 4;
#else
      char format[] = ""%ll_"";
      const int typeIndex = 3;
#endif
      switch (IOStreamScanStream(is, buffer)) {
        case 8:
          format[typeIndex] = 'o';
          break;
        case 0: // Default to decimal if not told otherwise.
        case 10:
          format[typeIndex] = type;
          break;
        case 16:
          format[typeIndex] = 'x';
          break;
      };

      // Use sscanf to parse the number from the buffer.
      T result;
      int success = (sscanf(buffer, format, &result) == 1) ? 1 : 0;

      // Set flags for resulting state.
      if (is.peek() == EOF) {
        state |= std::ios_base::eofbit;
      }
      if (!success) {
        state |= std::ios_base::failbit;
      } else {
        value = result;
      }
    } catch (...) {
      state |= std::ios_base::badbit;
    }
  }

  is.setstate(std::ios_base::iostate(state));
  return is;
}

// Print an integer value to an output stream.
template <class T>
std::ostream& IOStreamPrintTemplate(std::ostream& os, T value, char type)
{
  std::ostream::sentry okay(os);
  if (okay) {
    try {
      // Construct the format string.
      char format[8];
      char* f = format;
      *f� = '%';
      if (os.flags() & std::ios_base::showpos) {
        *f� = '';
      }
      if (os.flags() & std::ios_base::showbase) {
        *f� = '#';
      }
#if defined(_MSC_VER)
      *f� = 'I';
      *f� = '6';
      *f� = '4';
#else
      *f� = 'l';
      *f� = 'l';
#endif
      long bflags = os.flags() & std::ios_base::basefield;
      if (bflags == std::ios_base::oct) {
        *f� = 'o';
      } else if (bflags != std::ios_base::hex) {
        *f� = type;
      } else if (os.flags() & std::ios_base::uppercase) {
        *f� = 'X';
      } else {
        *f� = 'x';
      }
      *f = '\0';

      // Use sprintf to print to a buffer and then write the
      // buffer to the stream.
      char buffer[2 * KWSYS_IOS_INT64_MAX_DIG];
      sprintf(buffer, format, value);
      os << buffer;
    } catch (...) {
      os.clear(os.rdstate() | std::ios_base::badbit);
    }
  }
  return os;
}

#if !KWSYS_IOS_HAS_ISTREAM_LONG_LONG
// Implement input stream operator for IOStreamSLL.
std::istream& IOStreamScan(std::istream& is, IOStreamSLL& value)
{
",123,107,[76],[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_281.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_281.cpp,"#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  CONSOLE_SCREEN_BUFFER_INFO hOutInfo;
  HANDLE hOut = kwsysTerminalGetStreamHandle(stream);
  if(GetConsoleScreenBufferInfo(hOut, &hOutInfo))
    {
    pipeIsConsole = 1;
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream, color);
    }
#endif
  if(!pipeIsConsole && kwsysTerminalStreamIsVT100(stream,
                                                  default_vt100, default_tty))
    {
    pipeIsVT100 = 1;
    kwsysTerminalSetVT100Color(stream, color);
    }

  /* Format the text into the stream.  */
  {
  va_list var_args;
  va_start(var_args, format);
  vfprintf(stream, format, var_args);
  va_end(var_args);
  }

  /* Restore the normal color state for the stream.  */
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  if(pipeIsConsole)
    {
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream,
                                 kwsysTerminal_Color_Normal);
    }
#endif
  if(pipeIsVT100)
    {
    kwsysTerminalSetVT100Color(stream, kwsysTerminal_Color_Normal);
    }
}

/*--------------------------------------------------------------------------*/
","#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  CONSOLE_SCREEN_BUFFER_INFO hOutInfo;
  HANDLE hOut = kwsysTerminalGetStreamHandle(stream);
  if (GetConsoleScreenBufferInfo(hOut, &hOutInfo)) {
    pipeIsConsole = 1;
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream, color);
  }
#endif
  if (!pipeIsConsole &&
      kwsysTerminalStreamIsVT100(stream, default_vt100, default_tty)) {
    pipeIsVT100 = 1;
    kwsysTerminalSetVT100Color(stream, color);
  }

  /* Format the text into the stream.  */
  {
    va_list var_args;
    va_start(var_args, format);
    vfprintf(stream, format, var_args);
    va_end(var_args);
  }

/* Restore the normal color state for the stream.  */
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  if (pipeIsConsole) {
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream,
                                 kwsysTerminal_Color_Normal);
  }
#endif
  if (pipeIsVT100) {
    kwsysTerminalSetVT100Color(stream, kwsysTerminal_Color_Normal);
  }
}

/*--------------------------------------------------------------------------*/
",68,58,[20],[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_282.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_282.cpp,"
/*--------------------------------------------------------------------------*/
/* VT100 escape sequence strings.  */
#define KWSYS_TERMINAL_VT100_NORMAL              ""\33[0m""
#define KWSYS_TERMINAL_VT100_BOLD                ""\33[1m""
#define KWSYS_TERMINAL_VT100_UNDERLINE           ""\33[4m""
#define KWSYS_TERMINAL_VT100_BLINK               ""\33[5m""
#define KWSYS_TERMINAL_VT100_INVERSE             ""\33[7m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLACK    ""\33[30m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_RED      ""\33[31m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_GREEN    ""\33[32m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_YELLOW   ""\33[33m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLUE     ""\33[34m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_MAGENTA  ""\33[35m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_CYAN     ""\33[36m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_WHITE    ""\33[37m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLACK    ""\33[40m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_RED      ""\33[41m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_GREEN    ""\33[42m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_YELLOW   ""\33[43m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLUE     ""\33[44m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_MAGENTA  ""\33[45m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_CYAN     ""\33[46m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_WHITE    ""\33[47m""

/*--------------------------------------------------------------------------*/
/* Write VT100 escape sequences to the stream for the given color.  */
static void kwsysTerminalSetVT100Color(FILE* stream, int color)
{
  if(color == kwsysTerminal_Color_Normal)
    {
    fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
    return;
    }

  switch(color & kwsysTerminal_Color_ForegroundMask)
    {
    case kwsysTerminal_Color_Normal:
      fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
      break;
","
/*--------------------------------------------------------------------------*/
/* VT100 escape sequence strings.  */
#define KWSYS_TERMINAL_VT100_NORMAL ""\33[0m""
#define KWSYS_TERMINAL_VT100_BOLD ""\33[1m""
#define KWSYS_TERMINAL_VT100_UNDERLINE ""\33[4m""
#define KWSYS_TERMINAL_VT100_BLINK ""\33[5m""
#define KWSYS_TERMINAL_VT100_INVERSE ""\33[7m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLACK ""\33[30m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_RED ""\33[31m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_GREEN ""\33[32m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_YELLOW ""\33[33m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLUE ""\33[34m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_MAGENTA ""\33[35m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_CYAN ""\33[36m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_WHITE ""\33[37m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLACK ""\33[40m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_RED ""\33[41m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_GREEN ""\33[42m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_YELLOW ""\33[43m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLUE ""\33[44m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_MAGENTA ""\33[45m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_CYAN ""\33[46m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_WHITE ""\33[47m""

/*--------------------------------------------------------------------------*/
/* Write VT100 escape sequences to the stream for the given color.  */
static void kwsysTerminalSetVT100Color(FILE* stream, int color)
{
  if (color == kwsysTerminal_Color_Normal) {
    fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
    return;
  }

  switch (color & kwsysTerminal_Color_ForegroundMask) {
    case kwsysTerminal_Color_Normal:
      fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
      break;
",237,214,"[31, 38]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_283.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_283.cpp,"    case kwsysTerminal_Color_ForegroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_FOREGROUND_WHITE);
      break;
    }
  switch(color & kwsysTerminal_Color_BackgroundMask)
    {
    case kwsysTerminal_Color_BackgroundBlack:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_BLACK);
      break;
","    case kwsysTerminal_Color_ForegroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_FOREGROUND_WHITE);
      break;
  }
  switch (color & kwsysTerminal_Color_BackgroundMask) {
    case kwsysTerminal_Color_BackgroundBlack:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_BLACK);
      break;
",298,273,"[1, 7]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_284.cpp,"    case kwsysTerminal_Color_BackgroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_WHITE);
      break;
    }
  if(color & kwsysTerminal_Color_ForegroundBold)
    {
    fprintf(stream, KWSYS_TERMINAL_VT100_BOLD);
    }
}

/*--------------------------------------------------------------------------*/
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)

# define KWSYS_TERMINAL_MASK_FOREGROUND \
  (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY)
# define KWSYS_TERMINAL_MASK_BACKGROUND \
  (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY)

/* Get the Windows handle for a FILE stream.  */
","    case kwsysTerminal_Color_BackgroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_WHITE);
      break;
  }
  if (color & kwsysTerminal_Color_ForegroundBold) {
    fprintf(stream, KWSYS_TERMINAL_VT100_BOLD);
  }
}

/*--------------------------------------------------------------------------*/
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)

#define KWSYS_TERMINAL_MASK_FOREGROUND                                        \
  (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY)
#define KWSYS_TERMINAL_MASK_BACKGROUND                                        \
  (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY)

/* Get the Windows handle for a FILE stream.  */
",325,299,"[1, 6]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],testEncode.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_142.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_142.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_285.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_285.cpp,"  printf(""md5sum 1: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output1, md5out);
  return (strcmp(md5out, testMD5output1) != 0)? 1:0;
}

static int testMD5_2(kwsysMD5* md5)
","  printf(""md5sum 1: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output1, md5out);
  return (strcmp(md5out, testMD5output1) != 0) ? 1 : 0;
}

static int testMD5_2(kwsysMD5* md5)
",40,31,[0],[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],testEncode.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_142.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_142.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_286.cpp,"  printf(""md5sum 2: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output2, md5out);
  return (strcmp(md5out, testMD5output2) != 0)? 1:0;
}

int testEncode(int argc, char* argv[])
","  printf(""md5sum 2: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output2, md5out);
  return (strcmp(md5out, testMD5output2) != 0) ? 1 : 0;
}

int testEncode(int argc, char* argv[])
",55,46,[0],[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_287.cpp,"     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
","     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
",85,75,"[4, 5, 12, 13, 20, 21]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_288.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_288.cpp,"  /* Avoid error diagnostic popups since we are crashing on purpose.  */
  disable_debugger(1);
#endif
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");
  fflush(stdout);
","  /* Avoid error diagnostic popups since we are crashing on purpose.  */
  disable_debugger(1);
#endif
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");
  fflush(stdout);
",129,122,"[4, 5]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_289.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_289.cpp,"  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096*2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE�];
  (void)argc; (void)argv;
  for(i=0;i < TEST6_SIZE;�)
    {
    runaway[i] = '.';
    }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for(;;)
    {
    fwrite(runaway, 1, TEST6_SIZE�, stdout);
    fflush(stdout);
    }
}

/* Define MINPOLL to be one more than the number of times output is
","  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception, kwsysProcess_Exception_Fault,
               1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096 * 2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE  1];
  (void)argc;
  (void)argv;
  for (i = 0; i < TEST6_SIZE; �) {
    runaway[i] = '.';
  }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for (;;) {
    fwrite(runaway, 1, TEST6_SIZE  1, stdout);
    fflush(stdout);
  }
}

/* Define MINPOLL to be one more than the number of times output is
",155,149,"[0, 5, 6]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_290.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_290.cpp,"#define MAXPOLL 20
static int test7(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
","#define MAXPOLL 20
static int test7(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
",191,184,"[4, 5]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_291.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_291.cpp,"
static int test8_grandchild(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
","
static int test8_grandchild(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
",231,225,"[4, 5]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_292.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_292.cpp,"  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exited,
               kwsysProcess_Exception_None,
               0, 1, 1, 0, 30, 0, 1, 0, 0, 0);
  /* This sleep will avoid a race condition between this function exiting
     normally and our Ctrl� handler exiting abnormally after the process
     exits.  */
","  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exited, kwsysProcess_Exception_None, 0,
               1, 1, 0, 30, 0, 1, 0, 0, 0);
  /* This sleep will avoid a race condition between this function exiting
     normally and our Ctrl� handler exiting abnormally after the process
     exits.  */
",266,261,[0],[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_293.cpp,"static int test9_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc; (void)argv;
#if defined(_WIN32)
  if(!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE))
    {
    return 1;
    }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if(sigaction(SIGINT, &sa, 0) < 0)
    {
    return 1;
    }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
","static int test9_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc;
  (void)argv;
#if defined(_WIN32)
  if (!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE)) {
    return 1;
  }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if (sigaction(SIGINT, &sa, 0) < 0) {
    return 1;
  }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
",294,288,"[19, 20]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_294.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_294.cpp,"  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Interrupt,
               0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
","  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r =
    runChild(cmd, kwsysProcess_State_Exception,
             kwsysProcess_Exception_Interrupt, 0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
",341,334,"[0, 6, 7]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_295.cpp,"static int test10_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
","static int test10_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
",354,347,"[4, 5]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_296.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(漢� >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (漢� >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,"[54, 61, 99, 101, 103, 105, 110, 112, 117, 119, 127, 133, 141, 151]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_297.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_297.cpp," *                  BEFORE any reading/polling of pipes occurs and before any
 *                  detachment occurs.
 */
int runChild(const char* cmd[], int state, int exception, int value,
             int share, int output, int delay, double timeout,
             int poll, int repeat, int disown, int createNewGroup,
             unsigned int interruptDelay)
{
  int result = 1;
  kwsysProcess* kp = kwsysProcess_New();
  if(!kp)
    {
    fprintf(stderr, ""kwsysProcess_New returned NULL!\n"");
    return 1;
    }
  while(repeat-- > 0)
    {
    result = runChild2(kp, cmd, state, exception, value, share,
                       output, delay, timeout, poll, disown, createNewGroup,
                       interruptDelay);
    if(result)
      {
      break;
      }
    }
  kwsysProcess_Delete(kp);
  return result;
}
"," *                  BEFORE any reading/polling of pipes occurs and before any
 *                  detachment occurs.
 */
int runChild(const char* cmd[], int state, int exception, int value, int share,
             int output, int delay, double timeout, int poll, int repeat,
             int disown, int createNewGroup, unsigned int interruptDelay)
{
  int result = 1;
  kwsysProcess* kp = kwsysProcess_New();
  if (!kp) {
    fprintf(stderr, ""kwsysProcess_New returned NULL!\n"");
    return 1;
  }
  while (repeat-- > 0) {
    result = runChild2(kp, cmd, state, exception, value, share, output, delay,
                       timeout, poll, disown, createNewGroup, interruptDelay);
    if (result) {
      break;
    }
  }
  kwsysProcess_Delete(kp);
  return result;
}
",551,526,[12],[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C� coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_298.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_298.cpp,"    SetStdHandle(STD_ERROR_HANDLE, out);
    }
#endif
  if(argc == 2)
    {
    n = atoi(argv[1]);
    }
  else if(argc == 3 && strcmp(argv[1], ""run"") == 0)
    {
    n = atoi(argv[2]);
    }
  /* Check arguments.  */
  if(((n >= 1 && n <= 10) || n == 108 || n == 109 || n == 110) && argc == 3)
    {
    /* This is the child process for a requested test number.  */
    switch (n)
      {
      case 1: return test1(argc, argv);
      case 2: return test2(argc, argv);
      case 3: return test3(argc, argv);
      case 4: return test4(argc, argv);
      case 5: return test5(argc, argv);
      case 6: test6(argc, argv); return 0;
      case 7: return test7(argc, argv);
      case 8: return test8(argc, argv);
      case 9: return test9(argc, argv);
      case 10: return test10(argc, argv);
      case 108: return test8_grandchild(argc, argv);
      case 109: return test9_grandchild(argc, argv);
      case 110: return test10_grandchild(argc, argv);
      }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
    }
  else if(n >= 1 && n <= 10)
    {
    /* This is the parent process for a requested test number.  */
    int states[10] =
    {
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,
      kwsysProcess_State_Exception,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Expired, /* Ctrl� handler test */
      kwsysProcess_State_Exception /* Process group test */
    };
    int exceptions[10] =
    {
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_Fault,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_Interrupt
    };
    int values[10] = {0, 123, 1, 1, 0, 0, 0, 0, 1, 1};
    int shares[10] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1};
    int outputs[10] = {1, 1, 1, 1, 1, 0, 1, 1, 1, 1};
    int delays[10] = {0, 0, 0, 0, 0, 1, 0, 0, 0, 0};
    double timeouts[10] = {10, 10, 10, 30, 30, 10, -1, 10, 6, 4};
    int polls[10] = {0, 0, 0, 0, 0, 0, 1, 0, 0, 0};
    int repeat[10] = {257, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    int createNewGroups[10] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1};
    unsigned int interruptDelays[10] = {0, 0, 0, 0, 0, 0, 0, 0, 3, 2};
    int r;
    const char* cmd[4];
#ifdef _WIN32
    char* argv0 = 0;
#endif
    char* test1IterationsStr = getenv(""KWSYS_TEST_PROCESS_1_COUNT"");
    if(test1IterationsStr)
      {
      long int test1Iterations = strtol(test1IterationsStr, 0, 10);
      if(test1Iterations > 10 && test1Iterations != LONG_MAX)
        {
        repeat[0] = (int)test1Iterations;
        }
      }
#ifdef _WIN32
    if(n == 0 && (argv0 = strdup(argv[0])))
      {
      /* Try converting to forward slashes to see if it works.  */
      char* c;
      for(c=argv0; *c; �)
        {
        if(*c == '\\')
          {
          *c = '/';
          }
        }
      cmd[0] = argv0;
      }
    else
      {
      cmd[0] = argv[0];
      }
#else
    cmd[0] = argv[0];
#endif
","    SetStdHandle(STD_ERROR_HANDLE, out);
    }
#endif
  if (argc == 2) {
    n = atoi(argv[1]);
  } else if (argc == 3 && strcmp(argv[1], ""run"") == 0) {
    n = atoi(argv[2]);
  }
  /* Check arguments.  */
  if (((n >= 1 && n <= 10) || n == 108 || n == 109 || n == 110) && argc == 3) {
    /* This is the child process for a requested test number.  */
    switch (n) {
      case 1:
        return test1(argc, argv);
      case 2:
        return test2(argc, argv);
      case 3:
        return test3(argc, argv);
      case 4:
        return test4(argc, argv);
      case 5:
        return test5(argc, argv);
      case 6:
        test6(argc, argv);
        return 0;
      case 7:
        return test7(argc, argv);
      case 8:
        return test8(argc, argv);
      case 9:
        return test9(argc, argv);
      case 10:
        return test10(argc, argv);
      case 108:
        return test8_grandchild(argc, argv);
      case 109:
        return test9_grandchild(argc, argv);
      case 110:
        return test10_grandchild(argc, argv);
    }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
  } else if (n >= 1 && n <= 10) {
    /* This is the parent process for a requested test number.  */
    int states[10] = {
      kwsysProcess_State_Exited,   kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,  kwsysProcess_State_Exception,
      kwsysProcess_State_Exited,   kwsysProcess_State_Expired,
      kwsysProcess_State_Exited,   kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,  /* Ctrl� handler test */
      kwsysProcess_State_Exception /* Process group test */
    };
    int exceptions[10] = {
      kwsysProcess_Exception_None, kwsysProcess_Exception_None,
      kwsysProcess_Exception_None, kwsysProcess_Exception_Fault,
      kwsysProcess_Exception_None, kwsysProcess_Exception_None,
      kwsysProcess_Exception_None, kwsysProcess_Exception_None,
      kwsysProcess_Exception_None, kwsysProcess_Exception_Interrupt
    };
    int values[10] = { 0, 123, 1, 1, 0, 0, 0, 0, 1, 1 };
    int shares[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1 };
    int outputs[10] = { 1, 1, 1, 1, 1, 0, 1, 1, 1, 1 };
    int delays[10] = { 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 };
    double timeouts[10] = { 10, 10, 10, 30, 30, 10, -1, 10, 6, 4 };
    int polls[10] = { 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 };
    int repeat[10] = { 257, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    int createNewGroups[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1 };
    unsigned int interruptDelays[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 2 };
    int r;
    const char* cmd[4];
#ifdef _WIN32
    char* argv0 = 0;
#endif
    char* test1IterationsStr = getenv(""KWSYS_TEST_PROCESS_1_COUNT"");
    if (test1IterationsStr) {
      long int test1Iterations = strtol(test1IterationsStr, 0, 10);
      if (test1Iterations > 10 && test1Iterations != LONG_MAX) {
        repeat[0] = (int)test1Iterations;
      }
    }
#ifdef _WIN32
    if (n == 0 && (argv0 = strdup(argv[0]))) {
      /* Try converting to forward slashes to see if it works.  */
      char* c;
      for (c = argv0; *c; �) {
        if (*c == '\\') {
          *c = '/';
        }
      }
      cmd[0] = argv0;
    } else {
      cmd[0] = argv[0];
    }
#else
    cmd[0] = argv[0];
#endif
",609,578,[31],[]
2fe3e55d53989c909be595b00a4749b75886accf,"cmState: Move CacheEntryType enum to separate namespace

Port dependent code to the change.",[],Source/cmCacheManager.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_144.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_144.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_299.cpp,"  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"",
                      cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"",
                      cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"",
                      cmState::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
","  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"",
                      cmStateEnums::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"",
                      cmStateEnums::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"",
                      cmStateEnums::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
",244,244,"[4, 9]",[]
2fe3e55d53989c909be595b00a4749b75886accf,"cmState: Move CacheEntryType enum to separate namespace

Port dependent code to the change.",[],Source/cmGlobalGenerator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_145.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_145.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_300.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_300.cpp,"  sprintf(num, ""%d"", static_cast<int>(this->Makefiles.size()));
  this->GetCMakeInstance()->AddCacheEntry(""CMAKE_NUMBER_OF_MAKEFILES"", num,
                                          ""number of local generators"",
                                          cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
  // and for infinite loops
","  sprintf(num, ""%d"", static_cast<int>(this->Makefiles.size()));
  this->GetCMakeInstance()->AddCacheEntry(""CMAKE_NUMBER_OF_MAKEFILES"", num,
                                          ""number of local generators"",
                                          cmStateEnums::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
  // and for infinite loops
",1103,1103,[0],[]
a49751fb2eed0ca6415b243c35b23201b8060597,cmState: Move TargetType enum to separate namespace,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_146.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_146.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_301.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_301.cpp,"              ? ""NEW""
              : ""OLD"");

    if (targetType == cmState::EXECUTABLE) {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
    } else // if (targetType == cmState::STATIC_LIBRARY)
    {
      /* Put the static library at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
","              ? ""NEW""
              : ""OLD"");

    if (targetType == cmStateEnums::EXECUTABLE) {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
    } else // if (targetType == cmStateEnums::STATIC_LIBRARY)
    {
      /* Put the static library at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
",481,482,"[5, 8, 12]",[]
7aaed265ade4c3b38967e83095497280a7a55153,"cmExprParser: Port to bison 3

Use %-directives to specify the scanner/lexer arguments and update the
yyerror signature.  Reduce the list of post-bison modifications needed.",[],Source/cmExprParser.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_147.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_147.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_302.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_302.cpp,"#  define YYFPRINTF fprintf
# endif

# define YYDPRINTF(Args)      \
do {            \
  if (yydebug)          \
    YYFPRINTF Args;        \
} while (0)

# define YYDSYMPRINT(Args)      \
do {            \
  if (yydebug)          \
    yysymprint Args;        \
} while (0)

# define YYDSYMPRINTF(Title, Token, Value, Location)    \
do {                \
  if (yydebug)              \
    {                \
      YYFPRINTF (stderr, ""%s "", Title);        \
      yysymprint (stderr,           \
                  Token, Value);  \
      YYFPRINTF (stderr, ""\n"");          \
    }                \
} while (0)

/*------------------------------------------------------------------.
| yy_stack_print -- Print the state stack from its BOTTOM up to its |
| TOP (included).                                                   |
`------------------------------------------------------------------*/

#if defined (__STDC__) || defined (__cplusplus)
static void
yy_stack_print (short int *bottom, short int *top)
#else
static void
yy_stack_print (bottom, top)
    short int *bottom;
    short int *top;
#endif
{
  YYFPRINTF (stderr, ""Stack now"");
  for (/* Nothing. */; bottom <= top; 了ⶶ�)
    YYFPRINTF (stderr, "" %d"", *bottom);
  YYFPRINTF (stderr, ""\n"");
}

# define YY_STACK_PRINT(Bottom, Top)        \
do {                \
  if (yydebug)              \
    yy_stack_print ((Bottom), (Top));        \
} while (0)


/*------------------------------------------------.
| Report that the YYRULE is going to be reduced.  |
`------------------------------------------------*/

#if defined (__STDC__) || defined (__cplusplus)
static void
yy_reduce_print (int yyrule)
#else
static void
yy_reduce_print (yyrule)
    int yyrule;
#endif
{
  int yyi;
  unsigned int yylno = yyrline[yyrule];
  YYFPRINTF (stderr, ""Reducing stack by rule %d (line %u), "",
             yyrule - 1, yylno);
  /* Print the symbols being reduced, and their result.  */
  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi�)
    YYFPRINTF (stderr, ""%s "", yytname [yyrhs[yyi]]);
  YYFPRINTF (stderr, ""-> %s\n"", yytname [yyr1[yyrule]]);
}

# define YY_REDUCE_PRINT(Rule)    \
do {          \
  if (yydebug)        \
    yy_reduce_print (Rule);    \
} while (0)

/* Nonzero means print parse trace.  It is left uninitialized so that
   multiple parsers can coexist.  */
int yydebug;
#else /* !YYDEBUG */
# define YYDPRINTF(Args)
# define YYDSYMPRINT(Args)
# define YYDSYMPRINTF(Title, Token, Value, Location)
# define YY_STACK_PRINT(Bottom, Top)
# define YY_REDUCE_PRINT(Rule)
#endif /* !YYDEBUG */


/* YYINITDEPTH -- initial size of the parser's stacks.  */
#ifndef  YYINITDEPTH
# define YYINITDEPTH 200
#endif

/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
   if the built-in stack extension method is used).

   Do not make this value too large; the results are undefined if
   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
   evaluated with infinite-precision integer arithmetic.  */

#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
# undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
# define YYMAXDEPTH 10000
#endif



#if YYERROR_VERBOSE

# ifndef yystrlen
#  if defined (__GLIBC__) && defined (_STRING_H)
#   define yystrlen strlen
#  else
/* Return the length of YYSTR.  */
static YYSIZE_T
#   if defined (__STDC__) || defined (__cplusplus)
yystrlen (const char *yystr)
#   else
yystrlen (yystr)
     const char *yystr;
#   endif
{
  const char *yys = yystr;

  while (*yys� != '\0')
    continue;

  return yys - yystr - 1;
}
#  endif
# endif

# ifndef yystpcpy
#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
#   define yystpcpy stpcpy
#  else
/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
   YYDEST.  */
static char *
#   if defined (__STDC__) || defined (__cplusplus)
yystpcpy (char *yydest, const char *yysrc)
#   else
yystpcpy (yydest, yysrc)
     char *yydest;
     const char *yysrc;
#   endif
{
  char *yyd = yydest;
  const char *yys = yysrc;
","#  define YYFPRINTF fprintf
# endif

# define YYDPRINTF(Args)                        \
do {                                            \
  if (yydebug)                                  \
    YYFPRINTF Args;                             \
} while (0)

/* This macro is provided for backward compatibility. */
#ifndef YY_LOCATION_PRINT
# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
#endif


# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
do {                                                                      \
  if (yydebug)                                                            \
    {                                                                     \
      YYFPRINTF (stderr, ""%s "", Title);                                   \
      yy_symbol_print (stderr,                                            \
                  Type, Value, yyscanner); \
      YYFPRINTF (stderr, ""\n"");                                           \
    }                                                                     \
} while (0)


/*----------------------------------------.
| Print this symbol's value on YYOUTPUT.  |
`----------------------------------------*/

static void
yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, yyscan_t yyscanner)
{
  FILE *yyo = yyoutput;
  YYUSE (yyo);
  YYUSE (yyscanner);
  if (!yyvaluep)
    return;
# ifdef YYPRINT
  if (yytype < YYNTOKENS)
    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
# endif
  YYUSE (yytype);
}


/*--------------------------------.
| Print this symbol on YYOUTPUT.  |
`--------------------------------*/

static void
yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, yyscan_t yyscanner)
{
  YYFPRINTF (yyoutput, ""%s %s ("",
             yytype < YYNTOKENS ? ""token"" : ""nterm"", yytname[yytype]);

  yy_symbol_value_print (yyoutput, yytype, yyvaluep, yyscanner);
  YYFPRINTF (yyoutput, "")"");
}

/*------------------------------------------------------------------.
| yy_stack_print -- Print the state stack from its BOTTOM up to its |
| TOP (included).                                                   |
`------------------------------------------------------------------*/

static void
yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
{
  YYFPRINTF (stderr, ""Stack now"");
  for (; yybottom <= yytop; yybottom�)
    {
      int yybot = *yybottom;
      YYFPRINTF (stderr, "" %d"", yybot);
    }
  YYFPRINTF (stderr, ""\n"");
}

# define YY_STACK_PRINT(Bottom, Top)                            \
do {                                                            \
  if (yydebug)                                                  \
    yy_stack_print ((Bottom), (Top));                           \
} while (0)


/*------------------------------------------------.
| Report that the YYRULE is going to be reduced.  |
`------------------------------------------------*/

static void
yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule, yyscan_t yyscanner)
{
  unsigned long int yylno = yyrline[yyrule];
  int yynrhs = yyr2[yyrule];
  int yyi;
  YYFPRINTF (stderr, ""Reducing stack by rule %d (line %lu):\n"",
             yyrule - 1, yylno);
  /* The symbols being reduced.  */
  for (yyi = 0; yyi < yynrhs; yyi�)
    {
      YYFPRINTF (stderr, ""   $%d = "", yyi  1);
      yy_symbol_print (stderr,
                       yystos[yyssp[yyi  1 - yynrhs]],
                       &(yyvsp[(yyi  1) - (yynrhs)])
                                              , yyscanner);
      YYFPRINTF (stderr, ""\n"");
    }
}

# define YY_REDUCE_PRINT(Rule)          \
do {                                    \
  if (yydebug)                          \
    yy_reduce_print (yyssp, yyvsp, Rule, yyscanner); \
} while (0)

/* Nonzero means print parse trace.  It is left uninitialized so that
   multiple parsers can coexist.  */
int yydebug;
#else /* !YYDEBUG */
# define YYDPRINTF(Args)
# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
# define YY_STACK_PRINT(Bottom, Top)
# define YY_REDUCE_PRINT(Rule)
#endif /* !YYDEBUG */


/* YYINITDEPTH -- initial size of the parser's stacks.  */
#ifndef YYINITDEPTH
# define YYINITDEPTH 200
#endif

/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
   if the built-in stack extension method is used).

   Do not make this value too large; the results are undefined if
   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
   evaluated with infinite-precision integer arithmetic.  */

#ifndef YYMAXDEPTH
# define YYMAXDEPTH 10000
#endif


#if YYERROR_VERBOSE

# ifndef yystrlen
#  if defined __GLIBC__ && defined _STRING_H
#   define yystrlen strlen
#  else
/* Return the length of YYSTR.  */
static YYSIZE_T
yystrlen (const char *yystr)
{
  YYSIZE_T yylen;
  for (yylen = 0; yystr[yylen]; yylen�)
    continue;
  return yylen;
}
#  endif
# endif

# ifndef yystpcpy
#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
#   define yystpcpy stpcpy
#  else
/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
   YYDEST.  */
static char *
yystpcpy (char *yydest, const char *yysrc)
{
  char *yyd = yydest;
  const char *yys = yysrc;
",552,640,"[3, 15, 87, 89]",[]
7aaed265ade4c3b38967e83095497280a7a55153,"cmExprParser: Port to bison 3

Use %-directives to specify the scanner/lexer arguments and update the
yyerror signature.  Reduce the list of post-bison modifications needed.",[],Source/cmExprParser.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_148.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_148.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_304.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_304.cpp,"#  define YYFPRINTF fprintf
# endif

# define YYDPRINTF(Args)      \
do {            \
  if (yydebug)          \
    YYFPRINTF Args;        \
} while (0)

# define YYDSYMPRINT(Args)      \
do {            \
  if (yydebug)          \
    yysymprint Args;        \
} while (0)

# define YYDSYMPRINTF(Title, Token, Value, Location)    \
do {                \
  if (yydebug)              \
    {                \
      YYFPRINTF (stderr, ""%s "", Title);        \
      yysymprint (stderr,           \
                  Token, Value);  \
      YYFPRINTF (stderr, ""\n"");          \
    }                \
} while (0)

/*------------------------------------------------------------------.
| yy_stack_print -- Print the state stack from its BOTTOM up to its |
| TOP (included).                                                   |
`------------------------------------------------------------------*/

#if defined (__STDC__) || defined (__cplusplus)
static void
yy_stack_print (short int *bottom, short int *top)
#else
static void
yy_stack_print (bottom, top)
    short int *bottom;
    short int *top;
#endif
{
  YYFPRINTF (stderr, ""Stack now"");
  for (/* Nothing. */; bottom <= top; 了ⶶ�)
    YYFPRINTF (stderr, "" %d"", *bottom);
  YYFPRINTF (stderr, ""\n"");
}

# define YY_STACK_PRINT(Bottom, Top)        \
do {                \
  if (yydebug)              \
    yy_stack_print ((Bottom), (Top));        \
} while (0)


/*------------------------------------------------.
| Report that the YYRULE is going to be reduced.  |
`------------------------------------------------*/

#if defined (__STDC__) || defined (__cplusplus)
static void
yy_reduce_print (int yyrule)
#else
static void
yy_reduce_print (yyrule)
    int yyrule;
#endif
{
  int yyi;
  unsigned int yylno = yyrline[yyrule];
  YYFPRINTF (stderr, ""Reducing stack by rule %d (line %u), "",
             yyrule - 1, yylno);
  /* Print the symbols being reduced, and their result.  */
  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi�)
    YYFPRINTF (stderr, ""%s "", yytname [yyrhs[yyi]]);
  YYFPRINTF (stderr, ""-> %s\n"", yytname [yyr1[yyrule]]);
}

# define YY_REDUCE_PRINT(Rule)    \
do {          \
  if (yydebug)        \
    yy_reduce_print (Rule);    \
} while (0)

/* Nonzero means print parse trace.  It is left uninitialized so that
   multiple parsers can coexist.  */
int yydebug;
#else /* !YYDEBUG */
# define YYDPRINTF(Args)
# define YYDSYMPRINT(Args)
# define YYDSYMPRINTF(Title, Token, Value, Location)
# define YY_STACK_PRINT(Bottom, Top)
# define YY_REDUCE_PRINT(Rule)
#endif /* !YYDEBUG */


/* YYINITDEPTH -- initial size of the parser's stacks.  */
#ifndef  YYINITDEPTH
# define YYINITDEPTH 200
#endif

/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
   if the built-in stack extension method is used).

   Do not make this value too large; the results are undefined if
   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
   evaluated with infinite-precision integer arithmetic.  */

#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
# undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
# define YYMAXDEPTH 10000
#endif



#if YYERROR_VERBOSE

# ifndef yystrlen
#  if defined (__GLIBC__) && defined (_STRING_H)
#   define yystrlen strlen
#  else
/* Return the length of YYSTR.  */
static YYSIZE_T
#   if defined (__STDC__) || defined (__cplusplus)
yystrlen (const char *yystr)
#   else
yystrlen (yystr)
     const char *yystr;
#   endif
{
  const char *yys = yystr;

  while (*yys� != '\0')
    continue;

  return yys - yystr - 1;
}
#  endif
# endif

# ifndef yystpcpy
#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
#   define yystpcpy stpcpy
#  else
/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
   YYDEST.  */
static char *
#   if defined (__STDC__) || defined (__cplusplus)
yystpcpy (char *yydest, const char *yysrc)
#   else
yystpcpy (yydest, yysrc)
     char *yydest;
     const char *yysrc;
#   endif
{
  char *yyd = yydest;
  const char *yys = yysrc;
","#  define YYFPRINTF fprintf
# endif

# define YYDPRINTF(Args)                        \
do {                                            \
  if (yydebug)                                  \
    YYFPRINTF Args;                             \
} while (0)

/* This macro is provided for backward compatibility. */
#ifndef YY_LOCATION_PRINT
# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
#endif


# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
do {                                                                      \
  if (yydebug)                                                            \
    {                                                                     \
      YYFPRINTF (stderr, ""%s "", Title);                                   \
      yy_symbol_print (stderr,                                            \
                  Type, Value, yyscanner); \
      YYFPRINTF (stderr, ""\n"");                                           \
    }                                                                     \
} while (0)


/*----------------------------------------.
| Print this symbol's value on YYOUTPUT.  |
`----------------------------------------*/

static void
yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, yyscan_t yyscanner)
{
  FILE *yyo = yyoutput;
  YYUSE (yyo);
  YYUSE (yyscanner);
  if (!yyvaluep)
    return;
# ifdef YYPRINT
  if (yytype < YYNTOKENS)
    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
# endif
  YYUSE (yytype);
}


/*--------------------------------.
| Print this symbol on YYOUTPUT.  |
`--------------------------------*/

static void
yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, yyscan_t yyscanner)
{
  YYFPRINTF (yyoutput, ""%s %s ("",
             yytype < YYNTOKENS ? ""token"" : ""nterm"", yytname[yytype]);

  yy_symbol_value_print (yyoutput, yytype, yyvaluep, yyscanner);
  YYFPRINTF (yyoutput, "")"");
}

/*------------------------------------------------------------------.
| yy_stack_print -- Print the state stack from its BOTTOM up to its |
| TOP (included).                                                   |
`------------------------------------------------------------------*/

static void
yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
{
  YYFPRINTF (stderr, ""Stack now"");
  for (; yybottom <= yytop; yybottom�)
    {
      int yybot = *yybottom;
      YYFPRINTF (stderr, "" %d"", yybot);
    }
  YYFPRINTF (stderr, ""\n"");
}

# define YY_STACK_PRINT(Bottom, Top)                            \
do {                                                            \
  if (yydebug)                                                  \
    yy_stack_print ((Bottom), (Top));                           \
} while (0)


/*------------------------------------------------.
| Report that the YYRULE is going to be reduced.  |
`------------------------------------------------*/

static void
yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule, yyscan_t yyscanner)
{
  unsigned long int yylno = yyrline[yyrule];
  int yynrhs = yyr2[yyrule];
  int yyi;
  YYFPRINTF (stderr, ""Reducing stack by rule %d (line %lu):\n"",
             yyrule - 1, yylno);
  /* The symbols being reduced.  */
  for (yyi = 0; yyi < yynrhs; yyi�)
    {
      YYFPRINTF (stderr, ""   $%d = "", yyi  1);
      yy_symbol_print (stderr,
                       yystos[yyssp[yyi  1 - yynrhs]],
                       &(yyvsp[(yyi  1) - (yynrhs)])
                                              , yyscanner);
      YYFPRINTF (stderr, ""\n"");
    }
}

# define YY_REDUCE_PRINT(Rule)          \
do {                                    \
  if (yydebug)                          \
    yy_reduce_print (yyssp, yyvsp, Rule, yyscanner); \
} while (0)

/* Nonzero means print parse trace.  It is left uninitialized so that
   multiple parsers can coexist.  */
int yydebug;
#else /* !YYDEBUG */
# define YYDPRINTF(Args)
# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
# define YY_STACK_PRINT(Bottom, Top)
# define YY_REDUCE_PRINT(Rule)
#endif /* !YYDEBUG */


/* YYINITDEPTH -- initial size of the parser's stacks.  */
#ifndef YYINITDEPTH
# define YYINITDEPTH 200
#endif

/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
   if the built-in stack extension method is used).

   Do not make this value too large; the results are undefined if
   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
   evaluated with infinite-precision integer arithmetic.  */

#ifndef YYMAXDEPTH
# define YYMAXDEPTH 10000
#endif


#if YYERROR_VERBOSE

# ifndef yystrlen
#  if defined __GLIBC__ && defined _STRING_H
#   define yystrlen strlen
#  else
/* Return the length of YYSTR.  */
static YYSIZE_T
yystrlen (const char *yystr)
{
  YYSIZE_T yylen;
  for (yylen = 0; yystr[yylen]; yylen�)
    continue;
  return yylen;
}
#  endif
# endif

# ifndef yystpcpy
#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
#   define yystpcpy stpcpy
#  else
/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
   YYDEST.  */
static char *
yystpcpy (char *yydest, const char *yysrc)
{
  char *yyd = yydest;
  const char *yys = yysrc;
",552,640,"[3, 15, 87, 89]",[]
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_305.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_305.cpp,"/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
#endif

/* Gets input and stuffs it into ""buf"".  number of characters read, or YY_NULL,
 * is returned in ""result"".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
        if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
                { \
                int c = '*'; \
                size_t n; \
                for ( n = 0; n < max_size && \
                             (c = getc( yyin )) != EOF && c != '\n'; � ) \
                        buf[n] = (char) c; \
                if ( c == '\n' ) \
                        buf[n�] = (char) c; \
                if ( c == EOF && ferror( yyin ) ) \
                        YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
                result = n; \
                } \
        else \
                { \
                errno=0; \
                while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
                        { \
                        if( errno != EINTR) \
                                { \
                                YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
                                break; \
                                } \
                        errno=0; \
                        clearerr(yyin); \
                        } \
                }\
\

#endif
","/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
#endif

/* Gets input and stuffs it into ""buf"".  number of characters read, or YY_NULL,
 * is returned in ""result"".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
{ \
int c = '*'; \
size_t n; \
for ( n = 0; n < max_size && \
     (c = getc( yyin )) != EOF && c != '\n'; � ) \
buf[n] = (char) c; \
if ( c == '\n' ) \
buf[n�] = (char) c; \
if ( c == EOF && ferror( yyin ) ) \
YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
result = n; \
} \
else \
{ \
errno=0; \
while ( (result = (int) fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
{ \
if( errno != EINTR) \
{ \
YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
break; \
} \
errno=0; \
clearerr(yyin); \
} \
}\
\

#endif
",836,810,"[21, 31]",[]
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_306.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_306.cpp,"    unput(yytext[strlen(yytext)-1]);
    }
}
        YY_BREAK
case 8:
/* rule 8 can match eol */
YY_RULE_SETUP
#line 106 ""cmFortranLexer.in.l""
{
  unput ('\n');
  BEGIN(INITIAL);
  return UNTERMINATED_STRING;
}
case 9:
YY_RULE_SETUP
#line 112 ""cmFortranLexer.in.l""
{
  cmFortranParser_StringAppend(yyextra, yytext[0]);
}
        YY_BREAK
case 10:
/* rule 10 can match eol */
YY_RULE_SETUP
#line 116 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* Treat comments like */
case 11:
/* rule 11 can match eol */
YY_RULE_SETUP
#line 117 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* empty lines */
case 12:
YY_RULE_SETUP
#line 119 ""cmFortranLexer.in.l""
{ return CPP_LINE_DIRECTIVE; }
case 13:
/* rule 13 can match eol */
YY_RULE_SETUP
#line 120 ""cmFortranLexer.in.l""
{
  yytext[yyleng-1] = 0;
  yylvalp->string = strdup(strchr(yytext, '<')�);
  return CPP_INCLUDE_ANGLE;
}
case 14:
YY_RULE_SETUP
#line 125 ""cmFortranLexer.in.l""
{ return CPP_INCLUDE; }
case 15:
YY_RULE_SETUP
#line 126 ""cmFortranLexer.in.l""
{ return F90PPR_INCLUDE; }
case 16:
YY_RULE_SETUP
#line 127 ""cmFortranLexer.in.l""
{ return COCO_INCLUDE; }
case 17:
YY_RULE_SETUP
#line 129 ""cmFortranLexer.in.l""
{ return CPP_DEFINE; }
case 18:
YY_RULE_SETUP
#line 130 ""cmFortranLexer.in.l""
{ return F90PPR_DEFINE; }
case 19:
YY_RULE_SETUP
#line 132 ""cmFortranLexer.in.l""
{ return CPP_UNDEF; }
case 20:
YY_RULE_SETUP
#line 133 ""cmFortranLexer.in.l""
{ return F90PPR_UNDEF; }
case 21:
YY_RULE_SETUP
#line 135 ""cmFortranLexer.in.l""
{ return CPP_IFDEF; }
case 22:
YY_RULE_SETUP
#line 136 ""cmFortranLexer.in.l""
{ return CPP_IFNDEF; }
case 23:
YY_RULE_SETUP
#line 137 ""cmFortranLexer.in.l""
{ return CPP_IF; }
case 24:
YY_RULE_SETUP
#line 138 ""cmFortranLexer.in.l""
{ return CPP_ELIF; }
case 25:
YY_RULE_SETUP
#line 139 ""cmFortranLexer.in.l""
{ return CPP_ELSE; }
case 26:
YY_RULE_SETUP
#line 140 ""cmFortranLexer.in.l""
{ return CPP_ENDIF; }
case 27:
YY_RULE_SETUP
#line 142 ""cmFortranLexer.in.l""
{ return F90PPR_IFDEF; }
case 28:
YY_RULE_SETUP
#line 143 ""cmFortranLexer.in.l""
{ return F90PPR_IFNDEF; }
case 29:
YY_RULE_SETUP
#line 144 ""cmFortranLexer.in.l""
{ return F90PPR_IF; }
case 30:
YY_RULE_SETUP
#line 145 ""cmFortranLexer.in.l""
{ return F90PPR_ELIF; }
case 31:
YY_RULE_SETUP
#line 146 ""cmFortranLexer.in.l""
{ return F90PPR_ELSE; }
case 32:
YY_RULE_SETUP
#line 147 ""cmFortranLexer.in.l""
{ return F90PPR_ENDIF; }
/* Line continuations, possible involving comments.  */
case 33:
/* rule 33 can match eol */
YY_RULE_SETUP
#line 150 ""cmFortranLexer.in.l""

        YY_BREAK
case 34:
/* rule 34 can match eol */
YY_RULE_SETUP
#line 151 ""cmFortranLexer.in.l""

        YY_BREAK
case 35:
YY_RULE_SETUP
#line 153 ""cmFortranLexer.in.l""
{ return COMMA; }
case 36:
YY_RULE_SETUP
#line 155 ""cmFortranLexer.in.l""
{ return DCOLON; }
case 37:
/* rule 37 can match eol */
YY_RULE_SETUP
#line 157 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 38:
YY_RULE_SETUP
#line 159 ""cmFortranLexer.in.l""
{ return ASSIGNMENT_OP; }
case 39:
YY_RULE_SETUP
#line 161 ""cmFortranLexer.in.l""
{
  yylvalp->string = strdup(yytext);
  return WORD;
}
case 40:
YY_RULE_SETUP
#line 166 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 41:
/* rule 41 can match eol */
YY_RULE_SETUP
#line 168 ""cmFortranLexer.in.l""
{ return EOSTMT; }
case 42:
YY_RULE_SETUP
#line 171 ""cmFortranLexer.in.l""
/* Ignore */
        YY_BREAK
case 43:
/* rule 43 can match eol */
YY_RULE_SETUP
#line 172 ""cmFortranLexer.in.l""
/* Ignore line-endings preceded by \ */
        YY_BREAK
case 44:
YY_RULE_SETUP
#line 174 ""cmFortranLexer.in.l""
{ return *yytext; }
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(free_fmt):
case YY_STATE_EOF(fixed_fmt):
case YY_STATE_EOF(str_sq):
case YY_STATE_EOF(str_dq):
#line 176 ""cmFortranLexer.in.l""
{
  if(!cmFortranParser_FilePop(yyextra) )
    {
    return YY_NULL;
    }
}
        YY_BREAK
case 45:
YY_RULE_SETUP
#line 183 ""cmFortranLexer.in.l""
ECHO;
        YY_BREAK
#line 1291 ""cmFortranLexer.cxx""

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmFortran_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = שּׁ�>yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmFortran_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr  yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
        } /* end of user's declarations */
} /* end of cmFortran_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; � )
                *(dest�) = *(source�);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        yy_size_t num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                yy_size_t new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size = b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmFortran_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmFortran_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmFortran_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars = number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;
        yy_current_state = YY_AT_BOL();

        for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; שּׁ�_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 173 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 173 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 172);

        (void)yyg;
        return yy_is_jam ? 0 : yy_current_state;
}

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

        /* undo effects of setting up yytext */
        *yy_cp = yyg->yy_hold_char;

        if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
                { /* need to shift things up to make room */
                /* � for EOB chars. */
                yy_size_t number_to_move = yyg->yy_n_chars  2;
                char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
                                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
                char *source =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

                while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        *--dest = *--source;

                yy_cp = (int) (dest - source);
                yy_bp = (int) (dest - source);
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

                if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
                        YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
                }

        *--yy_cp = (char) c;

        yyg->yytext_ptr = yy_bp;
        yyg->yy_hold_char = *yy_cp;
        yyg->yy_c_buf_p = yy_cp;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","    unput(yytext[strlen(yytext)-1]);
    }
}
YY_BREAK
case 8:
/* rule 8 can match eol */
YY_RULE_SETUP
#line 99 ""cmFortranLexer.in.l""
{
  unput ('\n');
  BEGIN(INITIAL);
  return UNTERMINATED_STRING;
}
case 9:
YY_RULE_SETUP
#line 105 ""cmFortranLexer.in.l""
{
  cmFortranParser_StringAppend(yyextra, yytext[0]);
}
YY_BREAK
case 10:
/* rule 10 can match eol */
YY_RULE_SETUP
#line 109 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* Treat comments like */
case 11:
/* rule 11 can match eol */
YY_RULE_SETUP
#line 110 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* empty lines */
case 12:
YY_RULE_SETUP
#line 112 ""cmFortranLexer.in.l""
{ return CPP_LINE_DIRECTIVE; }
case 13:
/* rule 13 can match eol */
YY_RULE_SETUP
#line 113 ""cmFortranLexer.in.l""
{
  yytext[yyleng-1] = 0;
  yylvalp->string = strdup(strchr(yytext, '<')�);
  return CPP_INCLUDE_ANGLE;
}
case 14:
YY_RULE_SETUP
#line 118 ""cmFortranLexer.in.l""
{ return CPP_INCLUDE; }
case 15:
YY_RULE_SETUP
#line 119 ""cmFortranLexer.in.l""
{ return F90PPR_INCLUDE; }
case 16:
YY_RULE_SETUP
#line 120 ""cmFortranLexer.in.l""
{ return COCO_INCLUDE; }
case 17:
YY_RULE_SETUP
#line 122 ""cmFortranLexer.in.l""
{ return CPP_DEFINE; }
case 18:
YY_RULE_SETUP
#line 123 ""cmFortranLexer.in.l""
{ return F90PPR_DEFINE; }
case 19:
YY_RULE_SETUP
#line 125 ""cmFortranLexer.in.l""
{ return CPP_UNDEF; }
case 20:
YY_RULE_SETUP
#line 126 ""cmFortranLexer.in.l""
{ return F90PPR_UNDEF; }
case 21:
YY_RULE_SETUP
#line 128 ""cmFortranLexer.in.l""
{ return CPP_IFDEF; }
case 22:
YY_RULE_SETUP
#line 129 ""cmFortranLexer.in.l""
{ return CPP_IFNDEF; }
case 23:
YY_RULE_SETUP
#line 130 ""cmFortranLexer.in.l""
{ return CPP_IF; }
case 24:
YY_RULE_SETUP
#line 131 ""cmFortranLexer.in.l""
{ return CPP_ELIF; }
case 25:
YY_RULE_SETUP
#line 132 ""cmFortranLexer.in.l""
{ return CPP_ELSE; }
case 26:
YY_RULE_SETUP
#line 133 ""cmFortranLexer.in.l""
{ return CPP_ENDIF; }
case 27:
YY_RULE_SETUP
#line 135 ""cmFortranLexer.in.l""
{ return F90PPR_IFDEF; }
case 28:
YY_RULE_SETUP
#line 136 ""cmFortranLexer.in.l""
{ return F90PPR_IFNDEF; }
case 29:
YY_RULE_SETUP
#line 137 ""cmFortranLexer.in.l""
{ return F90PPR_IF; }
case 30:
YY_RULE_SETUP
#line 138 ""cmFortranLexer.in.l""
{ return F90PPR_ELIF; }
case 31:
YY_RULE_SETUP
#line 139 ""cmFortranLexer.in.l""
{ return F90PPR_ELSE; }
case 32:
YY_RULE_SETUP
#line 140 ""cmFortranLexer.in.l""
{ return F90PPR_ENDIF; }
/* Line continuations, possible involving comments.  */
case 33:
/* rule 33 can match eol */
YY_RULE_SETUP
#line 143 ""cmFortranLexer.in.l""

YY_BREAK
case 34:
/* rule 34 can match eol */
YY_RULE_SETUP
#line 144 ""cmFortranLexer.in.l""

YY_BREAK
case 35:
YY_RULE_SETUP
#line 146 ""cmFortranLexer.in.l""
{ return COMMA; }
case 36:
YY_RULE_SETUP
#line 148 ""cmFortranLexer.in.l""
{ return DCOLON; }
case 37:
/* rule 37 can match eol */
YY_RULE_SETUP
#line 150 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 38:
YY_RULE_SETUP
#line 152 ""cmFortranLexer.in.l""
{ return ASSIGNMENT_OP; }
case 39:
YY_RULE_SETUP
#line 154 ""cmFortranLexer.in.l""
{
  yylvalp->string = strdup(yytext);
  return WORD;
}
case 40:
YY_RULE_SETUP
#line 159 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 41:
/* rule 41 can match eol */
YY_RULE_SETUP
#line 161 ""cmFortranLexer.in.l""
{ return EOSTMT; }
case 42:
YY_RULE_SETUP
#line 164 ""cmFortranLexer.in.l""
/* Ignore */
YY_BREAK
case 43:
/* rule 43 can match eol */
YY_RULE_SETUP
#line 165 ""cmFortranLexer.in.l""
/* Ignore line-endings preceded by \ */
YY_BREAK
case 44:
YY_RULE_SETUP
#line 167 ""cmFortranLexer.in.l""
{ return *yytext; }
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(free_fmt):
case YY_STATE_EOF(fixed_fmt):
case YY_STATE_EOF(str_sq):
case YY_STATE_EOF(str_dq):
#line 169 ""cmFortranLexer.in.l""
{
  if(!cmFortranParser_FilePop(yyextra) )
    {
    return YY_NULL;
    }
}
YY_BREAK
case 45:
YY_RULE_SETUP
#line 176 ""cmFortranLexer.in.l""
ECHO;
YY_BREAK
#line 1276 ""cmFortranLexer.cxx""

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmFortran_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = שּׁ�>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmFortran_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmFortran_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; � )
*(dest�) = *(source�);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
int num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
int new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmFortran_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = NULL;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmFortran_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((int) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmFortran_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;
yy_current_state = YY_AT_BOL();

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; שּׁ�_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 173 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 173 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
yy_is_jam = (yy_current_state == 172);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

/* undo effects of setting up yytext */
*yy_cp = yyg->yy_hold_char;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
{ /* need to shift things up to make room */
/* � for EOB chars. */
int number_to_move = yyg->yy_n_chars  2;
char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
char *source =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
*--dest = *--source;

yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
}

*--yy_cp = (char) c;

yyg->yytext_ptr = yy_bp;
yyg->yy_hold_char = *yy_cp;
yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",1070,1044,"[323, 346, 414, 458, 559]",[]
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_307.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_307.cpp," */
    YY_BUFFER_STATE cmFortran_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        b = (YY_BUFFER_STATE) cmFortran_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_create_buffer()"" );

        b->yy_buf_size = size;

        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        b->yy_ch_buf = (char *) cmFortran_yyalloc(b->yy_buf_size  2 ,yyscanner );
        if ( ! b->yy_ch_buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_create_buffer()"" );

        b->yy_is_our_buffer = 1;

        cmFortran_yy_init_buffer(b,file ,yyscanner);

        return b;
}

/** Destroy the buffer.
"," */
    YY_BUFFER_STATE cmFortran_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

b = (YY_BUFFER_STATE) cmFortran_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_create_buffer()"" );

b->yy_buf_size = (yy_size_t)size;

/* yy_ch_buf has to be 2 characters longer than the size given because
 * we need to put in 2 end-of-buffer characters.
 */
b->yy_ch_buf = (char *) cmFortran_yyalloc(b->yy_buf_size  2 ,yyscanner );
if ( ! b->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_create_buffer()"" );

b->yy_is_our_buffer = 1;

cmFortran_yy_init_buffer(b,file ,yyscanner);

return b;
}

/** Destroy the buffer.
",1785,1763,"[7, 16]",[]
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_308.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_308.cpp,"void cmFortran_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        if (!YY_CURRENT_BUFFER)
                return;

        cmFortran_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
        YY_CURRENT_BUFFER_LVALUE = NULL;
        if (yyg->yy_buffer_stack_top > 0)
                --yyg->yy_buffer_stack_top;

        if (YY_CURRENT_BUFFER) {
                cmFortran_yy_load_buffer_state(yyscanner );
                yyg->yy_did_buffer_switch_on_eof = 1;
        }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmFortran_yyensure_buffer_stack (yyscan_t yyscanner)
{
        yy_size_t num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (!yyg->yy_buffer_stack) {

                /* First allocation is just for 2 elements, since we don't know if this
                 * scanner will even need a stack. We use 2 instead of 1 to avoid an
                 * immediate realloc on the next call.
         */
                num_to_alloc = 1;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyalloc
                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yyensure_buffer_stack()"" );

                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

                yyg->yy_buffer_stack_max = num_to_alloc;
                yyg->yy_buffer_stack_top = 0;
                return;
        }

        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

                /* Increase the buffer to prepare for a possible push. */
                int grow_size = 8 /* arbitrary grow size */;

                num_to_alloc = yyg->yy_buffer_stack_max  grow_size;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyrealloc
                                                                (yyg->yy_buffer_stack,
                                                                num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yyensure_buffer_stack()"" );

                /* zero only the new slots.*/
                memset(yyg->yy_buffer_stack  yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
                yyg->yy_buffer_stack_max = num_to_alloc;
        }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
","void cmFortran_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
if (!YY_CURRENT_BUFFER)
return;

cmFortran_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
YY_CURRENT_BUFFER_LVALUE = NULL;
if (yyg->yy_buffer_stack_top > 0)
--yyg->yy_buffer_stack_top;

if (YY_CURRENT_BUFFER) {
cmFortran_yy_load_buffer_state(yyscanner );
yyg->yy_did_buffer_switch_on_eof = 1;
}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmFortran_yyensure_buffer_stack (yyscan_t yyscanner)
{
int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

if (!yyg->yy_buffer_stack) {

/* First allocation is just for 2 elements, since we don't know if this
 * scanner will even need a stack. We use 2 instead of 1 to avoid an
 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
yyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyalloc
(num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yyensure_buffer_stack()"" );

memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

yyg->yy_buffer_stack_max = num_to_alloc;
yyg->yy_buffer_stack_top = 0;
return;
}

if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

/* Increase the buffer to prepare for a possible push. */
yy_size_t grow_size = 8 /* arbitrary grow size */;

num_to_alloc = yyg->yy_buffer_stack_max  grow_size;
yyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyrealloc
(yyg->yy_buffer_stack,
num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yyensure_buffer_stack()"" );

/* zero only the new slots.*/
memset(yyg->yy_buffer_stack  yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
yyg->yy_buffer_stack_max = num_to_alloc;
}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
",1924,1902,"[36, 56]",[]
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_309.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_309.cpp," */
YY_BUFFER_STATE cmFortran_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        if ( size < 2 ||
             base[size-2] != YY_END_OF_BUFFER_CHAR ||
             base[size-1] != YY_END_OF_BUFFER_CHAR )
                /* They forgot to leave room for the EOB's. */
                return 0;

        b = (YY_BUFFER_STATE) cmFortran_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_scan_buffer()"" );

        b->yy_buf_size = size - 2;      /* ""- 2"" to take care of EOB's */
        b->yy_buf_pos = b->yy_ch_buf = base;
        b->yy_is_our_buffer = 0;
        b->yy_input_file = 0;
        b->yy_n_chars = b->yy_buf_size;
        b->yy_is_interactive = 0;
        b->yy_at_bol = 1;
        b->yy_fill_buffer = 0;
        b->yy_buffer_status = YY_BUFFER_NEW;

        cmFortran_yy_switch_to_buffer(b ,yyscanner );

        return b;
}

/** Setup the input buffer state to scan a string. The next call to cmFortran_yylex() will
"," */
YY_BUFFER_STATE cmFortran_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

if ( size < 2 ||
     base[size-2] != YY_END_OF_BUFFER_CHAR ||
     base[size-1] != YY_END_OF_BUFFER_CHAR )
/* They forgot to leave room for the EOB's. */
return NULL;

b = (YY_BUFFER_STATE) cmFortran_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_scan_buffer()"" );

b->yy_buf_size = size - 2;/* ""- 2"" to take care of EOB's */
b->yy_buf_pos = b->yy_ch_buf = base;
b->yy_is_our_buffer = 0;
b->yy_input_file = NULL;
b->yy_n_chars = b->yy_buf_size;
b->yy_is_interactive = 0;
b->yy_at_bol = 1;
b->yy_fill_buffer = 0;
b->yy_buffer_status = YY_BUFFER_NEW;

cmFortran_yy_switch_to_buffer(b ,yyscanner );

return b;
}

/** Setup the input buffer state to scan a string. The next call to cmFortran_yylex() will
",1993,1971,[13],[]
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_310.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_310.cpp," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmFortran_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;
        char *buf;
        yy_size_t n;
        yy_size_t i;

        /* Get memory for full buffer, including space for trailing EOB's. */
        n = _yybytes_len  2;
        buf = (char *) cmFortran_yyalloc(n ,yyscanner );
        if ( ! buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_scan_bytes()"" );

        for ( i = 0; i < _yybytes_len; � )
                buf[i] = yybytes[i];

        buf[_yybytes_len] = buf[_yybytes_len�] = YY_END_OF_BUFFER_CHAR;

        b = cmFortran_yy_scan_buffer(buf,n ,yyscanner);
        if ( ! b )
                YY_FATAL_ERROR( ""bad buffer in cmFortran_yy_scan_bytes()"" );

        /* It's okay to grow etc. this buffer, and we should throw it
         * away when we're done.
         */
        b->yy_is_our_buffer = 1;

        return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
                yytext[yyleng] = yyg->yy_hold_char; \
                yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
                yyg->yy_hold_char = *yyg->yy_c_buf_p; \
                *yyg->yy_c_buf_p = '\0'; \
                yyleng = yyless_macro_arg; \
                } \
        while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

"," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmFortran_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = (yy_size_t) _yybytes_len  2;
buf = (char *) cmFortran_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_scan_bytes()"" );

for ( i = 0; i < (size_t)_yybytes_len; � )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_len�] = YY_END_OF_BUFFER_CHAR;

b = cmFortran_yy_scan_buffer(buf,n ,yyscanner);
if ( ! b )
YY_FATAL_ERROR( ""bad buffer in cmFortran_yy_scan_bytes()"" );

/* It's okay to grow etc. this buffer, and we should throw it
 * away when we're done.
 */
b->yy_is_our_buffer = 1;

return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
(void)yyg;
(void) fprintf( stderr, ""%s\n"", msg );
exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
do \
{ \
/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
yytext[yyleng] = yyg->yy_hold_char; \
yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
yyg->yy_hold_char = *yyg->yy_c_buf_p; \
*yyg->yy_c_buf_p = '\0'; \
yyleng = yyless_macro_arg; \
} \
while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",2041,2019,"[14, 23, 39]",[]
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_311.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_311.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmFortran_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmFortran_yyset_lineno called with no buffer"" );

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmFortran_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmFortran_yyset_column called with no buffer"" );

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmFortran_yy_switch_to_buffer
 */
void cmFortran_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmFortran_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmFortran_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmFortran_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmFortran_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmFortran_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmFortran_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmFortran_yy_switch_to_buffer
 */
void cmFortran_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmFortran_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmFortran_yyget_debug  (yyscan_t yyscanner)
",2183,2163,"[12, 27]",[]
e7b842e18955d13f6d9c021bab4a8935bf282744,Make sure unnused parameters are /*named*/,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_150.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_150.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_312.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_312.cpp,"  return 0;
}

void cmCursesMainForm::AddError(const char* message, const char*)
{
  this->Errors.push_back(message);
}
","  return 0;
}

void cmCursesMainForm::AddError(const char* message, const char* /*unused*/)
{
  this->Errors.push_back(message);
}
",675,675,[3],[]
e7b842e18955d13f6d9c021bab4a8935bf282744,Make sure unnused parameters are /*named*/,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_151.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_151.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_314.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_314.cpp,"  return 0;
}

void cmCursesMainForm::AddError(const char* message, const char*)
{
  this->Errors.push_back(message);
}
","  return 0;
}

void cmCursesMainForm::AddError(const char* message, const char* /*unused*/)
{
  this->Errors.push_back(message);
}
",675,675,[3],[]
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/base64.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_152.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_152.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_315.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_315.cpp,"               table64[obuf[0]],
               table64[obuf[1]]);
      break;
    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;
    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] );
      break;
    }
    output = 4;
  }
  *output = '\0';
  *outptr = base64data; /* return pointer to new data, allocated memory */

  free(convbuf);

  *outlen = strlen(base64data); /* return the length of the new data */

  return CURLE_OK;
}
","               table64[obuf[0]],
               table64[obuf[1]]);
      break;

    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;

    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]]);
      break;
    }
    output = 4;
  }

  /* Zero terminate */
  *output = '\0';

  /* Return the pointer to the new data (allocated memory) */
  *outptr = base64data;

  free(convbuf);

  /* Return the length of the new data */
  *outlen = strlen(base64data);

  return CURLE_OK;
}
",233,233,"[4, 10]",[]
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/conncache.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_153.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_153.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_316.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_316.cpp,"/* returns an allocated key to find a bundle for this connection */
static char *hashkey(struct connectdata *conn)
{
  return aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);
}

/* Look up the bundle with all the connections to the same host this
","/* returns an allocated key to find a bundle for this connection */
static char *hashkey(struct connectdata *conn)
{
  const char *hostname;

  if(conn->bits.proxy)
    hostname = conn->proxy.name;
  else if(conn->bits.conn_to_host)
    hostname = conn->conn_to_host.name;
  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}

/* Look up the bundle with all the connections to the same host this
",132,131,[3],[]
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/cookie.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_154.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_154.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_317.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_317.cpp,"      return 1; /* failure */
  }

  if(c) {
    char *format_ptr;

    fputs(""# Netscape HTTP Cookie File\n""
          ""# http://curl.haxx.se/docs/http-cookies.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);

    for(co = c->cookies; co; co = co->next) {
      if(!co->domain)
        continue;
      format_ptr = get_netscape_format(co);
      if(format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
        if(!use_stdout)
          fclose(out);
        return 1;
      }
      fprintf(out, ""%s\n"", format_ptr);
      free(format_ptr);
    }
  }

  if(!use_stdout)
","      return 1; /* failure */
  }

  fputs(""# Netscape HTTP Cookie File\n""
        ""# https://curl.haxx.se/docs/http-cookies.html\n""
        ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
        out);

  for(co = c->cookies; co; co = co->next) {
    if(!co->domain)
      continue;
    format_ptr = get_netscape_format(co);
    if(format_ptr == NULL) {
      fprintf(out, ""#\n# Fatal libcurl error\n"");
      if(!use_stdout)
        fclose(out);
      return 1;
    }
    fprintf(out, ""%s\n"", format_ptr);
    free(format_ptr);
  }

  if(!use_stdout)
",1267,1301,"[16, 21]",[]
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *value� = *str�;
  *value = 0;

  if('=' != *str�)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    str�;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; str�) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *content� = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *content� = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; i�)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    �;
    if(*s == '""' || *s == '\\') {
      �;
    }
    �;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *d� = '\\';
      }
      *d� = *s�;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; �)
    value[i] = *find_pos�;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i�)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i�)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i�)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlg�;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlg�;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlg�;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc�; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,"[113, 222, 419, 581, 614, 637, 667, 670, 866, 890, 901, 924, 930, 944, 953, 985, 1008, 1026, 1036, 1125]",[]
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_156.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_156.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_319.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_319.cpp,"    return CURLE_FAILED_INIT;
  }

#if defined(USE_LIBSSH2) && defined(HAVE_LIBSSH2_INIT)
  if(libssh2_init(0)) {
    DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));
","    return CURLE_FAILED_INIT;
  }

  (void)Curl_ipv6works();

#if defined(USE_LIBSSH2) && defined(HAVE_LIBSSH2_INIT)
  if(libssh2_init(0)) {
    DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));
",269,271,[5],[]
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_156.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_156.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_320.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_320.cpp,"    if(0 == pollrc) {
      /* timeout! */
      ev->ms = 0;
      /* fprintf(stderr, ""call curl_multi_socket_action( TIMEOUT )\n""); */
      mcode = curl_multi_socket_action(multi, CURL_SOCKET_TIMEOUT, 0,
                                       &ev->running_handles);
    }
","    if(0 == pollrc) {
      /* timeout! */
      ev->ms = 0;
      /* fprintf(stderr, ""call curl_multi_socket_action(TIMEOUT)\n""); */
      mcode = curl_multi_socket_action(multi, CURL_SOCKET_TIMEOUT, 0,
                                       &ev->running_handles);
    }
",609,625,[3],[]
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_321.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_321.cpp,"     information. Which for FILE can't be much more than the file size and
     date. */
  if(data->set.opt_no_body && data->set.include_header && fstated) {
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
","     information. Which for FILE can't be much more than the file size and
     date. */
  if(data->set.opt_no_body && data->set.include_header && fstated) {
    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
",468,472,[3],[]
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_322.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_322.cpp,"    if(result)
      return result;

    if(fstated) {
      time_t filetime = (time_t)statbuf.st_mtime;
      struct tm buffer;
      const struct tm *tm = &buffer;
      result = Curl_gmtime(filetime, &buffer);
      if(result)
        return result;

      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year  1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    }
    /* if we fstat()ed the file, set the file size to make it available post-
       transfer */
    if(fstated)
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }
","    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year  1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }
",479,486,[12],[]
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_158.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_158.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_323.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_323.cpp,"    }
  }

  cmd = aprintf( ""%s%s%s"",
                 data->set.str[STRING_CUSTOMREQUEST]?
                 data->set.str[STRING_CUSTOMREQUEST]:
                 (data->set.ftp_list_only?""NLST"":""LIST""),
                 lstArg? "" "": """",
                 lstArg? lstArg: """" );

  if(!cmd) {
    free(lstArg);
","    }
  }

  cmd = aprintf(""%s%s%s"",
                data->set.str[STRING_CUSTOMREQUEST]?
                data->set.str[STRING_CUSTOMREQUEST]:
                (data->set.ftp_list_only?""NLST"":""LIST""),
                lstArg? "" "": """",
                lstArg? lstArg: """");

  if(!cmd) {
    free(lstArg);
",1513,1524,[3],[]
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_324.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_324.cpp,"
  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
  free(authorization);
  if(!*userp)
","
  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
",309,310,[2],[]
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/http2.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_160.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_160.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_325.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_325.cpp,"  return snprintf(p, len, "" nghttp2/%s"", h2->version_str);
}

/*
 * The implementation of nghttp2_send_callback type. Here we write |data| with
 * size |length| to the network and return the number of bytes actually
","  return snprintf(p, len, "" nghttp2/%s"", h2->version_str);
}

/* HTTP/2 error code to name based on the Error Code Registry.
https://tools.ietf.org/html/rfc7540#page-77
nghttp2_error_code enums are identical.
*/
const char *Curl_http2_strerror(uint32_t err) {
#ifndef NGHTTP2_HAS_HTTP2_STRERROR
  const char *str[] = {
    ""NO_ERROR"",             /* 0x0 */
    ""PROTOCOL_ERROR"",       /* 0x1 */
    ""INTERNAL_ERROR"",       /* 0x2 */
    ""FLOW_CONTROL_ERROR"",   /* 0x3 */
    ""SETTINGS_TIMEOUT"",     /* 0x4 */
    ""STREAM_CLOSED"",        /* 0x5 */
    ""FRAME_SIZE_ERROR"",     /* 0x6 */
    ""REFUSED_STREAM"",       /* 0x7 */
    ""CANCEL"",               /* 0x8 */
    ""COMPRESSION_ERROR"",    /* 0x9 */
    ""CONNECT_ERROR"",        /* 0xA */
    ""ENHANCE_YOUR_CALM"",    /* 0xB */
    ""INADEQUATE_SECURITY"",  /* 0xC */
    ""HTTP_1_1_REQUIRED""     /* 0xD */
  };
  return (err < sizeof str / sizeof str[0]) ? str[err] : ""unknown"";
#else
  return nghttp2_http2_strerror(err);
#endif
}

/*
 * The implementation of nghttp2_send_callback type. Here we write |data| with
 * size |length| to the network and return the number of bytes actually
",183,217,[0],[]
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_161.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_161.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_326.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_326.cpp,"
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    header�;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
  }

  major_status = Curl_gss_init_sec_context(data,
                                           &minor_status,
                                           &neg_ctx->context,
                                           neg_ctx->server_name,
                                           &Curl_spnego_mech_oid,
                                           GSS_C_NO_CHANNEL_BINDINGS,
                                           &input_token,
                                           &output_token,
                                           TRUE,
                                           NULL);
  Curl_safefree(input_token.value);

  neg_ctx->status = major_status;
  if(GSS_ERROR(major_status)) {
    if(output_token.value)
      gss_release_buffer(&discard_st, &output_token);
    Curl_gss_log_error(conn->data, minor_status,
                       ""gss_init_sec_context() failed: "");
    return CURLE_OUT_OF_MEMORY;
  }

  if(!output_token.value || !output_token.length) {
    if(output_token.value)
      gss_release_buffer(&discard_st, &output_token);
    return CURLE_OUT_OF_MEMORY;
  }

  neg_ctx->output_token = output_token;

  return CURLE_OK;
}

CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;
  OM_uint32 discard_st;

  result = Curl_base64_encode(conn->data,
                              neg_ctx->output_token.value,
                              neg_ctx->output_token.length,
                              &encoded, &len);
  if(result) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return result;
  }

  if(!encoded || !len) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return CURLE_REMOTE_ACCESS_DENIED;
  }

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded);
  if(proxy) {
    Curl_safefree(conn->allocptr.proxyuserpwd);
    conn->allocptr.proxyuserpwd = userp;
","
#include ""curl_setup.h""

#if !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""rawstr.h""
#include ""http_negotiate.h""
#include ""vauth/vauth.h""

/* The last 3 #include files should be in this order */
#include ""curl_printf.h""
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct Curl_easy *data = conn->data;
  size_t len;

  /* Point to the username, password, service and host */
  const char *userp;
  const char *passwdp;
  const char *service;
  const char *host;

  /* Point to the correct struct with this */
  struct negotiatedata *neg_ctx;

  if(proxy) {
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    service = data->set.str[STRING_PROXY_SERVICE_NAME] ?
              data->set.str[STRING_PROXY_SERVICE_NAME] : ""HTTP"";
    host = conn->proxy.name;
    neg_ctx = &data->state.proxyneg;
  }
  else {
    userp = conn->user;
    passwdp = conn->passwd;
    service = data->set.str[STRING_SERVICE_NAME] ?
              data->set.str[STRING_SERVICE_NAME] : ""HTTP"";
    host = conn->host.name;
    neg_ctx = &data->state.negotiate;
  }

  /* Not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

  /* Obtain the input token, if any */
  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    header�;

  len = strlen(header);
  if(!len) {
    /* Is this the first call in a new negotiation? */
    if(neg_ctx->context) {
      /* The server rejected our authentication and hasn't suppled any more
      negotiation mechanisms */
      return CURLE_LOGIN_DENIED;
    }
  }

  /* Initilise the security context and decode our challenge */
  return Curl_auth_decode_spnego_message(data, userp, passwdp, service, host,
                                         header, neg_ctx);
}

CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy ? &conn->data->state.proxyneg :
    &conn->data->state.negotiate;
  char *base64 = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;

  result = Curl_auth_create_spnego_message(conn->data, neg_ctx, &base64, &len);
  if(result)
    return result;

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  base64);

  if(proxy) {
    Curl_safefree(conn->allocptr.proxyuserpwd);
    conn->allocptr.proxyuserpwd = userp;
",22,22,[151],[]
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/http_proxy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_162.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_162.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_327.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_327.cpp,"
      if(!result) {
        char *host=(char *)"""";
        const char *proxyconn="""";
        const char *useragent="""";
        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?
          ""1.0"" : ""1.1"";
        char *hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", conn->bits.ipv6_ip?""["":"""",
                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
","
      if(!result) {
        char *host=(char *)"""";
        const char *useragent="""";
        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?
          ""1.0"" : ""1.1"";
        bool ipv6_ip = conn->bits.ipv6_ip;
        char *hostheader;

        /* the hostname may be different */
        if(hostname != conn->host.name)
          ipv6_ip = (strchr(hostname, ':') != NULL);
        hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", ipv6_ip?""["":"""", hostname, ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
",150,160,[8],[]
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_163.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_163.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_328.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_328.cpp," *
 * If you ever want truly portable and good *printf() clones, the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at http://daniel.haxx.se/trio/
 */

#include ""curl_setup.h""

#if defined(DJGPP) && (DJGPP_MINOR < 4)
#undef _MPRINTF_REPLACE /* don't use x_was_used() here */
#endif

#include <curl/mprintf.h>

#include ""curl_memory.h""
"," *
 * If you ever want truly portable and good *printf() clones, the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at https://daniel.haxx.se/projects/trio/
 */

#include ""curl_setup.h""
#include <curl/mprintf.h>

#include ""curl_memory.h""
",32,32,[1],[]
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/multi.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_164.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_164.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_329.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_329.cpp,"}

#ifdef DEBUGBUILD
void Curl_multi_dump(const struct Curl_multi *multi_handle)
{
  struct Curl_multi *multi=(struct Curl_multi *)multi_handle;
  struct SessionHandle *data;
  int i;
  fprintf(stderr, ""* Multi status: %d handles, %d alive\n"",
          multi->num_easy, multi->num_alive);
","}

#ifdef DEBUGBUILD
void Curl_multi_dump(struct Curl_multi *multi)
{
  struct Curl_easy *data;
  int i;
  fprintf(stderr, ""* Multi status: %d handles, %d alive\n"",
          multi->num_easy, multi->num_alive);
",2789,3072,[8],[]
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_165.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_165.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_330.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_330.cpp," * The message SHALL NOT include any LF or CR.
 */

void Curl_failf(struct SessionHandle *data, const char *fmt, ...)
{
  va_list ap;
  size_t len;
"," * The message SHALL NOT include any LF or CR.
 */

void Curl_failf(struct Curl_easy *data, const char *fmt, ...)
{
  va_list ap;
  size_t len;
",140,225,[3],[]
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/sendf.h,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_166.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_166.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_331.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_331.cpp,"
CURLcode Curl_sendf(curl_socket_t sockfd, struct connectdata *,
                    const char *fmt, ...);
void Curl_infof(struct SessionHandle *, const char *fmt, ...);
void Curl_failf(struct SessionHandle *, const char *fmt, ...);

#if defined(CURL_DISABLE_VERBOSE_STRINGS)

","
CURLcode Curl_sendf(curl_socket_t sockfd, struct connectdata *,
                    const char *fmt, ...);
void Curl_infof(struct Curl_easy *, const char *fmt, ...);
void Curl_failf(struct Curl_easy *, const char *fmt, ...);

#if defined(CURL_DISABLE_VERBOSE_STRINGS)

",26,26,[4],[]
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/base64.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_167.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_167.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_332.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_332.cpp,"               table64[obuf[0]],
               table64[obuf[1]]);
      break;
    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;
    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] );
      break;
    }
    output = 4;
  }
  *output = '\0';
  *outptr = base64data; /* return pointer to new data, allocated memory */

  free(convbuf);

  *outlen = strlen(base64data); /* return the length of the new data */

  return CURLE_OK;
}
","               table64[obuf[0]],
               table64[obuf[1]]);
      break;

    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;

    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]]);
      break;
    }
    output = 4;
  }

  /* Zero terminate */
  *output = '\0';

  /* Return the pointer to the new data (allocated memory) */
  *outptr = base64data;

  free(convbuf);

  /* Return the length of the new data */
  *outlen = strlen(base64data);

  return CURLE_OK;
}
",233,233,"[4, 10]",[]
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/conncache.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_168.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_168.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_333.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_333.cpp,"/* returns an allocated key to find a bundle for this connection */
static char *hashkey(struct connectdata *conn)
{
  return aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);
}

/* Look up the bundle with all the connections to the same host this
","/* returns an allocated key to find a bundle for this connection */
static char *hashkey(struct connectdata *conn)
{
  const char *hostname;

  if(conn->bits.proxy)
    hostname = conn->proxy.name;
  else if(conn->bits.conn_to_host)
    hostname = conn->conn_to_host.name;
  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}

/* Look up the bundle with all the connections to the same host this
",132,131,[3],[]
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/cookie.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_169.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_169.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_334.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_334.cpp,"      return 1; /* failure */
  }

  if(c) {
    char *format_ptr;

    fputs(""# Netscape HTTP Cookie File\n""
          ""# http://curl.haxx.se/docs/http-cookies.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);

    for(co = c->cookies; co; co = co->next) {
      if(!co->domain)
        continue;
      format_ptr = get_netscape_format(co);
      if(format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
        if(!use_stdout)
          fclose(out);
        return 1;
      }
      fprintf(out, ""%s\n"", format_ptr);
      free(format_ptr);
    }
  }

  if(!use_stdout)
","      return 1; /* failure */
  }

  fputs(""# Netscape HTTP Cookie File\n""
        ""# https://curl.haxx.se/docs/http-cookies.html\n""
        ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
        out);

  for(co = c->cookies; co; co = co->next) {
    if(!co->domain)
      continue;
    format_ptr = get_netscape_format(co);
    if(format_ptr == NULL) {
      fprintf(out, ""#\n# Fatal libcurl error\n"");
      if(!use_stdout)
        fclose(out);
      return 1;
    }
    fprintf(out, ""%s\n"", format_ptr);
    free(format_ptr);
  }

  if(!use_stdout)
",1267,1301,"[16, 21]",[]
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *value� = *str�;
  *value = 0;

  if('=' != *str�)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    str�;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; str�) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *content� = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *content� = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; i�)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    �;
    if(*s == '""' || *s == '\\') {
      �;
    }
    �;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *d� = '\\';
      }
      *d� = *s�;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; �)
    value[i] = *find_pos�;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i�)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i�)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i�)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlg�;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlg�;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlg�;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc�; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,"[113, 222, 419, 581, 614, 637, 667, 670, 866, 890, 901, 924, 930, 944, 953, 985, 1008, 1026, 1036, 1125]",[]
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_171.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_171.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_336.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_336.cpp,"    return CURLE_FAILED_INIT;
  }

#if defined(USE_LIBSSH2) && defined(HAVE_LIBSSH2_INIT)
  if(libssh2_init(0)) {
    DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));
","    return CURLE_FAILED_INIT;
  }

  (void)Curl_ipv6works();

#if defined(USE_LIBSSH2) && defined(HAVE_LIBSSH2_INIT)
  if(libssh2_init(0)) {
    DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));
",269,271,[5],[]
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_171.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_171.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_337.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_337.cpp,"    if(0 == pollrc) {
      /* timeout! */
      ev->ms = 0;
      /* fprintf(stderr, ""call curl_multi_socket_action( TIMEOUT )\n""); */
      mcode = curl_multi_socket_action(multi, CURL_SOCKET_TIMEOUT, 0,
                                       &ev->running_handles);
    }
","    if(0 == pollrc) {
      /* timeout! */
      ev->ms = 0;
      /* fprintf(stderr, ""call curl_multi_socket_action(TIMEOUT)\n""); */
      mcode = curl_multi_socket_action(multi, CURL_SOCKET_TIMEOUT, 0,
                                       &ev->running_handles);
    }
",609,625,[3],[]
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_172.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_172.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_338.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_338.cpp,"     information. Which for FILE can't be much more than the file size and
     date. */
  if(data->set.opt_no_body && data->set.include_header && fstated) {
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
","     information. Which for FILE can't be much more than the file size and
     date. */
  if(data->set.opt_no_body && data->set.include_header && fstated) {
    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
",468,472,[3],[]
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_172.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_172.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_339.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_339.cpp,"    if(result)
      return result;

    if(fstated) {
      time_t filetime = (time_t)statbuf.st_mtime;
      struct tm buffer;
      const struct tm *tm = &buffer;
      result = Curl_gmtime(filetime, &buffer);
      if(result)
        return result;

      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year  1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    }
    /* if we fstat()ed the file, set the file size to make it available post-
       transfer */
    if(fstated)
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }
","    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year  1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }
",479,486,[12],[]
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_173.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_173.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_340.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_340.cpp,"    }
  }

  cmd = aprintf( ""%s%s%s"",
                 data->set.str[STRING_CUSTOMREQUEST]?
                 data->set.str[STRING_CUSTOMREQUEST]:
                 (data->set.ftp_list_only?""NLST"":""LIST""),
                 lstArg? "" "": """",
                 lstArg? lstArg: """" );

  if(!cmd) {
    free(lstArg);
","    }
  }

  cmd = aprintf(""%s%s%s"",
                data->set.str[STRING_CUSTOMREQUEST]?
                data->set.str[STRING_CUSTOMREQUEST]:
                (data->set.ftp_list_only?""NLST"":""LIST""),
                lstArg? "" "": """",
                lstArg? lstArg: """");

  if(!cmd) {
    free(lstArg);
",1513,1524,[3],[]
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_341.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_341.cpp,"
  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
  free(authorization);
  if(!*userp)
","
  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
",309,310,[2],[]
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/http2.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_175.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_175.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_342.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_342.cpp,"  return snprintf(p, len, "" nghttp2/%s"", h2->version_str);
}

/*
 * The implementation of nghttp2_send_callback type. Here we write |data| with
 * size |length| to the network and return the number of bytes actually
","  return snprintf(p, len, "" nghttp2/%s"", h2->version_str);
}

/* HTTP/2 error code to name based on the Error Code Registry.
https://tools.ietf.org/html/rfc7540#page-77
nghttp2_error_code enums are identical.
*/
const char *Curl_http2_strerror(uint32_t err) {
#ifndef NGHTTP2_HAS_HTTP2_STRERROR
  const char *str[] = {
    ""NO_ERROR"",             /* 0x0 */
    ""PROTOCOL_ERROR"",       /* 0x1 */
    ""INTERNAL_ERROR"",       /* 0x2 */
    ""FLOW_CONTROL_ERROR"",   /* 0x3 */
    ""SETTINGS_TIMEOUT"",     /* 0x4 */
    ""STREAM_CLOSED"",        /* 0x5 */
    ""FRAME_SIZE_ERROR"",     /* 0x6 */
    ""REFUSED_STREAM"",       /* 0x7 */
    ""CANCEL"",               /* 0x8 */
    ""COMPRESSION_ERROR"",    /* 0x9 */
    ""CONNECT_ERROR"",        /* 0xA */
    ""ENHANCE_YOUR_CALM"",    /* 0xB */
    ""INADEQUATE_SECURITY"",  /* 0xC */
    ""HTTP_1_1_REQUIRED""     /* 0xD */
  };
  return (err < sizeof str / sizeof str[0]) ? str[err] : ""unknown"";
#else
  return nghttp2_http2_strerror(err);
#endif
}

/*
 * The implementation of nghttp2_send_callback type. Here we write |data| with
 * size |length| to the network and return the number of bytes actually
",183,217,[0],[]
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_176.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_176.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_343.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_343.cpp,"
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    header�;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
  }

  major_status = Curl_gss_init_sec_context(data,
                                           &minor_status,
                                           &neg_ctx->context,
                                           neg_ctx->server_name,
                                           &Curl_spnego_mech_oid,
                                           GSS_C_NO_CHANNEL_BINDINGS,
                                           &input_token,
                                           &output_token,
                                           TRUE,
                                           NULL);
  Curl_safefree(input_token.value);

  neg_ctx->status = major_status;
  if(GSS_ERROR(major_status)) {
    if(output_token.value)
      gss_release_buffer(&discard_st, &output_token);
    Curl_gss_log_error(conn->data, minor_status,
                       ""gss_init_sec_context() failed: "");
    return CURLE_OUT_OF_MEMORY;
  }

  if(!output_token.value || !output_token.length) {
    if(output_token.value)
      gss_release_buffer(&discard_st, &output_token);
    return CURLE_OUT_OF_MEMORY;
  }

  neg_ctx->output_token = output_token;

  return CURLE_OK;
}

CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;
  OM_uint32 discard_st;

  result = Curl_base64_encode(conn->data,
                              neg_ctx->output_token.value,
                              neg_ctx->output_token.length,
                              &encoded, &len);
  if(result) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return result;
  }

  if(!encoded || !len) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return CURLE_REMOTE_ACCESS_DENIED;
  }

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded);
  if(proxy) {
    Curl_safefree(conn->allocptr.proxyuserpwd);
    conn->allocptr.proxyuserpwd = userp;
","
#include ""curl_setup.h""

#if !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""rawstr.h""
#include ""http_negotiate.h""
#include ""vauth/vauth.h""

/* The last 3 #include files should be in this order */
#include ""curl_printf.h""
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct Curl_easy *data = conn->data;
  size_t len;

  /* Point to the username, password, service and host */
  const char *userp;
  const char *passwdp;
  const char *service;
  const char *host;

  /* Point to the correct struct with this */
  struct negotiatedata *neg_ctx;

  if(proxy) {
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    service = data->set.str[STRING_PROXY_SERVICE_NAME] ?
              data->set.str[STRING_PROXY_SERVICE_NAME] : ""HTTP"";
    host = conn->proxy.name;
    neg_ctx = &data->state.proxyneg;
  }
  else {
    userp = conn->user;
    passwdp = conn->passwd;
    service = data->set.str[STRING_SERVICE_NAME] ?
              data->set.str[STRING_SERVICE_NAME] : ""HTTP"";
    host = conn->host.name;
    neg_ctx = &data->state.negotiate;
  }

  /* Not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

  /* Obtain the input token, if any */
  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    header�;

  len = strlen(header);
  if(!len) {
    /* Is this the first call in a new negotiation? */
    if(neg_ctx->context) {
      /* The server rejected our authentication and hasn't suppled any more
      negotiation mechanisms */
      return CURLE_LOGIN_DENIED;
    }
  }

  /* Initilise the security context and decode our challenge */
  return Curl_auth_decode_spnego_message(data, userp, passwdp, service, host,
                                         header, neg_ctx);
}

CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy ? &conn->data->state.proxyneg :
    &conn->data->state.negotiate;
  char *base64 = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;

  result = Curl_auth_create_spnego_message(conn->data, neg_ctx, &base64, &len);
  if(result)
    return result;

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  base64);

  if(proxy) {
    Curl_safefree(conn->allocptr.proxyuserpwd);
    conn->allocptr.proxyuserpwd = userp;
",22,22,[151],[]
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/http_proxy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_177.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_177.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_344.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_344.cpp,"
      if(!result) {
        char *host=(char *)"""";
        const char *proxyconn="""";
        const char *useragent="""";
        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?
          ""1.0"" : ""1.1"";
        char *hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", conn->bits.ipv6_ip?""["":"""",
                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
","
      if(!result) {
        char *host=(char *)"""";
        const char *useragent="""";
        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?
          ""1.0"" : ""1.1"";
        bool ipv6_ip = conn->bits.ipv6_ip;
        char *hostheader;

        /* the hostname may be different */
        if(hostname != conn->host.name)
          ipv6_ip = (strchr(hostname, ':') != NULL);
        hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", ipv6_ip?""["":"""", hostname, ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
",150,160,[8],[]
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_178.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_178.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_345.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_345.cpp," *
 * If you ever want truly portable and good *printf() clones, the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at http://daniel.haxx.se/trio/
 */

#include ""curl_setup.h""

#if defined(DJGPP) && (DJGPP_MINOR < 4)
#undef _MPRINTF_REPLACE /* don't use x_was_used() here */
#endif

#include <curl/mprintf.h>

#include ""curl_memory.h""
"," *
 * If you ever want truly portable and good *printf() clones, the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at https://daniel.haxx.se/projects/trio/
 */

#include ""curl_setup.h""
#include <curl/mprintf.h>

#include ""curl_memory.h""
",32,32,[1],[]
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/multi.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_179.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_179.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_346.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_346.cpp,"}

#ifdef DEBUGBUILD
void Curl_multi_dump(const struct Curl_multi *multi_handle)
{
  struct Curl_multi *multi=(struct Curl_multi *)multi_handle;
  struct SessionHandle *data;
  int i;
  fprintf(stderr, ""* Multi status: %d handles, %d alive\n"",
          multi->num_easy, multi->num_alive);
","}

#ifdef DEBUGBUILD
void Curl_multi_dump(struct Curl_multi *multi)
{
  struct Curl_easy *data;
  int i;
  fprintf(stderr, ""* Multi status: %d handles, %d alive\n"",
          multi->num_easy, multi->num_alive);
",2789,3072,[8],[]
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_180.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_180.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_347.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_347.cpp," * The message SHALL NOT include any LF or CR.
 */

void Curl_failf(struct SessionHandle *data, const char *fmt, ...)
{
  va_list ap;
  size_t len;
"," * The message SHALL NOT include any LF or CR.
 */

void Curl_failf(struct Curl_easy *data, const char *fmt, ...)
{
  va_list ap;
  size_t len;
",140,225,[3],[]
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/sendf.h,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_181.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_181.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_348.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_348.cpp,"
CURLcode Curl_sendf(curl_socket_t sockfd, struct connectdata *,
                    const char *fmt, ...);
void Curl_infof(struct SessionHandle *, const char *fmt, ...);
void Curl_failf(struct SessionHandle *, const char *fmt, ...);

#if defined(CURL_DISABLE_VERBOSE_STRINGS)

","
CURLcode Curl_sendf(curl_socket_t sockfd, struct connectdata *,
                    const char *fmt, ...);
void Curl_infof(struct Curl_easy *, const char *fmt, ...);
void Curl_failf(struct Curl_easy *, const char *fmt, ...);

#if defined(CURL_DISABLE_VERBOSE_STRINGS)

",26,26,[4],[]
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/tftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_349.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_349.cpp,"             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.data놼굺�,
                              TFTP_OPTION_TSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.data놼굺�, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.data놼굺�,
                              TFTP_OPTION_BLKSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.data놼굺�, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.data놼굺�,
                              TFTP_OPTION_INTERVAL);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.data놼굺�, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
","             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* optional addition of TFTP options */
    if(!data->set.tftp_no_options) {
      /* add tsize option */
      if(data->set.upload && (data->state.infilesize != -1))
        snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
                 data->state.infilesize);
      else
        strcpy(buf, ""0""); /* the destination is large enough */

      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.data놼굺�,
                                TFTP_OPTION_TSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.data놼굺�, buf);
      /* add blksize option */
      snprintf(buf, sizeof(buf), ""%d"", state->requested_blksize);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.data놼굺�,
                                TFTP_OPTION_BLKSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.data놼굺�, buf);

      /* add timeout option */
      snprintf(buf, sizeof(buf), ""%d"", state->retry_time);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.data놼굺�,
                                TFTP_OPTION_INTERVAL);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.data놼굺�, buf);
    }

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
",494,494,"[5, 16, 24]",[]
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/base64.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_183.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_183.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_350.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_350.cpp,"               table64[obuf[0]],
               table64[obuf[1]]);
      break;
    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;
    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] );
      break;
    }
    output = 4;
  }
  *output = '\0';
  *outptr = base64data; /* return pointer to new data, allocated memory */

  free(convbuf);

  *outlen = strlen(base64data); /* return the length of the new data */

  return CURLE_OK;
}
","               table64[obuf[0]],
               table64[obuf[1]]);
      break;

    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;

    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]]);
      break;
    }
    output = 4;
  }

  /* Zero terminate */
  *output = '\0';

  /* Return the pointer to the new data (allocated memory) */
  *outptr = base64data;

  free(convbuf);

  /* Return the length of the new data */
  *outlen = strlen(base64data);

  return CURLE_OK;
}
",233,233,"[4, 10]",[]
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/conncache.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_184.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_184.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_351.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_351.cpp,"/* returns an allocated key to find a bundle for this connection */
static char *hashkey(struct connectdata *conn)
{
  return aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);
}

/* Look up the bundle with all the connections to the same host this
","/* returns an allocated key to find a bundle for this connection */
static char *hashkey(struct connectdata *conn)
{
  const char *hostname;

  if(conn->bits.proxy)
    hostname = conn->proxy.name;
  else if(conn->bits.conn_to_host)
    hostname = conn->conn_to_host.name;
  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}

/* Look up the bundle with all the connections to the same host this
",132,131,[3],[]
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/cookie.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_185.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_185.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_352.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_352.cpp,"      return 1; /* failure */
  }

  if(c) {
    char *format_ptr;

    fputs(""# Netscape HTTP Cookie File\n""
          ""# http://curl.haxx.se/docs/http-cookies.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);

    for(co = c->cookies; co; co = co->next) {
      if(!co->domain)
        continue;
      format_ptr = get_netscape_format(co);
      if(format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
        if(!use_stdout)
          fclose(out);
        return 1;
      }
      fprintf(out, ""%s\n"", format_ptr);
      free(format_ptr);
    }
  }

  if(!use_stdout)
","      return 1; /* failure */
  }

  fputs(""# Netscape HTTP Cookie File\n""
        ""# https://curl.haxx.se/docs/http-cookies.html\n""
        ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
        out);

  for(co = c->cookies; co; co = co->next) {
    if(!co->domain)
      continue;
    format_ptr = get_netscape_format(co);
    if(format_ptr == NULL) {
      fprintf(out, ""#\n# Fatal libcurl error\n"");
      if(!use_stdout)
        fclose(out);
      return 1;
    }
    fprintf(out, ""%s\n"", format_ptr);
    free(format_ptr);
  }

  if(!use_stdout)
",1267,1301,"[16, 21]",[]
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *value� = *str�;
  *value = 0;

  if('=' != *str�)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    str�;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; str�) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *content� = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *content� = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; i�)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    �;
    if(*s == '""' || *s == '\\') {
      �;
    }
    �;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *d� = '\\';
      }
      *d� = *s�;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; �)
    value[i] = *find_pos�;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i�)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i�)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i�)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlg�;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlg�;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlg�;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc�; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,"[113, 222, 419, 581, 614, 637, 667, 670, 866, 890, 901, 924, 930, 944, 953, 985, 1008, 1026, 1036, 1125]",[]
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_187.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_187.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_354.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_354.cpp,"    return CURLE_FAILED_INIT;
  }

#if defined(USE_LIBSSH2) && defined(HAVE_LIBSSH2_INIT)
  if(libssh2_init(0)) {
    DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));
","    return CURLE_FAILED_INIT;
  }

  (void)Curl_ipv6works();

#if defined(USE_LIBSSH2) && defined(HAVE_LIBSSH2_INIT)
  if(libssh2_init(0)) {
    DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));
",269,271,[5],[]
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_187.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_187.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_355.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_355.cpp,"    if(0 == pollrc) {
      /* timeout! */
      ev->ms = 0;
      /* fprintf(stderr, ""call curl_multi_socket_action( TIMEOUT )\n""); */
      mcode = curl_multi_socket_action(multi, CURL_SOCKET_TIMEOUT, 0,
                                       &ev->running_handles);
    }
","    if(0 == pollrc) {
      /* timeout! */
      ev->ms = 0;
      /* fprintf(stderr, ""call curl_multi_socket_action(TIMEOUT)\n""); */
      mcode = curl_multi_socket_action(multi, CURL_SOCKET_TIMEOUT, 0,
                                       &ev->running_handles);
    }
",609,625,[3],[]
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_188.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_188.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_356.cpp,"     information. Which for FILE can't be much more than the file size and
     date. */
  if(data->set.opt_no_body && data->set.include_header && fstated) {
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
","     information. Which for FILE can't be much more than the file size and
     date. */
  if(data->set.opt_no_body && data->set.include_header && fstated) {
    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
",468,472,[3],[]
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_188.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_188.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_357.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_357.cpp,"    if(result)
      return result;

    if(fstated) {
      time_t filetime = (time_t)statbuf.st_mtime;
      struct tm buffer;
      const struct tm *tm = &buffer;
      result = Curl_gmtime(filetime, &buffer);
      if(result)
        return result;

      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year  1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    }
    /* if we fstat()ed the file, set the file size to make it available post-
       transfer */
    if(fstated)
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }
","    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year  1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }
",479,486,[12],[]
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_189.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_189.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_358.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_358.cpp,"    }
  }

  cmd = aprintf( ""%s%s%s"",
                 data->set.str[STRING_CUSTOMREQUEST]?
                 data->set.str[STRING_CUSTOMREQUEST]:
                 (data->set.ftp_list_only?""NLST"":""LIST""),
                 lstArg? "" "": """",
                 lstArg? lstArg: """" );

  if(!cmd) {
    free(lstArg);
","    }
  }

  cmd = aprintf(""%s%s%s"",
                data->set.str[STRING_CUSTOMREQUEST]?
                data->set.str[STRING_CUSTOMREQUEST]:
                (data->set.ftp_list_only?""NLST"":""LIST""),
                lstArg? "" "": """",
                lstArg? lstArg: """");

  if(!cmd) {
    free(lstArg);
",1513,1524,[3],[]
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_359.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_359.cpp,"
  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
  free(authorization);
  if(!*userp)
","
  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
",309,310,[2],[]
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/http2.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_191.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_191.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_360.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_360.cpp,"  return snprintf(p, len, "" nghttp2/%s"", h2->version_str);
}

/*
 * The implementation of nghttp2_send_callback type. Here we write |data| with
 * size |length| to the network and return the number of bytes actually
","  return snprintf(p, len, "" nghttp2/%s"", h2->version_str);
}

/* HTTP/2 error code to name based on the Error Code Registry.
https://tools.ietf.org/html/rfc7540#page-77
nghttp2_error_code enums are identical.
*/
const char *Curl_http2_strerror(uint32_t err) {
#ifndef NGHTTP2_HAS_HTTP2_STRERROR
  const char *str[] = {
    ""NO_ERROR"",             /* 0x0 */
    ""PROTOCOL_ERROR"",       /* 0x1 */
    ""INTERNAL_ERROR"",       /* 0x2 */
    ""FLOW_CONTROL_ERROR"",   /* 0x3 */
    ""SETTINGS_TIMEOUT"",     /* 0x4 */
    ""STREAM_CLOSED"",        /* 0x5 */
    ""FRAME_SIZE_ERROR"",     /* 0x6 */
    ""REFUSED_STREAM"",       /* 0x7 */
    ""CANCEL"",               /* 0x8 */
    ""COMPRESSION_ERROR"",    /* 0x9 */
    ""CONNECT_ERROR"",        /* 0xA */
    ""ENHANCE_YOUR_CALM"",    /* 0xB */
    ""INADEQUATE_SECURITY"",  /* 0xC */
    ""HTTP_1_1_REQUIRED""     /* 0xD */
  };
  return (err < sizeof str / sizeof str[0]) ? str[err] : ""unknown"";
#else
  return nghttp2_http2_strerror(err);
#endif
}

/*
 * The implementation of nghttp2_send_callback type. Here we write |data| with
 * size |length| to the network and return the number of bytes actually
",183,217,[0],[]
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_192.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_192.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_361.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_361.cpp,"
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    header�;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
  }

  major_status = Curl_gss_init_sec_context(data,
                                           &minor_status,
                                           &neg_ctx->context,
                                           neg_ctx->server_name,
                                           &Curl_spnego_mech_oid,
                                           GSS_C_NO_CHANNEL_BINDINGS,
                                           &input_token,
                                           &output_token,
                                           TRUE,
                                           NULL);
  Curl_safefree(input_token.value);

  neg_ctx->status = major_status;
  if(GSS_ERROR(major_status)) {
    if(output_token.value)
      gss_release_buffer(&discard_st, &output_token);
    Curl_gss_log_error(conn->data, minor_status,
                       ""gss_init_sec_context() failed: "");
    return CURLE_OUT_OF_MEMORY;
  }

  if(!output_token.value || !output_token.length) {
    if(output_token.value)
      gss_release_buffer(&discard_st, &output_token);
    return CURLE_OUT_OF_MEMORY;
  }

  neg_ctx->output_token = output_token;

  return CURLE_OK;
}

CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;
  OM_uint32 discard_st;

  result = Curl_base64_encode(conn->data,
                              neg_ctx->output_token.value,
                              neg_ctx->output_token.length,
                              &encoded, &len);
  if(result) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return result;
  }

  if(!encoded || !len) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return CURLE_REMOTE_ACCESS_DENIED;
  }

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded);
  if(proxy) {
    Curl_safefree(conn->allocptr.proxyuserpwd);
    conn->allocptr.proxyuserpwd = userp;
","
#include ""curl_setup.h""

#if !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""rawstr.h""
#include ""http_negotiate.h""
#include ""vauth/vauth.h""

/* The last 3 #include files should be in this order */
#include ""curl_printf.h""
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct Curl_easy *data = conn->data;
  size_t len;

  /* Point to the username, password, service and host */
  const char *userp;
  const char *passwdp;
  const char *service;
  const char *host;

  /* Point to the correct struct with this */
  struct negotiatedata *neg_ctx;

  if(proxy) {
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    service = data->set.str[STRING_PROXY_SERVICE_NAME] ?
              data->set.str[STRING_PROXY_SERVICE_NAME] : ""HTTP"";
    host = conn->proxy.name;
    neg_ctx = &data->state.proxyneg;
  }
  else {
    userp = conn->user;
    passwdp = conn->passwd;
    service = data->set.str[STRING_SERVICE_NAME] ?
              data->set.str[STRING_SERVICE_NAME] : ""HTTP"";
    host = conn->host.name;
    neg_ctx = &data->state.negotiate;
  }

  /* Not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

  /* Obtain the input token, if any */
  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    header�;

  len = strlen(header);
  if(!len) {
    /* Is this the first call in a new negotiation? */
    if(neg_ctx->context) {
      /* The server rejected our authentication and hasn't suppled any more
      negotiation mechanisms */
      return CURLE_LOGIN_DENIED;
    }
  }

  /* Initilise the security context and decode our challenge */
  return Curl_auth_decode_spnego_message(data, userp, passwdp, service, host,
                                         header, neg_ctx);
}

CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy ? &conn->data->state.proxyneg :
    &conn->data->state.negotiate;
  char *base64 = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;

  result = Curl_auth_create_spnego_message(conn->data, neg_ctx, &base64, &len);
  if(result)
    return result;

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  base64);

  if(proxy) {
    Curl_safefree(conn->allocptr.proxyuserpwd);
    conn->allocptr.proxyuserpwd = userp;
",22,22,[151],[]
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/http_proxy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_193.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_193.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_362.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_362.cpp,"
      if(!result) {
        char *host=(char *)"""";
        const char *proxyconn="""";
        const char *useragent="""";
        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?
          ""1.0"" : ""1.1"";
        char *hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", conn->bits.ipv6_ip?""["":"""",
                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
","
      if(!result) {
        char *host=(char *)"""";
        const char *useragent="""";
        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?
          ""1.0"" : ""1.1"";
        bool ipv6_ip = conn->bits.ipv6_ip;
        char *hostheader;

        /* the hostname may be different */
        if(hostname != conn->host.name)
          ipv6_ip = (strchr(hostname, ':') != NULL);
        hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", ipv6_ip?""["":"""", hostname, ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
",150,160,[8],[]
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_194.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_194.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_363.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_363.cpp," *
 * If you ever want truly portable and good *printf() clones, the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at http://daniel.haxx.se/trio/
 */

#include ""curl_setup.h""

#if defined(DJGPP) && (DJGPP_MINOR < 4)
#undef _MPRINTF_REPLACE /* don't use x_was_used() here */
#endif

#include <curl/mprintf.h>

#include ""curl_memory.h""
"," *
 * If you ever want truly portable and good *printf() clones, the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at https://daniel.haxx.se/projects/trio/
 */

#include ""curl_setup.h""
#include <curl/mprintf.h>

#include ""curl_memory.h""
",32,32,[1],[]
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/multi.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_195.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_195.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_364.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_364.cpp,"}

#ifdef DEBUGBUILD
void Curl_multi_dump(const struct Curl_multi *multi_handle)
{
  struct Curl_multi *multi=(struct Curl_multi *)multi_handle;
  struct SessionHandle *data;
  int i;
  fprintf(stderr, ""* Multi status: %d handles, %d alive\n"",
          multi->num_easy, multi->num_alive);
","}

#ifdef DEBUGBUILD
void Curl_multi_dump(struct Curl_multi *multi)
{
  struct Curl_easy *data;
  int i;
  fprintf(stderr, ""* Multi status: %d handles, %d alive\n"",
          multi->num_easy, multi->num_alive);
",2789,3072,[8],[]
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_196.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_196.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_365.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_365.cpp," * The message SHALL NOT include any LF or CR.
 */

void Curl_failf(struct SessionHandle *data, const char *fmt, ...)
{
  va_list ap;
  size_t len;
"," * The message SHALL NOT include any LF or CR.
 */

void Curl_failf(struct Curl_easy *data, const char *fmt, ...)
{
  va_list ap;
  size_t len;
",140,225,[3],[]
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/sendf.h,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_197.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_197.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_366.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_366.cpp,"
CURLcode Curl_sendf(curl_socket_t sockfd, struct connectdata *,
                    const char *fmt, ...);
void Curl_infof(struct SessionHandle *, const char *fmt, ...);
void Curl_failf(struct SessionHandle *, const char *fmt, ...);

#if defined(CURL_DISABLE_VERBOSE_STRINGS)

","
CURLcode Curl_sendf(curl_socket_t sockfd, struct connectdata *,
                    const char *fmt, ...);
void Curl_infof(struct Curl_easy *, const char *fmt, ...);
void Curl_failf(struct Curl_easy *, const char *fmt, ...);

#if defined(CURL_DISABLE_VERBOSE_STRINGS)

",26,26,[4],[]
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/tftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_198.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_198.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_367.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_367.cpp,"             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.data놼굺�,
                              TFTP_OPTION_TSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.data놼굺�, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.data놼굺�,
                              TFTP_OPTION_BLKSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.data놼굺�, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.data놼굺�,
                              TFTP_OPTION_INTERVAL);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.data놼굺�, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
","             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* optional addition of TFTP options */
    if(!data->set.tftp_no_options) {
      /* add tsize option */
      if(data->set.upload && (data->state.infilesize != -1))
        snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
                 data->state.infilesize);
      else
        strcpy(buf, ""0""); /* the destination is large enough */

      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.data놼굺�,
                                TFTP_OPTION_TSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.data놼굺�, buf);
      /* add blksize option */
      snprintf(buf, sizeof(buf), ""%d"", state->requested_blksize);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.data놼굺�,
                                TFTP_OPTION_BLKSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.data놼굺�, buf);

      /* add timeout option */
      snprintf(buf, sizeof(buf), ""%d"", state->retry_time);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.data놼굺�,
                                TFTP_OPTION_INTERVAL);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.data놼굺�, buf);
    }

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
",494,494,"[5, 16, 24]",[]
1d6909a287bb73b5ec7bf51ec56f7efcf2a869eb,use CM_NULLPTR,[],Source/cmSystemTools.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_199.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_199.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_368.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_368.cpp,"
  /* Use uname if it's present, else uid. */
  p = archive_entry_uname(entry);
  if ((p == NULL) || (*p == '\0')) {
    sprintf(tmp, ""%lu "", (unsigned long)archive_entry_uid(entry));
    p = tmp;
  }
","
  /* Use uname if it's present, else uid. */
  p = archive_entry_uname(entry);
  if ((p == CM_NULLPTR) || (*p == '\0')) {
    sprintf(tmp, ""%lu "", (unsigned long)archive_entry_uid(entry));
    p = tmp;
  }
",1432,1433,[4],[]
1d6909a287bb73b5ec7bf51ec56f7efcf2a869eb,use CM_NULLPTR,[],Source/cmSystemTools.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_199.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_199.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_369.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_369.cpp,"  fprintf(out, ""%-*s "", (int)u_width, p);
  /* Use gname if it's present, else gid. */
  p = archive_entry_gname(entry);
  if (p != NULL && p[0] != '\0') {
    fprintf(out, ""%s"", p);
    w = strlen(p);
  } else {
","  fprintf(out, ""%-*s "", (int)u_width, p);
  /* Use gname if it's present, else gid. */
  p = archive_entry_gname(entry);
  if (p != CM_NULLPTR && p[0] != '\0') {
    fprintf(out, ""%s"", p);
    w = strlen(p);
  } else {
",1443,1444,"[0, 4]",[]
1d6909a287bb73b5ec7bf51ec56f7efcf2a869eb,use CM_NULLPTR,[],Source/cmake.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_200.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_200.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_370.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_370.cpp,"
    gg->CreateGenerationObjects();
    cmLocalGenerator* lg = gg->LocalGenerators[0];
    std::string includeFlags = lg->GetIncludeFlags(includeDirs, 0, language);

    std::string definitions = mf->GetSafeDefinition(""PACKAGE_DEFINITIONS"");
    printf(""%s %s\n"", includeFlags.c_str(), definitions.c_str());
","
    gg->CreateGenerationObjects();
    cmLocalGenerator* lg = gg->LocalGenerators[0];
    std::string includeFlags =
      lg->GetIncludeFlags(includeDirs, CM_NULLPTR, language);

    std::string definitions = mf->GetSafeDefinition(""PACKAGE_DEFINITIONS"");
    printf(""%s %s\n"", includeFlags.c_str(), definitions.c_str());
",463,463,[6],[]
d38fc22132db1b82fad1ef5b8a7f5e030c71a90f,Merge branch 'update-libarchive' into release,[],Utilities/cmlibarchive/libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_201.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_201.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_371.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_371.cpp,"  }

  windowoffs = lzss_offset_for_position(&rar->lzss, startpos);
  if(windowoffs  length <= lzss_size(&rar->lzss))
    memcpy(&rar->unp_buffer[rar->unp_offset], &rar->lzss.window[windowoffs],
           length);
  else
  {
    firstpart = lzss_size(&rar->lzss) - windowoffs;
    if (firstpart < 0) {
      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
","  }

  windowoffs = lzss_offset_for_position(&rar->lzss, startpos);
  if(windowoffs  length <= lzss_size(&rar->lzss)) {
    memcpy(&rar->unp_buffer[rar->unp_offset], &rar->lzss.window[windowoffs],
           length);
  } else if (length <= lzss_size(&rar->lzss)) {
    firstpart = lzss_size(&rar->lzss) - windowoffs;
    if (firstpart < 0) {
      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
",2884,2890,[10],[]
d38fc22132db1b82fad1ef5b8a7f5e030c71a90f,Merge branch 'update-libarchive' into release,[],Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_202.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_202.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_372.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_372.cpp,"
/* If a length of full-pathname is longer than 240 bytes,
 * it violates Joliet extensions regulation. */
if (parent_len  np->mb_len > 240) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""The regulation of Joliet extensions;""
    "" A length of a full-pathname of `%s' is ""
","
/* If a length of full-pathname is longer than 240 bytes,
 * it violates Joliet extensions regulation. */
if (parent_len > 240
    || np->mb_len > 240
    || parent_len  np->mb_len > 240) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""The regulation of Joliet extensions;""
    "" A length of a full-pathname of `%s' is ""
",6302,6302,[4],[]
52f58267c311550db83f4a9430f378e730bd3d6b,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2016-06-19 (139d0576)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_203.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_203.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_373.cpp,"  }

  windowoffs = lzss_offset_for_position(&rar->lzss, startpos);
  if(windowoffs  length <= lzss_size(&rar->lzss))
    memcpy(&rar->unp_buffer[rar->unp_offset], &rar->lzss.window[windowoffs],
           length);
  else
  {
    firstpart = lzss_size(&rar->lzss) - windowoffs;
    if (firstpart < 0) {
      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
","  }

  windowoffs = lzss_offset_for_position(&rar->lzss, startpos);
  if(windowoffs  length <= lzss_size(&rar->lzss)) {
    memcpy(&rar->unp_buffer[rar->unp_offset], &rar->lzss.window[windowoffs],
           length);
  } else if (length <= lzss_size(&rar->lzss)) {
    firstpart = lzss_size(&rar->lzss) - windowoffs;
    if (firstpart < 0) {
      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
",2884,2890,[10],[]
52f58267c311550db83f4a9430f378e730bd3d6b,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2016-06-19 (139d0576)",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_204.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_204.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_374.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_374.cpp,"
/* If a length of full-pathname is longer than 240 bytes,
 * it violates Joliet extensions regulation. */
if (parent_len  np->mb_len > 240) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""The regulation of Joliet extensions;""
    "" A length of a full-pathname of `%s' is ""
","
/* If a length of full-pathname is longer than 240 bytes,
 * it violates Joliet extensions regulation. */
if (parent_len > 240
    || np->mb_len > 240
    || parent_len  np->mb_len > 240) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""The regulation of Joliet extensions;""
    "" A length of a full-pathname of `%s' is ""
",6302,6302,[4],[]
2b94d71d8850d68b677d5653c698371528344a10,"LibArchive 2016-06-19 (139d0576)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 139d0576b51a253732a5ab1f66805dffbf8b00af (master).",[],libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_205.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_205.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_375.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_375.cpp,"  }

  windowoffs = lzss_offset_for_position(&rar->lzss, startpos);
  if(windowoffs  length <= lzss_size(&rar->lzss))
    memcpy(&rar->unp_buffer[rar->unp_offset], &rar->lzss.window[windowoffs],
           length);
  else
  {
    firstpart = lzss_size(&rar->lzss) - windowoffs;
    if (firstpart < 0) {
      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
","  }

  windowoffs = lzss_offset_for_position(&rar->lzss, startpos);
  if(windowoffs  length <= lzss_size(&rar->lzss)) {
    memcpy(&rar->unp_buffer[rar->unp_offset], &rar->lzss.window[windowoffs],
           length);
  } else if (length <= lzss_size(&rar->lzss)) {
    firstpart = lzss_size(&rar->lzss) - windowoffs;
    if (firstpart < 0) {
      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
",2884,2890,[10],[]
2b94d71d8850d68b677d5653c698371528344a10,"LibArchive 2016-06-19 (139d0576)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 139d0576b51a253732a5ab1f66805dffbf8b00af (master).",[],libarchive/archive_write_set_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_206.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_206.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_376.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_376.cpp,"
/* If a length of full-pathname is longer than 240 bytes,
 * it violates Joliet extensions regulation. */
if (parent_len  np->mb_len > 240) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""The regulation of Joliet extensions;""
    "" A length of a full-pathname of `%s' is ""
","
/* If a length of full-pathname is longer than 240 bytes,
 * it violates Joliet extensions regulation. */
if (parent_len > 240
    || np->mb_len > 240
    || parent_len  np->mb_len > 240) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""The regulation of Joliet extensions;""
    "" A length of a full-pathname of `%s' is ""
",6302,6302,[4],[]
fb4791b37ccea1f38b8625b31df952408ab942f3,"cmCoreTryCompile: Refactor forwarding of variables to test project

De-duplicate the logic that constructs the cmake `-D` flag used to pass
variables into the test project cache.  Also subsume variables that were
propagated by generating `set()` commands in the project and pass them
as cache entries instead.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_207.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_207.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_377.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_377.cpp,"              fname.c_str());
    }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if (this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"") !=
        0) {
      std::string flag = ""-DCMAKE_OSX_ARCHITECTURES="";
      flag = this->Makefile->GetSafeDefinition(
        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
    } else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"") != 0) {
      std::string flag = ""-DCMAKE_OSX_ARCHITECTURES="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
    }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if (this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"") != 0) {
      std::string flag = ""-DCMAKE_OSX_SYSROOT="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
    }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if (this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"") != 0) {
      std::string flag = ""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
    }
    if (const char* cxxDef =
          this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET"")) {
      std::string flag = ""-DCMAKE_CXX_COMPILER_TARGET="";
      flag = cxxDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* cDef =
          this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET"")) {
      std::string flag = ""-DCMAKE_C_COMPILER_TARGET="";
      flag = cDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* tcxxDef = this->Makefile->GetDefinition(
          ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN"")) {
      std::string flag = ""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag = tcxxDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* tcDef = this->Makefile->GetDefinition(
          ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN"")) {
      std::string flag = ""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag = tcDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* rootDef = this->Makefile->GetDefinition(""CMAKE_SYSROOT"")) {
      std::string flag = ""-DCMAKE_SYSROOT="";
      flag = rootDef;
      cmakeFlags.push_back(flag);
    }
    if (this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"") !=
        0) {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
    }
    if (const char* lssDef =
          this->Makefile->GetDefinition(""CMAKE_LINK_SEARCH_START_STATIC"")) {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef);
    }
    if (const char* lssDef =
          this->Makefile->GetDefinition(""CMAKE_LINK_SEARCH_END_STATIC"")) {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef);
    }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
","              fname.c_str());
    }

    // Forward a set of variables to the inner project cache.
    {
      std::set<std::string> vars;
      vars.insert(kCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN);
      vars.insert(kCMAKE_C_COMPILER_TARGET);
      vars.insert(kCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN);
      vars.insert(kCMAKE_CXX_COMPILER_TARGET);
      vars.insert(kCMAKE_ENABLE_EXPORTS);
      vars.insert(kCMAKE_LINK_SEARCH_END_STATIC);
      vars.insert(kCMAKE_LINK_SEARCH_START_STATIC);
      vars.insert(kCMAKE_OSX_ARCHITECTURES);
      vars.insert(kCMAKE_OSX_DEPLOYMENT_TARGET);
      vars.insert(kCMAKE_OSX_SYSROOT);
      vars.insert(kCMAKE_POSITION_INDEPENDENT_CODE);
      vars.insert(kCMAKE_SYSROOT);

      /* for the TRY_COMPILEs we want to be able to specify the architecture.
         So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
         CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
         have the tests run for each specific architecture. Since
         cmLocalGenerator doesn't allow building for ""the other""
         architecture only via CMAKE_OSX_ARCHITECTURES.
         */
      if (const char* tcArchs = this->Makefile->GetDefinition(
            kCMAKE_TRY_COMPILE_OSX_ARCHITECTURES)) {
        vars.erase(kCMAKE_OSX_ARCHITECTURES);
        std::string flag = ""-DCMAKE_OSX_ARCHITECTURES=""  std::string(tcArchs);
        cmakeFlags.push_back(flag);
      }

      for (std::set<std::string>::iterator vi = vars.begin(); vi != vars.end();
           﫸�) {
        std::string const& var = *vi;
        if (const char* val = this->Makefile->GetDefinition(var)) {
          std::string flag = ""-D""  var  ""=""  val;
          cmakeFlags.push_back(flag);
        }
      }
    }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
",383,405,"[64, 68, 72]",[]
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_378.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_378.cpp," */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
        if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
                { \
                int c = '*'; \
                size_t n; \
                for ( n = 0; n < max_size && \
                             (c = getc( yyin )) != EOF && c != '\n'; � ) \
                        buf[n] = (char) c; \
                if ( c == '\n' ) \
                        buf[n�] = (char) c; \
                if ( c == EOF && ferror( yyin ) ) \
                        YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
                result = n; \
                } \
        else \
                { \
                errno=0; \
                while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
                        { \
                        if( errno != EINTR) \
                                { \
                                YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
                                break; \
                                } \
                        errno=0; \
                        clearerr(yyin); \
                        } \
                }\
\

#endif
"," */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
{ \
int c = '*'; \
size_t n; \
for ( n = 0; n < max_size && \
     (c = getc( yyin )) != EOF && c != '\n'; � ) \
buf[n] = (char) c; \
if ( c == '\n' ) \
buf[n�] = (char) c; \
if ( c == EOF && ferror( yyin ) ) \
YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
result = n; \
} \
else \
{ \
errno=0; \
while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
{ \
if( errno != EINTR) \
{ \
YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
break; \
} \
errno=0; \
clearerr(yyin); \
} \
}\
\

#endif
",761,776,"[13, 23]",[]
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_379.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_379.cpp,"}
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(COMMENT):
#line 277 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_None;
  cmListFileLexerSetToken(lexer, 0, 0);
  return 0;
}
case 24:
YY_RULE_SETUP
#line 283 ""cmListFileLexer.in.l""
ECHO;
        YY_BREAK
#line 1238 ""cmListFileLexer.c""

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmListFileLexer_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = שּׁ�>yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmListFileLexer_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr  yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
} /* end of cmListFileLexer_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; � )
                *(dest�) = *(source�);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        int num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size = b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmListFileLexer_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, (size_t) num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmListFileLexer_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmListFileLexer_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars = number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;

        for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; שּׁ�_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 77 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 77 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 76);

        return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","}
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(COMMENT):
#line 274 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_None;
  cmListFileLexerSetToken(lexer, 0, 0);
  return 0;
}
case 24:
YY_RULE_SETUP
#line 280 ""cmListFileLexer.in.l""
ECHO;
YY_BREAK
#line 1242 ""cmListFileLexer.c""

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmListFileLexer_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = שּׁ�>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmListFileLexer_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmListFileLexer_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; � )
*(dest�) = *(source�);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
yy_size_t num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
yy_size_t new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmListFileLexer_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = 0;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmListFileLexer_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmListFileLexer_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; שּׁ�_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 77 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 77 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
yy_is_jam = (yy_current_state == 76);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

/* undo effects of setting up yytext */
*yy_cp = yyg->yy_hold_char;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
{ /* need to shift things up to make room */
/* � for EOB chars. */
yy_size_t number_to_move = yyg->yy_n_chars  2;
char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
char *source =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
*--dest = *--source;

yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
}

*--yy_cp = (char) c;

    if ( c == '\n' ){
        --yylineno;
    }

yyg->yytext_ptr = yy_bp;
yyg->yy_hold_char = *yy_cp;
yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",1197,1213,"[139, 161, 229, 273]",[]
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_380.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_380.cpp," */
    YY_BUFFER_STATE cmListFileLexer_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        b = (YY_BUFFER_STATE) cmListFileLexer_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" );

        b->yy_buf_size = size;

        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        b->yy_ch_buf = (char *) cmListFileLexer_yyalloc(b->yy_buf_size  2 ,yyscanner );
        if ( ! b->yy_ch_buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" );

        b->yy_is_our_buffer = 1;

        cmListFileLexer_yy_init_buffer(b,file ,yyscanner);

        return b;
}

/** Destroy the buffer.
"," */
    YY_BUFFER_STATE cmListFileLexer_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

b = (YY_BUFFER_STATE) cmListFileLexer_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" );

b->yy_buf_size = (yy_size_t)size;

/* yy_ch_buf has to be 2 characters longer than the size given because
 * we need to put in 2 end-of-buffer characters.
 */
b->yy_ch_buf = (char *) cmListFileLexer_yyalloc(b->yy_buf_size  2 ,yyscanner );
if ( ! b->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" );

b->yy_is_our_buffer = 1;

cmListFileLexer_yy_init_buffer(b,file ,yyscanner);

return b;
}

/** Destroy the buffer.
",1692,1756,"[7, 16]",[]
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_381.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_381.cpp,"void cmListFileLexer_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        if (!YY_CURRENT_BUFFER)
                return;

        cmListFileLexer_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
        YY_CURRENT_BUFFER_LVALUE = NULL;
        if (yyg->yy_buffer_stack_top > 0)
                --yyg->yy_buffer_stack_top;

        if (YY_CURRENT_BUFFER) {
                cmListFileLexer_yy_load_buffer_state(yyscanner );
                yyg->yy_did_buffer_switch_on_eof = 1;
        }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmListFileLexer_yyensure_buffer_stack (yyscan_t yyscanner)
{
        int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (!yyg->yy_buffer_stack) {

                /* First allocation is just for 2 elements, since we don't know if this
                 * scanner will even need a stack. We use 2 instead of 1 to avoid an
                 * immediate realloc on the next call.
         */
                num_to_alloc = 1;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyalloc
                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" );

                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

                yyg->yy_buffer_stack_max = num_to_alloc;
                yyg->yy_buffer_stack_top = 0;
                return;
        }

        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

                /* Increase the buffer to prepare for a possible push. */
                int grow_size = 8 /* arbitrary grow size */;

                num_to_alloc = yyg->yy_buffer_stack_max  grow_size;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyrealloc
                                                                (yyg->yy_buffer_stack,
                                                                num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" );

                /* zero only the new slots.*/
                memset(yyg->yy_buffer_stack  yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
                yyg->yy_buffer_stack_max = num_to_alloc;
        }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
","void cmListFileLexer_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
if (!YY_CURRENT_BUFFER)
return;

cmListFileLexer_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
YY_CURRENT_BUFFER_LVALUE = NULL;
if (yyg->yy_buffer_stack_top > 0)
--yyg->yy_buffer_stack_top;

if (YY_CURRENT_BUFFER) {
cmListFileLexer_yy_load_buffer_state(yyscanner );
yyg->yy_did_buffer_switch_on_eof = 1;
}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmListFileLexer_yyensure_buffer_stack (yyscan_t yyscanner)
{
yy_size_t num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

if (!yyg->yy_buffer_stack) {

/* First allocation is just for 2 elements, since we don't know if this
 * scanner will even need a stack. We use 2 instead of 1 to avoid an
 * immediate realloc on the next call.
         */
num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
yyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyalloc
(num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" );

memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

yyg->yy_buffer_stack_max = num_to_alloc;
yyg->yy_buffer_stack_top = 0;
return;
}

if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

/* Increase the buffer to prepare for a possible push. */
yy_size_t grow_size = 8 /* arbitrary grow size */;

num_to_alloc = yyg->yy_buffer_stack_max  grow_size;
yyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyrealloc
(yyg->yy_buffer_stack,
num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" );

/* zero only the new slots.*/
memset(yyg->yy_buffer_stack  yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
yyg->yy_buffer_stack_max = num_to_alloc;
}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
",1831,1895,"[36, 56]",[]
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_382.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_382.cpp," */
YY_BUFFER_STATE cmListFileLexer_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        if ( size < 2 ||
             base[size-2] != YY_END_OF_BUFFER_CHAR ||
             base[size-1] != YY_END_OF_BUFFER_CHAR )
                /* They forgot to leave room for the EOB's. */
                return 0;

        b = (YY_BUFFER_STATE) cmListFileLexer_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_buffer()"" );

        b->yy_buf_size = size - 2;      /* ""- 2"" to take care of EOB's */
        b->yy_buf_pos = b->yy_ch_buf = base;
        b->yy_is_our_buffer = 0;
        b->yy_input_file = 0;
        b->yy_n_chars = b->yy_buf_size;
        b->yy_is_interactive = 0;
        b->yy_at_bol = 1;
        b->yy_fill_buffer = 0;
        b->yy_buffer_status = YY_BUFFER_NEW;

        cmListFileLexer_yy_switch_to_buffer(b ,yyscanner );

        return b;
}

/** Setup the input buffer state to scan a string. The next call to cmListFileLexer_yylex() will
"," */
YY_BUFFER_STATE cmListFileLexer_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

if ( size < 2 ||
     base[size-2] != YY_END_OF_BUFFER_CHAR ||
     base[size-1] != YY_END_OF_BUFFER_CHAR )
/* They forgot to leave room for the EOB's. */
return 0;

b = (YY_BUFFER_STATE) cmListFileLexer_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_buffer()"" );

b->yy_buf_size = size - 2;/* ""- 2"" to take care of EOB's */
b->yy_buf_pos = b->yy_ch_buf = base;
b->yy_is_our_buffer = 0;
b->yy_input_file = 0;
b->yy_n_chars = b->yy_buf_size;
b->yy_is_interactive = 0;
b->yy_at_bol = 1;
b->yy_fill_buffer = 0;
b->yy_buffer_status = YY_BUFFER_NEW;

cmListFileLexer_yy_switch_to_buffer(b ,yyscanner );

return b;
}

/** Setup the input buffer state to scan a string. The next call to cmListFileLexer_yylex() will
",1900,1964,[13],[]
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_383.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_383.cpp," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;
        char *buf;
        yy_size_t n;
        int i;

        /* Get memory for full buffer, including space for trailing EOB's. */
        n = _yybytes_len  2;
        buf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );
        if ( ! buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" );

        for ( i = 0; i < _yybytes_len; � )
                buf[i] = yybytes[i];

        buf[_yybytes_len] = buf[_yybytes_len�] = YY_END_OF_BUFFER_CHAR;

        b = cmListFileLexer_yy_scan_buffer(buf,n ,yyscanner);
        if ( ! b )
                YY_FATAL_ERROR( ""bad buffer in cmListFileLexer_yy_scan_bytes()"" );

        /* It's okay to grow etc. this buffer, and we should throw it
         * away when we're done.
         */
        b->yy_is_our_buffer = 1;

        return b;
}

#ifndef YY_EXIT_FAILURE
"," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = _yybytes_len  2;
buf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" );

for ( i = 0; i < _yybytes_len; � )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_len�] = YY_END_OF_BUFFER_CHAR;

b = cmListFileLexer_yy_scan_buffer(buf,n ,yyscanner);
if ( ! b )
YY_FATAL_ERROR( ""bad buffer in cmListFileLexer_yy_scan_bytes()"" );

/* It's okay to grow etc. this buffer, and we should throw it
 * away when we're done.
 */
b->yy_is_our_buffer = 1;

return b;
}

#ifndef YY_EXIT_FAILURE
",1948,2012,"[14, 23]",[]
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_384.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_384.cpp,"
static void yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
        (void)yyscanner;
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
                yytext[yyleng] = yyg->yy_hold_char; \
                yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
                yyg->yy_hold_char = *yyg->yy_c_buf_p; \
                *yyg->yy_c_buf_p = '\0'; \
                yyleng = yyless_macro_arg; \
                } \
        while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

","
static void yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
(void)yyg;
(void) fprintf( stderr, ""%s\n"", msg );
exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
do \
{ \
/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
yytext[yyleng] = yyg->yy_hold_char; \
yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
yyg->yy_hold_char = *yyg->yy_c_buf_p; \
*yyg->yy_c_buf_p = '\0'; \
yyleng = yyless_macro_arg; \
} \
while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1984,2048,[4],[]
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_385.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_385.cpp,"}

/** Set the current line number.
 * @param line_number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmListFileLexer_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param line_number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmListFileLexer_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmListFileLexer_yy_switch_to_buffer
 */
void cmListFileLexer_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmListFileLexer_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmListFileLexer_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmListFileLexer_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmListFileLexer_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmListFileLexer_yy_switch_to_buffer
 */
void cmListFileLexer_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmListFileLexer_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmListFileLexer_yyget_debug  (yyscan_t yyscanner)
",2091,2156,"[12, 27]",[]
d9fd2f5402eeaa345691313658e02b51038f570b,"Revise C� coding style using clang-format

Run the `Utilities/Scripts/clang-format.bash` script to update
all our C� code to a new style defined by `.clang-format`.
Use `clang-format` version 3.8.

* If you reached this commit for a line in `git blame`, re-run the blame
  operation starting at the parent of this commit to see older history
  for the content.

* See the parent commit for instructions to rebase a change across this
  style transition commit.",[],Source/CPack/cmCPackDebGenerator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_209.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_209.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_386.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_386.cpp," *      because 16-bit word addressed copies were faster?)  Anyhow, it should
 *      have been ripped out long ago.
 */
static int copy_ar(CF *cfp, off_t size)
{
  static char pad = '\n';
  off_t sz = size;
  size_t nr, nw;
  char buf[8*1024];

  if (sz == 0)
    return 0;

  FILE* from = cfp->rFile;
  FILE* to = cfp->wFile;
  while (sz &&
        (nr = fread(buf, 1, sz < static_cast<off_t>(sizeof(buf))
                    ? static_cast<size_t>(sz) : sizeof(buf), from ))
               > 0) {
    sz -= nr;
    for (size_t off = 0; off < nr; nr -= off, off = nw)
      if ((nw = fwrite(buf  off, 1, nr, to)) < nr)
        return -1;
    }
  if (sz)
    return -2;

  if (cfp->flags & WPAD && (size  ar_already_written) & 1
      && fwrite(&pad, 1, 1, to) != 1)
    return -4;

  return 0;
}

/* put_arobj --  Write an archive member to a file. */
static int put_arobj(CF *cfp, struct stat *sb)
{
  int result = 0;
  struct ar_hdr *hdr;

 /* If passed an sb structure, reading a file from disk.  Get stat(2)
  * information, build a name and construct a header.  (Files are named
  * by their last component in the archive.) */
  const char* name = ar_rname(cfp->rname);
  (void)stat(cfp->rname, sb);

 /* If not truncating names and the name is too long or contains
  * a space, use extended format 1.   */
  size_t lname = strlen(name);
  uid_t uid = sb->st_uid;
  gid_t gid = sb->st_gid;
  if (uid > USHRT_MAX) {
    uid = USHRT_MAX;
    }
  if (gid > USHRT_MAX) {
    gid = USHRT_MAX;
    }
  if (lname > sizeof(hdr->ar_name) || strchr(name, ' '))
    (void)sprintf(ar_hb, HDR1, AR_EFMT1, (int)lname,
                  (long int)sb->st_mtime, (unsigned)uid, (unsigned)gid,
                  (unsigned)sb->st_mode, (long long)sb->st_size  lname,
                  ARFMAG);
    else {
      lname = 0;
      (void)sprintf(ar_hb, HDR2, name,
                    (long int)sb->st_mtime, (unsigned)uid, (unsigned)gid,
                    (unsigned)sb->st_mode, (long long)sb->st_size,
                    ARFMAG);
      }
    off_t size = sb->st_size;

  if (fwrite(ar_hb, 1, sizeof(HDR), cfp->wFile) != sizeof(HDR))
    return -1;
"," *      because 16-bit word addressed copies were faster?)  Anyhow, it should
 *      have been ripped out long ago.
 */
static int copy_ar(CF* cfp, off_t size)
{
  static char pad = '\n';
  off_t sz = size;
  size_t nr, nw;
  char buf[8 * 1024];

  if (sz == 0)
    return 0;

  FILE* from = cfp->rFile;
  FILE* to = cfp->wFile;
  while (sz &&
         (nr = fread(buf, 1, sz < static_cast<off_t>(sizeof(buf))
                       ? static_cast<size_t>(sz)
                       : sizeof(buf),
                     from)) > 0) {
    sz -= nr;
    for (size_t off = 0; off < nr; nr -= off, off = nw)
      if ((nw = fwrite(buf  off, 1, nr, to)) < nr)
        return -1;
  }
  if (sz)
    return -2;

  if (cfp->flags & WPAD && (size  ar_already_written) & 1 &&
      fwrite(&pad, 1, 1, to) != 1)
    return -4;

  return 0;
}

/* put_arobj --  Write an archive member to a file. */
static int put_arobj(CF* cfp, struct stat* sb)
{
  int result = 0;
  struct ar_hdr* hdr;

  /* If passed an sb structure, reading a file from disk.  Get stat(2)
   * information, build a name and construct a header.  (Files are named
   * by their last component in the archive.) */
  const char* name = ar_rname(cfp->rname);
  (void)stat(cfp->rname, sb);

  /* If not truncating names and the name is too long or contains
   * a space, use extended format 1.   */
  size_t lname = strlen(name);
  uid_t uid = sb->st_uid;
  gid_t gid = sb->st_gid;
  if (uid > USHRT_MAX) {
    uid = USHRT_MAX;
  }
  if (gid > USHRT_MAX) {
    gid = USHRT_MAX;
  }
  if (lname > sizeof(hdr->ar_name) || strchr(name, ' '))
    (void)sprintf(ar_hb, HDR1, AR_EFMT1, (int)lname, (long int)sb->st_mtime,
                  (unsigned)uid, (unsigned)gid, (unsigned)sb->st_mode,
                  (long long)sb->st_size  lname, ARFMAG);
  else {
    lname = 0;
    (void)sprintf(ar_hb, HDR2, name, (long int)sb->st_mtime, (unsigned)uid,
                  (unsigned)gid, (unsigned)sb->st_mode, (long long)sb->st_size,
                  ARFMAG);
  }
  off_t size = sb->st_size;

  if (fwrite(ar_hb, 1, sizeof(HDR), cfp->wFile) != sizeof(HDR))
    return -1;
",908,823,"[58, 64]",[]
0ac18d40c8c29a17f1acfcaca506f41a26185901,"Remove `//------...` horizontal separator comments

Modern editors provide plenty of ways to visually separate functions.
Drop the explicit comments that previously served this purpose.
Use the following command to automate the change:

    $ git ls-files -z -- \
        ""*.c"" ""*.cc"" ""*.cpp"" ""*.cxx"" ""*.h"" ""*.hh"" ""*.hpp"" ""*.hxx"" |
      egrep -z -v ""^Source/cmCommandArgumentLexer\."" |
      egrep -z -v ""^Source/cmCommandArgumentParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmDependsJavaLexer\."" |
      egrep -z -v ""^Source/cmDependsJavaParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmExprLexer\."" |
      egrep -z -v ""^Source/cmExprParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmFortranLexer\."" |
      egrep -z -v ""^Source/cmFortranParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmListFileLexer\."" |
      egrep -z -v ""^Source/cm_sha2"" |
      egrep -z -v ""^Source/(kwsys|CursesDialog/form)/"" |
      egrep -z -v ""^Utilities/(KW|cm).*/"" |
      xargs -0 sed -i '/^\(\/\/---*\|\/\*---*\*\/\)$/ {d;}'

This avoids modifying third-party sources and generated sources.",[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_210.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_210.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_387.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_387.cpp,"  fprintf(stderr, ""%s\n"", e.str().c_str());
}

//----------------------------------------------------------------------------
void cmComputeLinkDepends::OrderLinkEntires()
{
  // Compute the DAG of strongly connected components.  The algorithm
","  fprintf(stderr, ""%s\n"", e.str().c_str());
}

void cmComputeLinkDepends::OrderLinkEntires()
{
  // Compute the DAG of strongly connected components.  The algorithm
",714,697,[0],[]
0ac18d40c8c29a17f1acfcaca506f41a26185901,"Remove `//------...` horizontal separator comments

Modern editors provide plenty of ways to visually separate functions.
Drop the explicit comments that previously served this purpose.
Use the following command to automate the change:

    $ git ls-files -z -- \
        ""*.c"" ""*.cc"" ""*.cpp"" ""*.cxx"" ""*.h"" ""*.hh"" ""*.hpp"" ""*.hxx"" |
      egrep -z -v ""^Source/cmCommandArgumentLexer\."" |
      egrep -z -v ""^Source/cmCommandArgumentParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmDependsJavaLexer\."" |
      egrep -z -v ""^Source/cmDependsJavaParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmExprLexer\."" |
      egrep -z -v ""^Source/cmExprParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmFortranLexer\."" |
      egrep -z -v ""^Source/cmFortranParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmListFileLexer\."" |
      egrep -z -v ""^Source/cm_sha2"" |
      egrep -z -v ""^Source/(kwsys|CursesDialog/form)/"" |
      egrep -z -v ""^Utilities/(KW|cm).*/"" |
      xargs -0 sed -i '/^\(\/\/---*\|\/\*---*\*\/\)$/ {d;}'

This avoids modifying third-party sources and generated sources.",[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_210.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_210.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_388.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_388.cpp,"  fprintf(stderr, ""\n"");
}

//----------------------------------------------------------------------------
void cmComputeLinkDepends::VisitComponent(unsigned int c)
{
  // Check if the node has already been visited.
","  fprintf(stderr, ""\n"");
}

void cmComputeLinkDepends::VisitComponent(unsigned int c)
{
  // Check if the node has already been visited.
",793,774,[0],[]
0ac18d40c8c29a17f1acfcaca506f41a26185901,"Remove `//------...` horizontal separator comments

Modern editors provide plenty of ways to visually separate functions.
Drop the explicit comments that previously served this purpose.
Use the following command to automate the change:

    $ git ls-files -z -- \
        ""*.c"" ""*.cc"" ""*.cpp"" ""*.cxx"" ""*.h"" ""*.hh"" ""*.hpp"" ""*.hxx"" |
      egrep -z -v ""^Source/cmCommandArgumentLexer\."" |
      egrep -z -v ""^Source/cmCommandArgumentParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmDependsJavaLexer\."" |
      egrep -z -v ""^Source/cmDependsJavaParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmExprLexer\."" |
      egrep -z -v ""^Source/cmExprParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmFortranLexer\."" |
      egrep -z -v ""^Source/cmFortranParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmListFileLexer\."" |
      egrep -z -v ""^Source/cm_sha2"" |
      egrep -z -v ""^Source/(kwsys|CursesDialog/form)/"" |
      egrep -z -v ""^Utilities/(KW|cm).*/"" |
      xargs -0 sed -i '/^\(\/\/---*\|\/\*---*\*\/\)$/ {d;}'

This avoids modifying third-party sources and generated sources.",[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_210.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_210.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_389.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_389.cpp,"  return count;
}

//----------------------------------------------------------------------------
void cmComputeLinkDepends::DisplayFinalEntries()
{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName().c_str());
","  return count;
}

void cmComputeLinkDepends::DisplayFinalEntries()
{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName().c_str());
",949,926,[6],[]
0ac18d40c8c29a17f1acfcaca506f41a26185901,"Remove `//------...` horizontal separator comments

Modern editors provide plenty of ways to visually separate functions.
Drop the explicit comments that previously served this purpose.
Use the following command to automate the change:

    $ git ls-files -z -- \
        ""*.c"" ""*.cc"" ""*.cpp"" ""*.cxx"" ""*.h"" ""*.hh"" ""*.hpp"" ""*.hxx"" |
      egrep -z -v ""^Source/cmCommandArgumentLexer\."" |
      egrep -z -v ""^Source/cmCommandArgumentParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmDependsJavaLexer\."" |
      egrep -z -v ""^Source/cmDependsJavaParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmExprLexer\."" |
      egrep -z -v ""^Source/cmExprParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmFortranLexer\."" |
      egrep -z -v ""^Source/cmFortranParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmListFileLexer\."" |
      egrep -z -v ""^Source/cm_sha2"" |
      egrep -z -v ""^Source/(kwsys|CursesDialog/form)/"" |
      egrep -z -v ""^Utilities/(KW|cm).*/"" |
      xargs -0 sed -i '/^\(\/\/---*\|\/\*---*\*\/\)$/ {d;}'

This avoids modifying third-party sources and generated sources.",[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_211.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_211.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_390.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_390.cpp,"  fprintf(stderr, ""\n"");
}

//----------------------------------------------------------------------------
void
cmComputeTargetDepends
::DisplayComponents(cmComputeComponentGraph const& ccg)
","  fprintf(stderr, ""\n"");
}

void
cmComputeTargetDepends
::DisplayComponents(cmComputeComponentGraph const& ccg)
",470,458,[0],[]
0ac18d40c8c29a17f1acfcaca506f41a26185901,"Remove `//------...` horizontal separator comments

Modern editors provide plenty of ways to visually separate functions.
Drop the explicit comments that previously served this purpose.
Use the following command to automate the change:

    $ git ls-files -z -- \
        ""*.c"" ""*.cc"" ""*.cpp"" ""*.cxx"" ""*.h"" ""*.hh"" ""*.hpp"" ""*.hxx"" |
      egrep -z -v ""^Source/cmCommandArgumentLexer\."" |
      egrep -z -v ""^Source/cmCommandArgumentParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmDependsJavaLexer\."" |
      egrep -z -v ""^Source/cmDependsJavaParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmExprLexer\."" |
      egrep -z -v ""^Source/cmExprParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmFortranLexer\."" |
      egrep -z -v ""^Source/cmFortranParser(\.y|\.cxx|Tokens\.h)"" |
      egrep -z -v ""^Source/cmListFileLexer\."" |
      egrep -z -v ""^Source/cm_sha2"" |
      egrep -z -v ""^Source/(kwsys|CursesDialog/form)/"" |
      egrep -z -v ""^Utilities/(KW|cm).*/"" |
      xargs -0 sed -i '/^\(\/\/---*\|\/\*---*\*\/\)$/ {d;}'

This avoids modifying third-party sources and generated sources.",[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_211.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_211.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_391.cpp,"  fprintf(stderr, ""\n"");
}

//----------------------------------------------------------------------------
bool
cmComputeTargetDepends
::CheckComponents(cmComputeComponentGraph const& ccg)
","  fprintf(stderr, ""\n"");
}

bool
cmComputeTargetDepends
::CheckComponents(cmComputeComponentGraph const& ccg)
",492,479,[0],[]
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_212.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_212.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_392.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_392.cpp,"while (off_s < size) {
off_s = lseek(*fd, off_s, SEEK_DATA);
if (off_s == (off_t)-1) {
if (errno == ENXIO)
break;/* no more hole */
archive_set_error(&a->archive, errno,
    ""lseek(SEEK_HOLE) failed"");
exit_sts = ARCHIVE_FAILED;
","while (off_s < size) {
off_s = lseek(*fd, off_s, SEEK_DATA);
if (off_s == (off_t)-1) {
if (errno == ENXIO) {
/* no more hole */
if (archive_entry_sparse_count(entry) == 0) {
/* Potentially a fully-sparse file. */
check_fully_sparse = 1;
}
break;
}
archive_set_error(&a->archive, errno,
    ""lseek(SEEK_HOLE) failed"");
exit_sts = ARCHIVE_FAILED;
",1191,1197,[5],[]
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_213.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_213.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_393.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_393.cpp,"archive_set_error(&a->archive, errno, ""fchdir failed"");
return (ARCHIVE_FAILED);
}
vr = statvfs(tree_current_access_path(t), &svfs);
r = statfs(tree_current_access_path(t), &sfs);
if (r == 0)
xr = get_xfer_size(t, -1, tree_current_access_path(t));
#endif
} else {
#ifdef HAVE_FSTATFS
vr = fstatvfs(tree_current_dir_fd(t), &svfs);
r = fstatfs(tree_current_dir_fd(t), &sfs);
if (r == 0)
xr = get_xfer_size(t, tree_current_dir_fd(t), NULL);
","archive_set_error(&a->archive, errno, ""fchdir failed"");
return (ARCHIVE_FAILED);
}
#if defined(HAVE_STATVFS)
vr = statvfs(tree_current_access_path(t), &svfs);
#endif
r = statfs(tree_current_access_path(t), &sfs);
if (r == 0)
xr = get_xfer_size(t, -1, tree_current_access_path(t));
#endif
} else {
#ifdef HAVE_FSTATFS
#if defined(HAVE_FSTATVFS)
vr = fstatvfs(tree_current_dir_fd(t), &svfs);
#endif
r = fstatfs(tree_current_dir_fd(t), &sfs);
if (r == 0)
xr = get_xfer_size(t, tree_current_dir_fd(t), NULL);
",1708,1724,[0],[]
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_213.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_213.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_394.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_394.cpp,"archive_set_error(&a->archive, errno, ""fchdir failed"");
return (ARCHIVE_FAILED);
}
vr = statvfs(""."", &svfs);
r = statfs(""."", &sfs);
if (r == 0)
xr = get_xfer_size(t, -1, ""."");
","archive_set_error(&a->archive, errno, ""fchdir failed"");
return (ARCHIVE_FAILED);
}
#if defined(HAVE_STATVFS)
vr = statvfs(""."", &svfs);
#endif
r = statfs(""."", &sfs);
if (r == 0)
xr = get_xfer_size(t, -1, ""."");
",1724,1744,[0],[]
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_214.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_214.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_395.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_395.cpp,"struct mtree_entry *entry;
struct mtree_option *iter;
const char *next, *eq, *name, *end;
size_t len;
int r;

if ((entry = malloc(sizeof(*entry))) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
","struct mtree_entry *entry;
struct mtree_option *iter;
const char *next, *eq, *name, *end;
size_t name_len, len;
int r, i;

if ((entry = malloc(sizeof(*entry))) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
",852,856,[7],[]
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_214.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_214.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_396.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_396.cpp,"*last_entry = entry;

if (is_form_d) {
/*
 * This form places the file name as last parameter.
 */
name = line  line_len -1;
while (line_len > 0) {
if (*name != '\r' && *name != '\n' &&
    *name != '\t' && *name != ' ')
break;
name--;
line_len--;
}
len = 0;
while (line_len > 0) {
if (*name == '\r' || *name == '\n' ||
    *name == '\t' || *name == ' ') {
name�;
break;
}
name--;
line_len--;
len�;
}
end = name;
} else {
len = strcspn(line, "" \t\r\n"");
name = line;
line = len;
end = line  line_len;
}

if ((entry->name = malloc(len  1)) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
return (ARCHIVE_FATAL);
}

memcpy(entry->name, name, len);
entry->name[len] = '\0';
parse_escapes(entry->name, entry);

for (iter = *global; iter != NULL; iter = iter->next) {
","*last_entry = entry;

if (is_form_d) {
/* Filename is last item on line. */
/* Adjust line_len to trim trailing whitespace */
while (line_len > 0) {
char last_character = line[line_len - 1];
if (last_character == '\r'
    || last_character == '\n'
    || last_character == '\t'
    || last_character == ' ') {
line_len--;
} else {
break;
}
}
/* Name starts after the last whitespace separator */
name = line;
for (i = 0; i < line_len; i�) {
if (line[i] == '\r'
    || line[i] == '\n'
    || line[i] == '\t'
    || line[i] == ' ') {
name = line  i  1;
}
}
name_len = line  line_len - name;
end = name;
} else {
/* Filename is first item on line */
name_len = strcspn(line, "" \t\r\n"");
name = line;
line = name_len;
end = line  line_len;
}
/* name/name_len is the name within the line. */
/* line..end brackets the entire line except the name */

if ((entry->name = malloc(name_len  1)) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
return (ARCHIVE_FATAL);
}

memcpy(entry->name, name, name_len);
entry->name[name_len] = '\0';
parse_escapes(entry->name, entry);

for (iter = *global; iter != NULL; iter = iter->next) {
",873,877,[34],[]
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_215.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_215.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_397.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_397.cpp,"{
struct unknown_tag *tag;

#if DEBUG
fprintf(stderr, ""unknowntag_start:%s\n"", name);
#endif
tag = malloc(sizeof(*tag));
if (tag == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
","{
struct unknown_tag *tag;

tag = malloc(sizeof(*tag));
if (tag == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
",1939,1939,"[4, 8]",[]
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_215.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_215.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_398.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_398.cpp,"{
struct unknown_tag *tag;

#if DEBUG
fprintf(stderr, ""unknowntag_end:%s\n"", name);
#endif
tag = xar->unknowntags;
if (tag == NULL || name == NULL)
return;
if (strcmp(tag->name.s, name) == 0) {
xar->unknowntags = tag->next;
archive_string_free(&(tag->name));
free(tag);
if (xar->unknowntags == NULL)
xar->xmlsts = xar->xmlsts_unknown;
}
}

","{
struct unknown_tag *tag;

tag = xar->unknowntags;
if (tag == NULL || name == NULL)
return;
if (strcmp(tag->name.s, name) == 0) {
xar->unknowntags = tag->next;
archive_string_free(&(tag->name));
free(tag);
if (xar->unknowntags == NULL) {
#if DEBUG
fprintf(stderr, ""UNKNOWNTAG_END:%s\n"", name);
#endif
xar->xmlsts = xar->xmlsts_unknown;
}
}
}

",1963,1963,[4],[]
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_216.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_216.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_399.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_399.cpp,"unsigned short datasize = archive_le16dec(p  offset  2);

offset = 4;
if (offset  datasize > extra_length)
break;
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%04x, length %d\n"",
    headerid, datasize);
","unsigned short datasize = archive_le16dec(p  offset  2);

offset = 4;
if (offset  datasize > extra_length) {
break;
}
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%04x, length %d\n"",
    headerid, datasize);
",419,420,[6],[]
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_216.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_216.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_400.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_400.cpp,"}
}

/* Read the extra data. */
if ((h = __archive_read_ahead(a, extra_length, NULL)) == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file header"");
return (ARCHIVE_FATAL);
}

process_extra(h, extra_length, zip_entry);
__archive_read_consume(a, extra_length);

if (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {
/* If this came from the central dir, it's size info
 * is definitive, so ignore the length-at-end flag. */
","}
}

/* Make sure directories end in '/' */
if ((zip_entry->mode & AE_IFMT) == AE_IFDIR) {
wp = archive_entry_pathname_w(entry);
if (wp != NULL) {
len = wcslen(wp);
if (len > 0 && wp[len - 1] != L'/') {
struct archive_wstring s;
archive_string_init(&s);
archive_wstrcat(&s, wp);
archive_wstrappend_wchar(&s, L'/');
archive_entry_copy_pathname_w(entry, s.s);
}
} else {
cp = archive_entry_pathname(entry);
len = (cp != NULL)?strlen(cp):0;
if (len > 0 && cp[len - 1] != '/') {
struct archive_string s;
archive_string_init(&s);
archive_strcat(&s, cp);
archive_strappend_char(&s, '/');
archive_entry_set_pathname(entry, s.s);
}
}
}

if (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {
/* If this came from the central dir, it's size info
 * is definitive, so ignore the length-at-end flag. */
",843,868,[5],[]
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_lz4.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_217.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_217.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_401.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_401.cpp," * We don't have lz4 library, and execute external lz4 program
 * instead.
 */
data->pdata = __archive_write_program_allocate();
if (data->pdata == NULL) {
free(data);
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
"," * We don't have lz4 library, and execute external lz4 program
 * instead.
 */
data->pdata = __archive_write_program_allocate(""lz4"");
if (data->pdata == NULL) {
free(data);
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
",137,137,[6],[]
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_lz4.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_217.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_217.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_402.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_402.cpp,"struct private_data *data = (struct private_data *)f->data;
int outsize;

if (data->compression_level < 3) {
if (data->lz4_stream == NULL) {
data->lz4_stream = LZ4_createStream();
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
outsize = LZ4_compress_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size);
} else {
if (data->lz4_stream == NULL) {
data->lz4_stream =
    LZ4_createHC(data->in_buffer_allocated);
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
outsize = LZ4_compressHC2_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size, data->compression_level);
}

if (outsize) {
","struct private_data *data = (struct private_data *)f->data;
int outsize;

#define DICT_SIZE(64 * 1024)
#ifdef HAVE_LZ4HC_H
if (data->compression_level >= 3) {
if (data->lz4_stream == NULL) {
#if LZ4_VERSION_MAJOR >= 1 && LZ4_VERSION_MINOR >= 7
data->lz4_stream = LZ4_createStreamHC();
LZ4_resetStreamHC(data->lz4_stream, data->compression_level);
#else
data->lz4_stream =
    LZ4_createHC(data->in_buffer_allocated);
#endif
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
else
LZ4_loadDictHC(data->lz4_stream, data->in_buffer_allocated, DICT_SIZE);

#if LZ4_VERSION_MAJOR >= 1 && LZ4_VERSION_MINOR >= 7
outsize = LZ4_compress_HC_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size);
#else
outsize = LZ4_compressHC2_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size, data->compression_level);
#endif
} else
#endif
{
if (data->lz4_stream == NULL) {
data->lz4_stream = LZ4_createStream();
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
else
LZ4_loadDict(data->lz4_stream, data->in_buffer_allocated, DICT_SIZE);

#if LZ4_VERSION_MAJOR >= 1 && LZ4_VERSION_MINOR >= 7
outsize = LZ4_compress_fast_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size, 1);
#else
outsize = LZ4_compress_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size);
#endif
}

if (outsize) {
",518,547,"[7, 21]",[]
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_403.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_403.cpp,"    &data->child_stdout);
if (child == -1) {
archive_set_error(f->archive, EINVAL,
    ""Can't initialise filter"");
return (ARCHIVE_FATAL);
}
#if defined(_WIN32) && !defined(__CYGWIN__)
","    &data->child_stdout);
if (child == -1) {
archive_set_error(f->archive, EINVAL,
    ""Can't launch external program: %s"", cmd);
return (ARCHIVE_FATAL);
}
#if defined(_WIN32) && !defined(__CYGWIN__)
",231,233,[2],[]
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_404.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_404.cpp,"close(data->child_stdout);
data->child_stdout = -1;
archive_set_error(f->archive, EINVAL,
    ""Can't initialise filter"");
return (ARCHIVE_FATAL);
}
#else
","close(data->child_stdout);
data->child_stdout = -1;
archive_set_error(f->archive, EINVAL,
    ""Can't launch external program: %s"", cmd);
return (ARCHIVE_FATAL);
}
#else
",242,244,[2],[]
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_405.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_405.cpp,"ret = child_write(f, data, buf, length);
if (ret == -1 || ret == 0) {
archive_set_error(f->archive, EIO,
    ""Can't write to filter"");
return (ARCHIVE_FATAL);
}
length -= ret;
","ret = child_write(f, data, buf, length);
if (ret == -1 || ret == 0) {
archive_set_error(f->archive, EIO,
    ""Can't write to program: %s"", data->program_name);
return (ARCHIVE_FATAL);
}
length -= ret;
",334,336,[2],[]
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_406.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_406.cpp,"
if (bytes_read == -1) {
archive_set_error(f->archive, errno,
    ""Read from filter failed unexpectedly."");
ret = ARCHIVE_FATAL;
goto cleanup;
}
","
if (bytes_read == -1) {
archive_set_error(f->archive, errno,
    ""Error reading from program: %s"", data->program_name);
ret = ARCHIVE_FATAL;
goto cleanup;
}
",373,375,[2],[]
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_219.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_219.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_407.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_407.cpp,"if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
/* Reject entries over 4GB. */
if (archive_entry_size_is_set(entry)
    && (archive_entry_size(entry) >
ARCHIVE_LITERAL_LL(0xffffffff))) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Files > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
}
/* Reject entries if archive is > 4GB. */
if (zip->written_bytes > ARCHIVE_LITERAL_LL(0xffffffff)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Archives > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
","if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
/* Reject entries over 4GB. */
if (archive_entry_size_is_set(entry)
    && (archive_entry_size(entry) > ZIP_4GB_MAX)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Files > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
}
/* Reject entries if archive is > 4GB. */
if (zip->written_bytes > ZIP_4GB_MAX) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Archives > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
",532,535,"[5, 11]",[]
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive.h,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_220.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_220.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_408.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_408.cpp," * header and library are very different, you should expect some
 * strangeness.  Don't do that.
 */

/*
 * The version number is expressed as a single integer that makes it
 * easy to compare versions at build time: for version a.b.c, the
 * version number is printf(""%d%03d%03d"",a,b,c).  For example, if you
 * know your application requires version 2.12.108 or later, you can
 * assert that ARCHIVE_VERSION_NUMBER >= 2012108.
 */
/* Note: Compiler will complain if this does not match archive_entry.h! */
#defineARCHIVE_VERSION_NUMBER 3001002
__LA_DECL intarchive_version_number(void);

/*
 * Textual name/version of the library, useful for version displays.
 */
#defineARCHIVE_VERSION_ONLY_STRING ""3.1.2""
#defineARCHIVE_VERSION_STRING ""libarchive "" ARCHIVE_VERSION_ONLY_STRING
__LA_DECL const char *archive_version_string(void);

"," * header and library are very different, you should expect some
 * strangeness.  Don't do that.
 */
__LA_DECL intarchive_version_number(void);

/*
 * Textual name/version of the library, useful for version displays.
 */
#defineARCHIVE_VERSION_ONLY_STRING ""3.2.0""
#defineARCHIVE_VERSION_STRING ""libarchive "" ARCHIVE_VERSION_ONLY_STRING
__LA_DECL const char *archive_version_string(void);

",134,150,[7],[]
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_221.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_221.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_409.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_409.cpp,"while (off_s < size) {
off_s = lseek(*fd, off_s, SEEK_DATA);
if (off_s == (off_t)-1) {
if (errno == ENXIO)
break;/* no more hole */
archive_set_error(&a->archive, errno,
    ""lseek(SEEK_HOLE) failed"");
exit_sts = ARCHIVE_FAILED;
","while (off_s < size) {
off_s = lseek(*fd, off_s, SEEK_DATA);
if (off_s == (off_t)-1) {
if (errno == ENXIO) {
/* no more hole */
if (archive_entry_sparse_count(entry) == 0) {
/* Potentially a fully-sparse file. */
check_fully_sparse = 1;
}
break;
}
archive_set_error(&a->archive, errno,
    ""lseek(SEEK_HOLE) failed"");
exit_sts = ARCHIVE_FAILED;
",1191,1197,[5],[]
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_222.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_222.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_410.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_410.cpp,"archive_set_error(&a->archive, errno, ""fchdir failed"");
return (ARCHIVE_FAILED);
}
vr = statvfs(tree_current_access_path(t), &svfs);
r = statfs(tree_current_access_path(t), &sfs);
if (r == 0)
xr = get_xfer_size(t, -1, tree_current_access_path(t));
#endif
} else {
#ifdef HAVE_FSTATFS
vr = fstatvfs(tree_current_dir_fd(t), &svfs);
r = fstatfs(tree_current_dir_fd(t), &sfs);
if (r == 0)
xr = get_xfer_size(t, tree_current_dir_fd(t), NULL);
","archive_set_error(&a->archive, errno, ""fchdir failed"");
return (ARCHIVE_FAILED);
}
#if defined(HAVE_STATVFS)
vr = statvfs(tree_current_access_path(t), &svfs);
#endif
r = statfs(tree_current_access_path(t), &sfs);
if (r == 0)
xr = get_xfer_size(t, -1, tree_current_access_path(t));
#endif
} else {
#ifdef HAVE_FSTATFS
#if defined(HAVE_FSTATVFS)
vr = fstatvfs(tree_current_dir_fd(t), &svfs);
#endif
r = fstatfs(tree_current_dir_fd(t), &sfs);
if (r == 0)
xr = get_xfer_size(t, tree_current_dir_fd(t), NULL);
",1708,1724,[0],[]
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_222.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_222.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_411.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_411.cpp,"archive_set_error(&a->archive, errno, ""fchdir failed"");
return (ARCHIVE_FAILED);
}
vr = statvfs(""."", &svfs);
r = statfs(""."", &sfs);
if (r == 0)
xr = get_xfer_size(t, -1, ""."");
","archive_set_error(&a->archive, errno, ""fchdir failed"");
return (ARCHIVE_FAILED);
}
#if defined(HAVE_STATVFS)
vr = statvfs(""."", &svfs);
#endif
r = statfs(""."", &sfs);
if (r == 0)
xr = get_xfer_size(t, -1, ""."");
",1724,1744,[0],[]
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_223.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_223.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_412.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_412.cpp,"struct mtree_entry *entry;
struct mtree_option *iter;
const char *next, *eq, *name, *end;
size_t len;
int r;

if ((entry = malloc(sizeof(*entry))) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
","struct mtree_entry *entry;
struct mtree_option *iter;
const char *next, *eq, *name, *end;
size_t name_len, len;
int r, i;

if ((entry = malloc(sizeof(*entry))) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
",852,856,[7],[]
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_223.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_223.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_413.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_413.cpp,"*last_entry = entry;

if (is_form_d) {
/*
 * This form places the file name as last parameter.
 */
name = line  line_len -1;
while (line_len > 0) {
if (*name != '\r' && *name != '\n' &&
    *name != '\t' && *name != ' ')
break;
name--;
line_len--;
}
len = 0;
while (line_len > 0) {
if (*name == '\r' || *name == '\n' ||
    *name == '\t' || *name == ' ') {
name�;
break;
}
name--;
line_len--;
len�;
}
end = name;
} else {
len = strcspn(line, "" \t\r\n"");
name = line;
line = len;
end = line  line_len;
}

if ((entry->name = malloc(len  1)) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
return (ARCHIVE_FATAL);
}

memcpy(entry->name, name, len);
entry->name[len] = '\0';
parse_escapes(entry->name, entry);

for (iter = *global; iter != NULL; iter = iter->next) {
","*last_entry = entry;

if (is_form_d) {
/* Filename is last item on line. */
/* Adjust line_len to trim trailing whitespace */
while (line_len > 0) {
char last_character = line[line_len - 1];
if (last_character == '\r'
    || last_character == '\n'
    || last_character == '\t'
    || last_character == ' ') {
line_len--;
} else {
break;
}
}
/* Name starts after the last whitespace separator */
name = line;
for (i = 0; i < line_len; i�) {
if (line[i] == '\r'
    || line[i] == '\n'
    || line[i] == '\t'
    || line[i] == ' ') {
name = line  i  1;
}
}
name_len = line  line_len - name;
end = name;
} else {
/* Filename is first item on line */
name_len = strcspn(line, "" \t\r\n"");
name = line;
line = name_len;
end = line  line_len;
}
/* name/name_len is the name within the line. */
/* line..end brackets the entire line except the name */

if ((entry->name = malloc(name_len  1)) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
return (ARCHIVE_FATAL);
}

memcpy(entry->name, name, name_len);
entry->name[name_len] = '\0';
parse_escapes(entry->name, entry);

for (iter = *global; iter != NULL; iter = iter->next) {
",873,877,[34],[]
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_224.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_224.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_414.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_414.cpp,"{
struct unknown_tag *tag;

#if DEBUG
fprintf(stderr, ""unknowntag_start:%s\n"", name);
#endif
tag = malloc(sizeof(*tag));
if (tag == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
","{
struct unknown_tag *tag;

tag = malloc(sizeof(*tag));
if (tag == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
",1939,1939,"[4, 8]",[]
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_224.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_224.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_415.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_415.cpp,"{
struct unknown_tag *tag;

#if DEBUG
fprintf(stderr, ""unknowntag_end:%s\n"", name);
#endif
tag = xar->unknowntags;
if (tag == NULL || name == NULL)
return;
if (strcmp(tag->name.s, name) == 0) {
xar->unknowntags = tag->next;
archive_string_free(&(tag->name));
free(tag);
if (xar->unknowntags == NULL)
xar->xmlsts = xar->xmlsts_unknown;
}
}

","{
struct unknown_tag *tag;

tag = xar->unknowntags;
if (tag == NULL || name == NULL)
return;
if (strcmp(tag->name.s, name) == 0) {
xar->unknowntags = tag->next;
archive_string_free(&(tag->name));
free(tag);
if (xar->unknowntags == NULL) {
#if DEBUG
fprintf(stderr, ""UNKNOWNTAG_END:%s\n"", name);
#endif
xar->xmlsts = xar->xmlsts_unknown;
}
}
}

",1963,1963,[4],[]
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_225.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_225.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_416.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_416.cpp,"unsigned short datasize = archive_le16dec(p  offset  2);

offset = 4;
if (offset  datasize > extra_length)
break;
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%04x, length %d\n"",
    headerid, datasize);
","unsigned short datasize = archive_le16dec(p  offset  2);

offset = 4;
if (offset  datasize > extra_length) {
break;
}
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%04x, length %d\n"",
    headerid, datasize);
",419,420,[6],[]
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_225.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_225.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_417.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_417.cpp,"}
}

/* Read the extra data. */
if ((h = __archive_read_ahead(a, extra_length, NULL)) == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file header"");
return (ARCHIVE_FATAL);
}

process_extra(h, extra_length, zip_entry);
__archive_read_consume(a, extra_length);

if (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {
/* If this came from the central dir, it's size info
 * is definitive, so ignore the length-at-end flag. */
","}
}

/* Make sure directories end in '/' */
if ((zip_entry->mode & AE_IFMT) == AE_IFDIR) {
wp = archive_entry_pathname_w(entry);
if (wp != NULL) {
len = wcslen(wp);
if (len > 0 && wp[len - 1] != L'/') {
struct archive_wstring s;
archive_string_init(&s);
archive_wstrcat(&s, wp);
archive_wstrappend_wchar(&s, L'/');
archive_entry_copy_pathname_w(entry, s.s);
}
} else {
cp = archive_entry_pathname(entry);
len = (cp != NULL)?strlen(cp):0;
if (len > 0 && cp[len - 1] != '/') {
struct archive_string s;
archive_string_init(&s);
archive_strcat(&s, cp);
archive_strappend_char(&s, '/');
archive_entry_set_pathname(entry, s.s);
}
}
}

if (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {
/* If this came from the central dir, it's size info
 * is definitive, so ignore the length-at-end flag. */
",843,868,[5],[]
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_lz4.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_226.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_226.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_418.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_418.cpp," * We don't have lz4 library, and execute external lz4 program
 * instead.
 */
data->pdata = __archive_write_program_allocate();
if (data->pdata == NULL) {
free(data);
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
"," * We don't have lz4 library, and execute external lz4 program
 * instead.
 */
data->pdata = __archive_write_program_allocate(""lz4"");
if (data->pdata == NULL) {
free(data);
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
",137,137,[6],[]
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_lz4.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_226.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_226.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_419.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_419.cpp,"struct private_data *data = (struct private_data *)f->data;
int outsize;

if (data->compression_level < 3) {
if (data->lz4_stream == NULL) {
data->lz4_stream = LZ4_createStream();
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
outsize = LZ4_compress_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size);
} else {
if (data->lz4_stream == NULL) {
data->lz4_stream =
    LZ4_createHC(data->in_buffer_allocated);
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
outsize = LZ4_compressHC2_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size, data->compression_level);
}

if (outsize) {
","struct private_data *data = (struct private_data *)f->data;
int outsize;

#define DICT_SIZE(64 * 1024)
#ifdef HAVE_LZ4HC_H
if (data->compression_level >= 3) {
if (data->lz4_stream == NULL) {
#if LZ4_VERSION_MAJOR >= 1 && LZ4_VERSION_MINOR >= 7
data->lz4_stream = LZ4_createStreamHC();
LZ4_resetStreamHC(data->lz4_stream, data->compression_level);
#else
data->lz4_stream =
    LZ4_createHC(data->in_buffer_allocated);
#endif
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
else
LZ4_loadDictHC(data->lz4_stream, data->in_buffer_allocated, DICT_SIZE);

#if LZ4_VERSION_MAJOR >= 1 && LZ4_VERSION_MINOR >= 7
outsize = LZ4_compress_HC_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size);
#else
outsize = LZ4_compressHC2_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size, data->compression_level);
#endif
} else
#endif
{
if (data->lz4_stream == NULL) {
data->lz4_stream = LZ4_createStream();
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
else
LZ4_loadDict(data->lz4_stream, data->in_buffer_allocated, DICT_SIZE);

#if LZ4_VERSION_MAJOR >= 1 && LZ4_VERSION_MINOR >= 7
outsize = LZ4_compress_fast_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size, 1);
#else
outsize = LZ4_compress_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size);
#endif
}

if (outsize) {
",518,547,"[7, 21]",[]
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_420.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_420.cpp,"    &data->child_stdout);
if (child == -1) {
archive_set_error(f->archive, EINVAL,
    ""Can't initialise filter"");
return (ARCHIVE_FATAL);
}
#if defined(_WIN32) && !defined(__CYGWIN__)
","    &data->child_stdout);
if (child == -1) {
archive_set_error(f->archive, EINVAL,
    ""Can't launch external program: %s"", cmd);
return (ARCHIVE_FATAL);
}
#if defined(_WIN32) && !defined(__CYGWIN__)
",231,233,[2],[]
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_421.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_421.cpp,"close(data->child_stdout);
data->child_stdout = -1;
archive_set_error(f->archive, EINVAL,
    ""Can't initialise filter"");
return (ARCHIVE_FATAL);
}
#else
","close(data->child_stdout);
data->child_stdout = -1;
archive_set_error(f->archive, EINVAL,
    ""Can't launch external program: %s"", cmd);
return (ARCHIVE_FATAL);
}
#else
",242,244,[2],[]
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_422.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_422.cpp,"ret = child_write(f, data, buf, length);
if (ret == -1 || ret == 0) {
archive_set_error(f->archive, EIO,
    ""Can't write to filter"");
return (ARCHIVE_FATAL);
}
length -= ret;
","ret = child_write(f, data, buf, length);
if (ret == -1 || ret == 0) {
archive_set_error(f->archive, EIO,
    ""Can't write to program: %s"", data->program_name);
return (ARCHIVE_FATAL);
}
length -= ret;
",334,336,[2],[]
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_423.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_423.cpp,"
if (bytes_read == -1) {
archive_set_error(f->archive, errno,
    ""Read from filter failed unexpectedly."");
ret = ARCHIVE_FATAL;
goto cleanup;
}
","
if (bytes_read == -1) {
archive_set_error(f->archive, errno,
    ""Error reading from program: %s"", data->program_name);
ret = ARCHIVE_FATAL;
goto cleanup;
}
",373,375,[2],[]
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_228.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_228.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_424.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_424.cpp,"if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
/* Reject entries over 4GB. */
if (archive_entry_size_is_set(entry)
    && (archive_entry_size(entry) > 0xffffffff)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Files > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
}
/* Reject entries if archive is > 4GB. */
if (zip->written_bytes > 0xffffffff) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Archives > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
","if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
/* Reject entries over 4GB. */
if (archive_entry_size_is_set(entry)
    && (archive_entry_size(entry) > ZIP_4GB_MAX)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Files > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
}
/* Reject entries if archive is > 4GB. */
if (zip->written_bytes > ZIP_4GB_MAX) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Archives > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
",532,535,"[4, 10]",[]
7f1bd9fe6910f7633d98dec018cc01331a46b87e,"try_compile: Add option to control type of target

Create a `CMAKE_TRY_COMPILE_TARGET_TYPE` option to specify use
of `add_library(... STATIC ...)` for the generated test project.
This will be useful for cross-compiling toolchains that cannot
link a binary without custom flags or scripts.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_229.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_229.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_425.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_425.cpp,"      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName.c_str());
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); 靖�)
      {
","      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }

    if (targetType == cmState::EXECUTABLE)
      {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
      }
    else // if (targetType == cmState::STATIC_LIBRARY)
      {
      /* Put the static library at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual static library.  */
      fprintf(fout, ""add_library(%s STATIC"", targetName.c_str());
      }
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); 靖�)
      {
",486,515,"[0, 4, 7]",[]
1c1ace2db012919f23b6de5400ab192b9277dfc6,"De-duplicate symbols listed in generated module definition files

MS tools have a limit on the number of symbols that can be listed
in a `.def` file.  If multiple `.obj` files provide a symbol then
avoid listing it more than once in the generated `.def` file to
avoid counting toward the limit.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_426.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_426.cpp,"                symbol.erase(0,1);
                }
              }
            if (this->ImportFlag) {
               this->ImportFlag = false;
               fprintf(this->FileOut,""EXPORTS \n"");
            }
            /*
            Check whether it is ""Scalar deleting destructor"" and
            ""Vector deleting destructor""
","                symbol.erase(0,1);
                }
              }
            /*
            Check whether it is ""Scalar deleting destructor"" and
            ""Vector deleting destructor""
",296,298,[5],[]
1c1ace2db012919f23b6de5400ab192b9277dfc6,"De-duplicate symbols listed in generated module definition files

MS tools have a limit on the number of symbols that can be listed
in a `.def` file.  If multiple `.obj` files provide a symbol then
avoid listing it more than once in the generated `.def` file to
avoid counting toward the limit.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_427.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_427.cpp,"                 SectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str());
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     fprintf(this->FileOut, ""\t%s\n"", symbol.c_str());
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
","                 SectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  this->DataSymbols.insert(symbol);
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     this->Symbols.insert(symbol);
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
",319,317,"[3, 7, 9]",[]
1c1ace2db012919f23b6de5400ab192b9277dfc6,"De-duplicate symbols listed in generated module definition files

MS tools have a limit on the number of symbols that can be listed
in a `.def` file.  If multiple `.obj` files provide a symbol then
avoid listing it more than once in the generated `.def` file to
avoid counting toward the limit.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_428.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_428.cpp,"            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!this->ImportFlag) {
               this->ImportFlag = true;
               fprintf(this->FileOut,""IMPORTS \n"");
            }
            fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()�);
         }
      }

","            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            this->DataSymbols.insert(symbol);
         }
      }

",340,338,"[5, 7]",[]
ba819f49df33b546072a5928de3253770c4716b9,"cmFortranParser: Parse #line directives

Teach the lexer to extract the #line directive prefix and line number as
a new token type.  Teach the parser to recognize this token followed by
a string as the file name (plus possibly other content).  Report the
named file as included by the source file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_429.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_429.cpp,"
        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmFortran_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmFortran_yyset_column (int  column_no , yyscan_t yyscanner)
","
        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmFortran_yyset_lineno called with no buffer"" );

    yylineno = line_number;
}

/** Set the current column.
 * @param line_number
 * @param yyscanner The scanner object.
 */
void cmFortran_yyset_column (int  column_no , yyscan_t yyscanner)
",2174,2192,[3],[]
ba819f49df33b546072a5928de3253770c4716b9,"cmFortranParser: Parse #line directives

Teach the lexer to extract the #line directive prefix and line number as
a new token type.  Teach the parser to recognize this token followed by
a string as the file name (plus possibly other content).  Report the
named file as included by the source file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_430.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_430.cpp,"
        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmFortran_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}
","
        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmFortran_yyset_column called with no buffer"" );

    yycolumn = column_no;
}
",2189,2207,[3],[]
7f8bb857b8ab714b80acfa6a6e2c34195fabff6f,VS6: Port to cmGeneratorTarget.,[],Source/cmLocalVisualStudio6Generator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_232.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_232.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_431.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_431.cpp,"
void
cmLocalVisualStudio6Generator
::AddUtilityCommandHack(cmTarget& target, int count,
                        std::vector<std::string>& depends,
                        const cmCustomCommand& origCommand)
{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->GetCurrentBinaryDirectory())
                            target.GetName().size()  30)];
  sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);
  const char* comment = origCommand.GetComment();
  if(!comment && origCommand.GetOutputs().empty())
    {
","
void
cmLocalVisualStudio6Generator
::AddUtilityCommandHack(cmGeneratorTarget *target, int count,
                        std::vector<std::string>& depends,
                        const cmCustomCommand& origCommand)
{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->GetCurrentBinaryDirectory())
                            target->GetName().size()  30)];
  sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target->GetName().c_str(), count);
  const char* comment = origCommand.GetComment();
  if(!comment && origCommand.GetOutputs().empty())
    {
",575,570,[10],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_233.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_233.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_432.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_432.cpp,"}

if (a->read_data_offset < a->read_data_output_offset) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Encountered out-of-order sparse blocks"");
return (ARCHIVE_RETRY);
}
","}

if (a->read_data_offset < a->read_data_output_offset) {
archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Encountered out-of-order sparse blocks"");
return (ARCHIVE_RETRY);
}
",843,850,[3],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_233.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_233.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_433.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_433.cpp,"if (a->format->read_data == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
    ""Internal error: ""
    ""No format_read_data_block function registered"");
return (ARCHIVE_FATAL);
}

","if (a->format->read_data == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
    ""Internal error: ""
    ""No format->read_data function registered"");
return (ARCHIVE_FATAL);
}

",953,975,[1],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_434.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_434.cpp,"if (strncmp(h  AR_fmag_offset, ""`\n"", 2) != 0) {
archive_set_error(&a->archive, EINVAL,
    ""Incorrect file header signature"");
return (ARCHIVE_WARN);
}

/* Copy filename into work buffer. */
","if (strncmp(h  AR_fmag_offset, ""`\n"", 2) != 0) {
archive_set_error(&a->archive, EINVAL,
    ""Incorrect file header signature"");
return (ARCHIVE_FATAL);
}

/* Copy filename into work buffer. */
",180,180,[1],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_435.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_435.cpp,"if (entry_size == 0) {
archive_set_error(&a->archive, EINVAL,
    ""Invalid string table"");
return (ARCHIVE_WARN);
}
if (ar->strtab != NULL) {
archive_set_error(&a->archive, EINVAL,
    ""More than one string tables exist"");
return (ARCHIVE_WARN);
}

/* Read the filename table into memory. */
","if (entry_size == 0) {
archive_set_error(&a->archive, EINVAL,
    ""Invalid string table"");
return (ARCHIVE_FATAL);
}
if (ar->strtab != NULL) {
archive_set_error(&a->archive, EINVAL,
    ""More than one string tables exist"");
return (ARCHIVE_FATAL);
}

/* Read the filename table into memory. */
",262,269,"[1, 6]",[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_436.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_436.cpp," */
if (ar->strtab == NULL || number > ar->strtab_size) {
archive_set_error(&a->archive, EINVAL,
    ""Can't find long filename for entry"");
archive_entry_copy_pathname(entry, filename);
/* Parse the time, owner, mode, size fields. */
ar_parse_common_header(ar, entry, h);
return (ARCHIVE_WARN);
}

archive_entry_copy_pathname(entry, &ar->strtab[(size_t)number]);
"," */
if (ar->strtab == NULL || number > ar->strtab_size) {
archive_set_error(&a->archive, EINVAL,
    ""Can't find long filename for GNU/SVR4 archive entry"");
archive_entry_copy_pathname(entry, filename);
/* Parse the time, owner, mode, size fields. */
ar_parse_common_header(ar, entry, h);
return (ARCHIVE_FATAL);
}

archive_entry_copy_pathname(entry, &ar->strtab[(size_t)number]);
",311,318,[2],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_235.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_235.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_437.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_437.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Pathname is too long"");
}

r = archive_entry_copy_pathname_l(entry,
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Pathname is too long"");
return (ARCHIVE_FATAL);
}

r = archive_entry_copy_pathname_l(entry,
",1225,1225,[0],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_236.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_236.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_438.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_438.cpp,"lha->entry_unconsumed = 0;
}
if (lha->end_of_entry) {
if (!lha->end_of_entry_cleanup) {
if ((lha->setflag & CRC_IS_SET) &&
    lha->crc != lha->entry_crc_calculated) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""LHa data CRC error"");
return (ARCHIVE_WARN);
}

/* End-of-entry cleanup done. */
lha->end_of_entry_cleanup = 1;
}
*offset = lha->entry_offset;
*size = 0;
*buff = NULL;
return (ARCHIVE_EOF);
}

if (lha->entry_is_compressed)
","lha->entry_unconsumed = 0;
}
if (lha->end_of_entry) {
*offset = lha->entry_offset;
*size = 0;
*buff = NULL;
return (lha_end_of_entry(a));
}

if (lha->entry_is_compressed)
",1390,1374,[6],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_236.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_236.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_439.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_439.cpp,"ssize_t bytes_avail;
int r;

/* If the buffer hasn't been allocated, allocate it now. */
if (lha->uncompressed_buffer == NULL) {
lha->uncompressed_buffer_size = 64 * 1024;
lha->uncompressed_buffer
    = (unsigned char *)malloc(lha->uncompressed_buffer_size);
if (lha->uncompressed_buffer == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""No memory for lzh decompression"");
return (ARCHIVE_FATAL);
}
}

/* If we haven't yet read any data, initialize the decompressor. */
if (!lha->decompress_init) {
r = lzh_decode_init(&(lha->strm), lha->method);
","ssize_t bytes_avail;
int r;

/* If we haven't yet read any data, initialize the decompressor. */
if (!lha->decompress_init) {
r = lzh_decode_init(&(lha->strm), lha->method);
",1477,1449,[9],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_440.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_440.cpp,"mtree->fd = open(path, O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(mtree->fd);
if (mtree->fd == -1 &&
(errno != ENOENT ||
 archive_strlen(&mtree->contents_name) > 0)) {
archive_set_error(&a->archive, errno,
""Can't open %s"", path);
r = ARCHIVE_WARN;
","mtree->fd = open(path, O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(mtree->fd);
if (mtree->fd == -1 &&
(errno != ENOENT ||
 archive_strlen(&mtree->contents_name) > 0)) {
archive_set_error(&a->archive, errno,
""Can't open %s"", path);
r = ARCHIVE_WARN;
",1151,1153,[5],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_441.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_441.cpp,"}

/*
 * Check for a mismatch between the type in the specification and
 * the type of the contents object on disk.
 */
if (st != NULL) {
if (
((st->st_mode & S_IFMT) == S_IFREG &&
 archive_entry_filetype(entry) == AE_IFREG)
#ifdef S_IFLNK
|| ((st->st_mode & S_IFMT) == S_IFLNK &&
archive_entry_filetype(entry) == AE_IFLNK)
#endif
#ifdef S_IFSOCK
|| ((st->st_mode & S_IFSOCK) == S_IFSOCK &&
archive_entry_filetype(entry) == AE_IFSOCK)
#endif
#ifdef S_IFCHR
|| ((st->st_mode & S_IFMT) == S_IFCHR &&
archive_entry_filetype(entry) == AE_IFCHR)
#endif
#ifdef S_IFBLK
|| ((st->st_mode & S_IFMT) == S_IFBLK &&
archive_entry_filetype(entry) == AE_IFBLK)
#endif
|| ((st->st_mode & S_IFMT) == S_IFDIR &&
archive_entry_filetype(entry) == AE_IFDIR)
#ifdef S_IFIFO
|| ((st->st_mode & S_IFMT) == S_IFIFO &&
archive_entry_filetype(entry) == AE_IFIFO)
#endif
) {
/* Types match. */
} else {
/* Types don't match; bail out gracefully. */
if (mtree->fd >= 0)
close(mtree->fd);
mtree->fd = -1;
if (parsed_kws & MTREE_HAS_OPTIONAL) {
/* It's not an error for an optional entry
   to not match disk. */
*use_next = 1;
} else if (r == ARCHIVE_OK) {
archive_set_error(&a->archive,
ARCHIVE_ERRNO_MISC,
""mtree specification has different type for %s"",
archive_entry_pathname(entry));
r = ARCHIVE_WARN;
}
return r;
}
}

/*
 * If there is a contents file on disk, pick some of the metadata
 * from that file.  For most of these, we only set it from the contents
 * if it wasn't already parsed from the specification.
 */
if (st != NULL) {
if (((parsed_kws & MTREE_HAS_DEVICE) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0) &&
(archive_entry_filetype(entry) == AE_IFCHR ||
 archive_entry_filetype(entry) == AE_IFBLK))
archive_entry_set_rdev(entry, st->st_rdev);
if ((parsed_kws & (MTREE_HAS_GID | MTREE_HAS_GNAME)) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_gid(entry, st->st_gid);
if ((parsed_kws & (MTREE_HAS_UID | MTREE_HAS_UNAME)) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_uid(entry, st->st_uid);
if ((parsed_kws & MTREE_HAS_MTIME) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0) {
#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC
archive_entry_set_mtime(entry, st->st_mtime,
st->st_mtimespec.tv_nsec);
","}

/*
 * Check for a mismatch between the type in the specification
 * and the type of the contents object on disk.
 */
if (st != NULL) {
if (((st->st_mode & S_IFMT) == S_IFREG &&
      archive_entry_filetype(entry) == AE_IFREG)
#ifdef S_IFLNK
  ||((st->st_mode & S_IFMT) == S_IFLNK &&
      archive_entry_filetype(entry) == AE_IFLNK)
#endif
#ifdef S_IFSOCK
  ||((st->st_mode & S_IFSOCK) == S_IFSOCK &&
      archive_entry_filetype(entry) == AE_IFSOCK)
#endif
#ifdef S_IFCHR
  ||((st->st_mode & S_IFMT) == S_IFCHR &&
      archive_entry_filetype(entry) == AE_IFCHR)
#endif
#ifdef S_IFBLK
  ||((st->st_mode & S_IFMT) == S_IFBLK &&
      archive_entry_filetype(entry) == AE_IFBLK)
#endif
  ||((st->st_mode & S_IFMT) == S_IFDIR &&
      archive_entry_filetype(entry) == AE_IFDIR)
#ifdef S_IFIFO
  ||((st->st_mode & S_IFMT) == S_IFIFO &&
      archive_entry_filetype(entry) == AE_IFIFO)
#endif
) {
/* Types match. */
} else {
/* Types don't match; bail out gracefully. */
if (mtree->fd >= 0)
close(mtree->fd);
mtree->fd = -1;
if (parsed_kws & MTREE_HAS_OPTIONAL) {
/* It's not an error for an optional
 * entry to not match disk. */
*use_next = 1;
} else if (r == ARCHIVE_OK) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""mtree specification has different""
    "" type for %s"",
    archive_entry_pathname(entry));
r = ARCHIVE_WARN;
}
return (r);
}
}

/*
 * If there is a contents file on disk, pick some of the
 * metadata from that file.  For most of these, we only
 * set it from the contents if it wasn't already parsed
 * from the specification.
 */
if (st != NULL) {
if (((parsed_kws & MTREE_HAS_DEVICE) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0) &&
(archive_entry_filetype(entry) == AE_IFCHR ||
 archive_entry_filetype(entry) == AE_IFBLK))
archive_entry_set_rdev(entry, st->st_rdev);
if ((parsed_kws & (MTREE_HAS_GID | MTREE_HAS_GNAME))
== 0 ||
    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_gid(entry, st->st_gid);
if ((parsed_kws & (MTREE_HAS_UID | MTREE_HAS_UNAME))
== 0 ||
    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_uid(entry, st->st_uid);
if ((parsed_kws & MTREE_HAS_MTIME) == 0 ||
    (parsed_kws & MTREE_HAS_NOCHANGE) != 0) {
#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC
archive_entry_set_mtime(entry, st->st_mtime,
st->st_mtimespec.tv_nsec);
",1175,1177,[44],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_442.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_442.cpp,"    ""Missing number"");
return ARCHIVE_WARN;
}
numbers[argc�] = mtree_atol(&p);
if (argc > MAX_PACK_ARGS) {
archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Too many arguments"");
","    ""Missing number"");
return ARCHIVE_WARN;
}
numbers[argc�] = (unsigned long)mtree_atol(&p);
if (argc > MAX_PACK_ARGS) {
archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Too many arguments"");
",1370,1376,[5],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_443.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_443.cpp,"}
case 'c':
if (strcmp(val, ""char"") == 0) {
archive_entry_set_filetype(entry, AE_IFCHR);
break;
}
case 'd':
if (strcmp(val, ""dir"") == 0) {
archive_entry_set_filetype(entry, AE_IFDIR);
break;
}
case 'f':
if (strcmp(val, ""fifo"") == 0) {
archive_entry_set_filetype(entry, AE_IFIFO);
break;
}
if (strcmp(val, ""file"") == 0) {
archive_entry_set_filetype(entry, AE_IFREG);
break;
}
case 'l':
if (strcmp(val, ""link"") == 0) {
archive_entry_set_filetype(entry, AE_IFLNK);
break;
}
default:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Unrecognized file type \""%s\""; assuming \""file\"""", val);
archive_entry_set_filetype(entry, AE_IFREG);
return (ARCHIVE_WARN);
}
","}
case 'c':
if (strcmp(val, ""char"") == 0) {
archive_entry_set_filetype(entry,
AE_IFCHR);
break;
}
case 'd':
if (strcmp(val, ""dir"") == 0) {
archive_entry_set_filetype(entry,
AE_IFDIR);
break;
}
case 'f':
if (strcmp(val, ""fifo"") == 0) {
archive_entry_set_filetype(entry,
AE_IFIFO);
break;
}
if (strcmp(val, ""file"") == 0) {
archive_entry_set_filetype(entry,
AE_IFREG);
break;
}
case 'l':
if (strcmp(val, ""link"") == 0) {
archive_entry_set_filetype(entry,
AE_IFLNK);
break;
}
default:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Unrecognized file type \""%s\""; ""
    ""assuming \""file\"""", val);
archive_entry_set_filetype(entry, AE_IFREG);
return (ARCHIVE_WARN);
}
",1583,1589,[26],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_444.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_444.cpp,"return (0);
if (bytes_read < 0)
return (ARCHIVE_FATAL);
s = t;  /* Start of line? */
p = memchr(t, '\n', bytes_read);
/* If we found '\n', trim the read. */
if (p != NULL) {
bytes_read = 1  ((const char *)p) - s;
}
if (total_size  bytes_read  1 > limit) {
archive_set_error(&a->archive,
","return (0);
if (bytes_read < 0)
return (ARCHIVE_FATAL);
nl = memchr(t, '\n', bytes_read);
/* If we found '\n', trim the read to end exactly there. */
if (nl != NULL) {
bytes_read = ((const char *)nl) - ((const char *)t)  1;
}
if (total_size  bytes_read  1 > limit) {
archive_set_error(&a->archive,
",1916,1933,[10],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_238.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_238.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_445.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_445.cpp,"{
  int i, j, codebits = 0, symbolsleft = numsymbols;

  if (new_node(code) < 0) {
    archive_set_error(&a->archive, ENOMEM,
                      ""Unable to allocate memory for node data."");
","{
  int i, j, codebits = 0, symbolsleft = numsymbols;

  code->numentries = 0;
  code->numallocatedentries = 0;
  if (new_node(code) < 0) {
    archive_set_error(&a->archive, ENOMEM,
                      ""Unable to allocate memory for node data."");
",2406,2408,[4],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_446.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_446.cpp,"{
unsigned offset = 0;

while (offset < extra_length - 4)
{
unsigned short headerid = archive_le16dec(p  offset);
unsigned short datasize = archive_le16dec(p  offset  2);
offset = 4;
if (offset  datasize > extra_length)
break;
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%x, length %d\n"",
    headerid, datasize);
#endif
switch (headerid) {
","{
unsigned offset = 0;

while (offset < extra_length - 4) {
unsigned short headerid = archive_le16dec(p  offset);
unsigned short datasize = archive_le16dec(p  offset  2);

offset = 4;
if (offset  datasize > extra_length)
break;
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%04x, length %d\n"",
    headerid, datasize);
#endif
switch (headerid) {
",248,418,[11],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_447.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_447.cpp,"    ""Truncated Zip file"");
return ARCHIVE_FATAL;
}
if (__archive_read_consume(a, linkname_length) < 0) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Read error skipping symlink target name"");
return ARCHIVE_FATAL;
}

sconv = zip->sconv;
if (sconv == NULL && (zip->entry->zip_flags & ZIP_UTF8_NAME))
","    ""Truncated Zip file"");
return ARCHIVE_FATAL;
}

sconv = zip->sconv;
if (sconv == NULL && (zip->entry->zip_flags & ZIP_UTF8_NAME))
",696,927,[4],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_448.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_448.cpp,"zip->end_of_entry = 1;

/* Set up a more descriptive format name. */
snprintf(zip->format_name, sizeof(zip->format_name), ""ZIP %d.%d (%s)"",
    version / 10, version % 10,
    compression_name(zip->entry->compression));
a->archive.archive_format_name = zip->format_name;

return (ret);
}

/*
 * Read ""uncompressed"" data.  There are three cases:
 *  1) We know the size of the data.  This is always true for the
","zip->end_of_entry = 1;

/* Set up a more descriptive format name. */
archive_string_sprintf(&zip->format_name, ""ZIP %d.%d (%s)"",
    version / 10, version % 10,
    compression_name(zip->entry->compression));
a->archive.archive_format_name = zip->format_name.s;

return (ret);
}

static int
check_authentication_code(struct archive_read *a, const void *_p)
{
struct zip *zip = (struct zip *)(a->format->data);

/* Check authentication code. */
if (zip->hctx_valid) {
const void *p;
uint8_t hmac[20];
size_t hmac_len = 20;
int cmp;

archive_hmac_sha1_final(&zip->hctx, hmac, &hmac_len);
if (_p == NULL) {
/* Read authentication code. */
p = __archive_read_ahead(a, AUTH_CODE_SIZE, NULL);
if (p == NULL) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file data"");
return (ARCHIVE_FATAL);
}
} else {
p = _p;
}
cmp = memcmp(hmac, p, AUTH_CODE_SIZE);
__archive_read_consume(a, AUTH_CODE_SIZE);
if (cmp != 0) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""ZIP bad Authentication code"");
return (ARCHIVE_WARN);
}
}
return (ARCHIVE_OK);
}

/*
 * Read ""uncompressed"" data.  There are three cases:
 *  1) We know the size of the data.  This is always true for the
",748,980,[3],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_449.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_449.cpp,"if (AE_IFREG != (zip->entry->mode & AE_IFMT))
return (ARCHIVE_EOF);

if (zip->entry->zip_flags & (ZIP_ENCRYPTED | ZIP_STRONG_ENCRYPTED)) {
zip->has_encrypted_entries = 1;
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Encrypted file is unsupported"");
return (ARCHIVE_FAILED);
}

__archive_read_consume(a, zip->unconsumed);
zip->unconsumed = 0;

switch(zip->entry->compression) {
case 0:  /* No compression. */
r =  zip_read_data_none(a, buff, size, offset);
","if (AE_IFREG != (zip->entry->mode & AE_IFMT))
return (ARCHIVE_EOF);

__archive_read_consume(a, zip->unconsumed);
zip->unconsumed = 0;

if (zip->init_decryption) {
zip->has_encrypted_entries = 1;
if (zip->entry->zip_flags & ZIP_STRONG_ENCRYPTED)
r = read_decryption_header(a);
else if (zip->entry->compression == WINZIP_AES_ENCRYPTION)
r = init_WinZip_AES_decryption(a);
else
r = init_traditional_PKWARE_decryption(a);
if (r != ARCHIVE_OK)
return (r);
zip->init_decryption = 0;
}

switch(zip->entry->compression) {
case 0:  /* No compression. */
r =  zip_read_data_none(a, buff, size, offset);
",1037,1790,[5],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_450.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_450.cpp,"return (ARCHIVE_WARN);
}
/* Check computed CRC against header */
if (zip->entry->crc32 != zip->entry_crc32
    && !zip->ignore_crc32) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""ZIP bad CRC: 0x%lx should be 0x%lx"",
","return (ARCHIVE_WARN);
}
/* Check computed CRC against header */
if ((!zip->hctx_valid ||
      zip->entry->aes_extra.vendor != AES_VENDOR_AE_2) &&
   zip->entry->crc32 != zip->entry_crc32
    && !zip->ignore_crc32) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""ZIP bad CRC: 0x%lx should be 0x%lx"",
",1096,1855,[5],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_451.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_451.cpp,"archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_zip"");

zip = (struct zip *)malloc(sizeof(*zip));
if (zip == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate zip data"");
return (ARCHIVE_FATAL);
}
memset(zip, 0, sizeof(*zip));

/* Streamable reader doesn't support mac extensions. */
zip->process_mac_extensions = 0;
","archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_zip"");

zip = (struct zip *)calloc(1, sizeof(*zip));
if (zip == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate zip data"");
return (ARCHIVE_FATAL);
}

/* Streamable reader doesn't support mac extensions. */
zip->process_mac_extensions = 0;
",1427,2223,[5],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_452.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_452.cpp,"/* We're done with the regular data; get the filename and
 * extra data. */
__archive_read_consume(a, 46);
if ((p = __archive_read_ahead(a, filename_length  extra_length, NULL))
    == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file header"");
return ARCHIVE_FATAL;
}
","/* We're done with the regular data; get the filename and
 * extra data. */
__archive_read_consume(a, 46);
p = __archive_read_ahead(a, filename_length  extra_length,
NULL);
if (p == NULL) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file header"");
return ARCHIVE_FATAL;
}
",1823,2626,[5],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_240.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_240.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_453.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_453.cpp,"{
static const lzma_stream lzma_stream_init_data = LZMA_STREAM_INIT;
int ret;

data->stream = lzma_stream_init_data;
data->stream.next_out = data->compressed;
data->stream.avail_out = data->compressed_buffer_size;
if (f->code == ARCHIVE_FILTER_XZ)
ret = lzma_stream_encoder(&(data->stream),
    data->lzmafilters, LZMA_CHECK_CRC64);
else if (f->code == ARCHIVE_FILTER_LZMA)
ret = lzma_alone_encoder(&(data->stream), &data->lzma_opt);
else {/* ARCHIVE_FILTER_LZIP */
int dict_size = data->lzma_opt.dict_size;
int ds, log2dic, wedges;

/* Calculate a coded dictionary size */
if (dict_size < (1 << 12) || dict_size > (1 << 27)) {
archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
    ""Unacceptable dictionary dize for lzip: %d"",
    dict_size);
return (ARCHIVE_FATAL);
}
","{
static const lzma_stream lzma_stream_init_data = LZMA_STREAM_INIT;
int ret;
#ifdef HAVE_LZMA_STREAM_ENCODER_MT
lzma_mt mt_options;
#endif

data->stream = lzma_stream_init_data;
data->stream.next_out = data->compressed;
data->stream.avail_out = data->compressed_buffer_size;
if (f->code == ARCHIVE_FILTER_XZ) {
#ifdef HAVE_LZMA_STREAM_ENCODER_MT
if (data->threads != 1) {
bzero(&mt_options, sizeof(mt_options));
mt_options.threads = data->threads;
mt_options.timeout = 300;
mt_options.filters = data->lzmafilters;
mt_options.check = LZMA_CHECK_CRC64;
ret = lzma_stream_encoder_mt(&(data->stream),
    &mt_options);
} else
#endif
ret = lzma_stream_encoder(&(data->stream),
    data->lzmafilters, LZMA_CHECK_CRC64);
} else if (f->code == ARCHIVE_FILTER_LZMA) {
ret = lzma_alone_encoder(&(data->stream), &data->lzma_opt);
} else {/* ARCHIVE_FILTER_LZIP */
int dict_size = data->lzma_opt.dict_size;
int ds, log2dic, wedges;

/* Calculate a coded dictionary size */
if (dict_size < (1 << 12) || dict_size > (1 << 27)) {
archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
    ""Unacceptable dictionary size for lzip: %d"",
    dict_size);
return (ARCHIVE_FATAL);
}
",221,223,[18],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_454.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_454.cpp,"return (r);
if ((size_t)r < size) {
archive_set_error(&a->archive, 0,
    ""Write request too large"");
return (ARCHIVE_WARN);
}
return (ARCHIVE_OK);
}

static ssize_t
","return (r);
if ((size_t)r < size) {
archive_set_error(&a->archive, 0,
    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);
return (ARCHIVE_WARN);
}
#if ARCHIVE_VERSION_NUMBER < 3999000
return (ARCHIVE_OK);
#else
return (size);
#endif
}

static ssize_t
",1467,1468,[2],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_455.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_455.cpp,"
if (!S_ISDIR(a->st.st_mode)) {
/* A non-dir is in the way, unlink it. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't unlink already-existing object"");
","
if (!S_ISDIR(a->st.st_mode)) {
/* A non-dir is in the way, unlink it. */
if (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)
(void)clear_nochange_fflags(a);
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't unlink already-existing object"");
",1940,1954,[4],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_456.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_456.cpp,"en = create_filesystem_object(a);
} else if (!S_ISDIR(a->mode)) {
/* A dir is in the way of a non-dir, rmdir it. */
if (rmdir(a->name) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't replace existing directory with non-directory"");
","en = create_filesystem_object(a);
} else if (!S_ISDIR(a->mode)) {
/* A dir is in the way of a non-dir, rmdir it. */
if (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)
(void)clear_nochange_fflags(a);
if (rmdir(a->name) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't replace existing directory with non-directory"");
",1950,1966,[4],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_457.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_457.cpp," * impact.
 */
if (lchmod(a->name, mode) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't set permissions to 0%o"", (int)mode);
r = ARCHIVE_WARN;
}
#endif
} else if (!S_ISDIR(a->mode)) {
"," * impact.
 */
if (lchmod(a->name, mode) != 0) {
switch (errno) {
case ENOTSUP:
case ENOSYS:
#if ENOTSUP != EOPNOTSUPP
case EOPNOTSUPP:
#endif
/*
 * if lchmod is defined but the platform
 * doesn't support it, silently ignore
 * error
 */
break;
default:
archive_set_error(&a->archive, errno,
    ""Can't set permissions to 0%o"", (int)mode);
r = ARCHIVE_WARN;
}
}
#endif
} else if (!S_ISDIR(a->mode)) {
",3056,3082,[3],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_242.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_242.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_458.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_458.cpp,"
if (value == NULL)
return (ARCHIVE_OK);

r = xmlTextWriterStartElement(writer, BAD_CAST_CONST(key));
if (r < 0) {
archive_set_error(&a->archive,
","
if (value == NULL)
return (ARCHIVE_OK);

r = xmlTextWriterStartElement(writer, BAD_CAST_CONST(key));
if (r < 0) {
archive_set_error(&a->archive,
",805,827,[6],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_243.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_243.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_459.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_459.cpp,"if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
/* Reject entries over 4GB. */
if (archive_entry_size_is_set(entry)
    && (archive_entry_size(entry) > 0xffffffff)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Files > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
}
/* Reject entries if archive is > 4GB. */
if (zip->written_bytes > 0xffffffff) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Archives > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
","if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
/* Reject entries over 4GB. */
if (archive_entry_size_is_set(entry)
    && (archive_entry_size(entry) >
ARCHIVE_LITERAL_LL(0xffffffff))) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Files > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
}
/* Reject entries if archive is > 4GB. */
if (zip->written_bytes > ARCHIVE_LITERAL_LL(0xffffffff)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Archives > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
",425,532,"[4, 10]",[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_243.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_243.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_460.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_460.cpp,"zip->stream.opaque = Z_NULL;
zip->stream.next_out = zip->buf;
zip->stream.avail_out = (uInt)zip->len_buf;
if (deflateInit2(&zip->stream, Z_DEFAULT_COMPRESSION,
    Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY) != Z_OK) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't init deflate compressor"");
","zip->stream.opaque = Z_NULL;
zip->stream.next_out = zip->buf;
zip->stream.avail_out = (uInt)zip->len_buf;
if (deflateInit2(&zip->stream, zip->deflate_compression_level,
    Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY) != Z_OK) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't init deflate compressor"");
",758,986,[5],[]
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_243.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_243.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_461.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_461.cpp,"archive_le64enc(z, zip->entry_offset);
z = 8;
}
archive_le16enc(zip64  2, z - (zip64  4));
zd = cd_alloc(zip, z - zip64);
if (zd == NULL) {
archive_set_error(&a->archive, ENOMEM,
","archive_le64enc(z, zip->entry_offset);
z = 8;
}
archive_le16enc(zip64  2, (uint16_t)(z - (zip64  4)));
zd = cd_alloc(zip, z - zip64);
if (zd == NULL) {
archive_set_error(&a->archive, ENOMEM,
",892,1236,[6],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_244.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_244.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_462.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_462.cpp,"}

if (a->read_data_offset < a->read_data_output_offset) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Encountered out-of-order sparse blocks"");
return (ARCHIVE_RETRY);
}
","}

if (a->read_data_offset < a->read_data_output_offset) {
archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Encountered out-of-order sparse blocks"");
return (ARCHIVE_RETRY);
}
",843,850,[3],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_244.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_244.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_463.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_463.cpp,"if (a->format->read_data == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
    ""Internal error: ""
    ""No format_read_data_block function registered"");
return (ARCHIVE_FATAL);
}

","if (a->format->read_data == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
    ""Internal error: ""
    ""No format->read_data function registered"");
return (ARCHIVE_FATAL);
}

",953,975,[1],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_464.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_464.cpp,"if (strncmp(h  AR_fmag_offset, ""`\n"", 2) != 0) {
archive_set_error(&a->archive, EINVAL,
    ""Incorrect file header signature"");
return (ARCHIVE_WARN);
}

/* Copy filename into work buffer. */
","if (strncmp(h  AR_fmag_offset, ""`\n"", 2) != 0) {
archive_set_error(&a->archive, EINVAL,
    ""Incorrect file header signature"");
return (ARCHIVE_FATAL);
}

/* Copy filename into work buffer. */
",180,180,[1],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_465.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_465.cpp,"if (entry_size == 0) {
archive_set_error(&a->archive, EINVAL,
    ""Invalid string table"");
return (ARCHIVE_WARN);
}
if (ar->strtab != NULL) {
archive_set_error(&a->archive, EINVAL,
    ""More than one string tables exist"");
return (ARCHIVE_WARN);
}

/* Read the filename table into memory. */
","if (entry_size == 0) {
archive_set_error(&a->archive, EINVAL,
    ""Invalid string table"");
return (ARCHIVE_FATAL);
}
if (ar->strtab != NULL) {
archive_set_error(&a->archive, EINVAL,
    ""More than one string tables exist"");
return (ARCHIVE_FATAL);
}

/* Read the filename table into memory. */
",262,269,"[1, 6]",[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_466.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_466.cpp," */
if (ar->strtab == NULL || number > ar->strtab_size) {
archive_set_error(&a->archive, EINVAL,
    ""Can't find long filename for entry"");
archive_entry_copy_pathname(entry, filename);
/* Parse the time, owner, mode, size fields. */
ar_parse_common_header(ar, entry, h);
return (ARCHIVE_WARN);
}

archive_entry_copy_pathname(entry, &ar->strtab[(size_t)number]);
"," */
if (ar->strtab == NULL || number > ar->strtab_size) {
archive_set_error(&a->archive, EINVAL,
    ""Can't find long filename for GNU/SVR4 archive entry"");
archive_entry_copy_pathname(entry, filename);
/* Parse the time, owner, mode, size fields. */
ar_parse_common_header(ar, entry, h);
return (ARCHIVE_FATAL);
}

archive_entry_copy_pathname(entry, &ar->strtab[(size_t)number]);
",311,318,[2],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_246.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_246.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_467.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_467.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Pathname is too long"");
}

r = archive_entry_copy_pathname_l(entry,
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Pathname is too long"");
return (ARCHIVE_FATAL);
}

r = archive_entry_copy_pathname_l(entry,
",1225,1225,[0],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_247.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_247.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_468.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_468.cpp,"lha->entry_unconsumed = 0;
}
if (lha->end_of_entry) {
if (!lha->end_of_entry_cleanup) {
if ((lha->setflag & CRC_IS_SET) &&
    lha->crc != lha->entry_crc_calculated) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""LHa data CRC error"");
return (ARCHIVE_WARN);
}

/* End-of-entry cleanup done. */
lha->end_of_entry_cleanup = 1;
}
*offset = lha->entry_offset;
*size = 0;
*buff = NULL;
return (ARCHIVE_EOF);
}

if (lha->entry_is_compressed)
","lha->entry_unconsumed = 0;
}
if (lha->end_of_entry) {
*offset = lha->entry_offset;
*size = 0;
*buff = NULL;
return (lha_end_of_entry(a));
}

if (lha->entry_is_compressed)
",1390,1374,[6],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_247.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_247.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_469.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_469.cpp,"ssize_t bytes_avail;
int r;

/* If the buffer hasn't been allocated, allocate it now. */
if (lha->uncompressed_buffer == NULL) {
lha->uncompressed_buffer_size = 64 * 1024;
lha->uncompressed_buffer
    = (unsigned char *)malloc(lha->uncompressed_buffer_size);
if (lha->uncompressed_buffer == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""No memory for lzh decompression"");
return (ARCHIVE_FATAL);
}
}

/* If we haven't yet read any data, initialize the decompressor. */
if (!lha->decompress_init) {
r = lzh_decode_init(&(lha->strm), lha->method);
","ssize_t bytes_avail;
int r;

/* If we haven't yet read any data, initialize the decompressor. */
if (!lha->decompress_init) {
r = lzh_decode_init(&(lha->strm), lha->method);
",1477,1449,[9],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_470.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_470.cpp,"mtree->fd = open(path, O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(mtree->fd);
if (mtree->fd == -1 &&
(errno != ENOENT ||
 archive_strlen(&mtree->contents_name) > 0)) {
archive_set_error(&a->archive, errno,
""Can't open %s"", path);
r = ARCHIVE_WARN;
","mtree->fd = open(path, O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(mtree->fd);
if (mtree->fd == -1 &&
(errno != ENOENT ||
 archive_strlen(&mtree->contents_name) > 0)) {
archive_set_error(&a->archive, errno,
""Can't open %s"", path);
r = ARCHIVE_WARN;
",1151,1153,[5],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_471.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_471.cpp,"}

/*
 * Check for a mismatch between the type in the specification and
 * the type of the contents object on disk.
 */
if (st != NULL) {
if (
((st->st_mode & S_IFMT) == S_IFREG &&
 archive_entry_filetype(entry) == AE_IFREG)
#ifdef S_IFLNK
|| ((st->st_mode & S_IFMT) == S_IFLNK &&
archive_entry_filetype(entry) == AE_IFLNK)
#endif
#ifdef S_IFSOCK
|| ((st->st_mode & S_IFSOCK) == S_IFSOCK &&
archive_entry_filetype(entry) == AE_IFSOCK)
#endif
#ifdef S_IFCHR
|| ((st->st_mode & S_IFMT) == S_IFCHR &&
archive_entry_filetype(entry) == AE_IFCHR)
#endif
#ifdef S_IFBLK
|| ((st->st_mode & S_IFMT) == S_IFBLK &&
archive_entry_filetype(entry) == AE_IFBLK)
#endif
|| ((st->st_mode & S_IFMT) == S_IFDIR &&
archive_entry_filetype(entry) == AE_IFDIR)
#ifdef S_IFIFO
|| ((st->st_mode & S_IFMT) == S_IFIFO &&
archive_entry_filetype(entry) == AE_IFIFO)
#endif
) {
/* Types match. */
} else {
/* Types don't match; bail out gracefully. */
if (mtree->fd >= 0)
close(mtree->fd);
mtree->fd = -1;
if (parsed_kws & MTREE_HAS_OPTIONAL) {
/* It's not an error for an optional entry
   to not match disk. */
*use_next = 1;
} else if (r == ARCHIVE_OK) {
archive_set_error(&a->archive,
ARCHIVE_ERRNO_MISC,
""mtree specification has different type for %s"",
archive_entry_pathname(entry));
r = ARCHIVE_WARN;
}
return r;
}
}

/*
 * If there is a contents file on disk, pick some of the metadata
 * from that file.  For most of these, we only set it from the contents
 * if it wasn't already parsed from the specification.
 */
if (st != NULL) {
if (((parsed_kws & MTREE_HAS_DEVICE) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0) &&
(archive_entry_filetype(entry) == AE_IFCHR ||
 archive_entry_filetype(entry) == AE_IFBLK))
archive_entry_set_rdev(entry, st->st_rdev);
if ((parsed_kws & (MTREE_HAS_GID | MTREE_HAS_GNAME)) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_gid(entry, st->st_gid);
if ((parsed_kws & (MTREE_HAS_UID | MTREE_HAS_UNAME)) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_uid(entry, st->st_uid);
if ((parsed_kws & MTREE_HAS_MTIME) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0) {
#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC
archive_entry_set_mtime(entry, st->st_mtime,
st->st_mtimespec.tv_nsec);
","}

/*
 * Check for a mismatch between the type in the specification
 * and the type of the contents object on disk.
 */
if (st != NULL) {
if (((st->st_mode & S_IFMT) == S_IFREG &&
      archive_entry_filetype(entry) == AE_IFREG)
#ifdef S_IFLNK
  ||((st->st_mode & S_IFMT) == S_IFLNK &&
      archive_entry_filetype(entry) == AE_IFLNK)
#endif
#ifdef S_IFSOCK
  ||((st->st_mode & S_IFSOCK) == S_IFSOCK &&
      archive_entry_filetype(entry) == AE_IFSOCK)
#endif
#ifdef S_IFCHR
  ||((st->st_mode & S_IFMT) == S_IFCHR &&
      archive_entry_filetype(entry) == AE_IFCHR)
#endif
#ifdef S_IFBLK
  ||((st->st_mode & S_IFMT) == S_IFBLK &&
      archive_entry_filetype(entry) == AE_IFBLK)
#endif
  ||((st->st_mode & S_IFMT) == S_IFDIR &&
      archive_entry_filetype(entry) == AE_IFDIR)
#ifdef S_IFIFO
  ||((st->st_mode & S_IFMT) == S_IFIFO &&
      archive_entry_filetype(entry) == AE_IFIFO)
#endif
) {
/* Types match. */
} else {
/* Types don't match; bail out gracefully. */
if (mtree->fd >= 0)
close(mtree->fd);
mtree->fd = -1;
if (parsed_kws & MTREE_HAS_OPTIONAL) {
/* It's not an error for an optional
 * entry to not match disk. */
*use_next = 1;
} else if (r == ARCHIVE_OK) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""mtree specification has different""
    "" type for %s"",
    archive_entry_pathname(entry));
r = ARCHIVE_WARN;
}
return (r);
}
}

/*
 * If there is a contents file on disk, pick some of the
 * metadata from that file.  For most of these, we only
 * set it from the contents if it wasn't already parsed
 * from the specification.
 */
if (st != NULL) {
if (((parsed_kws & MTREE_HAS_DEVICE) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0) &&
(archive_entry_filetype(entry) == AE_IFCHR ||
 archive_entry_filetype(entry) == AE_IFBLK))
archive_entry_set_rdev(entry, st->st_rdev);
if ((parsed_kws & (MTREE_HAS_GID | MTREE_HAS_GNAME))
== 0 ||
    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_gid(entry, st->st_gid);
if ((parsed_kws & (MTREE_HAS_UID | MTREE_HAS_UNAME))
== 0 ||
    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_uid(entry, st->st_uid);
if ((parsed_kws & MTREE_HAS_MTIME) == 0 ||
    (parsed_kws & MTREE_HAS_NOCHANGE) != 0) {
#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC
archive_entry_set_mtime(entry, st->st_mtime,
st->st_mtimespec.tv_nsec);
",1175,1177,[44],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_472.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_472.cpp,"    ""Missing number"");
return ARCHIVE_WARN;
}
numbers[argc�] = mtree_atol(&p);
if (argc > MAX_PACK_ARGS) {
archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Too many arguments"");
","    ""Missing number"");
return ARCHIVE_WARN;
}
numbers[argc�] = (unsigned long)mtree_atol(&p);
if (argc > MAX_PACK_ARGS) {
archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Too many arguments"");
",1370,1376,[5],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_473.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_473.cpp,"}
case 'c':
if (strcmp(val, ""char"") == 0) {
archive_entry_set_filetype(entry, AE_IFCHR);
break;
}
case 'd':
if (strcmp(val, ""dir"") == 0) {
archive_entry_set_filetype(entry, AE_IFDIR);
break;
}
case 'f':
if (strcmp(val, ""fifo"") == 0) {
archive_entry_set_filetype(entry, AE_IFIFO);
break;
}
if (strcmp(val, ""file"") == 0) {
archive_entry_set_filetype(entry, AE_IFREG);
break;
}
case 'l':
if (strcmp(val, ""link"") == 0) {
archive_entry_set_filetype(entry, AE_IFLNK);
break;
}
default:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Unrecognized file type \""%s\""; assuming \""file\"""", val);
archive_entry_set_filetype(entry, AE_IFREG);
return (ARCHIVE_WARN);
}
","}
case 'c':
if (strcmp(val, ""char"") == 0) {
archive_entry_set_filetype(entry,
AE_IFCHR);
break;
}
case 'd':
if (strcmp(val, ""dir"") == 0) {
archive_entry_set_filetype(entry,
AE_IFDIR);
break;
}
case 'f':
if (strcmp(val, ""fifo"") == 0) {
archive_entry_set_filetype(entry,
AE_IFIFO);
break;
}
if (strcmp(val, ""file"") == 0) {
archive_entry_set_filetype(entry,
AE_IFREG);
break;
}
case 'l':
if (strcmp(val, ""link"") == 0) {
archive_entry_set_filetype(entry,
AE_IFLNK);
break;
}
default:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Unrecognized file type \""%s\""; ""
    ""assuming \""file\"""", val);
archive_entry_set_filetype(entry, AE_IFREG);
return (ARCHIVE_WARN);
}
",1583,1589,[26],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_474.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_474.cpp,"return (0);
if (bytes_read < 0)
return (ARCHIVE_FATAL);
s = t;  /* Start of line? */
p = memchr(t, '\n', bytes_read);
/* If we found '\n', trim the read. */
if (p != NULL) {
bytes_read = 1  ((const char *)p) - s;
}
if (total_size  bytes_read  1 > limit) {
archive_set_error(&a->archive,
","return (0);
if (bytes_read < 0)
return (ARCHIVE_FATAL);
nl = memchr(t, '\n', bytes_read);
/* If we found '\n', trim the read to end exactly there. */
if (nl != NULL) {
bytes_read = ((const char *)nl) - ((const char *)t)  1;
}
if (total_size  bytes_read  1 > limit) {
archive_set_error(&a->archive,
",1916,1933,[10],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_249.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_249.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_475.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_475.cpp,"{
  int i, j, codebits = 0, symbolsleft = numsymbols;

  if (new_node(code) < 0) {
    archive_set_error(&a->archive, ENOMEM,
                      ""Unable to allocate memory for node data."");
","{
  int i, j, codebits = 0, symbolsleft = numsymbols;

  code->numentries = 0;
  code->numallocatedentries = 0;
  if (new_node(code) < 0) {
    archive_set_error(&a->archive, ENOMEM,
                      ""Unable to allocate memory for node data."");
",2406,2408,[4],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_476.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_476.cpp,"{
unsigned offset = 0;

while (offset < extra_length - 4)
{
unsigned short headerid = archive_le16dec(p  offset);
unsigned short datasize = archive_le16dec(p  offset  2);
offset = 4;
if (offset  datasize > extra_length)
break;
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%x, length %d\n"",
    headerid, datasize);
#endif
switch (headerid) {
","{
unsigned offset = 0;

while (offset < extra_length - 4) {
unsigned short headerid = archive_le16dec(p  offset);
unsigned short datasize = archive_le16dec(p  offset  2);

offset = 4;
if (offset  datasize > extra_length)
break;
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%04x, length %d\n"",
    headerid, datasize);
#endif
switch (headerid) {
",244,414,[11],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_477.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_477.cpp,"    ""Truncated Zip file"");
return ARCHIVE_FATAL;
}
if (__archive_read_consume(a, linkname_length) < 0) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Read error skipping symlink target name"");
return ARCHIVE_FATAL;
}

sconv = zip->sconv;
if (sconv == NULL && (zip->entry->zip_flags & ZIP_UTF8_NAME))
","    ""Truncated Zip file"");
return ARCHIVE_FATAL;
}

sconv = zip->sconv;
if (sconv == NULL && (zip->entry->zip_flags & ZIP_UTF8_NAME))
",692,923,[4],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_478.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_478.cpp,"zip->end_of_entry = 1;

/* Set up a more descriptive format name. */
snprintf(zip->format_name, sizeof(zip->format_name), ""ZIP %d.%d (%s)"",
    version / 10, version % 10,
    compression_name(zip->entry->compression));
a->archive.archive_format_name = zip->format_name;

return (ret);
}

/*
 * Read ""uncompressed"" data.  There are three cases:
 *  1) We know the size of the data.  This is always true for the
","zip->end_of_entry = 1;

/* Set up a more descriptive format name. */
archive_string_sprintf(&zip->format_name, ""ZIP %d.%d (%s)"",
    version / 10, version % 10,
    compression_name(zip->entry->compression));
a->archive.archive_format_name = zip->format_name.s;

return (ret);
}

static int
check_authentication_code(struct archive_read *a, const void *_p)
{
struct zip *zip = (struct zip *)(a->format->data);

/* Check authentication code. */
if (zip->hctx_valid) {
const void *p;
uint8_t hmac[20];
size_t hmac_len = 20;
int cmp;

archive_hmac_sha1_final(&zip->hctx, hmac, &hmac_len);
if (_p == NULL) {
/* Read authentication code. */
p = __archive_read_ahead(a, AUTH_CODE_SIZE, NULL);
if (p == NULL) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file data"");
return (ARCHIVE_FATAL);
}
} else {
p = _p;
}
cmp = memcmp(hmac, p, AUTH_CODE_SIZE);
__archive_read_consume(a, AUTH_CODE_SIZE);
if (cmp != 0) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""ZIP bad Authentication code"");
return (ARCHIVE_WARN);
}
}
return (ARCHIVE_OK);
}

/*
 * Read ""uncompressed"" data.  There are three cases:
 *  1) We know the size of the data.  This is always true for the
",744,976,[3],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_479.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_479.cpp,"if (AE_IFREG != (zip->entry->mode & AE_IFMT))
return (ARCHIVE_EOF);

if (zip->entry->zip_flags & (ZIP_ENCRYPTED | ZIP_STRONG_ENCRYPTED)) {
zip->has_encrypted_entries = 1;
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Encrypted file is unsupported"");
return (ARCHIVE_FAILED);
}

__archive_read_consume(a, zip->unconsumed);
zip->unconsumed = 0;

switch(zip->entry->compression) {
case 0:  /* No compression. */
r =  zip_read_data_none(a, buff, size, offset);
","if (AE_IFREG != (zip->entry->mode & AE_IFMT))
return (ARCHIVE_EOF);

__archive_read_consume(a, zip->unconsumed);
zip->unconsumed = 0;

if (zip->init_decryption) {
zip->has_encrypted_entries = 1;
if (zip->entry->zip_flags & ZIP_STRONG_ENCRYPTED)
r = read_decryption_header(a);
else if (zip->entry->compression == WINZIP_AES_ENCRYPTION)
r = init_WinZip_AES_decryption(a);
else
r = init_traditional_PKWARE_decryption(a);
if (r != ARCHIVE_OK)
return (r);
zip->init_decryption = 0;
}

switch(zip->entry->compression) {
case 0:  /* No compression. */
r =  zip_read_data_none(a, buff, size, offset);
",1033,1786,[5],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_480.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_480.cpp,"return (ARCHIVE_WARN);
}
/* Check computed CRC against header */
if (zip->entry->crc32 != zip->entry_crc32
    && !zip->ignore_crc32) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""ZIP bad CRC: 0x%lx should be 0x%lx"",
","return (ARCHIVE_WARN);
}
/* Check computed CRC against header */
if ((!zip->hctx_valid ||
      zip->entry->aes_extra.vendor != AES_VENDOR_AE_2) &&
   zip->entry->crc32 != zip->entry_crc32
    && !zip->ignore_crc32) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""ZIP bad CRC: 0x%lx should be 0x%lx"",
",1092,1851,[5],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_481.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_481.cpp,"archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_zip"");

zip = (struct zip *)malloc(sizeof(*zip));
if (zip == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate zip data"");
return (ARCHIVE_FATAL);
}
memset(zip, 0, sizeof(*zip));

/* Streamable reader doesn't support mac extensions. */
zip->process_mac_extensions = 0;
","archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_zip"");

zip = (struct zip *)calloc(1, sizeof(*zip));
if (zip == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate zip data"");
return (ARCHIVE_FATAL);
}

/* Streamable reader doesn't support mac extensions. */
zip->process_mac_extensions = 0;
",1423,2219,[5],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_482.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_482.cpp,"/* We're done with the regular data; get the filename and
 * extra data. */
__archive_read_consume(a, 46);
if ((p = __archive_read_ahead(a, filename_length  extra_length, NULL))
    == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file header"");
return ARCHIVE_FATAL;
}
","/* We're done with the regular data; get the filename and
 * extra data. */
__archive_read_consume(a, 46);
p = __archive_read_ahead(a, filename_length  extra_length,
NULL);
if (p == NULL) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file header"");
return ARCHIVE_FATAL;
}
",1819,2622,[5],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_add_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_251.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_251.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_483.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_483.cpp,"{
static const lzma_stream lzma_stream_init_data = LZMA_STREAM_INIT;
int ret;

data->stream = lzma_stream_init_data;
data->stream.next_out = data->compressed;
data->stream.avail_out = data->compressed_buffer_size;
if (f->code == ARCHIVE_FILTER_XZ)
ret = lzma_stream_encoder(&(data->stream),
    data->lzmafilters, LZMA_CHECK_CRC64);
else if (f->code == ARCHIVE_FILTER_LZMA)
ret = lzma_alone_encoder(&(data->stream), &data->lzma_opt);
else {/* ARCHIVE_FILTER_LZIP */
int dict_size = data->lzma_opt.dict_size;
int ds, log2dic, wedges;

/* Calculate a coded dictionary size */
if (dict_size < (1 << 12) || dict_size > (1 << 27)) {
archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
    ""Unacceptable dictionary dize for lzip: %d"",
    dict_size);
return (ARCHIVE_FATAL);
}
","{
static const lzma_stream lzma_stream_init_data = LZMA_STREAM_INIT;
int ret;
#ifdef HAVE_LZMA_STREAM_ENCODER_MT
lzma_mt mt_options;
#endif

data->stream = lzma_stream_init_data;
data->stream.next_out = data->compressed;
data->stream.avail_out = data->compressed_buffer_size;
if (f->code == ARCHIVE_FILTER_XZ) {
#ifdef HAVE_LZMA_STREAM_ENCODER_MT
if (data->threads != 1) {
bzero(&mt_options, sizeof(mt_options));
mt_options.threads = data->threads;
mt_options.timeout = 300;
mt_options.filters = data->lzmafilters;
mt_options.check = LZMA_CHECK_CRC64;
ret = lzma_stream_encoder_mt(&(data->stream),
    &mt_options);
} else
#endif
ret = lzma_stream_encoder(&(data->stream),
    data->lzmafilters, LZMA_CHECK_CRC64);
} else if (f->code == ARCHIVE_FILTER_LZMA) {
ret = lzma_alone_encoder(&(data->stream), &data->lzma_opt);
} else {/* ARCHIVE_FILTER_LZIP */
int dict_size = data->lzma_opt.dict_size;
int ds, log2dic, wedges;

/* Calculate a coded dictionary size */
if (dict_size < (1 << 12) || dict_size > (1 << 27)) {
archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
    ""Unacceptable dictionary size for lzip: %d"",
    dict_size);
return (ARCHIVE_FATAL);
}
",221,223,[18],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_484.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_484.cpp,"return (r);
if ((size_t)r < size) {
archive_set_error(&a->archive, 0,
    ""Write request too large"");
return (ARCHIVE_WARN);
}
return (ARCHIVE_OK);
}

static ssize_t
","return (r);
if ((size_t)r < size) {
archive_set_error(&a->archive, 0,
    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);
return (ARCHIVE_WARN);
}
#if ARCHIVE_VERSION_NUMBER < 3999000
return (ARCHIVE_OK);
#else
return (size);
#endif
}

static ssize_t
",1467,1468,[2],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_485.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_485.cpp,"
if (!S_ISDIR(a->st.st_mode)) {
/* A non-dir is in the way, unlink it. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't unlink already-existing object"");
","
if (!S_ISDIR(a->st.st_mode)) {
/* A non-dir is in the way, unlink it. */
if (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)
(void)clear_nochange_fflags(a);
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't unlink already-existing object"");
",1940,1954,[4],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_486.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_486.cpp,"en = create_filesystem_object(a);
} else if (!S_ISDIR(a->mode)) {
/* A dir is in the way of a non-dir, rmdir it. */
if (rmdir(a->name) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't replace existing directory with non-directory"");
","en = create_filesystem_object(a);
} else if (!S_ISDIR(a->mode)) {
/* A dir is in the way of a non-dir, rmdir it. */
if (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)
(void)clear_nochange_fflags(a);
if (rmdir(a->name) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't replace existing directory with non-directory"");
",1950,1966,[4],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_487.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_487.cpp," * impact.
 */
if (lchmod(a->name, mode) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't set permissions to 0%o"", (int)mode);
r = ARCHIVE_WARN;
}
#endif
} else if (!S_ISDIR(a->mode)) {
"," * impact.
 */
if (lchmod(a->name, mode) != 0) {
switch (errno) {
case ENOTSUP:
case ENOSYS:
#if ENOTSUP != EOPNOTSUPP
case EOPNOTSUPP:
#endif
/*
 * if lchmod is defined but the platform
 * doesn't support it, silently ignore
 * error
 */
break;
default:
archive_set_error(&a->archive, errno,
    ""Can't set permissions to 0%o"", (int)mode);
r = ARCHIVE_WARN;
}
}
#endif
} else if (!S_ISDIR(a->mode)) {
",3054,3082,[3],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_set_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_253.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_253.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_488.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_488.cpp,"
if (value == NULL)
return (ARCHIVE_OK);

r = xmlTextWriterStartElement(writer, BAD_CAST_CONST(key));
if (r < 0) {
archive_set_error(&a->archive,
","
if (value == NULL)
return (ARCHIVE_OK);

r = xmlTextWriterStartElement(writer, BAD_CAST_CONST(key));
if (r < 0) {
archive_set_error(&a->archive,
",805,827,[6],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_254.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_254.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_489.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_489.cpp,"zip->stream.opaque = Z_NULL;
zip->stream.next_out = zip->buf;
zip->stream.avail_out = (uInt)zip->len_buf;
if (deflateInit2(&zip->stream, Z_DEFAULT_COMPRESSION,
    Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY) != Z_OK) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't init deflate compressor"");
","zip->stream.opaque = Z_NULL;
zip->stream.next_out = zip->buf;
zip->stream.avail_out = (uInt)zip->len_buf;
if (deflateInit2(&zip->stream, zip->deflate_compression_level,
    Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY) != Z_OK) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't init deflate compressor"");
",758,983,[5],[]
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_254.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_254.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_490.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_490.cpp,"archive_le64enc(z, zip->entry_offset);
z = 8;
}
archive_le16enc(zip64  2, z - (zip64  4));
zd = cd_alloc(zip, z - zip64);
if (zd == NULL) {
archive_set_error(&a->archive, ENOMEM,
","archive_le64enc(z, zip->entry_offset);
z = 8;
}
archive_le16enc(zip64  2, (uint16_t)(z - (zip64  4)));
zd = cd_alloc(zip, z - zip64);
if (zd == NULL) {
archive_set_error(&a->archive, ENOMEM,
",892,1233,[6],[]
bbef3c2da83b7a69d1f99b21dc92d5506d98fb35,cmLocalGenerator: Add current binary directory accessor.,[],Source/cmLocalVisualStudio6Generator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_255.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_255.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_491.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_491.cpp,"                        const cmCustomCommand& origCommand)
{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->Makefile->GetCurrentBinaryDirectory())
                            target.GetName().size()  30)];
  sprintf(output,""%s/%s_force_%i"", this->Makefile->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);
  const char* comment = origCommand.GetComment();
  if(!comment && origCommand.GetOutputs().empty())
","                        const cmCustomCommand& origCommand)
{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->GetCurrentBinaryDirectory())
                            target.GetName().size()  30)];
  sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);
  const char* comment = origCommand.GetComment();
  if(!comment && origCommand.GetOutputs().empty())
",578,578,[5],[]
3339a7508e2d90cbc832490e64f593c1ab935097,CTest: Port away from cmLocalGenerator.,[],Source/CTest/cmCTestScriptHandler.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_256.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_256.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_492.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_492.cpp,"
void cmCTestScriptHandler::UpdateElapsedTime()
{
  if (this->LocalGenerator)
    {
    // set the current elapsed time
    char timeString[20];
    int itime = static_cast<unsigned int>(cmSystemTools::GetTime()
                                          - this->ScriptStartTime);
    sprintf(timeString,""%i"",itime);
    this->LocalGenerator->GetMakefile()->AddDefinition(""CTEST_ELAPSED_TIME"",
                                                   timeString);
    }
}

","
void cmCTestScriptHandler::UpdateElapsedTime()
{
  if (this->Makefile)
    {
    // set the current elapsed time
    char timeString[20];
    int itime = static_cast<unsigned int>(cmSystemTools::GetTime()
                                          - this->ScriptStartTime);
    sprintf(timeString,""%i"",itime);
    this->Makefile->AddDefinition(""CTEST_ELAPSED_TIME"", timeString);
    }
}

",179,173,[9],[]
2e6063068c94d4045e699fed51e6d1e9af344bbf,"Merge branch 'improve-variable-help-formatting' into revert-cmake-W-options

Resolve conflicts in

 Help/variable/CMAKE_ERROR_DEPRECATED.rst
 Help/variable/CMAKE_WARN_DEPRECATED.rst

by integrating changes from both sides.",[],Source/cmGlobalGenerator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_257.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_257.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_493.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_493.cpp,"  // update the cache entry for the number of local generators, this is used
  // for progress
  char num[100];
  sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_LOCAL_GENERATORS"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
","  // update the cache entry for the number of local generators, this is used
  // for progress
  char num[100];
  sprintf(num,""%d"",static_cast<int>(this->Makefiles.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_MAKEFILES"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
",1111,1148,[3],[]
6c442e5a899e07a85038c4f9c65dfe224ac9485e,"ccmake: Pass format string to 'printw' (#15738)

printw takes a format string as first argument, so don't pass variable
strings to it directly.",[u'https://gitlab.kitware.com/cmake/cmake/issues/15738'],Source/CursesDialog/cmCursesLongMessageForm.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_258.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_258.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_494.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_494.cpp,"  sprintf(version눧幊障�, ""%s"", vertmp);
  version[width] = '\0';

  curses_move(y-4,0);
  attron(A_STANDOUT);
  printw(bar);
  attroff(A_STANDOUT);
  curses_move(y-3,0);
  printw(version);
  pos_form_cursor(this->Form);
}

","  sprintf(version눧幊障�, ""%s"", vertmp);
  version[width] = '\0';

  char fmt_s[] = ""%s"";
  curses_move(y-4,0);
  attron(A_STANDOUT);
  printw(fmt_s, bar);
  attroff(A_STANDOUT);
  curses_move(y-3,0);
  printw(fmt_s, version);
  pos_form_cursor(this->Form);
}

",80,80,[0],[]
6c442e5a899e07a85038c4f9c65dfe224ac9485e,"ccmake: Pass format string to 'printw' (#15738)

printw takes a format string as first argument, so don't pass variable
strings to it directly.",[u'https://gitlab.kitware.com/cmake/cmake/issues/15738'],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_259.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_259.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_495.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_495.cpp,"    }

  curses_move(y-4,0);
  char fmt[512] = ""Press [enter] to edit option"";
  if ( process )
    {
    strcpy(fmt, ""                           "");
    }
  printw(fmt);
  curses_move(y-3,0);
  printw(firstLine);
  curses_move(y-2,0);
  printw(secondLine);
  curses_move(y-1,0);
  printw(thirdLine);

  if (cw)
    {
    sprintf(firstLine, ""Page %d of %d"", cw->GetPage(), this->NumberOfPages);
    curses_move(0,65-static_cast<unsigned int>(strlen(firstLine))-1);
    printw(firstLine);
    }
//    }

","    }

  curses_move(y-4,0);
  char fmt_s[] = ""%s"";
  char fmt[512] = ""Press [enter] to edit option"";
  if ( process )
    {
    strcpy(fmt, ""                           "");
    }
  printw(fmt_s, fmt);
  curses_move(y-3,0);
  printw(fmt_s, firstLine);
  curses_move(y-2,0);
  printw(fmt_s, secondLine);
  curses_move(y-1,0);
  printw(fmt_s, thirdLine);

  if (cw)
    {
    sprintf(firstLine, ""Page %d of %d"", cw->GetPage(), this->NumberOfPages);
    curses_move(0,65-static_cast<unsigned int>(strlen(firstLine))-1);
    printw(fmt_s, firstLine);
    }
//    }

",451,451,[18],[]
db7f069a4b33f3e8b45142b67289e51c142c90b4,"Windows: Fix 64-bit DLL module definition file generation on VS 2015

With 64-bit Windows builds, there is no need to remove the leading
underscore from all the symbols.  This is because it does not have one
in the .obj file unless it is really in the name.  This did not cause
any trouble until VS 2015 which has some system functions that have a
leading underscore that end up in the .def file.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_260.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_260.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_496.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_496.cpp,"                  symbol.erase(posAt);
               }
            }
            if (symbol[0] == '_') symbol.erase(0,1);
            if (this->ImportFlag) {
               this->ImportFlag = false;
               fprintf(this->FileOut,""EXPORTS \n"");
","                  symbol.erase(posAt);
               }
            }
            // For 64 bit builds we don't need to remove _
            if(!this->Is64Bit)
              {
              if (symbol[0] == '_')
                {
                symbol.erase(0,1);
                }
              }
            if (this->ImportFlag) {
               this->ImportFlag = false;
               fprintf(this->FileOut,""EXPORTS \n"");
",287,288,[6],[]
c5cc3441b379e2bc6e70efd6dbd530edebbf0024,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/CommandLineArguments.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_261.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_261.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_497.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_497.cpp,"    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for ( sit = mpit->second.begin(); sit != mpit->second.end(); sit� )
      {
      str << kwsys_ios::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
","    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for ( sit = mpit->second.begin(); sit != mpit->second.end(); sit� )
      {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
",604,601,[5],[]
1b79433a6d7cdd1da1a0af74240f2299c78e4112,"KWSys 2015-08-28 (dc3fdd7f)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ dc3fdd7f | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' cdaf522c..dc3fdd7f
Brad King (9):
      15a16826 Remove include <kwsys/ios/*> and kwsys_ios:: compatibility layer
      a5799c17 Remove unused KWSYS_IOS_USE_{SSTREAM,STRSTREAM_H,STRSTREA_H} checks
      198957cf Remove unused KWSYS_IOS_USE_SSTREAM check
      24d2b60e Remove support for pre-Cﯟ streams
      2a581c30 Remove support for pre-Cﯟ std::string missing operators
      5f3fd465 Remove support for pre-Cﯟ STL
      cded1574 Remove support for pre-Cﯟ STL from hash_map and hash_set
      f130a3ab Remove kwsys/cstddef compatibility header
      dc3fdd7f Remove support for pre-Cﯟ template capabilities",[],CommandLineArguments.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_262.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_262.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_498.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_498.cpp,"    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for ( sit = mpit->second.begin(); sit != mpit->second.end(); sit� )
      {
      str << kwsys_ios::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
","    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for ( sit = mpit->second.begin(); sit != mpit->second.end(); sit� )
      {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
",604,601,[5],[]
49d293a795c42c0325aa677d6a7c0f55c647da91,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_263.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_263.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_499.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_499.cpp,"
static int test1(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
","
static int test1(int argc, const char* argv[])
{
  /* This is a very basic functional test of kwsysProcess.  It is repeated
     numerous times to verify that there are no resource leaks in kwsysProcess
     that eventually lead to an error.  Many versions of OS X will fail after
     256 leaked file handles, so 257 iterations seems to be a good test.  On
     the other hand, too many iterations will cause the test to time out -
     especially if the test is instrumented with e.g. valgrind.

     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
",74,75,"[4, 5]",[]
ca96be228345d93f51cb4edbd0428b709f529b84,"KWSys 2015-08-24 (cdaf522c)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ cdaf522c | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' dad68c33..cdaf522c
Brad King (2):
      c8e5d1b2 Pass C� standard flags to SunPro in standalone build
      91cb7820 Remove unused source file ""CMakeEmptyInputFile.in""

James Johnston (6):
      0bca555e Process: Test running a process many times to discover resource leaks
      52788bb8 SystemTools:  Remove trailing whitespace.
      8122214c cmake: Set CMAKE_LEGACY_CYGWIN_WIN32 to 0.
      389d416b SystemTools:  Clarify/simplify behavior of FileExists
      8970cd56 SystemTools:  Added new TestFileAccess function.
      cdaf522c SystemTools:  Add honor_umask parameter to SetPermissions.

Mattias Ellert (1):
      b9df3e48 Fix implementation of KWSYS_PROPERTIES_C",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_264.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_264.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_500.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_500.cpp,"
static int test1(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
","
static int test1(int argc, const char* argv[])
{
  /* This is a very basic functional test of kwsysProcess.  It is repeated
     numerous times to verify that there are no resource leaks in kwsysProcess
     that eventually lead to an error.  Many versions of OS X will fail after
     256 leaked file handles, so 257 iterations seems to be a good test.  On
     the other hand, too many iterations will cause the test to time out -
     especially if the test is instrumented with e.g. valgrind.

     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
",74,75,"[4, 5]",[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/cookie.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_265.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_265.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_501.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_501.cpp,"          ""# http://curl.haxx.se/docs/http-cookies.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);
    co = c->cookies;

    while(co) {
      format_ptr = get_netscape_format(co);
      if(format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
","          ""# http://curl.haxx.se/docs/http-cookies.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);

    for(co = c->cookies; co; co = co->next) {
      if(!co->domain)
        continue;
      format_ptr = get_netscape_format(co);
      if(format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
",1274,1274,[8],[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/cookie.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_265.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_265.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_502.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_502.cpp,"      }
      fprintf(out, ""%s\n"", format_ptr);
      free(format_ptr);
      co=co->next;
    }
  }

","      }
      fprintf(out, ""%s\n"", format_ptr);
      free(format_ptr);
    }
  }

",1286,1287,[1],[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/curl_ntlm.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_266.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_266.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_503.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_503.cpp,"  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    error = Curl_ntlm_create_type1_message(userp, passwdp, ntlm, &base64,
                                           &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    error = Curl_ntlm_create_type3_message(conn->data, userp, passwdp,
                                           ntlm, &base64, &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
","  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    result = Curl_sasl_create_ntlm_type1_message(userp, passwdp, ntlm, &base64,
                                                 &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    result = Curl_sasl_create_ntlm_type3_message(conn->data, userp, passwdp,
                                                 ntlm, &base64, &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
",175,171,"[10, 16, 29, 35]",[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/curl_ntlm_msgs.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_267.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_267.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_504.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_504.cpp,"    fprintf(stderr, ""\n****\n"");
    fprintf(stderr, ""**** Header %s\n "", header);
  });
#endif
  free(buffer);

  return CURLE_OK;
}

#ifdef USE_WINDOWS_SSPI
void Curl_ntlm_sspi_cleanup(struct ntlmdata *ntlm)
{
  Curl_safefree(ntlm->type_2);

  if(ntlm->has_handles) {
    s_pSecFn->DeleteSecurityContext(&ntlm->c_handle);
    s_pSecFn->FreeCredentialsHandle(&ntlm->handle);
    ntlm->has_handles = 0;
  }

  ntlm->max_token_length = 0;
  Curl_safefree(ntlm->output_token);

  Curl_sspi_free_identity(ntlm->p_identity);
  ntlm->p_identity = NULL;
}
#endif

#ifndef USE_WINDOWS_SSPI
/* copy the source to the destination and fill in zeroes in every
   other destination byte! */
static void unicodecpy(unsigned char *dest, const char *src, size_t length)
","    fprintf(stderr, ""\n****\n"");
    fprintf(stderr, ""**** Header %s\n "", header);
  });

  free(type2);

  return result;
}

/* copy the source to the destination and fill in zeroes in every
   other destination byte! */
static void unicodecpy(unsigned char *dest, const char *src, size_t length)
",336,305,"[0, 1]",[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/curl_ntlm_msgs.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_267.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_267.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_505.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_505.cpp,"  /* Initial packet length */
  size = 32  hostlen  domlen;

#endif

  DEBUG_OUT({
    fprintf(stderr, ""* TYPE1 header flags=0x%02.2x%02.2x%02.2x%02.2x ""
            ""0x%08.8x "",
","  /* Initial packet length */
  size = 32  hostlen  domlen;

  DEBUG_OUT({
    fprintf(stderr, ""* TYPE1 header flags=0x%02.2x%02.2x%02.2x%02.2x ""
            ""0x%08.8x "",
",550,415,[6],[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/curl_ntlm_wb.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_268.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_268.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_506.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_506.cpp,"    if(res)
      return res;

    Curl_safefree(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
    DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    Curl_safefree(conn->response_header);
    conn->response_header = NULL;
    break;
  case NTLMSTATE_TYPE2:
","    if(res)
      return res;

    free(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
    DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    free(conn->response_header);
    conn->response_header = NULL;
    break;
  case NTLMSTATE_TYPE2:
",391,389,"[4, 7]",[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/curl_ntlm_wb.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_268.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_268.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_507.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_507.cpp,"    if(res)
      return res;

    Curl_safefree(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
","    if(res)
      return res;

    free(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
",409,407,[4],[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_269.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_269.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_508.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_508.cpp,"    }

  if(flags & CURL_GLOBAL_WIN32)
    if(win32_init() != CURLE_OK) {
      DEBUGF(fprintf(stderr, ""Error: win32_init failed\n""));
      return CURLE_FAILED_INIT;
    }
","    }

  if(flags & CURL_GLOBAL_WIN32)
    if(win32_init()) {
      DEBUGF(fprintf(stderr, ""Error: win32_init failed\n""));
      return CURLE_FAILED_INIT;
    }
",243,242,[4],[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_269.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_269.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_509.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_509.cpp,"  idna_init();
#endif

  if(Curl_resolver_global_init() != CURLE_OK) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }
","  idna_init();
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }
",265,264,[4],[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_269.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_269.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_510.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_510.cpp," */
CURL *curl_easy_init(void)
{
  CURLcode res;
  struct SessionHandle *data;

  /* Make sure we inited the global SSL stuff */
  if(!initialized) {
    res = curl_global_init(CURL_GLOBAL_DEFAULT);
    if(res) {
      /* something in the global init failed, return nothing */
      DEBUGF(fprintf(stderr, ""Error: curl_global_init failed\n""));
      return NULL;
    }
  }

  /* We use curl_open() with undefined URL so far */
  res = Curl_open(&data);
  if(res != CURLE_OK) {
    DEBUGF(fprintf(stderr, ""Error: Curl_open failed\n""));
    return NULL;
  }
"," */
CURL *curl_easy_init(void)
{
  CURLcode result;
  struct SessionHandle *data;

  /* Make sure we inited the global SSL stuff */
  if(!initialized) {
    result = curl_global_init(CURL_GLOBAL_DEFAULT);
    if(result) {
      /* something in the global init failed, return nothing */
      DEBUGF(fprintf(stderr, ""Error: curl_global_init failed\n""));
      return NULL;
    }
  }

  /* We use curl_open() with undefined URL so far */
  result = Curl_open(&data);
  if(result) {
    DEBUGF(fprintf(stderr, ""Error: Curl_open failed\n""));
    return NULL;
  }
",357,356,"[11, 19]",[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_270.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_270.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_511.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_511.cpp,"     information. Which for FILE can't be much more than the file size and
     date. */
  if(data->set.opt_no_body && data->set.include_header && fstated) {
    CURLcode result;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
","     information. Which for FILE can't be much more than the file size and
     date. */
  if(data->set.opt_no_body && data->set.include_header && fstated) {
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
",464,468,[4],[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_512.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_512.cpp,"        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);

          if(conn->bits.tunnel_proxy ||
             conn->proxytype == CURLPROXY_SOCKS5 ||
             conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
             conn->proxytype == CURLPROXY_SOCKS4 ||
             conn->proxytype == CURLPROXY_SOCKS4A)
            /* proxy tunnel -> use other host info because ip_addr_str is the
               proxy address not the ftp host */
            snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name);
          else
            /* use the same IP we are already connected to */
            snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str);
        }
      }
      else
","        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);
          ftpc->newhost = strdup(control_address(conn));
          if(!ftpc->newhost)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else
",1933,1967,"[11, 15]",[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_513.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_513.cpp,"
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the one we used
         for the control connection */
      infof(data, ""Skips %d.%d.%d.%d for data connection, uses %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->ip_addr_str);
      if(conn->bits.tunnel_proxy ||
         conn->proxytype == CURLPROXY_SOCKS5 ||
         conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
         conn->proxytype == CURLPROXY_SOCKS4 ||
         conn->proxytype == CURLPROXY_SOCKS4A)
        /* proxy tunnel -> use other host info because ip_addr_str is the
           proxy address not the ftp host */
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name);
      else
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str);
    }
    else
      snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);
    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
","
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the host we used
         for the control connection */
      infof(data, ""Skip %d.%d.%d.%d for data connection, re-use %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->host.name);
      ftpc->newhost = strdup(control_address(conn));
    }
    else
      ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);

    if(!ftpc->newhost)
      return CURLE_OUT_OF_MEMORY;

    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
",1986,2010,"[15, 17, 21]",[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_272.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_272.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_514.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_514.cpp,"
  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  error = Curl_base64_encode(data,
                             data->state.buffer, strlen(data->state.buffer),
                             &authorization, &size);
  if(error)
    return error;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  Curl_safefree(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
","
  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
",294,298,"[1, 13]",[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_272.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_272.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_515.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_515.cpp,"    if(((httpreq == HTTPREQ_GET) || (httpreq == HTTPREQ_HEAD)) &&
       !Curl_checkheaders(conn, ""Range:"")) {
      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);
    }
    else if((httpreq != HTTPREQ_GET) &&
            !Curl_checkheaders(conn, ""Content-Range:"")) {

      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);

      if(data->set.set_resume_from < 0) {
        /* Upload resume was asked for, but we don't know the size of the
","    if(((httpreq == HTTPREQ_GET) || (httpreq == HTTPREQ_HEAD)) &&
       !Curl_checkheaders(conn, ""Range:"")) {
      /* if a line like this was already allocated, free the previous one */
      free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);
    }
    else if((httpreq != HTTPREQ_GET) &&
            !Curl_checkheaders(conn, ""Content-Range:"")) {

      /* if a line like this was already allocated, free the previous one */
      free(conn->allocptr.rangeline);

      if(data->set.set_resume_from < 0) {
        /* Upload resume was asked for, but we don't know the size of the
",2153,2198,[5],[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_516.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_516.cpp,"
#include ""urldata.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""curl_md5.h""
#include ""http_digest.h""
#include ""strtok.h""
#include ""curl_memory.h""
#include ""vtls/vtls.h"" /* for Curl_rand() */
#include ""non-ascii.h"" /* included for Curl_convert_... prototypes */
#include ""warnless.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

#define MAX_VALUE_LENGTH 256
#define MAX_CONTENT_LENGTH 1024

static void digest_cleanup_one(struct digestdata *dig);

/*
 * Return 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
static int get_pair(const char *str, char *value, char *content,
                    const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c=MAX_VALUE_LENGTH-1; (*str && (*str != '=') && c--); )
    *value� = *str�;
  *value=0;

  if('=' != *str�)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    str�;
    starts_with_quote = TRUE;
  }

  for(c=MAX_CONTENT_LENGTH-1; *str && c--; str�) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *content� = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c=0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c=0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c=0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *content� = *str;
  }
  *content=0;

  *endptr = str;

  return 0; /* all is fine! */
}

/* Test example headers:

WWW-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""
Proxy-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""

*/

CURLdigest Curl_input_digest(struct connectdata *conn,
                             bool proxy,
                             const char *header) /* rest of the *-authenticate:
                                                    header */
{
  char *token = NULL;
  char *tmp = NULL;
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  struct SessionHandle *data=conn->data;
  bool before = FALSE; /* got a nonce before */
  struct digestdata *d;

  if(proxy) {
    d = &data->state.proxydigest;
  }
  else {
    d = &data->state.digest;
  }

  if(checkprefix(""Digest"", header)) {
    header = strlen(""Digest"");

    /* If we already have received a nonce, keep that in mind */
    if(d->nonce)
      before = TRUE;

    /* clear off any former leftovers and init to defaults */
    digest_cleanup_one(d);

    for(;;) {
      char value[MAX_VALUE_LENGTH];
      char content[MAX_CONTENT_LENGTH];

      while(*header && ISSPACE(*header))
        header�;

      /* extract a value=content pair */
      if(!get_pair(header, value, content, &header)) {
        if(Curl_raw_equal(value, ""nonce"")) {
          d->nonce = strdup(content);
          if(!d->nonce)
            return CURLDIGEST_NOMEM;
        }
        else if(Curl_raw_equal(value, ""stale"")) {
          if(Curl_raw_equal(content, ""true"")) {
            d->stale = TRUE;
            d->nc = 1; /* we make a new nonce now */
          }
        }
        else if(Curl_raw_equal(value, ""realm"")) {
          d->realm = strdup(content);
          if(!d->realm)
            return CURLDIGEST_NOMEM;
        }
        else if(Curl_raw_equal(value, ""opaque"")) {
          d->opaque = strdup(content);
          if(!d->opaque)
            return CURLDIGEST_NOMEM;
        }
        else if(Curl_raw_equal(value, ""qop"")) {
          char *tok_buf;
          /* tokenize the list and choose auth if possible, use a temporary
             clone of the buffer since strtok_r() ruins it */
          tmp = strdup(content);
          if(!tmp)
            return CURLDIGEST_NOMEM;
          token = strtok_r(tmp, "","", &tok_buf);
          while(token != NULL) {
            if(Curl_raw_equal(token, ""auth"")) {
              foundAuth = TRUE;
            }
            else if(Curl_raw_equal(token, ""auth-int"")) {
              foundAuthInt = TRUE;
            }
            token = strtok_r(NULL, "","", &tok_buf);
          }
          free(tmp);
          /*select only auth o auth-int. Otherwise, ignore*/
          if(foundAuth) {
            d->qop = strdup(""auth"");
            if(!d->qop)
              return CURLDIGEST_NOMEM;
          }
          else if(foundAuthInt) {
            d->qop = strdup(""auth-int"");
            if(!d->qop)
              return CURLDIGEST_NOMEM;
          }
        }
        else if(Curl_raw_equal(value, ""algorithm"")) {
          d->algorithm = strdup(content);
          if(!d->algorithm)
            return CURLDIGEST_NOMEM;
          if(Curl_raw_equal(content, ""MD5-sess""))
            d->algo = CURLDIGESTALGO_MD5SESS;
          else if(Curl_raw_equal(content, ""MD5""))
            d->algo = CURLDIGESTALGO_MD5;
          else
            return CURLDIGEST_BADALGO;
        }
        else {
          /* unknown specifier, ignore it! */
        }
      }
      else
        break; /* we're done here */

      /* pass all additional spaces here */
      while(*header && ISSPACE(*header))
        header�;
      if(',' == *header)
        /* allow the list to be comma-separated */
        header�;
    }
    /* We had a nonce since before, and we got another one now without
       'stale=true'. This means we provided bad credentials in the previous
       request */
    if(before && !d->stale)
      return CURLDIGEST_BAD;

    /* We got this header without a nonce, that's a bad Digest line! */
    if(!d->nonce)
      return CURLDIGEST_BAD;
  }
  else
    /* else not a digest, get out */
    return CURLDIGEST_NONE;

  return CURLDIGEST_FINE;
}

/* convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void md5_to_ascii(unsigned char *source, /* 16 bytes */
                         unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i=0; i<16; i�)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    �;
    if(*s == '""' || *s == '\\') {
      �;
    }
    �;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *d� = '\\';
      }
      *d� = *s�;
    }
    *d = 0;
  }

  return dest;
}

CURLcode Curl_output_digest(struct connectdata *conn,
                            bool proxy,
                            const unsigned char *request,
                            const unsigned char *uripath)
{
  /* We have a Digest setup for this, use it!  Now, to get all the details for
     this sorted out, I must urge you dear friend to read up on the RFC2617
     section 3.2.2, */
  size_t urilen;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *tmp = NULL;
  char **allocuserpwd;
  size_t userlen;
  const char *userp;
  char *userp_quoted;
  const char *passwdp;
  struct auth *authp;

  struct SessionHandle *data = conn->data;
  struct digestdata *d;
  CURLcode rc;
/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  rc = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(rc != CURLE_OK) { \
    free(b); \
    return rc; \
  }

  if(proxy) {
    d = &data->state.proxydigest;
    allocuserpwd = &conn->allocptr.proxyuserpwd;
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    authp = &data->state.authproxy;
  }
  else {
    d = &data->state.digest;
    allocuserpwd = &conn->allocptr.userpwd;
    userp = conn->user;
    passwdp = conn->passwd;
","
#include ""urldata.h""
#include ""rawstr.h""
#include ""curl_sasl.h""
#include ""http_digest.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

/* Test example headers:

WWW-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""
Proxy-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""

*/

CURLcode Curl_input_digest(struct connectdata *conn,
                           bool proxy,
                           const char *header) /* rest of the *-authenticate:
                                                  header */
{
  struct SessionHandle *data = conn->data;

  /* Point to the correct struct with this */
  struct digestdata *digest;

  if(proxy) {
    digest = &data->state.proxydigest;
  }
  else {
    digest = &data->state.digest;
  }

  if(!checkprefix(""Digest"", header))
    return CURLE_BAD_CONTENT_ENCODING;

  header = strlen(""Digest"");
  while(*header && ISSPACE(*header))
    header�;

  return Curl_sasl_decode_digest_http_message(header, digest);
}

CURLcode Curl_output_digest(struct connectdata *conn,
                            bool proxy,
                            const unsigned char *request,
                            const unsigned char *uripath)
{
  CURLcode result;
  struct SessionHandle *data = conn->data;
  unsigned char *path;
  char *tmp;
  char *response;
  size_t len;
  bool have_chlg;

  /* Point to the address of the pointer that holds the string to send to the
     server, which is for a plain host or for a HTTP proxy */
  char **allocuserpwd;

  /* Point to the name and password for this */
  const char *userp;
  const char *passwdp;

  /* Point to the correct struct with this */
  struct digestdata *digest;
  struct auth *authp;

  if(proxy) {
    digest = &data->state.proxydigest;
    allocuserpwd = &conn->allocptr.proxyuserpwd;
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    authp = &data->state.authproxy;
  }
  else {
    digest = &data->state.digest;
    allocuserpwd = &conn->allocptr.userpwd;
    userp = conn->user;
    passwdp = conn->passwd;
",26,26,[236],[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_517.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_517.cpp,"
  /* not set means empty */
  if(!userp)
    userp="""";

  if(!passwdp)
    passwdp="""";

  if(!d->nonce) {
    authp->done = FALSE;
    return CURLE_OK;
  }
  authp->done = TRUE;

  if(!d->nc)
    d->nc = 1;

  if(!d->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, d->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha1);

  if(d->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
","
  /* not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

#if defined(USE_WINDOWS_SSPI)
  have_chlg = digest->input_token ? TRUE : FALSE;
#else
  have_chlg = digest->nonce ? TRUE : FALSE;
#endif

  if(!have_chlg) {
    authp->done = FALSE;
    return CURLE_OK;
  }

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
",352,112,"[18, 40, 51]",[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_518.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_518.cpp,"
#include ""curl_setup.h""

#ifdef HAVE_GSSAPI
#ifdef HAVE_OLD_GSSMIT
#define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
#define NCOMPAT 1
#endif

#ifndef CURL_DISABLE_HTTP

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_memory.h""
#include ""url.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

static int
get_gss_name(struct connectdata *conn, bool proxy, gss_name_t *server)
{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service)  1  strlen(proxy ? conn->proxy.name :
                                              conn->host.name)  1;
  if(token.length  1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}

static void
log_gss_error(struct connectdata *conn, OM_uint32 error_status,
              const char *prefix)
{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len  status_string.length  1) {
        snprintf(buf  len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len = status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}

/* returning zero (0) means success, everything else is treated as ""failure""
   with no care exactly what the failure was */
int Curl_input_negotiate(struct connectdata *conn, bool proxy,
                         const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  int ret;
  size_t len;
  size_t rawlen = 0;
  CURLcode error;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return -1;
  }

  if(neg_ctx->server_name == NULL &&
      (ret = get_gss_name(conn, proxy, &neg_ctx->server_name)))
    return ret;

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    header�;

  len = strlen(header);
  if(len > 0) {
    error = Curl_base64_decode(header,
                               (unsigned char **)&input_token.value, &rawlen);
    if(error || rawlen == 0)
      return -1;
    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
","
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    header�;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
",22,22,"[39, 61, 71]",[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_proxy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_275.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_275.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_519.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_519.cpp,"
      host_port = aprintf(""%s:%hu"", hostname, remote_port);
      if(!host_port) {
        free(req_buffer);
        return CURLE_OUT_OF_MEMORY;
      }

","
      host_port = aprintf(""%s:%hu"", hostname, remote_port);
      if(!host_port) {
        Curl_add_buffer_free(req_buffer);
        return CURLE_OUT_OF_MEMORY;
      }

",139,139,[1],[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_proxy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_275.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_275.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_520.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_520.cpp,"                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          free(req_buffer);
          return CURLE_OUT_OF_MEMORY;
        }

        if(!Curl_checkProxyheaders(conn, ""Host:"")) {
          host = aprintf(""Host: %s\r\n"", hostheader);
          if(!host) {
            free(hostheader);
            free(req_buffer);
            return CURLE_OUT_OF_MEMORY;
          }
        }
","                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
          return CURLE_OUT_OF_MEMORY;
        }

        if(!Curl_checkProxyheaders(conn, ""Host:"")) {
          host = aprintf(""Host: %s\r\n"", hostheader);
          if(!host) {
            free(hostheader);
            Curl_add_buffer_free(req_buffer);
            return CURLE_OUT_OF_MEMORY;
          }
        }
",159,159,[8],[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/if2ip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_276.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_276.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_521.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_521.cpp,"}

if2ip_result_t Curl_if2ip(int af, unsigned int remote_scope,
                          const char *interf, char *buf, int buf_size)
{
  struct ifaddrs *iface, *head;
  if2ip_result_t res = IF2IP_NOT_FOUND;

#ifndef ENABLE_IPV6
  (void) remote_scope;
#endif

  if(getifaddrs(&head) >= 0) {
    for(iface=head; iface != NULL; iface=iface->ifa_next) {
      if(iface->ifa_addr != NULL) {
        if(iface->ifa_addr->sa_family == af) {
          if(curl_strequal(iface->ifa_name, interf)) {
            void *addr;
            char *ip;
            char scope[12]="""";
            char ipstr[64];
#ifdef ENABLE_IPV6
            if(af == AF_INET6) {
              unsigned int scopeid = 0;
              addr = &((struct sockaddr_in6 *)iface->ifa_addr)->sin6_addr;
#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
              /* Include the scope of this interface as part of the address */
              scopeid =
                ((struct sockaddr_in6 *)iface->ifa_addr)->sin6_scope_id;
#endif
              if(scopeid != remote_scope) {
                /* We are interested only in interface addresses whose
                   scope ID matches the remote address we want to
                   connect to: global (0) for global, link-local for
                   link-local, etc... */
                if(res == IF2IP_NOT_FOUND) res = IF2IP_AF_NOT_SUPPORTED;
                continue;
              }
              if(scopeid)
                snprintf(scope, sizeof(scope), ""%%%u"", scopeid);
            }
","}

if2ip_result_t Curl_if2ip(int af, unsigned int remote_scope,
                          unsigned int remote_scope_id, const char *interf,
                          char *buf, int buf_size)
{
  struct ifaddrs *iface, *head;
  if2ip_result_t res = IF2IP_NOT_FOUND;

#ifndef ENABLE_IPV6
  (void) remote_scope;

#ifndef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
  (void) remote_scope_id;
#endif

#endif

  if(getifaddrs(&head) >= 0) {
    for(iface = head; iface != NULL; iface=iface->ifa_next) {
      if(iface->ifa_addr != NULL) {
        if(iface->ifa_addr->sa_family == af) {
          if(curl_strequal(iface->ifa_name, interf)) {
            void *addr;
            char *ip;
            char scope[12] = """";
            char ipstr[64];
#ifdef ENABLE_IPV6
            if(af == AF_INET6) {
              unsigned int scopeid = 0;
              unsigned int ifscope = Curl_ipv6_scope(iface->ifa_addr);

              if(ifscope != remote_scope) {
                /* We are interested only in interface addresses whose
                   scope matches the remote address we want to
                   connect to: global for global, link-local for
                   link-local, etc... */
                if(res == IF2IP_NOT_FOUND) res = IF2IP_AF_NOT_SUPPORTED;
                continue;
              }

              addr = &((struct sockaddr_in6 *)iface->ifa_addr)->sin6_addr;
#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
              /* Include the scope of this interface as part of the address */
              scopeid =
                ((struct sockaddr_in6 *)iface->ifa_addr)->sin6_scope_id;

              /* If given, scope id should match. */
              if(remote_scope_id && scopeid != remote_scope_id) {
                if(res == IF2IP_NOT_FOUND)
                  res = IF2IP_AF_NOT_SUPPORTED;

                continue;
              }
#endif
              if(scopeid)
                snprintf(scope, sizeof(scope), ""%%%u"", scopeid);
            }
",84,114,[39],[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/krb5.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_277.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_277.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_522.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_522.cpp,"                                      (unsigned char **)&_gssresp.value,
                                      &_gssresp.length);
          if(result) {
            Curl_failf(data,""base64-decoding: %s"", curl_easy_strerror(result));
            ret = AUTH_CONTINUE;
            break;
          }
","                                      (unsigned char **)&_gssresp.value,
                                      &_gssresp.length);
          if(result) {
            Curl_failf(data, ""base64-decoding: %s"",
                       curl_easy_strerror(result));
            ret = AUTH_CONTINUE;
            break;
          }
",289,279,[3],[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/cookie.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_278.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_278.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_523.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_523.cpp,"          ""# http://curl.haxx.se/docs/http-cookies.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);
    co = c->cookies;

    while(co) {
      format_ptr = get_netscape_format(co);
      if(format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
","          ""# http://curl.haxx.se/docs/http-cookies.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);

    for(co = c->cookies; co; co = co->next) {
      if(!co->domain)
        continue;
      format_ptr = get_netscape_format(co);
      if(format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
",1274,1274,[8],[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/cookie.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_278.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_278.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_524.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_524.cpp,"      }
      fprintf(out, ""%s\n"", format_ptr);
      free(format_ptr);
      co=co->next;
    }
  }

","      }
      fprintf(out, ""%s\n"", format_ptr);
      free(format_ptr);
    }
  }

",1286,1287,[1],[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/curl_ntlm.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_279.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_279.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_525.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_525.cpp,"  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    error = Curl_ntlm_create_type1_message(userp, passwdp, ntlm, &base64,
                                           &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    error = Curl_ntlm_create_type3_message(conn->data, userp, passwdp,
                                           ntlm, &base64, &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
","  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    result = Curl_sasl_create_ntlm_type1_message(userp, passwdp, ntlm, &base64,
                                                 &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    result = Curl_sasl_create_ntlm_type3_message(conn->data, userp, passwdp,
                                                 ntlm, &base64, &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
",175,171,"[10, 16, 29, 35]",[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/curl_ntlm_msgs.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_280.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_280.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_526.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_526.cpp,"    fprintf(stderr, ""\n****\n"");
    fprintf(stderr, ""**** Header %s\n "", header);
  });
#endif
  free(buffer);

  return CURLE_OK;
}

#ifdef USE_WINDOWS_SSPI
void Curl_ntlm_sspi_cleanup(struct ntlmdata *ntlm)
{
  Curl_safefree(ntlm->type_2);

  if(ntlm->has_handles) {
    s_pSecFn->DeleteSecurityContext(&ntlm->c_handle);
    s_pSecFn->FreeCredentialsHandle(&ntlm->handle);
    ntlm->has_handles = 0;
  }

  ntlm->max_token_length = 0;
  Curl_safefree(ntlm->output_token);

  Curl_sspi_free_identity(ntlm->p_identity);
  ntlm->p_identity = NULL;
}
#endif

#ifndef USE_WINDOWS_SSPI
/* copy the source to the destination and fill in zeroes in every
   other destination byte! */
static void unicodecpy(unsigned char *dest, const char *src, size_t length)
","    fprintf(stderr, ""\n****\n"");
    fprintf(stderr, ""**** Header %s\n "", header);
  });

  free(type2);

  return result;
}

/* copy the source to the destination and fill in zeroes in every
   other destination byte! */
static void unicodecpy(unsigned char *dest, const char *src, size_t length)
",336,305,"[0, 1]",[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/curl_ntlm_msgs.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_280.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_280.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_527.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_527.cpp,"  /* Initial packet length */
  size = 32  hostlen  domlen;

#endif

  DEBUG_OUT({
    fprintf(stderr, ""* TYPE1 header flags=0x%02.2x%02.2x%02.2x%02.2x ""
            ""0x%08.8x "",
","  /* Initial packet length */
  size = 32  hostlen  domlen;

  DEBUG_OUT({
    fprintf(stderr, ""* TYPE1 header flags=0x%02.2x%02.2x%02.2x%02.2x ""
            ""0x%08.8x "",
",550,415,[6],[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/curl_ntlm_wb.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_281.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_281.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_528.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_528.cpp,"    if(res)
      return res;

    Curl_safefree(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
    DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    Curl_safefree(conn->response_header);
    conn->response_header = NULL;
    break;
  case NTLMSTATE_TYPE2:
","    if(res)
      return res;

    free(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
    DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    free(conn->response_header);
    conn->response_header = NULL;
    break;
  case NTLMSTATE_TYPE2:
",391,389,"[4, 7]",[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/curl_ntlm_wb.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_281.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_281.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_529.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_529.cpp,"    if(res)
      return res;

    Curl_safefree(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
","    if(res)
      return res;

    free(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
",409,407,[4],[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_282.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_282.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_530.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_530.cpp,"    }

  if(flags & CURL_GLOBAL_WIN32)
    if(win32_init() != CURLE_OK) {
      DEBUGF(fprintf(stderr, ""Error: win32_init failed\n""));
      return CURLE_FAILED_INIT;
    }
","    }

  if(flags & CURL_GLOBAL_WIN32)
    if(win32_init()) {
      DEBUGF(fprintf(stderr, ""Error: win32_init failed\n""));
      return CURLE_FAILED_INIT;
    }
",243,242,[4],[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_282.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_282.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_531.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_531.cpp,"  idna_init();
#endif

  if(Curl_resolver_global_init() != CURLE_OK) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }
","  idna_init();
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }
",265,264,[4],[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_282.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_282.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_532.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_532.cpp," */
CURL *curl_easy_init(void)
{
  CURLcode res;
  struct SessionHandle *data;

  /* Make sure we inited the global SSL stuff */
  if(!initialized) {
    res = curl_global_init(CURL_GLOBAL_DEFAULT);
    if(res) {
      /* something in the global init failed, return nothing */
      DEBUGF(fprintf(stderr, ""Error: curl_global_init failed\n""));
      return NULL;
    }
  }

  /* We use curl_open() with undefined URL so far */
  res = Curl_open(&data);
  if(res != CURLE_OK) {
    DEBUGF(fprintf(stderr, ""Error: Curl_open failed\n""));
    return NULL;
  }
"," */
CURL *curl_easy_init(void)
{
  CURLcode result;
  struct SessionHandle *data;

  /* Make sure we inited the global SSL stuff */
  if(!initialized) {
    result = curl_global_init(CURL_GLOBAL_DEFAULT);
    if(result) {
      /* something in the global init failed, return nothing */
      DEBUGF(fprintf(stderr, ""Error: curl_global_init failed\n""));
      return NULL;
    }
  }

  /* We use curl_open() with undefined URL so far */
  result = Curl_open(&data);
  if(result) {
    DEBUGF(fprintf(stderr, ""Error: Curl_open failed\n""));
    return NULL;
  }
",357,356,"[11, 19]",[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_283.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_283.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_533.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_533.cpp,"     information. Which for FILE can't be much more than the file size and
     date. */
  if(data->set.opt_no_body && data->set.include_header && fstated) {
    CURLcode result;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
","     information. Which for FILE can't be much more than the file size and
     date. */
  if(data->set.opt_no_body && data->set.include_header && fstated) {
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
",464,468,[4],[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_534.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_534.cpp,"        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);

          if(conn->bits.tunnel_proxy ||
             conn->proxytype == CURLPROXY_SOCKS5 ||
             conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
             conn->proxytype == CURLPROXY_SOCKS4 ||
             conn->proxytype == CURLPROXY_SOCKS4A)
            /* proxy tunnel -> use other host info because ip_addr_str is the
               proxy address not the ftp host */
            snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name);
          else
            /* use the same IP we are already connected to */
            snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str);
        }
      }
      else
","        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);
          ftpc->newhost = strdup(control_address(conn));
          if(!ftpc->newhost)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else
",1933,1967,"[11, 15]",[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_535.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_535.cpp,"
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the one we used
         for the control connection */
      infof(data, ""Skips %d.%d.%d.%d for data connection, uses %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->ip_addr_str);
      if(conn->bits.tunnel_proxy ||
         conn->proxytype == CURLPROXY_SOCKS5 ||
         conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
         conn->proxytype == CURLPROXY_SOCKS4 ||
         conn->proxytype == CURLPROXY_SOCKS4A)
        /* proxy tunnel -> use other host info because ip_addr_str is the
           proxy address not the ftp host */
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name);
      else
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str);
    }
    else
      snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);
    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
","
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the host we used
         for the control connection */
      infof(data, ""Skip %d.%d.%d.%d for data connection, re-use %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->host.name);
      ftpc->newhost = strdup(control_address(conn));
    }
    else
      ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);

    if(!ftpc->newhost)
      return CURLE_OUT_OF_MEMORY;

    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
",1986,2010,"[15, 17, 21]",[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_285.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_285.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_536.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_536.cpp,"
  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  error = Curl_base64_encode(data,
                             data->state.buffer, strlen(data->state.buffer),
                             &authorization, &size);
  if(error)
    return error;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  Curl_safefree(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
","
  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
",294,298,"[1, 13]",[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_285.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_285.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_537.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_537.cpp,"    if(((httpreq == HTTPREQ_GET) || (httpreq == HTTPREQ_HEAD)) &&
       !Curl_checkheaders(conn, ""Range:"")) {
      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);
    }
    else if((httpreq != HTTPREQ_GET) &&
            !Curl_checkheaders(conn, ""Content-Range:"")) {

      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);

      if(data->set.set_resume_from < 0) {
        /* Upload resume was asked for, but we don't know the size of the
","    if(((httpreq == HTTPREQ_GET) || (httpreq == HTTPREQ_HEAD)) &&
       !Curl_checkheaders(conn, ""Range:"")) {
      /* if a line like this was already allocated, free the previous one */
      free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);
    }
    else if((httpreq != HTTPREQ_GET) &&
            !Curl_checkheaders(conn, ""Content-Range:"")) {

      /* if a line like this was already allocated, free the previous one */
      free(conn->allocptr.rangeline);

      if(data->set.set_resume_from < 0) {
        /* Upload resume was asked for, but we don't know the size of the
",2153,2198,[5],[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_538.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_538.cpp,"
#include ""urldata.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""curl_md5.h""
#include ""http_digest.h""
#include ""strtok.h""
#include ""curl_memory.h""
#include ""vtls/vtls.h"" /* for Curl_rand() */
#include ""non-ascii.h"" /* included for Curl_convert_... prototypes */
#include ""warnless.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

#define MAX_VALUE_LENGTH 256
#define MAX_CONTENT_LENGTH 1024

static void digest_cleanup_one(struct digestdata *dig);

/*
 * Return 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
static int get_pair(const char *str, char *value, char *content,
                    const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c=MAX_VALUE_LENGTH-1; (*str && (*str != '=') && c--); )
    *value� = *str�;
  *value=0;

  if('=' != *str�)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    str�;
    starts_with_quote = TRUE;
  }

  for(c=MAX_CONTENT_LENGTH-1; *str && c--; str�) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *content� = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c=0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c=0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c=0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *content� = *str;
  }
  *content=0;

  *endptr = str;

  return 0; /* all is fine! */
}

/* Test example headers:

WWW-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""
Proxy-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""

*/

CURLdigest Curl_input_digest(struct connectdata *conn,
                             bool proxy,
                             const char *header) /* rest of the *-authenticate:
                                                    header */
{
  char *token = NULL;
  char *tmp = NULL;
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  struct SessionHandle *data=conn->data;
  bool before = FALSE; /* got a nonce before */
  struct digestdata *d;

  if(proxy) {
    d = &data->state.proxydigest;
  }
  else {
    d = &data->state.digest;
  }

  if(checkprefix(""Digest"", header)) {
    header = strlen(""Digest"");

    /* If we already have received a nonce, keep that in mind */
    if(d->nonce)
      before = TRUE;

    /* clear off any former leftovers and init to defaults */
    digest_cleanup_one(d);

    for(;;) {
      char value[MAX_VALUE_LENGTH];
      char content[MAX_CONTENT_LENGTH];

      while(*header && ISSPACE(*header))
        header�;

      /* extract a value=content pair */
      if(!get_pair(header, value, content, &header)) {
        if(Curl_raw_equal(value, ""nonce"")) {
          d->nonce = strdup(content);
          if(!d->nonce)
            return CURLDIGEST_NOMEM;
        }
        else if(Curl_raw_equal(value, ""stale"")) {
          if(Curl_raw_equal(content, ""true"")) {
            d->stale = TRUE;
            d->nc = 1; /* we make a new nonce now */
          }
        }
        else if(Curl_raw_equal(value, ""realm"")) {
          d->realm = strdup(content);
          if(!d->realm)
            return CURLDIGEST_NOMEM;
        }
        else if(Curl_raw_equal(value, ""opaque"")) {
          d->opaque = strdup(content);
          if(!d->opaque)
            return CURLDIGEST_NOMEM;
        }
        else if(Curl_raw_equal(value, ""qop"")) {
          char *tok_buf;
          /* tokenize the list and choose auth if possible, use a temporary
             clone of the buffer since strtok_r() ruins it */
          tmp = strdup(content);
          if(!tmp)
            return CURLDIGEST_NOMEM;
          token = strtok_r(tmp, "","", &tok_buf);
          while(token != NULL) {
            if(Curl_raw_equal(token, ""auth"")) {
              foundAuth = TRUE;
            }
            else if(Curl_raw_equal(token, ""auth-int"")) {
              foundAuthInt = TRUE;
            }
            token = strtok_r(NULL, "","", &tok_buf);
          }
          free(tmp);
          /*select only auth o auth-int. Otherwise, ignore*/
          if(foundAuth) {
            d->qop = strdup(""auth"");
            if(!d->qop)
              return CURLDIGEST_NOMEM;
          }
          else if(foundAuthInt) {
            d->qop = strdup(""auth-int"");
            if(!d->qop)
              return CURLDIGEST_NOMEM;
          }
        }
        else if(Curl_raw_equal(value, ""algorithm"")) {
          d->algorithm = strdup(content);
          if(!d->algorithm)
            return CURLDIGEST_NOMEM;
          if(Curl_raw_equal(content, ""MD5-sess""))
            d->algo = CURLDIGESTALGO_MD5SESS;
          else if(Curl_raw_equal(content, ""MD5""))
            d->algo = CURLDIGESTALGO_MD5;
          else
            return CURLDIGEST_BADALGO;
        }
        else {
          /* unknown specifier, ignore it! */
        }
      }
      else
        break; /* we're done here */

      /* pass all additional spaces here */
      while(*header && ISSPACE(*header))
        header�;
      if(',' == *header)
        /* allow the list to be comma-separated */
        header�;
    }
    /* We had a nonce since before, and we got another one now without
       'stale=true'. This means we provided bad credentials in the previous
       request */
    if(before && !d->stale)
      return CURLDIGEST_BAD;

    /* We got this header without a nonce, that's a bad Digest line! */
    if(!d->nonce)
      return CURLDIGEST_BAD;
  }
  else
    /* else not a digest, get out */
    return CURLDIGEST_NONE;

  return CURLDIGEST_FINE;
}

/* convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void md5_to_ascii(unsigned char *source, /* 16 bytes */
                         unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i=0; i<16; i�)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    �;
    if(*s == '""' || *s == '\\') {
      �;
    }
    �;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *d� = '\\';
      }
      *d� = *s�;
    }
    *d = 0;
  }

  return dest;
}

CURLcode Curl_output_digest(struct connectdata *conn,
                            bool proxy,
                            const unsigned char *request,
                            const unsigned char *uripath)
{
  /* We have a Digest setup for this, use it!  Now, to get all the details for
     this sorted out, I must urge you dear friend to read up on the RFC2617
     section 3.2.2, */
  size_t urilen;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *tmp = NULL;
  char **allocuserpwd;
  size_t userlen;
  const char *userp;
  char *userp_quoted;
  const char *passwdp;
  struct auth *authp;

  struct SessionHandle *data = conn->data;
  struct digestdata *d;
  CURLcode rc;
/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  rc = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(rc != CURLE_OK) { \
    free(b); \
    return rc; \
  }

  if(proxy) {
    d = &data->state.proxydigest;
    allocuserpwd = &conn->allocptr.proxyuserpwd;
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    authp = &data->state.authproxy;
  }
  else {
    d = &data->state.digest;
    allocuserpwd = &conn->allocptr.userpwd;
    userp = conn->user;
    passwdp = conn->passwd;
","
#include ""urldata.h""
#include ""rawstr.h""
#include ""curl_sasl.h""
#include ""http_digest.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

/* Test example headers:

WWW-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""
Proxy-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""

*/

CURLcode Curl_input_digest(struct connectdata *conn,
                           bool proxy,
                           const char *header) /* rest of the *-authenticate:
                                                  header */
{
  struct SessionHandle *data = conn->data;

  /* Point to the correct struct with this */
  struct digestdata *digest;

  if(proxy) {
    digest = &data->state.proxydigest;
  }
  else {
    digest = &data->state.digest;
  }

  if(!checkprefix(""Digest"", header))
    return CURLE_BAD_CONTENT_ENCODING;

  header = strlen(""Digest"");
  while(*header && ISSPACE(*header))
    header�;

  return Curl_sasl_decode_digest_http_message(header, digest);
}

CURLcode Curl_output_digest(struct connectdata *conn,
                            bool proxy,
                            const unsigned char *request,
                            const unsigned char *uripath)
{
  CURLcode result;
  struct SessionHandle *data = conn->data;
  unsigned char *path;
  char *tmp;
  char *response;
  size_t len;
  bool have_chlg;

  /* Point to the address of the pointer that holds the string to send to the
     server, which is for a plain host or for a HTTP proxy */
  char **allocuserpwd;

  /* Point to the name and password for this */
  const char *userp;
  const char *passwdp;

  /* Point to the correct struct with this */
  struct digestdata *digest;
  struct auth *authp;

  if(proxy) {
    digest = &data->state.proxydigest;
    allocuserpwd = &conn->allocptr.proxyuserpwd;
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    authp = &data->state.authproxy;
  }
  else {
    digest = &data->state.digest;
    allocuserpwd = &conn->allocptr.userpwd;
    userp = conn->user;
    passwdp = conn->passwd;
",26,26,[236],[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_539.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_539.cpp,"
  /* not set means empty */
  if(!userp)
    userp="""";

  if(!passwdp)
    passwdp="""";

  if(!d->nonce) {
    authp->done = FALSE;
    return CURLE_OK;
  }
  authp->done = TRUE;

  if(!d->nc)
    d->nc = 1;

  if(!d->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, d->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha1);

  if(d->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
","
  /* not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

#if defined(USE_WINDOWS_SSPI)
  have_chlg = digest->input_token ? TRUE : FALSE;
#else
  have_chlg = digest->nonce ? TRUE : FALSE;
#endif

  if(!have_chlg) {
    authp->done = FALSE;
    return CURLE_OK;
  }

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
",352,112,"[18, 40, 51]",[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_540.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_540.cpp,"
#include ""curl_setup.h""

#ifdef HAVE_GSSAPI
#ifdef HAVE_OLD_GSSMIT
#define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
#define NCOMPAT 1
#endif

#ifndef CURL_DISABLE_HTTP

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_memory.h""
#include ""url.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

static int
get_gss_name(struct connectdata *conn, bool proxy, gss_name_t *server)
{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service)  1  strlen(proxy ? conn->proxy.name :
                                              conn->host.name)  1;
  if(token.length  1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}

static void
log_gss_error(struct connectdata *conn, OM_uint32 error_status,
              const char *prefix)
{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len  status_string.length  1) {
        snprintf(buf  len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len = status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}

/* returning zero (0) means success, everything else is treated as ""failure""
   with no care exactly what the failure was */
int Curl_input_negotiate(struct connectdata *conn, bool proxy,
                         const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  int ret;
  size_t len;
  size_t rawlen = 0;
  CURLcode error;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return -1;
  }

  if(neg_ctx->server_name == NULL &&
      (ret = get_gss_name(conn, proxy, &neg_ctx->server_name)))
    return ret;

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    header�;

  len = strlen(header);
  if(len > 0) {
    error = Curl_base64_decode(header,
                               (unsigned char **)&input_token.value, &rawlen);
    if(error || rawlen == 0)
      return -1;
    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
","
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    header�;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
",22,22,"[39, 61, 71]",[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_proxy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_288.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_288.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_541.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_541.cpp,"
      host_port = aprintf(""%s:%hu"", hostname, remote_port);
      if(!host_port) {
        free(req_buffer);
        return CURLE_OUT_OF_MEMORY;
      }

","
      host_port = aprintf(""%s:%hu"", hostname, remote_port);
      if(!host_port) {
        Curl_add_buffer_free(req_buffer);
        return CURLE_OUT_OF_MEMORY;
      }

",139,139,[1],[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_proxy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_288.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_288.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_542.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_542.cpp,"                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          free(req_buffer);
          return CURLE_OUT_OF_MEMORY;
        }

        if(!Curl_checkProxyheaders(conn, ""Host:"")) {
          host = aprintf(""Host: %s\r\n"", hostheader);
          if(!host) {
            free(hostheader);
            free(req_buffer);
            return CURLE_OUT_OF_MEMORY;
          }
        }
","                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
          return CURLE_OUT_OF_MEMORY;
        }

        if(!Curl_checkProxyheaders(conn, ""Host:"")) {
          host = aprintf(""Host: %s\r\n"", hostheader);
          if(!host) {
            free(hostheader);
            Curl_add_buffer_free(req_buffer);
            return CURLE_OUT_OF_MEMORY;
          }
        }
",159,159,[8],[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/if2ip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_289.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_289.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_543.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_543.cpp,"}

if2ip_result_t Curl_if2ip(int af, unsigned int remote_scope,
                          const char *interf, char *buf, int buf_size)
{
  struct ifaddrs *iface, *head;
  if2ip_result_t res = IF2IP_NOT_FOUND;

#ifndef ENABLE_IPV6
  (void) remote_scope;
#endif

  if(getifaddrs(&head) >= 0) {
    for(iface=head; iface != NULL; iface=iface->ifa_next) {
      if(iface->ifa_addr != NULL) {
        if(iface->ifa_addr->sa_family == af) {
          if(curl_strequal(iface->ifa_name, interf)) {
            void *addr;
            char *ip;
            char scope[12]="""";
            char ipstr[64];
#ifdef ENABLE_IPV6
            if(af == AF_INET6) {
              unsigned int scopeid = 0;
              addr = &((struct sockaddr_in6 *)iface->ifa_addr)->sin6_addr;
#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
              /* Include the scope of this interface as part of the address */
              scopeid =
                ((struct sockaddr_in6 *)iface->ifa_addr)->sin6_scope_id;
#endif
              if(scopeid != remote_scope) {
                /* We are interested only in interface addresses whose
                   scope ID matches the remote address we want to
                   connect to: global (0) for global, link-local for
                   link-local, etc... */
                if(res == IF2IP_NOT_FOUND) res = IF2IP_AF_NOT_SUPPORTED;
                continue;
              }
              if(scopeid)
                snprintf(scope, sizeof(scope), ""%%%u"", scopeid);
            }
","}

if2ip_result_t Curl_if2ip(int af, unsigned int remote_scope,
                          unsigned int remote_scope_id, const char *interf,
                          char *buf, int buf_size)
{
  struct ifaddrs *iface, *head;
  if2ip_result_t res = IF2IP_NOT_FOUND;

#ifndef ENABLE_IPV6
  (void) remote_scope;

#ifndef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
  (void) remote_scope_id;
#endif

#endif

  if(getifaddrs(&head) >= 0) {
    for(iface = head; iface != NULL; iface=iface->ifa_next) {
      if(iface->ifa_addr != NULL) {
        if(iface->ifa_addr->sa_family == af) {
          if(curl_strequal(iface->ifa_name, interf)) {
            void *addr;
            char *ip;
            char scope[12] = """";
            char ipstr[64];
#ifdef ENABLE_IPV6
            if(af == AF_INET6) {
              unsigned int scopeid = 0;
              unsigned int ifscope = Curl_ipv6_scope(iface->ifa_addr);

              if(ifscope != remote_scope) {
                /* We are interested only in interface addresses whose
                   scope matches the remote address we want to
                   connect to: global for global, link-local for
                   link-local, etc... */
                if(res == IF2IP_NOT_FOUND) res = IF2IP_AF_NOT_SUPPORTED;
                continue;
              }

              addr = &((struct sockaddr_in6 *)iface->ifa_addr)->sin6_addr;
#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
              /* Include the scope of this interface as part of the address */
              scopeid =
                ((struct sockaddr_in6 *)iface->ifa_addr)->sin6_scope_id;

              /* If given, scope id should match. */
              if(remote_scope_id && scopeid != remote_scope_id) {
                if(res == IF2IP_NOT_FOUND)
                  res = IF2IP_AF_NOT_SUPPORTED;

                continue;
              }
#endif
              if(scopeid)
                snprintf(scope, sizeof(scope), ""%%%u"", scopeid);
            }
",84,114,[39],[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/krb5.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_290.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_290.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_544.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_544.cpp,"                                      (unsigned char **)&_gssresp.value,
                                      &_gssresp.length);
          if(result) {
            Curl_failf(data,""base64-decoding: %s"", curl_easy_strerror(result));
            ret = AUTH_CONTINUE;
            break;
          }
","                                      (unsigned char **)&_gssresp.value,
                                      &_gssresp.length);
          if(result) {
            Curl_failf(data, ""base64-decoding: %s"",
                       curl_easy_strerror(result));
            ret = AUTH_CONTINUE;
            break;
          }
",289,279,[3],[]
f8be9ba9c258698ed88a7510cf2ba3335491f3da,"cmGlobalGenerator: Base progress on Makefiles, not LocalGenerators.",[],Source/cmGlobalGenerator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_291.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_291.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_545.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_545.cpp,"  // update the cache entry for the number of local generators, this is used
  // for progress
  char num[100];
  sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_LOCAL_GENERATORS"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
","  // update the cache entry for the number of local generators, this is used
  // for progress
  char num[100];
  sprintf(num,""%d"",static_cast<int>(this->Makefiles.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_MAKEFILES"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
",1148,1148,[3],[]
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_292.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_292.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_546.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_546.cpp,"    if(cp->ErrorMessage[0] == 0)
      {
      /* Format the error message.  */
      DWORD original = GetLastError();
      wchar_t err_msg[KWSYSPE_PIPE_BUFFER_SIZE];
      DWORD length = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                                   FORMAT_MESSAGE_IGNORE_INSERTS, 0, original,
                                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                   err_msg, KWSYSPE_PIPE_BUFFER_SIZE, 0);
      WideCharToMultiByte(CP_UTF8, 0, err_msg, -1, cp->ErrorMessage,
                          KWSYSPE_PIPE_BUFFER_SIZE, NULL, NULL);
      if(length < 1)
        {
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError());
        }
      }

","    if(cp->ErrorMessage[0] == 0)
      {
      /* Format the error message.  */
      wchar_t err_msg[KWSYSPE_PIPE_BUFFER_SIZE];
      DWORD length = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                                   FORMAT_MESSAGE_IGNORE_INSERTS, 0, error,
                                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                   err_msg, KWSYSPE_PIPE_BUFFER_SIZE, 0);
      if(length < 1)
        {
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  error, GetLastError());
        }
      if(!WideCharToMultiByte(CP_UTF8, 0, err_msg, -1, cp->ErrorMessage,
                              KWSYSPE_PIPE_BUFFER_SIZE, NULL, NULL))
        {
        /* WideCharToMultiByte failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""WideCharToMultiByte failed with error 0x%X"",
                  error, GetLastError());
        }
      }

",1886,2007,[14],[]
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_547.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_547.cpp,"  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
#if defined(_WIN32)
  Sleep(15000);
#else
  sleep(15);
#endif
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
","  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
  testProcess_sleep(15);
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
",73,95,"[0, 8, 9]",[]
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_548.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_548.cpp,"#endif
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");  
  fflush(stdout);
  fflush(stderr);
  assert(invalidAddress); /* Quiet Clang scan-build. */
","#endif
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");
  fflush(stdout);
  fflush(stderr);
  assert(invalidAddress); /* Quiet Clang scan-build. */
",102,120,"[2, 3]",[]
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_549.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_549.cpp,"  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
","  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
",127,145,"[4, 5]",[]
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_550.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_550.cpp,"  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
#if defined(_WIN32)
  Sleep(1000);
#else
  sleep(1);
#endif
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
","  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
  testProcess_sleep(1);
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
",168,186,"[8, 9]",[]
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_551.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_551.cpp,"  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Disowned, kwsysProcess_Exception_None,
               1, 1, 1, 0, 10, 0, 1, 1);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
","  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Disowned, kwsysProcess_Exception_None,
               1, 1, 1, 0, 10, 0, 1, 1, 0, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
",196,210,"[4, 5]",[]
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_552.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_552.cpp,"      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };
  
  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
","      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
",337,476,[0],[]
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_553.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_553.cpp,"              value, kwsysProcess_GetExitValue(kp));
      }
    }
  
  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
","              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
",353,492,[6],[]
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_554.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_554.cpp,"      case 6: test6(argc, argv); return 0;
      case 7: return test7(argc, argv);
      case 8: return test8(argc, argv);
      case 108: return test8_grandchild(argc, argv);
      }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
    }
  else if(n >= 1 && n <= 8)
    {
    /* This is the parent process for a requested test number.  */
    int states[8] =
    {
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
","      case 6: test6(argc, argv); return 0;
      case 7: return test7(argc, argv);
      case 8: return test8(argc, argv);
      case 9: return test9(argc, argv);
      case 10: return test10(argc, argv);
      case 108: return test8_grandchild(argc, argv);
      case 109: return test9_grandchild(argc, argv);
      case 110: return test10_grandchild(argc, argv);
      }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
    }
  else if(n >= 1 && n <= 10)
    {
    /* This is the parent process for a requested test number.  */
    int states[10] =
    {
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
",448,616,[5],[]
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_555.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_555.cpp,"    fprintf(stderr, ""Output on stderr before test %d.\n"", n);
    fflush(stdout);
    fflush(stderr);
    r = runChild(cmd, states[n-1], exceptions[n-1], values[n-1], 0,
                 outputs[n-1], delays[n-1], timeouts[n-1],
                 polls[n-1], repeat[n-1], 0);
    fprintf(stdout, ""Output on stdout after test %d.\n"", n);
    fprintf(stderr, ""Output on stderr after test %d.\n"", n);
    fflush(stdout);
","    fprintf(stderr, ""Output on stderr before test %d.\n"", n);
    fflush(stdout);
    fflush(stderr);
    r = runChild(cmd, states[n-1], exceptions[n-1], values[n-1], shares[n-1],
                 outputs[n-1], delays[n-1], timeouts[n-1],
                 polls[n-1], repeat[n-1], 0, createNewGroups[n-1],
                 interruptDelays[n-1]);
    fprintf(stdout, ""Output on stdout after test %d.\n"", n);
    fprintf(stderr, ""Output on stderr after test %d.\n"", n);
    fflush(stdout);
",515,694,"[0, 6, 7]",[]
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrl�.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrl� and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_294.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_294.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_556.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_556.cpp,"    if(cp->ErrorMessage[0] == 0)
      {
      /* Format the error message.  */
      DWORD original = GetLastError();
      wchar_t err_msg[KWSYSPE_PIPE_BUFFER_SIZE];
      DWORD length = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                                   FORMAT_MESSAGE_IGNORE_INSERTS, 0, original,
                                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                   err_msg, KWSYSPE_PIPE_BUFFER_SIZE, 0);
      WideCharToMultiByte(CP_UTF8, 0, err_msg, -1, cp->ErrorMessage,
                          KWSYSPE_PIPE_BUFFER_SIZE, NULL, NULL);
      if(length < 1)
        {
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError());
        }
      }

","    if(cp->ErrorMessage[0] == 0)
      {
      /* Format the error message.  */
      wchar_t err_msg[KWSYSPE_PIPE_BUFFER_SIZE];
      DWORD length = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                                   FORMAT_MESSAGE_IGNORE_INSERTS, 0, error,
                                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                   err_msg, KWSYSPE_PIPE_BUFFER_SIZE, 0);
      if(length < 1)
        {
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  error, GetLastError());
        }
      if(!WideCharToMultiByte(CP_UTF8, 0, err_msg, -1, cp->ErrorMessage,
                              KWSYSPE_PIPE_BUFFER_SIZE, NULL, NULL))
        {
        /* WideCharToMultiByte failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""WideCharToMultiByte failed with error 0x%X"",
                  error, GetLastError());
        }
      }

",1886,2007,[14],[]
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrl�.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrl� and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_557.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_557.cpp,"  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
#if defined(_WIN32)
  Sleep(15000);
#else
  sleep(15);
#endif
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
","  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
  testProcess_sleep(15);
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
",73,95,"[0, 8, 9]",[]
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrl�.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrl� and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_558.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_558.cpp,"#endif
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");  
  fflush(stdout);
  fflush(stderr);
  assert(invalidAddress); /* Quiet Clang scan-build. */
","#endif
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");
  fflush(stdout);
  fflush(stderr);
  assert(invalidAddress); /* Quiet Clang scan-build. */
",102,120,"[2, 3]",[]
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrl�.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrl� and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_559.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_559.cpp,"  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
","  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
",127,145,"[4, 5]",[]
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrl�.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrl� and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_560.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_560.cpp,"  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
#if defined(_WIN32)
  Sleep(1000);
#else
  sleep(1);
#endif
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
","  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
  testProcess_sleep(1);
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
",168,186,"[8, 9]",[]
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrl�.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrl� and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_561.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_561.cpp,"  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Disowned, kwsysProcess_Exception_None,
               1, 1, 1, 0, 10, 0, 1, 1);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
","  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Disowned, kwsysProcess_Exception_None,
               1, 1, 1, 0, 10, 0, 1, 1, 0, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
",196,210,"[4, 5]",[]
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrl�.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrl� and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_562.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_562.cpp,"      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };
  
  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
","      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
",337,476,[0],[]
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrl�.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrl� and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_563.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_563.cpp,"              value, kwsysProcess_GetExitValue(kp));
      }
    }
  
  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
","              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
",353,492,[6],[]
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrl�.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrl� and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_564.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_564.cpp,"      case 6: test6(argc, argv); return 0;
      case 7: return test7(argc, argv);
      case 8: return test8(argc, argv);
      case 108: return test8_grandchild(argc, argv);
      }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
    }
  else if(n >= 1 && n <= 8)
    {
    /* This is the parent process for a requested test number.  */
    int states[8] =
    {
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
","      case 6: test6(argc, argv); return 0;
      case 7: return test7(argc, argv);
      case 8: return test8(argc, argv);
      case 9: return test9(argc, argv);
      case 10: return test10(argc, argv);
      case 108: return test8_grandchild(argc, argv);
      case 109: return test9_grandchild(argc, argv);
      case 110: return test10_grandchild(argc, argv);
      }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
    }
  else if(n >= 1 && n <= 10)
    {
    /* This is the parent process for a requested test number.  */
    int states[10] =
    {
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
",448,616,[5],[]
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrl�.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrl� and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_565.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_565.cpp,"    fprintf(stderr, ""Output on stderr before test %d.\n"", n);
    fflush(stdout);
    fflush(stderr);
    r = runChild(cmd, states[n-1], exceptions[n-1], values[n-1], 0,
                 outputs[n-1], delays[n-1], timeouts[n-1],
                 polls[n-1], repeat[n-1], 0);
    fprintf(stdout, ""Output on stdout after test %d.\n"", n);
    fprintf(stderr, ""Output on stderr after test %d.\n"", n);
    fflush(stdout);
","    fprintf(stderr, ""Output on stderr before test %d.\n"", n);
    fflush(stdout);
    fflush(stderr);
    r = runChild(cmd, states[n-1], exceptions[n-1], values[n-1], shares[n-1],
                 outputs[n-1], delays[n-1], timeouts[n-1],
                 polls[n-1], repeat[n-1], 0, createNewGroups[n-1],
                 interruptDelays[n-1]);
    fprintf(stdout, ""Output on stdout after test %d.\n"", n);
    fprintf(stderr, ""Output on stderr after test %d.\n"", n);
    fflush(stdout);
",515,694,"[0, 6, 7]",[]
069aa93b555293679f4b8c07623133ba62a74ee4,"bindexplib: Add support for ""/bigobj"" format objects",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_566.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_566.cpp,"               }
            }
            if (symbol[0] == '_') symbol.erase(0,1);
            if (fImportFlag) {
               fImportFlag = 0;
               fprintf(fout,""EXPORTS \n"");
            }
            /*
            Check whether it is ""Scalar deleting destructor"" and
","               }
            }
            if (symbol[0] == '_') symbol.erase(0,1);
            if (this->ImportFlag) {
               this->ImportFlag = false;
               fprintf(this->FileOut,""EXPORTS \n"");
            }
            /*
            Check whether it is ""Scalar deleting destructor"" and
",209,288,[5],[]
069aa93b555293679f4b8c07623133ba62a74ee4,"bindexplib: Add support for ""/bigobj"" format objects",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_567.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_567.cpp,"                symbol.compare(0, 4, vectorPrefix) )
            {
               SectChar =
                pSectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  fprintf(fout, ""\t%s \t DATA\n"", symbol.c_str());
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     fprintf(fout, ""\t%s\n"", symbol.c_str());
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
","                symbol.compare(0, 4, vectorPrefix) )
            {
               SectChar =
                 this->
                 SectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str());
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     fprintf(this->FileOut, ""\t%s\n"", symbol.c_str());
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
",228,307,"[6, 10, 12]",[]
069aa93b555293679f4b8c07623133ba62a74ee4,"bindexplib: Add support for ""/bigobj"" format objects",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_568.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_568.cpp,"            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!fImportFlag) {
               fImportFlag = 1;
               fprintf(fout,""IMPORTS \n"");
            }
            fprintf(fout, ""\t%s DATA \n"", symbol.c_str()�);
         }
      }

","            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!this->ImportFlag) {
               this->ImportFlag = true;
               fprintf(this->FileOut,""IMPORTS \n"");
            }
            fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()�);
         }
      }

",252,332,"[5, 7]",[]
de70c922d9c846cf3a6fabfbedd054c02f4b8934,"bindexplib: Teach DumpFile to return errors

This will allow callers to know if it worked.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_297.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_297.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_569.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_569.cpp,"      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file with CreateFile()\n"");
      return;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
","      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
      return false;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return false;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return false;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return false;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
",309,310,"[3, 10, 18, 24]",[]
2963cb2a559fd27edd53b7fb7036cba0adc8b9ca,bindexplib: Wrap long lines,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_298.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_298.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_570.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_570.cpp,"               symbol.compare(0, 4, vectorPrefix) &&
               symbol.find(""real@"") == std::string::npos)
            {
               SectChar = pSectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  fprintf(fout, ""\t%s \t DATA\n"", symbol.c_str());
               } else {
                  if ( pSymbolTable->Type  || !(SectChar & IMAGE_SCN_MEM_READ)) {
                     fprintf(fout, ""\t%s\n"", symbol.c_str());
                  } else {
                     //                    printf("" strange symbol: %s \n"",s);
","               symbol.compare(0, 4, vectorPrefix) &&
               symbol.find(""real@"") == std::string::npos)
            {
               SectChar =
                pSectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  fprintf(fout, ""\t%s \t DATA\n"", symbol.c_str());
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     fprintf(fout, ""\t%s\n"", symbol.c_str());
                  } else {
                     //                    printf("" strange symbol: %s \n"",s);
",207,212,"[6, 9, 11]",[]
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bp�;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bp�;
      }
      argv[argc�] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bp�;
               break;
            }
            bp�;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bp�;
            break;
         }
         bp�;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; i� ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable�;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; i� ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()�);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable�;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,"[193, 196, 206, 208, 210, 212, 216, 223, 270, 272]",[]
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_572.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_572.cpp,"            }

            while (isspace(symbol[0])) symbol.erase(0,1);
#ifdef _MSC_VER
            if (symbol[0] == '_') symbol.erase(0,1);
            if (fort) {
               std::string::size_type posAt = symbol.find('@');
               if (posAt != std::string::npos) symbol.erase(posAt);
            }
#endif
            if (fImportFlag) {
               fImportFlag = 0;
               fprintf(fout,""EXPORTS \n"");
","            }

            while (isspace(symbol[0])) symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (fImportFlag) {
               fImportFlag = 0;
               fprintf(fout,""EXPORTS \n"");
",470,192,[12],[]
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_573.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_573.cpp,"
   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
#if 0
      DumpExeFile( dosHeader );
#else
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return;
#endif
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
","
   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
",610,317,[6],[]
faec4e611d08ea2f75d2127e3ca3f5e9a427465b,cmComputeTargetDepends: Change API to use cmGeneratorTarget.,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_300.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_300.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_574.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_574.cpp,"  for(int depender_index = 0; depender_index < n; 輪ꥺ睞�_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); 喝�)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
","  for(int depender_index = 0; depender_index < n; 輪ꥺ睞�_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmGeneratorTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); 喝�)
      {
      int dependee_index = *ni;
      cmGeneratorTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
",457,464,"[4, 10]",[]
f971ab04cfdcb73e1ac2b182caf302172aebe6a8,"cmMacroCommand: Store the FilePath when creating the prototype.

Instead of setting it each time the macro is invoked.",[],Source/cmMacroCommand.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_301.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_301.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_575.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_575.cpp,"    sprintf(argvName,""${ARGV%i}"",j);
    argVs.push_back(argvName);
    }
  if(!this->Functions.empty())
    {
    this->FilePath = this->Functions[0].FilePath;
    }
  // Invoke all the functions that were collected in the block.
  cmListFileFunction newLFF;
  // for each function
","    sprintf(argvName,""${ARGV%i}"",j);
    argVs.push_back(argvName);
    }
  // Invoke all the functions that were collected in the block.
  cmListFileFunction newLFF;
  // for each function
",122,122,[0],[]
59e21ffa134faf0b089d9a704b3763e7f6f237d5,Port static calls from cmLocalGenerator to cmOutputConverter.,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_302.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_302.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_576.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_576.cpp,"      std::string langFlags = ""CMAKE_""  *li  ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmLocalGenerator::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
","      std::string langFlags = ""CMAKE_""  *li  ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmOutputConverter::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
",322,322,"[2, 4]",[]
8fbc509a48e53f7462143dded5a01c77ab5ba6bd,cmCTestCoverageHandler: Port to cmXMLWriter,[],Source/CTest/cmCTestCoverageHandler.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_303.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_303.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_577.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_577.cpp,"      << covLogFilename << std::endl);
    return false;
    }
  std::string local_start_time = this->CTest->CurrentTime();
  this->CTest->StartXML(covLogFile, this->AppendXML);
  covLogFile << ""<CoverageLog>"" << std::endl
             << ""\t<StartDateTime>"" << local_start_time << ""</StartDateTime>""
             << ""\t<StartTime>""
             << static_cast<unsigned int>(cmSystemTools::GetTime())
             << ""</StartTime>""
    << std::endl;
  return true;
}

//----------------------------------------------------------------------
void cmCTestCoverageHandler::EndCoverageLogFile(cmGeneratedFileStream& ostr,
  int logFileCount)
{
  std::string local_end_time = this->CTest->CurrentTime();
  ostr << ""\t<EndDateTime>"" << local_end_time << ""</EndDateTime>"" << std::endl
       << ""\t<EndTime>"" <<
       static_cast<unsigned int>(cmSystemTools::GetTime())
       << ""</EndTime>"" << std::endl
    << ""</CoverageLog>"" << std::endl;
  this->CTest->EndXML(ostr);
  char covLogFilename[1024];
  sprintf(covLogFilename, ""CoverageLog-%d.xml"", logFileCount);
  cmCTestOptionalLog(this->CTest, HANDLER_VERBOSE_OUTPUT, ""Close file: ""
","      << covLogFilename << std::endl);
    return false;
    }
  return true;
}

//----------------------------------------------------------------------
void cmCTestCoverageHandler::EndCoverageLogFile(cmGeneratedFileStream& ostr,
  int logFileCount)
{
  char covLogFilename[1024];
  sprintf(covLogFilename, ""CoverageLog-%d.xml"", logFileCount);
  cmCTestOptionalLog(this->CTest, HANDLER_VERBOSE_OUTPUT, ""Close file: ""
",185,185,[26],[]
9486769866661e3aa76dd588ca5a7466e2969dc3,Don't use a cmLocalGenerator instance to call static methods.,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_304.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_304.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_578.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_578.cpp,"      std::string langFlags = ""CMAKE_""  *li  ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
","      std::string langFlags = ""CMAKE_""  *li  ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmLocalGenerator::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
",323,322,"[2, 4]",[]
f081c5bdddcfcaaf5bee7b918fe5c7ff01faae35,cmState: Move CacheEntryType enum from cmCacheManager.,[],Source/cmCacheManager.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_305.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_305.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_579.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_579.cpp,"  sprintf(temp, ""%d"", cmVersion::GetMinorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"", cmCacheManager::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"", cmCacheManager::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"", cmCacheManager::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
","  sprintf(temp, ""%d"", cmVersion::GetMinorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"", cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"", cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"", cmState::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
",427,381,"[0, 4, 8]",[]
f081c5bdddcfcaaf5bee7b918fe5c7ff01faae35,cmState: Move CacheEntryType enum from cmCacheManager.,[],Source/cmGlobalGenerator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_306.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_306.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_580.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_580.cpp,"  sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_LOCAL_GENERATORS"", num,
     ""number of local generators"", cmCacheManager::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
  // and for infinite loops
","  sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_LOCAL_GENERATORS"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
  // and for infinite loops
",1116,1116,[0],[]
f081c5bdddcfcaaf5bee7b918fe5c7ff01faae35,cmState: Move CacheEntryType enum from cmCacheManager.,[],Source/cmCacheManager.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_307.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_307.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_582.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_582.cpp,"  sprintf(temp, ""%d"", cmVersion::GetMinorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"", cmCacheManager::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"", cmCacheManager::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"", cmCacheManager::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
","  sprintf(temp, ""%d"", cmVersion::GetMinorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"", cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"", cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"", cmState::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
",427,381,"[0, 4, 8]",[]
f081c5bdddcfcaaf5bee7b918fe5c7ff01faae35,cmState: Move CacheEntryType enum from cmCacheManager.,[],Source/cmGlobalGenerator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_308.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_308.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_583.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_583.cpp,"  sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_LOCAL_GENERATORS"", num,
     ""number of local generators"", cmCacheManager::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
  // and for infinite loops
","  sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_LOCAL_GENERATORS"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
  // and for infinite loops
",1116,1116,[0],[]
fc58bdb9ad90ddd41c5336bc1ab2e35fa0f74d41,ctest_coverage: Add QUIET option,[],Source/CTest/cmCTestCoverageHandler.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_309.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_309.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_584.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_584.cpp,"{
  char covLogFilename[1024];
  sprintf(covLogFilename, ""CoverageLog-%d"", logFileCount);
  cmCTestLog(this->CTest, HANDLER_VERBOSE_OUTPUT, ""Open file: ""
    << covLogFilename << std::endl);
  if(!this->StartResultingXML(cmCTest::PartCoverage,
                              covLogFilename, covLogFile))
    {
","{
  char covLogFilename[1024];
  sprintf(covLogFilename, ""CoverageLog-%d"", logFileCount);
  cmCTestOptionalLog(this->CTest, HANDLER_VERBOSE_OUTPUT, ""Open file: ""
    << covLogFilename << std::endl, this->Quiet);
  if(!this->StartResultingXML(cmCTest::PartCoverage,
                              covLogFilename, covLogFile))
    {
",176,176,[2],[]
fc58bdb9ad90ddd41c5336bc1ab2e35fa0f74d41,ctest_coverage: Add QUIET option,[],Source/CTest/cmCTestCoverageHandler.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_309.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_309.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_585.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_585.cpp,"  this->CTest->EndXML(ostr);
  char covLogFilename[1024];
  sprintf(covLogFilename, ""CoverageLog-%d.xml"", logFileCount);
  cmCTestLog(this->CTest, HANDLER_VERBOSE_OUTPUT, ""Close file: ""
    << covLogFilename << std::endl);
  ostr.Close();
}

","  this->CTest->EndXML(ostr);
  char covLogFilename[1024];
  sprintf(covLogFilename, ""CoverageLog-%d.xml"", logFileCount);
  cmCTestOptionalLog(this->CTest, HANDLER_VERBOSE_OUTPUT, ""Close file: ""
    << covLogFilename << std::endl, this->Quiet);
  ostr.Close();
}

",209,209,[2],[]
876a680d4851a39e77b49daa3c670fe2e535c1e6,ctest_test: Add QUIET option,[],Source/CTest/cmCTestTestHandler.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_310.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_310.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_586.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_586.cpp,"      }
    char realBuf[1024];
    sprintf(realBuf, ""%6.2f sec"", (double)(clock_finish - clock_start));
    cmCTestLog(this->CTest, HANDLER_OUTPUT, ""\nTotal Test time (real) = ""
               << realBuf << ""\n"" );

    if (!failed.empty())
      {
","      }
    char realBuf[1024];
    sprintf(realBuf, ""%6.2f sec"", (double)(clock_finish - clock_start));
    cmCTestOptionalLog(this->CTest, HANDLER_OUTPUT,
      ""\nTotal Test time (real) = "" << realBuf << ""\n"", this->Quiet );

    if (!failed.empty())
      {
",593,593,[2],[]
876a680d4851a39e77b49daa3c670fe2e535c1e6,ctest_test: Add QUIET option,[],Source/CTest/cmCTestTestHandler.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_310.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_310.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_587.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_587.cpp,"    label.resize(maxlen +3, ' ');
    char buf[1024];
    sprintf(buf, ""%6.2f sec"", labelTimes[*i]);
    cmCTestLog(this->CTest, HANDLER_OUTPUT, ""\n""
               << label << "" = "" << buf );
    if ( this->LogFile )
      {
      *this->LogFile << ""\n"" << *i << "" = ""
","    label.resize(maxlen +3, ' ');
    char buf[1024];
    sprintf(buf, ""%6.2f sec"", labelTimes[*i]);
    cmCTestOptionalLog(this->CTest, HANDLER_OUTPUT, ""\n""
               << label << "" = "" << buf, this->Quiet );
    if ( this->LogFile )
      {
      *this->LogFile << ""\n"" << *i << "" = ""
",709,710,[2],[]
8521fdf56e4908676c28c6bbdda3f1fb2284d3d7,"Makefile: Fix output during parallel builds (#12991)

Replace use of separate ""cmake -E cmake_progress_report"" and ""cmake -E
cmake_echo_color"" commands to report the progress and message portions
of build output lines with --progress-* options to the latter to print
everything with a single command.  The line buffering of the stdout FILE
stream should cause the whole line to be printed with one atomic write.
This will avoid inter-mixing of line-wise messages from different
processes during a parallel build.",[u'https://gitlab.kitware.com/cmake/cmake/issues/12991'],Source/cmcmd.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_311.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_311.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_588.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_588.cpp,"    // Command to report progress for a build
    else if (args[1] == ""cmake_progress_report"" && args.size() >= 3)
      {
      std::string dirName = args[2];
      dirName += ""/Progress"";
      std::string fName;
      FILE *progFile;

      // read the count
      fName = dirName;
      fName += ""/count.txt"";
      progFile = cmsys::SystemTools::Fopen(fName,""r"");
      int count = 0;
      if (!progFile)
        {
        return 0;
        }
      else
        {
        if (1!=fscanf(progFile,""%i"",&count))
          {
          cmSystemTools::Message(""Could not read from progress file."");
          }
        fclose(progFile);
        }
      unsigned int i;
      for (i = 3; i < args.size(); ++i)
        {
        fName = dirName;
        fName += ""/"";
        fName += args[i];
        progFile = cmsys::SystemTools::Fopen(fName,""w"");
        if (progFile)
          {
          fprintf(progFile,""empty"");
          fclose(progFile);
          }
        }
      int fileNum = static_cast<int>
        (cmsys::Directory::GetNumberOfFilesInDirectory(dirName));
      if (count > 0)
        {
        // print the progress
        fprintf(stdout,""[%3i%%] "",((fileNum-3)*100)/count);
        }
      return 0;
      }

","    // Command to report progress for a build
    else if (args[1] == ""cmake_progress_report"" && args.size() >= 3)
      {
      // This has been superseded by cmake_echo_color --progress-*
      // options.  We leave it here to avoid errors if somehow this
      // is invoked by an existing makefile without regenerating.
      return 0;
      }

",534,534,"[34, 43]",[]
fd7b37129360364531ddfeda7edb6e34ba773d00,Replace foo.size() pattern with !foo.empty().,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_312.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_312.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_589.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_589.cpp,"    fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""add_definitions( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
","    fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (!compileDefs.empty())
      {
      fprintf(fout, ""add_definitions( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
",371,371,"[0, 1, 5]",[]
1abd7cd930022ba045c3c0cd34406cbe19db84d3,"Use containers of labeled search paths instead of individual members

Manage classes of search paths in labeled containers.  This removes the
need to have a seperate member variable for each type of search path, but
also allows path types to be grouped togethor in various different ways
and manipulated as subsets of the full set of search paths.",[],Source/cmFindCommon.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_313.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_313.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_590.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_590.cpp,"    fprintf(stderr, ""[%s]\n"", i->c_str());
    }
#endif

  // Short-circuit if there is nothing to do.
  if(this->FindRootPathMode == RootPathModeNever)
    {
    return;
    }
  const char* sysroot =
    this->Makefile->GetDefinition(""CMAKE_SYSROOT"");
  const char* rootPath =
","    fprintf(stderr, ""[%s]\n"", i->c_str());
    }
#endif
  // Short-circuit if there is nothing to do.
  if(this->FindRootPathMode == RootPathModeNever)
    {
    return;
    }

  const char* sysroot =
    this->Makefile->GetDefinition(""CMAKE_SYSROOT"");
  const char* rootPath =
",140,178,[0],[]
80c881f7938969dab169f4fc4fbf8bc3d4355fc2,"Merge branch 'curl-upstream' into update-curl

Resolve all conflicts in favor of the upstream side.
We can re-apply specific changes later.",[],Utilities/cmcurl/include/curl/mprintf.h,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_314.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_314.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_591.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_591.cpp,"CURL_EXTERN int curl_mprintf(const char *format, ...);
CURL_EXTERN int curl_mfprintf(FILE *fd, const char *format, ...);
CURL_EXTERN int curl_msprintf(char *buffer, const char *format, ...);
CURL_EXTERN int curl_msnprintf(char *buffer, size_t maxlength, const char *format, ...);
CURL_EXTERN int curl_mvprintf(const char *format, va_list args);
CURL_EXTERN int curl_mvfprintf(FILE *fd, const char *format, va_list args);
CURL_EXTERN int curl_mvsprintf(char *buffer, const char *format, va_list args);
CURL_EXTERN int curl_mvsnprintf(char *buffer, size_t maxlength, const char *format, va_list args);
CURL_EXTERN char *curl_maprintf(const char *format, ...);
CURL_EXTERN char *curl_mvaprintf(const char *format, va_list args);

","CURL_EXTERN int curl_mprintf(const char *format, ...);
CURL_EXTERN int curl_mfprintf(FILE *fd, const char *format, ...);
CURL_EXTERN int curl_msprintf(char *buffer, const char *format, ...);
CURL_EXTERN int curl_msnprintf(char *buffer, size_t maxlength,
                               const char *format, ...);
CURL_EXTERN int curl_mvprintf(const char *format, va_list args);
CURL_EXTERN int curl_mvfprintf(FILE *fd, const char *format, va_list args);
CURL_EXTERN int curl_mvsprintf(char *buffer, const char *format, va_list args);
CURL_EXTERN int curl_mvsnprintf(char *buffer, size_t maxlength,
                                const char *format, va_list args);
CURL_EXTERN char *curl_maprintf(const char *format, ...);
CURL_EXTERN char *curl_mvaprintf(const char *format, va_list args);

",35,34,"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]",[]
80c881f7938969dab169f4fc4fbf8bc3d4355fc2,"Merge branch 'curl-upstream' into update-curl

Resolve all conflicts in favor of the upstream side.
We can re-apply specific changes later.",[],Utilities/cmcurl/lib/connect.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_315.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_315.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_592.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_592.cpp," * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 * $Id$
 ***************************************************************************/

#include ""setup.h""

#ifndef WIN32
/* headers for non-win32 */
#ifdef HAVE_SYS_TIME_H
#include <sys/time.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif
#ifdef HAVE_NETINET_IN_H
#include <netinet/in.h> /* <netinet/tcp.h> may need it */
#endif
#ifdef HAVE_NETINET_TCP_H
#include <netinet/tcp.h> /* for TCP_NODELAY */
#endif
#ifdef HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_NETDB_H
#include <netdb.h>
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#ifdef HAVE_NETINET_IN_H
#include <netinet/in.h>
#endif
#ifdef HAVE_ARPA_INET_H
#include <arpa/inet.h>
#endif
#ifdef HAVE_STDLIB_H
#include <stdlib.h> /* required for free() prototype, without it, this crashes
                       on macos 68K */
#endif
#if (defined(HAVE_FIONBIO) && defined(__NOVELL_LIBC__))
#include <sys/filio.h>
#endif
#if (defined(NETWARE) && defined(__NOVELL_LIBC__))
#undef in_addr_t
#define in_addr_t unsigned long
#endif
#ifdef VMS
#include <in.h>
#include <inet.h>
#endif

#endif
#include <stdio.h>
#include <errno.h>
#include <string.h>

#ifndef TRUE
#define TRUE 1
#define FALSE 0
#endif

#ifdef USE_WINSOCK
#define EINPROGRESS WSAEINPROGRESS
#define EWOULDBLOCK WSAEWOULDBLOCK
#define EISCONN     WSAEISCONN
#define ENOTSOCK    WSAENOTSOCK
#define ECONNREFUSED WSAECONNREFUSED
#endif

#include ""urldata.h""
#include ""sendf.h""
#include ""if2ip.h""
#include ""strerror.h""
#include ""connect.h""
#include ""memory.h""
#include ""select.h""
#include ""url.h"" /* for Curl_safefree() */
#include ""multiif.h""
#include ""sockaddr.h"" /* required for Curl_sockaddr_storage */
#include ""inet_ntop.h""

/* The last #include file should be: */
#include ""memdebug.h""

static bool verifyconnect(curl_socket_t sockfd, int *error);

static curl_socket_t
singleipconnect(struct connectdata *conn,
                const Curl_addrinfo *ai, /* start connecting to this */
                long timeout_ms,
                bool *connected);

/*
 * Curl_sockerrno() returns the *socket-related* errno (or equivalent) on this
 * platform to hide platform specific for the function that calls this.
 */
int Curl_sockerrno(void)
{
#ifdef USE_WINSOCK
  return (int)WSAGetLastError();
#else
  return errno;
#endif
}

/*
 * Curl_nonblock() set the given socket to either blocking or non-blocking
 * mode based on the 'nonblock' boolean argument. This function is highly
 * portable.
 */
int Curl_nonblock(curl_socket_t sockfd,    /* operate on this */
                  int nonblock   /* TRUE or FALSE */)
{
#undef SETBLOCK
#define SETBLOCK 0
#ifdef HAVE_O_NONBLOCK
  /* most recent unix versions */
  int flags;

  flags = fcntl(sockfd, F_GETFL, 0);
  if (TRUE == nonblock)
    return fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
  else
    return fcntl(sockfd, F_SETFL, flags & (~O_NONBLOCK));
#undef SETBLOCK
#define SETBLOCK 1
#endif

#if defined(HAVE_FIONBIO) && (SETBLOCK == 0)
  /* older unix versions */
  int flags;

  flags = nonblock;
  return ioctl(sockfd, FIONBIO, &flags);
#undef SETBLOCK
#define SETBLOCK 2
#endif

#if defined(HAVE_IOCTLSOCKET) && (SETBLOCK == 0)
  /* Windows? */
  unsigned long flags;
  flags = nonblock;

  return ioctlsocket(sockfd, FIONBIO, &flags);
#undef SETBLOCK
#define SETBLOCK 3
#endif

#if defined(HAVE_IOCTLSOCKET_CASE) && (SETBLOCK == 0)
  /* presumably for Amiga */
  return IoctlSocket(sockfd, FIONBIO, (long)nonblock);
#undef SETBLOCK
#define SETBLOCK 4
#endif

#if defined(HAVE_SO_NONBLOCK) && (SETBLOCK == 0)
  /* BeOS */
  long b = nonblock ? 1 : 0;
  return setsockopt(sockfd, SOL_SOCKET, SO_NONBLOCK, &b, sizeof(b));
#undef SETBLOCK
#define SETBLOCK 5
#endif

#ifdef HAVE_DISABLED_NONBLOCKING
  return 0; /* returns success */
#undef SETBLOCK
#define SETBLOCK 6
#endif

#if (SETBLOCK == 0)
#error ""no non-blocking method was found/used/set""
#endif
}

/*
 * waitconnect() waits for a TCP connect on the given socket for the specified
 * number if milliseconds. It returns:
 * 0    fine connect
 * -1   select() error
 * 1    select() timeout
 * 2    select() returned with an error condition fd_set
 */

#define WAITCONN_CONNECTED     0
#define WAITCONN_SELECT_ERROR -1
#define WAITCONN_TIMEOUT       1
#define WAITCONN_FDSET_ERROR   2

static
int waitconnect(curl_socket_t sockfd, /* socket */
                long timeout_msec)
{
  int rc;
#ifdef mpeix
  /* Call this function once now, and ignore the results. We do this to
     ""clear"" the error state on the socket so that we can later read it
     reliably. This is reported necessary on the MPE/iX operating system. */
  (void)verifyconnect(sockfd, NULL);
#endif

  /* now select() until we get connect or timeout */
  rc = Curl_select(CURL_SOCKET_BAD, sockfd, (int)timeout_msec);
  if(-1 == rc)
    /* error, no connect here, try next */
    return WAITCONN_SELECT_ERROR;

  else if(0 == rc)
    /* timeout, no connect today */
    return WAITCONN_TIMEOUT;

  if(rc & CSELECT_ERR)
    /* error condition caught */
    return WAITCONN_FDSET_ERROR;

  /* we have a connect! */
  return WAITCONN_CONNECTED;
}

static CURLcode bindlocal(struct connectdata *conn,
                          curl_socket_t sockfd)
{
  struct SessionHandle *data = conn->data;
  struct sockaddr_in me;
  struct sockaddr *sock = NULL;  /* bind to this address */
  socklen_t socksize; /* size of the data sock points to */
  unsigned short port = data->set.localport; /* use this port number, 0 for
                                                ""random"" */
  /* how many port numbers to try to bind to, increasing one at a time */
  int portnum = data->set.localportrange;

  /*************************************************************
   * Select device to bind socket to
   *************************************************************/
  if (data->set.device && (strlen(data->set.device)<255) ) {
    struct Curl_dns_entry *h=NULL;
    char myhost[256] = """";
    in_addr_t in;
    int rc;
    bool was_iface = FALSE;

    /* First check if the given name is an IP address */
    in=inet_addr(data->set.device);

    if((in == CURL_INADDR_NONE) &&
       Curl_if2ip(data->set.device, myhost, sizeof(myhost))) {
      /*
       * We now have the numerical IPv4-style x.y.z.w in the 'myhost' buffer
       */
      rc = Curl_resolv(conn, myhost, 0, &h);
      if(rc == CURLRESOLV_PENDING)
        (void)Curl_wait_for_resolv(conn, &h);

      if(h) {
        was_iface = TRUE;
        Curl_resolv_unlock(data, h);
      }
    }

    if(!was_iface) {
      /*
       * This was not an interface, resolve the name as a host name
       * or IP number
       */
      rc = Curl_resolv(conn, data->set.device, 0, &h);
      if(rc == CURLRESOLV_PENDING)
        (void)Curl_wait_for_resolv(conn, &h);

      if(h) {
        if(in == CURL_INADDR_NONE)
          /* convert the resolved address, sizeof myhost >= INET_ADDRSTRLEN */
          Curl_inet_ntop(h->addr->ai_addr->sa_family,
                         &((struct sockaddr_in*)h->addr->ai_addr)->sin_addr,
                         myhost, sizeof myhost);
        else
          /* we know data->set.device is shorter than the myhost array */
          strcpy(myhost, data->set.device);
        Curl_resolv_unlock(data, h);
      }
    }

    if(! *myhost) {
      /* need to fix this
         h=Curl_gethost(data,
         getmyhost(*myhost,sizeof(myhost)),
         hostent_buf,
         sizeof(hostent_buf));
      */
      failf(data, ""Couldn't bind to '%s'"", data->set.device);
      return CURLE_HTTP_PORT_FAILED;
    }

    infof(data, ""Bind local address to %s\n"", myhost);

#ifdef SO_BINDTODEVICE
    /* I am not sure any other OSs than Linux that provide this feature, and
     * at the least I cannot test. --Ben
     *
     * This feature allows one to tightly bind the local socket to a
     * particular interface.  This will force even requests to other local
     * interfaces to go out the external interface.
     *
     */
    if (was_iface) {
      /* Only bind to the interface when specified as interface, not just as a
       * hostname or ip address.
       */
      if (setsockopt(sockfd, SOL_SOCKET, SO_BINDTODEVICE,
                     data->set.device, strlen(data->set.device)+1) != 0) {
        /* printf(""Failed to BINDTODEVICE, socket: %d  device: %s error: %s\n"",
           sockfd, data->set.device, Curl_strerror(Curl_sockerrno())); */
        infof(data, ""SO_BINDTODEVICE %s failed\n"",
              data->set.device);
        /* This is typically ""errno 1, error: Operation not permitted"" if
           you're not running as root or another suitable privileged user */
      }
    }
#endif

    in=inet_addr(myhost);
    if (CURL_INADDR_NONE == in) {
      failf(data,""couldn't find my own IP address (%s)"", myhost);
      return CURLE_HTTP_PORT_FAILED;
    } /* end of inet_addr */

    if ( h ) {
      Curl_addrinfo *addr = h->addr;
      sock = addr->ai_addr;
      socksize = addr->ai_addrlen;
    }
    else
      return CURLE_HTTP_PORT_FAILED;

  }
  else if(port) {
    /* if a local port number is requested but no local IP, extract the
       address from the socket */
    memset(&me, 0, sizeof(struct sockaddr));
    me.sin_family = AF_INET;
    me.sin_addr.s_addr = INADDR_ANY;

    sock = (struct sockaddr *)&me;
    socksize = sizeof(struct sockaddr);

  }
  else
    /* no local kind of binding was requested */
    return CURLE_OK;

  do {

    /* Set port number to bind to, 0 makes the system pick one */
    if(sock->sa_family == AF_INET)
      ((struct sockaddr_in *)sock)->sin_port = htons(port);
#ifdef ENABLE_IPV6
    else
      ((struct sockaddr_in6 *)sock)->sin6_port = htons(port);
#endif

    if( bind(sockfd, sock, socksize) >= 0) {
      /* we succeeded to bind */
      struct Curl_sockaddr_storage add;
      socklen_t size;

      size = sizeof(add);
      if(getsockname(sockfd, (struct sockaddr *) &add, &size) < 0) {
        failf(data, ""getsockname() failed"");
        return CURLE_HTTP_PORT_FAILED;
      }
      /* We re-use/clobber the port variable here below */
      if(((struct sockaddr *)&add)->sa_family == AF_INET)
        port = ntohs(((struct sockaddr_in *)&add)->sin_port);
#ifdef ENABLE_IPV6
      else
        port = ntohs(((struct sockaddr_in6 *)&add)->sin6_port);
#endif
      infof(data, ""Local port: %d\n"", port);
      return CURLE_OK;
    }
    if(--portnum > 0) {
      infof(data, ""Bind to local port %d failed, trying next\n"", port);
      port++; /* try next port */
    }
    else
      break;
  } while(1);

  data->state.os_errno = Curl_sockerrno();
  failf(data, ""bind failure: %s"",
        Curl_strerror(conn, data->state.os_errno));
  return CURLE_HTTP_PORT_FAILED;

}

/*
"," * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 ***************************************************************************/

#include ""curl_setup.h""

#ifdef HAVE_NETINET_IN_H
#include <netinet/in.h> /* <netinet/tcp.h> may need it */
#endif
#ifdef HAVE_SYS_UN_H
#include <sys/un.h> /* for sockaddr_un */
#endif
#ifdef HAVE_NETINET_TCP_H
#include <netinet/tcp.h> /* for TCP_NODELAY */
#endif
#ifdef HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif
#ifdef HAVE_NETDB_H
#include <netdb.h>
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#ifdef HAVE_ARPA_INET_H
#include <arpa/inet.h>
#endif

#if (defined(HAVE_IOCTL_FIONBIO) && defined(NETWARE))
#include <sys/filio.h>
#endif
#ifdef NETWARE
#undef in_addr_t
#define in_addr_t unsigned long
#endif
#ifdef __VMS
#include <in.h>
#include <inet.h>
#endif

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

#include ""urldata.h""
#include ""sendf.h""
#include ""if2ip.h""
#include ""strerror.h""
#include ""connect.h""
#include ""curl_memory.h""
#include ""select.h""
#include ""url.h"" /* for Curl_safefree() */
#include ""multiif.h""
#include ""sockaddr.h"" /* required for Curl_sockaddr_storage */
#include ""inet_ntop.h""
#include ""inet_pton.h""
#include ""vtls/vtls.h"" /* for Curl_ssl_check_cxn() */
#include ""progress.h""
#include ""warnless.h""
#include ""conncache.h""
#include ""multihandle.h""

/* The last #include file should be: */
#include ""memdebug.h""

#ifdef __SYMBIAN32__
/* This isn't actually supported under Symbian OS */
#undef SO_NOSIGPIPE
#endif

static bool verifyconnect(curl_socket_t sockfd, int *error);

#if defined(__DragonFly__) || defined(HAVE_WINSOCK_H)
/* DragonFlyBSD and Windows use millisecond units */
#define KEEPALIVE_FACTOR(x) (x *= 1000)
#else
#define KEEPALIVE_FACTOR(x)
#endif

#if defined(HAVE_WINSOCK2_H) && !defined(SIO_KEEPALIVE_VALS)
#define SIO_KEEPALIVE_VALS    _WSAIOW(IOC_VENDOR,4)

struct tcp_keepalive {
  u_long onoff;
  u_long keepalivetime;
  u_long keepaliveinterval;
};
#endif

static void
tcpkeepalive(struct SessionHandle *data,
             curl_socket_t sockfd)
{
  int optval = data->set.tcp_keepalive?1:0;

  /* only set IDLE and INTVL if setting KEEPALIVE is successful */
  if(setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE,
        (void *)&optval, sizeof(optval)) < 0) {
    infof(data, ""Failed to set SO_KEEPALIVE on fd %d\n"", sockfd);
  }
  else {
#if defined(SIO_KEEPALIVE_VALS)
    struct tcp_keepalive vals;
    DWORD dummy;
    vals.onoff = 1;
    optval = curlx_sltosi(data->set.tcp_keepidle);
    KEEPALIVE_FACTOR(optval);
    vals.keepalivetime = optval;
    optval = curlx_sltosi(data->set.tcp_keepintvl);
    KEEPALIVE_FACTOR(optval);
    vals.keepaliveinterval = optval;
    if(WSAIoctl(sockfd, SIO_KEEPALIVE_VALS, (LPVOID) &vals, sizeof(vals),
                NULL, 0, &dummy, NULL, NULL) != 0) {
      infof(data, ""Failed to set SIO_KEEPALIVE_VALS on fd %d: %d\n"",
            (int)sockfd, WSAGetLastError());
    }
#else
#ifdef TCP_KEEPIDLE
    optval = curlx_sltosi(data->set.tcp_keepidle);
    KEEPALIVE_FACTOR(optval);
    if(setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPIDLE,
          (void *)&optval, sizeof(optval)) < 0) {
      infof(data, ""Failed to set TCP_KEEPIDLE on fd %d\n"", sockfd);
    }
#endif
#ifdef TCP_KEEPINTVL
    optval = curlx_sltosi(data->set.tcp_keepintvl);
    KEEPALIVE_FACTOR(optval);
    if(setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPINTVL,
          (void *)&optval, sizeof(optval)) < 0) {
      infof(data, ""Failed to set TCP_KEEPINTVL on fd %d\n"", sockfd);
    }
#endif
#ifdef TCP_KEEPALIVE
    /* Mac OS X style */
    optval = curlx_sltosi(data->set.tcp_keepidle);
    KEEPALIVE_FACTOR(optval);
    if(setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPALIVE,
          (void *)&optval, sizeof(optval)) < 0) {
      infof(data, ""Failed to set TCP_KEEPALIVE on fd %d\n"", sockfd);
    }
#endif
#endif
  }
}

static CURLcode
singleipconnect(struct connectdata *conn,
                const Curl_addrinfo *ai, /* start connecting to this */
                curl_socket_t *sock);

/*
 * Curl_timeleft() returns the amount of milliseconds left allowed for the
 * transfer/connection. If the value is negative, the timeout time has already
 * elapsed.
 *
 * The start time is stored in progress.t_startsingle - as set with
 * Curl_pgrsTime(..., TIMER_STARTSINGLE);
 *
 * If 'nowp' is non-NULL, it points to the current time.
 * 'duringconnect' is FALSE if not during a connect, as then of course the
 * connect timeout is not taken into account!
 *
 * @unittest: 1303
 */
long Curl_timeleft(struct SessionHandle *data,
                   struct timeval *nowp,
                   bool duringconnect)
{
  int timeout_set = 0;
  long timeout_ms = duringconnect?DEFAULT_CONNECT_TIMEOUT:0;
  struct timeval now;

  /* if a timeout is set, use the most restrictive one */

  if(data->set.timeout > 0)
    timeout_set |= 1;
  if(duringconnect && (data->set.connecttimeout > 0))
    timeout_set |= 2;

  switch (timeout_set) {
  case 1:
    timeout_ms = data->set.timeout;
    break;
  case 2:
    timeout_ms = data->set.connecttimeout;
    break;
  case 3:
    if(data->set.timeout < data->set.connecttimeout)
      timeout_ms = data->set.timeout;
    else
      timeout_ms = data->set.connecttimeout;
    break;
  default:
    /* use the default */
    if(!duringconnect)
      /* if we're not during connect, there's no default timeout so if we're
         at zero we better just return zero and not make it a negative number
         by the math below */
      return 0;
    break;
  }

  if(!nowp) {
    now = Curl_tvnow();
    nowp = &now;
  }

  /* subtract elapsed time */
  if(duringconnect)
    /* since this most recent connect started */
    timeout_ms -= Curl_tvdiff(*nowp, data->progress.t_startsingle);
  else
    /* since the entire operation started */
    timeout_ms -= Curl_tvdiff(*nowp, data->progress.t_startop);
  if(!timeout_ms)
    /* avoid returning 0 as that means no timeout! */
    return -1;

  return timeout_ms;
}

static CURLcode bindlocal(struct connectdata *conn,
                          curl_socket_t sockfd, int af)
{
  struct SessionHandle *data = conn->data;

  struct Curl_sockaddr_storage sa;
  struct sockaddr *sock = (struct sockaddr *)&sa;  /* bind to this address */
  curl_socklen_t sizeof_sa = 0; /* size of the data sock points to */
  struct sockaddr_in *si4 = (struct sockaddr_in *)&sa;
#ifdef ENABLE_IPV6
  struct sockaddr_in6 *si6 = (struct sockaddr_in6 *)&sa;
#endif

  struct Curl_dns_entry *h=NULL;
  unsigned short port = data->set.localport; /* use this port number, 0 for
                                                ""random"" */
  /* how many port numbers to try to bind to, increasing one at a time */
  int portnum = data->set.localportrange;
  const char *dev = data->set.str[STRING_DEVICE];
  int error;
  char myhost[256] = """";
  int done = 0; /* -1 for error, 1 for address found */
  bool is_interface = FALSE;
  bool is_host = FALSE;
  static const char *if_prefix = ""if!"";
  static const char *host_prefix = ""host!"";

  /*************************************************************
   * Select device to bind socket to
   *************************************************************/
  if(!dev && !port)
    /* no local kind of binding was requested */
    return CURLE_OK;

  memset(&sa, 0, sizeof(struct Curl_sockaddr_storage));

  if(dev && (strlen(dev)<255) ) {
    if(strncmp(if_prefix, dev, strlen(if_prefix)) == 0) {
      dev += strlen(if_prefix);
      is_interface = TRUE;
    }
    else if(strncmp(host_prefix, dev, strlen(host_prefix)) == 0) {
      dev += strlen(host_prefix);
      is_host = TRUE;
    }

    /* interface */
    if(!is_host) {
      switch(Curl_if2ip(af, conn->scope, dev, myhost, sizeof(myhost))) {
        case IF2IP_NOT_FOUND:
          if(is_interface) {
            /* Do not fall back to treating it as a host name */
            failf(data, ""Couldn't bind to interface '%s'"", dev);
            return CURLE_INTERFACE_FAILED;
          }
          break;
        case IF2IP_AF_NOT_SUPPORTED:
          /* Signal the caller to try another address family if available */
          return CURLE_UNSUPPORTED_PROTOCOL;
        case IF2IP_FOUND:
          is_interface = TRUE;
          /*
           * We now have the numerical IP address in the 'myhost' buffer
           */
          infof(data, ""Local Interface %s is ip %s using address family %i\n"",
                dev, myhost, af);
          done = 1;

#ifdef SO_BINDTODEVICE
          /* I am not sure any other OSs than Linux that provide this feature,
           * and at the least I cannot test. --Ben
           *
           * This feature allows one to tightly bind the local socket to a
           * particular interface.  This will force even requests to other
           * local interfaces to go out the external interface.
           *
           *
           * Only bind to the interface when specified as interface, not just
           * as a hostname or ip address.
           */
          if(setsockopt(sockfd, SOL_SOCKET, SO_BINDTODEVICE,
                        dev, (curl_socklen_t)strlen(dev)+1) != 0) {
            error = SOCKERRNO;
            infof(data, ""SO_BINDTODEVICE %s failed with errno %d: %s;""
                  "" will do regular bind\n"",
                  dev, error, Curl_strerror(conn, error));
            /* This is typically ""errno 1, error: Operation not permitted"" if
               you're not running as root or another suitable privileged
               user */
          }
#endif
          break;
      }
    }
    if(!is_interface) {
      /*
       * This was not an interface, resolve the name as a host name
       * or IP number
       *
       * Temporarily force name resolution to use only the address type
       * of the connection. The resolve functions should really be changed
       * to take a type parameter instead.
       */
      long ipver = conn->ip_version;
      int rc;

      if(af == AF_INET)
        conn->ip_version = CURL_IPRESOLVE_V4;
#ifdef ENABLE_IPV6
      else if(af == AF_INET6)
        conn->ip_version = CURL_IPRESOLVE_V6;
#endif

      rc = Curl_resolv(conn, dev, 0, &h);
      if(rc == CURLRESOLV_PENDING)
        (void)Curl_resolver_wait_resolv(conn, &h);
      conn->ip_version = ipver;

      if(h) {
        /* convert the resolved address, sizeof myhost >= INET_ADDRSTRLEN */
        Curl_printable_address(h->addr, myhost, sizeof(myhost));
        infof(data, ""Name '%s' family %i resolved to '%s' family %i\n"",
              dev, af, myhost, h->addr->ai_family);
        Curl_resolv_unlock(data, h);
        done = 1;
      }
      else {
        /*
         * provided dev was no interface (or interfaces are not supported
         * e.g. solaris) no ip address and no domain we fail here
         */
        done = -1;
      }
    }

    if(done > 0) {
#ifdef ENABLE_IPV6
      /* ipv6 address */
      if(af == AF_INET6) {
#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
        char *scope_ptr = strchr(myhost, '%');
        if(scope_ptr)
          *(scope_ptr++) = 0;
#endif
        if(Curl_inet_pton(AF_INET6, myhost, &si6->sin6_addr) > 0) {
          si6->sin6_family = AF_INET6;
          si6->sin6_port = htons(port);
#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
          if(scope_ptr)
            /* The ""myhost"" string either comes from Curl_if2ip or from
               Curl_printable_address. The latter returns only numeric scope
               IDs and the former returns none at all.  So the scope ID, if
               present, is known to be numeric */
            si6->sin6_scope_id = atoi(scope_ptr);
#endif
        }
        sizeof_sa = sizeof(struct sockaddr_in6);
      }
      else
#endif
      /* ipv4 address */
      if((af == AF_INET) &&
         (Curl_inet_pton(AF_INET, myhost, &si4->sin_addr) > 0)) {
        si4->sin_family = AF_INET;
        si4->sin_port = htons(port);
        sizeof_sa = sizeof(struct sockaddr_in);
      }
    }

    if(done < 1) {
      failf(data, ""Couldn't bind to '%s'"", dev);
      return CURLE_INTERFACE_FAILED;
    }
  }
  else {
    /* no device was given, prepare sa to match af's needs */
#ifdef ENABLE_IPV6
    if(af == AF_INET6) {
      si6->sin6_family = AF_INET6;
      si6->sin6_port = htons(port);
      sizeof_sa = sizeof(struct sockaddr_in6);
    }
    else
#endif
    if(af == AF_INET) {
      si4->sin_family = AF_INET;
      si4->sin_port = htons(port);
      sizeof_sa = sizeof(struct sockaddr_in);
    }
  }

  for(;;) {
    if(bind(sockfd, sock, sizeof_sa) >= 0) {
      /* we succeeded to bind */
      struct Curl_sockaddr_storage add;
      curl_socklen_t size = sizeof(add);
      memset(&add, 0, sizeof(struct Curl_sockaddr_storage));
      if(getsockname(sockfd, (struct sockaddr *) &add, &size) < 0) {
        data->state.os_errno = error = SOCKERRNO;
        failf(data, ""getsockname() failed with errno %d: %s"",
              error, Curl_strerror(conn, error));
        return CURLE_INTERFACE_FAILED;
      }
      infof(data, ""Local port: %hu\n"", port);
      conn->bits.bound = TRUE;
      return CURLE_OK;
    }

    if(--portnum > 0) {
      infof(data, ""Bind to local port %hu failed, trying next\n"", port);
      port++; /* try next port */
      /* We re-use/clobber the port variable here below */
      if(sock->sa_family == AF_INET)
        si4->sin_port = ntohs(port);
#ifdef ENABLE_IPV6
      else
        si6->sin6_port = ntohs(port);
#endif
    }
    else
      break;
  }

  data->state.os_errno = error = SOCKERRNO;
  failf(data, ""bind failed with errno %d: %s"",
        error, Curl_strerror(conn, error));

  return CURLE_INTERFACE_FAILED;
}

/*
",18,18,[316],[]
80c881f7938969dab169f4fc4fbf8bc3d4355fc2,"Merge branch 'curl-upstream' into update-curl

Resolve all conflicts in favor of the upstream side.
We can re-apply specific changes later.",[],Utilities/cmcurl/lib/cookie.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_316.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_316.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_593.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_593.cpp,"static char *get_netscape_format(const struct Cookie *co)
{
  return aprintf(
    ""%s%s\t"" /* domain */
    ""%s\t""   /* tailmatch */
    ""%s\t""   /* path */
    ""%s\t""   /* secure */
    ""%"" FORMAT_OFF_T ""\t""   /* expires */
    ""%s\t""   /* name */
    ""%s"",    /* value */
    /* Make sure all domains are prefixed with a dot if they allow
       tailmatching. This is Mozilla-style. */
    (co->tailmatch && co->domain && co->domain[0] != '.')? ""."":"""",
","static char *get_netscape_format(const struct Cookie *co)
{
  return aprintf(
    ""%s""     /* httponly preamble */
    ""%s%s\t"" /* domain */
    ""%s\t""   /* tailmatch */
    ""%s\t""   /* path */
    ""%s\t""   /* secure */
    ""%"" CURL_FORMAT_CURL_OFF_T ""\t""   /* expires */
    ""%s\t""   /* name */
    ""%s"",    /* value */
    co->httponly?""#HttpOnly_"":"""",
    /* Make sure all domains are prefixed with a dot if they allow
       tailmatching. This is Mozilla-style. */
    (co->tailmatch && co->domain && co->domain[0] != '.')? ""."":"""",
",907,1213,[2],[]
80c881f7938969dab169f4fc4fbf8bc3d4355fc2,"Merge branch 'curl-upstream' into update-curl

Resolve all conflicts in favor of the upstream side.
We can re-apply specific changes later.",[],Utilities/cmcurl/lib/cookie.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_316.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_316.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_594.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_594.cpp,"    char *format_ptr;

    fputs(""# Netscape HTTP Cookie File\n""
          ""# http://curlm.haxx.se/rfc/cookie_spec.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);
    co = c->cookies;

    while(co) {
      format_ptr = get_netscape_format(co);
      if (format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
        if(!use_stdout)
          fclose(out);
","    char *format_ptr;

    fputs(""# Netscape HTTP Cookie File\n""
          ""# http://curl.haxx.se/docs/http-cookies.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);
    co = c->cookies;

    while(co) {
      format_ptr = get_netscape_format(co);
      if(format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
        if(!use_stdout)
          fclose(out);
",960,1271,[11],[]
cc1139cc304b6bd4c8403d437cf08f73e06e243a,"strings: Remove redundant calls to std::string::c_str()

Replacements were detected and performed by the clang tool
remove-cstr-calls on a linux build.",[],Source/cmcmd.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_317.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_317.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_595.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_595.cpp,"        // write the count into the directory
        std::string fName = dirName;
        fName += ""/count.txt"";
        FILE *progFile = cmsys::SystemTools::Fopen(fName.c_str(),""w"");
        if (progFile)
          {
          fprintf(progFile,""%i\n"",count);
","        // write the count into the directory
        std::string fName = dirName;
        fName += ""/count.txt"";
        FILE *progFile = cmsys::SystemTools::Fopen(fName,""w"");
        if (progFile)
          {
          fprintf(progFile,""%i\n"",count);
",476,476,[6],[]
cc1139cc304b6bd4c8403d437cf08f73e06e243a,"strings: Remove redundant calls to std::string::c_str()

Replacements were detected and performed by the clang tool
remove-cstr-calls on a linux build.",[],Source/cmcmd.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_317.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_317.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_596.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_596.cpp,"        fName = dirName;
        fName += ""/"";
        fName += args[i];
        progFile = cmsys::SystemTools::Fopen(fName.c_str(),""w"");
        if (progFile)
          {
          fprintf(progFile,""empty"");
          fclose(progFile);
          }
        }
      int fileNum = static_cast<int>
        (cmsys::Directory::GetNumberOfFilesInDirectory(dirName.c_str()));
      if (count > 0)
        {
        // print the progress
","        fName = dirName;
        fName += ""/"";
        fName += args[i];
        progFile = cmsys::SystemTools::Fopen(fName,""w"");
        if (progFile)
          {
          fprintf(progFile,""empty"");
          fclose(progFile);
          }
        }
      int fileNum = static_cast<int>
        (cmsys::Directory::GetNumberOfFilesInDirectory(dirName));
      if (count > 0)
        {
        // print the progress
",517,517,[6],[]
3fe5d9bff98b4716e219516c30d71462495324f4,"curl 7.38.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.38.0 &&
r=202aa9f7 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/connect.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_597.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_597.cpp," * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 * $Id$
 ***************************************************************************/

#include ""setup.h""

#ifndef WIN32
/* headers for non-win32 */
#ifdef HAVE_SYS_TIME_H
#include <sys/time.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif
#ifdef HAVE_NETINET_IN_H
#include <netinet/in.h> /* <netinet/tcp.h> may need it */
#endif
#ifdef HAVE_NETINET_TCP_H
#include <netinet/tcp.h> /* for TCP_NODELAY */
#endif
#ifdef HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_NETDB_H
#include <netdb.h>
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#ifdef HAVE_NETINET_IN_H
#include <netinet/in.h>
#endif
#ifdef HAVE_ARPA_INET_H
#include <arpa/inet.h>
#endif
#ifdef HAVE_STDLIB_H
#include <stdlib.h> /* required for free() prototype, without it, this crashes
                       on macos 68K */
#endif
#if (defined(HAVE_FIONBIO) && defined(__NOVELL_LIBC__))
#include <sys/filio.h>
#endif
#if (defined(NETWARE) && defined(__NOVELL_LIBC__))
#undef in_addr_t
#define in_addr_t unsigned long
#endif
#ifdef VMS
#include <in.h>
#include <inet.h>
#endif

#endif
#include <stdio.h>
#include <errno.h>
#include <string.h>

#ifndef TRUE
#define TRUE 1
#define FALSE 0
#endif

#ifdef USE_WINSOCK
#define EINPROGRESS WSAEINPROGRESS
#define EWOULDBLOCK WSAEWOULDBLOCK
#define EISCONN     WSAEISCONN
#define ENOTSOCK    WSAENOTSOCK
#define ECONNREFUSED WSAECONNREFUSED
#endif

#include ""urldata.h""
#include ""sendf.h""
#include ""if2ip.h""
#include ""strerror.h""
#include ""connect.h""
#include ""memory.h""
#include ""select.h""
#include ""url.h"" /* for Curl_safefree() */
#include ""multiif.h""
#include ""sockaddr.h"" /* required for Curl_sockaddr_storage */
#include ""inet_ntop.h""

/* The last #include file should be: */
#include ""memdebug.h""

static bool verifyconnect(curl_socket_t sockfd, int *error);

static curl_socket_t
singleipconnect(struct connectdata *conn,
                const Curl_addrinfo *ai, /* start connecting to this */
                long timeout_ms,
                bool *connected);

/*
 * Curl_sockerrno() returns the *socket-related* errno (or equivalent) on this
 * platform to hide platform specific for the function that calls this.
 */
int Curl_sockerrno(void)
{
#ifdef USE_WINSOCK
  return (int)WSAGetLastError();
#else
  return errno;
#endif
}

/*
 * Curl_nonblock() set the given socket to either blocking or non-blocking
 * mode based on the 'nonblock' boolean argument. This function is highly
 * portable.
 */
int Curl_nonblock(curl_socket_t sockfd,    /* operate on this */
                  int nonblock   /* TRUE or FALSE */)
{
#undef SETBLOCK
#define SETBLOCK 0
#ifdef HAVE_O_NONBLOCK
  /* most recent unix versions */
  int flags;

  flags = fcntl(sockfd, F_GETFL, 0);
  if (TRUE == nonblock)
    return fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
  else
    return fcntl(sockfd, F_SETFL, flags & (~O_NONBLOCK));
#undef SETBLOCK
#define SETBLOCK 1
#endif

#if defined(HAVE_FIONBIO) && (SETBLOCK == 0)
  /* older unix versions */
  int flags;

  flags = nonblock;
  return ioctl(sockfd, FIONBIO, &flags);
#undef SETBLOCK
#define SETBLOCK 2
#endif

#if defined(HAVE_IOCTLSOCKET) && (SETBLOCK == 0)
  /* Windows? */
  unsigned long flags;
  flags = nonblock;

  return ioctlsocket(sockfd, FIONBIO, &flags);
#undef SETBLOCK
#define SETBLOCK 3
#endif

#if defined(HAVE_IOCTLSOCKET_CASE) && (SETBLOCK == 0)
  /* presumably for Amiga */
  return IoctlSocket(sockfd, FIONBIO, (long)nonblock);
#undef SETBLOCK
#define SETBLOCK 4
#endif

#if defined(HAVE_SO_NONBLOCK) && (SETBLOCK == 0)
  /* BeOS */
  long b = nonblock ? 1 : 0;
  return setsockopt(sockfd, SOL_SOCKET, SO_NONBLOCK, &b, sizeof(b));
#undef SETBLOCK
#define SETBLOCK 5
#endif

#ifdef HAVE_DISABLED_NONBLOCKING
  return 0; /* returns success */
#undef SETBLOCK
#define SETBLOCK 6
#endif

#if (SETBLOCK == 0)
#error ""no non-blocking method was found/used/set""
#endif
}

/*
 * waitconnect() waits for a TCP connect on the given socket for the specified
 * number if milliseconds. It returns:
 * 0    fine connect
 * -1   select() error
 * 1    select() timeout
 * 2    select() returned with an error condition fd_set
 */

#define WAITCONN_CONNECTED     0
#define WAITCONN_SELECT_ERROR -1
#define WAITCONN_TIMEOUT       1
#define WAITCONN_FDSET_ERROR   2

static
int waitconnect(curl_socket_t sockfd, /* socket */
                long timeout_msec)
{
  int rc;
#ifdef mpeix
  /* Call this function once now, and ignore the results. We do this to
     ""clear"" the error state on the socket so that we can later read it
     reliably. This is reported necessary on the MPE/iX operating system. */
  (void)verifyconnect(sockfd, NULL);
#endif

  /* now select() until we get connect or timeout */
  rc = Curl_select(CURL_SOCKET_BAD, sockfd, (int)timeout_msec);
  if(-1 == rc)
    /* error, no connect here, try next */
    return WAITCONN_SELECT_ERROR;

  else if(0 == rc)
    /* timeout, no connect today */
    return WAITCONN_TIMEOUT;

  if(rc & CSELECT_ERR)
    /* error condition caught */
    return WAITCONN_FDSET_ERROR;

  /* we have a connect! */
  return WAITCONN_CONNECTED;
}

static CURLcode bindlocal(struct connectdata *conn,
                          curl_socket_t sockfd)
{
  struct SessionHandle *data = conn->data;
  struct sockaddr_in me;
  struct sockaddr *sock = NULL;  /* bind to this address */
  socklen_t socksize; /* size of the data sock points to */
  unsigned short port = data->set.localport; /* use this port number, 0 for
                                                ""random"" */
  /* how many port numbers to try to bind to, increasing one at a time */
  int portnum = data->set.localportrange;

  /*************************************************************
   * Select device to bind socket to
   *************************************************************/
  if (data->set.device && (strlen(data->set.device)<255) ) {
    struct Curl_dns_entry *h=NULL;
    char myhost[256] = """";
    in_addr_t in;
    int rc;
    bool was_iface = FALSE;

    /* First check if the given name is an IP address */
    in=inet_addr(data->set.device);

    if((in == CURL_INADDR_NONE) &&
       Curl_if2ip(data->set.device, myhost, sizeof(myhost))) {
      /*
       * We now have the numerical IPv4-style x.y.z.w in the 'myhost' buffer
       */
      rc = Curl_resolv(conn, myhost, 0, &h);
      if(rc == CURLRESOLV_PENDING)
        (void)Curl_wait_for_resolv(conn, &h);

      if(h) {
        was_iface = TRUE;
        Curl_resolv_unlock(data, h);
      }
    }

    if(!was_iface) {
      /*
       * This was not an interface, resolve the name as a host name
       * or IP number
       */
      rc = Curl_resolv(conn, data->set.device, 0, &h);
      if(rc == CURLRESOLV_PENDING)
        (void)Curl_wait_for_resolv(conn, &h);

      if(h) {
        if(in == CURL_INADDR_NONE)
          /* convert the resolved address, sizeof myhost >= INET_ADDRSTRLEN */
          Curl_inet_ntop(h->addr->ai_addr->sa_family,
                         &((struct sockaddr_in*)h->addr->ai_addr)->sin_addr,
                         myhost, sizeof myhost);
        else
          /* we know data->set.device is shorter than the myhost array */
          strcpy(myhost, data->set.device);
        Curl_resolv_unlock(data, h);
      }
    }

    if(! *myhost) {
      /* need to fix this
         h=Curl_gethost(data,
         getmyhost(*myhost,sizeof(myhost)),
         hostent_buf,
         sizeof(hostent_buf));
      */
      failf(data, ""Couldn't bind to '%s'"", data->set.device);
      return CURLE_HTTP_PORT_FAILED;
    }

    infof(data, ""Bind local address to %s\n"", myhost);

#ifdef SO_BINDTODEVICE
    /* I am not sure any other OSs than Linux that provide this feature, and
     * at the least I cannot test. --Ben
     *
     * This feature allows one to tightly bind the local socket to a
     * particular interface.  This will force even requests to other local
     * interfaces to go out the external interface.
     *
     */
    if (was_iface) {
      /* Only bind to the interface when specified as interface, not just as a
       * hostname or ip address.
       */
      if (setsockopt(sockfd, SOL_SOCKET, SO_BINDTODEVICE,
                     data->set.device, strlen(data->set.device)+1) != 0) {
        /* printf(""Failed to BINDTODEVICE, socket: %d  device: %s error: %s\n"",
           sockfd, data->set.device, Curl_strerror(Curl_sockerrno())); */
        infof(data, ""SO_BINDTODEVICE %s failed\n"",
              data->set.device);
        /* This is typically ""errno 1, error: Operation not permitted"" if
           you're not running as root or another suitable privileged user */
      }
    }
#endif

    in=inet_addr(myhost);
    if (CURL_INADDR_NONE == in) {
      failf(data,""couldn't find my own IP address (%s)"", myhost);
      return CURLE_HTTP_PORT_FAILED;
    } /* end of inet_addr */

    if ( h ) {
      Curl_addrinfo *addr = h->addr;
      sock = addr->ai_addr;
      socksize = addr->ai_addrlen;
    }
    else
      return CURLE_HTTP_PORT_FAILED;

  }
  else if(port) {
    /* if a local port number is requested but no local IP, extract the
       address from the socket */
    memset(&me, 0, sizeof(struct sockaddr));
    me.sin_family = AF_INET;
    me.sin_addr.s_addr = INADDR_ANY;

    sock = (struct sockaddr *)&me;
    socksize = sizeof(struct sockaddr);

  }
  else
    /* no local kind of binding was requested */
    return CURLE_OK;

  do {

    /* Set port number to bind to, 0 makes the system pick one */
    if(sock->sa_family == AF_INET)
      ((struct sockaddr_in *)sock)->sin_port = htons(port);
#ifdef ENABLE_IPV6
    else
      ((struct sockaddr_in6 *)sock)->sin6_port = htons(port);
#endif

    if( bind(sockfd, sock, socksize) >= 0) {
      /* we succeeded to bind */
      struct Curl_sockaddr_storage add;
      socklen_t size;

      size = sizeof(add);
      if(getsockname(sockfd, (struct sockaddr *) &add, &size) < 0) {
        failf(data, ""getsockname() failed"");
        return CURLE_HTTP_PORT_FAILED;
      }
      /* We re-use/clobber the port variable here below */
      if(((struct sockaddr *)&add)->sa_family == AF_INET)
        port = ntohs(((struct sockaddr_in *)&add)->sin_port);
#ifdef ENABLE_IPV6
      else
        port = ntohs(((struct sockaddr_in6 *)&add)->sin6_port);
#endif
      infof(data, ""Local port: %d\n"", port);
      return CURLE_OK;
    }
    if(--portnum > 0) {
      infof(data, ""Bind to local port %d failed, trying next\n"", port);
      port++; /* try next port */
    }
    else
      break;
  } while(1);

  data->state.os_errno = Curl_sockerrno();
  failf(data, ""bind failure: %s"",
        Curl_strerror(conn, data->state.os_errno));
  return CURLE_HTTP_PORT_FAILED;

}

/*
"," * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 ***************************************************************************/

#include ""curl_setup.h""

#ifdef HAVE_NETINET_IN_H
#include <netinet/in.h> /* <netinet/tcp.h> may need it */
#endif
#ifdef HAVE_SYS_UN_H
#include <sys/un.h> /* for sockaddr_un */
#endif
#ifdef HAVE_NETINET_TCP_H
#include <netinet/tcp.h> /* for TCP_NODELAY */
#endif
#ifdef HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif
#ifdef HAVE_NETDB_H
#include <netdb.h>
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#ifdef HAVE_ARPA_INET_H
#include <arpa/inet.h>
#endif

#if (defined(HAVE_IOCTL_FIONBIO) && defined(NETWARE))
#include <sys/filio.h>
#endif
#ifdef NETWARE
#undef in_addr_t
#define in_addr_t unsigned long
#endif
#ifdef __VMS
#include <in.h>
#include <inet.h>
#endif

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

#include ""urldata.h""
#include ""sendf.h""
#include ""if2ip.h""
#include ""strerror.h""
#include ""connect.h""
#include ""curl_memory.h""
#include ""select.h""
#include ""url.h"" /* for Curl_safefree() */
#include ""multiif.h""
#include ""sockaddr.h"" /* required for Curl_sockaddr_storage */
#include ""inet_ntop.h""
#include ""inet_pton.h""
#include ""vtls/vtls.h"" /* for Curl_ssl_check_cxn() */
#include ""progress.h""
#include ""warnless.h""
#include ""conncache.h""
#include ""multihandle.h""

/* The last #include file should be: */
#include ""memdebug.h""

#ifdef __SYMBIAN32__
/* This isn't actually supported under Symbian OS */
#undef SO_NOSIGPIPE
#endif

static bool verifyconnect(curl_socket_t sockfd, int *error);

#if defined(__DragonFly__) || defined(HAVE_WINSOCK_H)
/* DragonFlyBSD and Windows use millisecond units */
#define KEEPALIVE_FACTOR(x) (x *= 1000)
#else
#define KEEPALIVE_FACTOR(x)
#endif

#if defined(HAVE_WINSOCK2_H) && !defined(SIO_KEEPALIVE_VALS)
#define SIO_KEEPALIVE_VALS    _WSAIOW(IOC_VENDOR,4)

struct tcp_keepalive {
  u_long onoff;
  u_long keepalivetime;
  u_long keepaliveinterval;
};
#endif

static void
tcpkeepalive(struct SessionHandle *data,
             curl_socket_t sockfd)
{
  int optval = data->set.tcp_keepalive?1:0;

  /* only set IDLE and INTVL if setting KEEPALIVE is successful */
  if(setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE,
        (void *)&optval, sizeof(optval)) < 0) {
    infof(data, ""Failed to set SO_KEEPALIVE on fd %d\n"", sockfd);
  }
  else {
#if defined(SIO_KEEPALIVE_VALS)
    struct tcp_keepalive vals;
    DWORD dummy;
    vals.onoff = 1;
    optval = curlx_sltosi(data->set.tcp_keepidle);
    KEEPALIVE_FACTOR(optval);
    vals.keepalivetime = optval;
    optval = curlx_sltosi(data->set.tcp_keepintvl);
    KEEPALIVE_FACTOR(optval);
    vals.keepaliveinterval = optval;
    if(WSAIoctl(sockfd, SIO_KEEPALIVE_VALS, (LPVOID) &vals, sizeof(vals),
                NULL, 0, &dummy, NULL, NULL) != 0) {
      infof(data, ""Failed to set SIO_KEEPALIVE_VALS on fd %d: %d\n"",
            (int)sockfd, WSAGetLastError());
    }
#else
#ifdef TCP_KEEPIDLE
    optval = curlx_sltosi(data->set.tcp_keepidle);
    KEEPALIVE_FACTOR(optval);
    if(setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPIDLE,
          (void *)&optval, sizeof(optval)) < 0) {
      infof(data, ""Failed to set TCP_KEEPIDLE on fd %d\n"", sockfd);
    }
#endif
#ifdef TCP_KEEPINTVL
    optval = curlx_sltosi(data->set.tcp_keepintvl);
    KEEPALIVE_FACTOR(optval);
    if(setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPINTVL,
          (void *)&optval, sizeof(optval)) < 0) {
      infof(data, ""Failed to set TCP_KEEPINTVL on fd %d\n"", sockfd);
    }
#endif
#ifdef TCP_KEEPALIVE
    /* Mac OS X style */
    optval = curlx_sltosi(data->set.tcp_keepidle);
    KEEPALIVE_FACTOR(optval);
    if(setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPALIVE,
          (void *)&optval, sizeof(optval)) < 0) {
      infof(data, ""Failed to set TCP_KEEPALIVE on fd %d\n"", sockfd);
    }
#endif
#endif
  }
}

static CURLcode
singleipconnect(struct connectdata *conn,
                const Curl_addrinfo *ai, /* start connecting to this */
                curl_socket_t *sock);

/*
 * Curl_timeleft() returns the amount of milliseconds left allowed for the
 * transfer/connection. If the value is negative, the timeout time has already
 * elapsed.
 *
 * The start time is stored in progress.t_startsingle - as set with
 * Curl_pgrsTime(..., TIMER_STARTSINGLE);
 *
 * If 'nowp' is non-NULL, it points to the current time.
 * 'duringconnect' is FALSE if not during a connect, as then of course the
 * connect timeout is not taken into account!
 *
 * @unittest: 1303
 */
long Curl_timeleft(struct SessionHandle *data,
                   struct timeval *nowp,
                   bool duringconnect)
{
  int timeout_set = 0;
  long timeout_ms = duringconnect?DEFAULT_CONNECT_TIMEOUT:0;
  struct timeval now;

  /* if a timeout is set, use the most restrictive one */

  if(data->set.timeout > 0)
    timeout_set |= 1;
  if(duringconnect && (data->set.connecttimeout > 0))
    timeout_set |= 2;

  switch (timeout_set) {
  case 1:
    timeout_ms = data->set.timeout;
    break;
  case 2:
    timeout_ms = data->set.connecttimeout;
    break;
  case 3:
    if(data->set.timeout < data->set.connecttimeout)
      timeout_ms = data->set.timeout;
    else
      timeout_ms = data->set.connecttimeout;
    break;
  default:
    /* use the default */
    if(!duringconnect)
      /* if we're not during connect, there's no default timeout so if we're
         at zero we better just return zero and not make it a negative number
         by the math below */
      return 0;
    break;
  }

  if(!nowp) {
    now = Curl_tvnow();
    nowp = &now;
  }

  /* subtract elapsed time */
  if(duringconnect)
    /* since this most recent connect started */
    timeout_ms -= Curl_tvdiff(*nowp, data->progress.t_startsingle);
  else
    /* since the entire operation started */
    timeout_ms -= Curl_tvdiff(*nowp, data->progress.t_startop);
  if(!timeout_ms)
    /* avoid returning 0 as that means no timeout! */
    return -1;

  return timeout_ms;
}

static CURLcode bindlocal(struct connectdata *conn,
                          curl_socket_t sockfd, int af)
{
  struct SessionHandle *data = conn->data;

  struct Curl_sockaddr_storage sa;
  struct sockaddr *sock = (struct sockaddr *)&sa;  /* bind to this address */
  curl_socklen_t sizeof_sa = 0; /* size of the data sock points to */
  struct sockaddr_in *si4 = (struct sockaddr_in *)&sa;
#ifdef ENABLE_IPV6
  struct sockaddr_in6 *si6 = (struct sockaddr_in6 *)&sa;
#endif

  struct Curl_dns_entry *h=NULL;
  unsigned short port = data->set.localport; /* use this port number, 0 for
                                                ""random"" */
  /* how many port numbers to try to bind to, increasing one at a time */
  int portnum = data->set.localportrange;
  const char *dev = data->set.str[STRING_DEVICE];
  int error;
  char myhost[256] = """";
  int done = 0; /* -1 for error, 1 for address found */
  bool is_interface = FALSE;
  bool is_host = FALSE;
  static const char *if_prefix = ""if!"";
  static const char *host_prefix = ""host!"";

  /*************************************************************
   * Select device to bind socket to
   *************************************************************/
  if(!dev && !port)
    /* no local kind of binding was requested */
    return CURLE_OK;

  memset(&sa, 0, sizeof(struct Curl_sockaddr_storage));

  if(dev && (strlen(dev)<255) ) {
    if(strncmp(if_prefix, dev, strlen(if_prefix)) == 0) {
      dev += strlen(if_prefix);
      is_interface = TRUE;
    }
    else if(strncmp(host_prefix, dev, strlen(host_prefix)) == 0) {
      dev += strlen(host_prefix);
      is_host = TRUE;
    }

    /* interface */
    if(!is_host) {
      switch(Curl_if2ip(af, conn->scope, dev, myhost, sizeof(myhost))) {
        case IF2IP_NOT_FOUND:
          if(is_interface) {
            /* Do not fall back to treating it as a host name */
            failf(data, ""Couldn't bind to interface '%s'"", dev);
            return CURLE_INTERFACE_FAILED;
          }
          break;
        case IF2IP_AF_NOT_SUPPORTED:
          /* Signal the caller to try another address family if available */
          return CURLE_UNSUPPORTED_PROTOCOL;
        case IF2IP_FOUND:
          is_interface = TRUE;
          /*
           * We now have the numerical IP address in the 'myhost' buffer
           */
          infof(data, ""Local Interface %s is ip %s using address family %i\n"",
                dev, myhost, af);
          done = 1;

#ifdef SO_BINDTODEVICE
          /* I am not sure any other OSs than Linux that provide this feature,
           * and at the least I cannot test. --Ben
           *
           * This feature allows one to tightly bind the local socket to a
           * particular interface.  This will force even requests to other
           * local interfaces to go out the external interface.
           *
           *
           * Only bind to the interface when specified as interface, not just
           * as a hostname or ip address.
           */
          if(setsockopt(sockfd, SOL_SOCKET, SO_BINDTODEVICE,
                        dev, (curl_socklen_t)strlen(dev)+1) != 0) {
            error = SOCKERRNO;
            infof(data, ""SO_BINDTODEVICE %s failed with errno %d: %s;""
                  "" will do regular bind\n"",
                  dev, error, Curl_strerror(conn, error));
            /* This is typically ""errno 1, error: Operation not permitted"" if
               you're not running as root or another suitable privileged
               user */
          }
#endif
          break;
      }
    }
    if(!is_interface) {
      /*
       * This was not an interface, resolve the name as a host name
       * or IP number
       *
       * Temporarily force name resolution to use only the address type
       * of the connection. The resolve functions should really be changed
       * to take a type parameter instead.
       */
      long ipver = conn->ip_version;
      int rc;

      if(af == AF_INET)
        conn->ip_version = CURL_IPRESOLVE_V4;
#ifdef ENABLE_IPV6
      else if(af == AF_INET6)
        conn->ip_version = CURL_IPRESOLVE_V6;
#endif

      rc = Curl_resolv(conn, dev, 0, &h);
      if(rc == CURLRESOLV_PENDING)
        (void)Curl_resolver_wait_resolv(conn, &h);
      conn->ip_version = ipver;

      if(h) {
        /* convert the resolved address, sizeof myhost >= INET_ADDRSTRLEN */
        Curl_printable_address(h->addr, myhost, sizeof(myhost));
        infof(data, ""Name '%s' family %i resolved to '%s' family %i\n"",
              dev, af, myhost, h->addr->ai_family);
        Curl_resolv_unlock(data, h);
        done = 1;
      }
      else {
        /*
         * provided dev was no interface (or interfaces are not supported
         * e.g. solaris) no ip address and no domain we fail here
         */
        done = -1;
      }
    }

    if(done > 0) {
#ifdef ENABLE_IPV6
      /* ipv6 address */
      if(af == AF_INET6) {
#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
        char *scope_ptr = strchr(myhost, '%');
        if(scope_ptr)
          *(scope_ptr++) = 0;
#endif
        if(Curl_inet_pton(AF_INET6, myhost, &si6->sin6_addr) > 0) {
          si6->sin6_family = AF_INET6;
          si6->sin6_port = htons(port);
#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
          if(scope_ptr)
            /* The ""myhost"" string either comes from Curl_if2ip or from
               Curl_printable_address. The latter returns only numeric scope
               IDs and the former returns none at all.  So the scope ID, if
               present, is known to be numeric */
            si6->sin6_scope_id = atoi(scope_ptr);
#endif
        }
        sizeof_sa = sizeof(struct sockaddr_in6);
      }
      else
#endif
      /* ipv4 address */
      if((af == AF_INET) &&
         (Curl_inet_pton(AF_INET, myhost, &si4->sin_addr) > 0)) {
        si4->sin_family = AF_INET;
        si4->sin_port = htons(port);
        sizeof_sa = sizeof(struct sockaddr_in);
      }
    }

    if(done < 1) {
      failf(data, ""Couldn't bind to '%s'"", dev);
      return CURLE_INTERFACE_FAILED;
    }
  }
  else {
    /* no device was given, prepare sa to match af's needs */
#ifdef ENABLE_IPV6
    if(af == AF_INET6) {
      si6->sin6_family = AF_INET6;
      si6->sin6_port = htons(port);
      sizeof_sa = sizeof(struct sockaddr_in6);
    }
    else
#endif
    if(af == AF_INET) {
      si4->sin_family = AF_INET;
      si4->sin_port = htons(port);
      sizeof_sa = sizeof(struct sockaddr_in);
    }
  }

  for(;;) {
    if(bind(sockfd, sock, sizeof_sa) >= 0) {
      /* we succeeded to bind */
      struct Curl_sockaddr_storage add;
      curl_socklen_t size = sizeof(add);
      memset(&add, 0, sizeof(struct Curl_sockaddr_storage));
      if(getsockname(sockfd, (struct sockaddr *) &add, &size) < 0) {
        data->state.os_errno = error = SOCKERRNO;
        failf(data, ""getsockname() failed with errno %d: %s"",
              error, Curl_strerror(conn, error));
        return CURLE_INTERFACE_FAILED;
      }
      infof(data, ""Local port: %hu\n"", port);
      conn->bits.bound = TRUE;
      return CURLE_OK;
    }

    if(--portnum > 0) {
      infof(data, ""Bind to local port %hu failed, trying next\n"", port);
      port++; /* try next port */
      /* We re-use/clobber the port variable here below */
      if(sock->sa_family == AF_INET)
        si4->sin_port = ntohs(port);
#ifdef ENABLE_IPV6
      else
        si6->sin6_port = ntohs(port);
#endif
    }
    else
      break;
  }

  data->state.os_errno = error = SOCKERRNO;
  failf(data, ""bind failed with errno %d: %s"",
        error, Curl_strerror(conn, error));

  return CURLE_INTERFACE_FAILED;
}

/*
",18,18,[316],[]
3fe5d9bff98b4716e219516c30d71462495324f4,"curl 7.38.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.38.0 &&
r=202aa9f7 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/cookie.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_319.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_319.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_598.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_598.cpp,"static char *get_netscape_format(const struct Cookie *co)
{
  return aprintf(
    ""%s%s\t"" /* domain */
    ""%s\t""   /* tailmatch */
    ""%s\t""   /* path */
    ""%s\t""   /* secure */
    ""%"" FORMAT_OFF_T ""\t""   /* expires */
    ""%s\t""   /* name */
    ""%s"",    /* value */
    /* Make sure all domains are prefixed with a dot if they allow
       tailmatching. This is Mozilla-style. */
    (co->tailmatch && co->domain && co->domain[0] != '.')? ""."":"""",
","static char *get_netscape_format(const struct Cookie *co)
{
  return aprintf(
    ""%s""     /* httponly preamble */
    ""%s%s\t"" /* domain */
    ""%s\t""   /* tailmatch */
    ""%s\t""   /* path */
    ""%s\t""   /* secure */
    ""%"" CURL_FORMAT_CURL_OFF_T ""\t""   /* expires */
    ""%s\t""   /* name */
    ""%s"",    /* value */
    co->httponly?""#HttpOnly_"":"""",
    /* Make sure all domains are prefixed with a dot if they allow
       tailmatching. This is Mozilla-style. */
    (co->tailmatch && co->domain && co->domain[0] != '.')? ""."":"""",
",907,1213,[2],[]
3fe5d9bff98b4716e219516c30d71462495324f4,"curl 7.38.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.38.0 &&
r=202aa9f7 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/cookie.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_319.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_319.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_599.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_599.cpp,"    char *format_ptr;

    fputs(""# Netscape HTTP Cookie File\n""
          ""# http://curlm.haxx.se/rfc/cookie_spec.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);
    co = c->cookies;

    while(co) {
      format_ptr = get_netscape_format(co);
      if (format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
        return 1;
      }
      fprintf(out, ""%s\n"", format_ptr);
","    char *format_ptr;

    fputs(""# Netscape HTTP Cookie File\n""
          ""# http://curl.haxx.se/docs/http-cookies.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);
    co = c->cookies;

    while(co) {
      format_ptr = get_netscape_format(co);
      if(format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
        if(!use_stdout)
          fclose(out);
        return 1;
      }
      fprintf(out, ""%s\n"", format_ptr);
",960,1271,"[11, 14]",[]
60c783676c91ff1ded2ed5e6fd50d0f9664032e5,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_320.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_320.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_600.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_600.cpp,"  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = strlen(name);
  if ( name[n - 1] == '/' || name[n - 1] == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( strchr(name, '\\') )
      {
      sprintf(buf, ""%s\\*"", name);
      }
    else
      {
      sprintf(buf, ""%s/*"", name);
      }
    }
  struct _wfinddata_t data;      // data of current file
","  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' || *name.rbegin() == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( name.find('\\') != name.npos )
      {
      sprintf(buf, ""%s\\*"", name.c_str());
      }
    else
      {
      sprintf(buf, ""%s/*"", name.c_str());
      }
    }
  struct _wfinddata_t data;      // data of current file
",112,112,"[7, 16, 20]",[]
60c783676c91ff1ded2ed5e6fd50d0f9664032e5,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_320.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_320.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_601.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_601.cpp,"  return _findclose(srchHandle) != -1;
}

unsigned long Directory::GetNumberOfFilesInDirectory(const char* name)
{
#if _MSC_VER < 1300
  long srchHandle;
#else
  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = strlen(name);
  if ( name[n - 1] == '/' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }
  else
    {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name);
    }
  struct _wfinddata_t data;      // data of current file

","  return _findclose(srchHandle) != -1;
}

unsigned long Directory::GetNumberOfFilesInDirectory(const kwsys_stl::string& name)
{
#if _MSC_VER < 1300
  long srchHandle;
#else
  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
    }
  struct _wfinddata_t data;      // data of current file

",153,153,"[15, 20]",[]
158c6d1cffe863fde284d4e5eeeb8129d40ce0e9,"KWSys 2014-08-04 (e787837a)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ e787837a | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 65b36ede..e787837a
Ben Boeckel (4):
      9927862c SystemTools: more string replacements
      b3d598b0 strings: remove unnecessary c_str calls
      ffe94132 SystemTools: use char instead of const char*
      f29fec7c Directory: accept strings in methods

Rashad M (1):
      e787837a SharedForward: Cast away const to call execvp on MinGW 64-bit

Change-Id: I96437b332971670cfcd953717c5563e9ba0f2b99",[],Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_321.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_321.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_602.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_602.cpp,"  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = strlen(name);
  if ( name[n - 1] == '/' || name[n - 1] == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( strchr(name, '\\') )
      {
      sprintf(buf, ""%s\\*"", name);
      }
    else
      {
      sprintf(buf, ""%s/*"", name);
      }
    }
  struct _wfinddata_t data;      // data of current file
","  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' || *name.rbegin() == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( name.find('\\') != name.npos )
      {
      sprintf(buf, ""%s\\*"", name.c_str());
      }
    else
      {
      sprintf(buf, ""%s/*"", name.c_str());
      }
    }
  struct _wfinddata_t data;      // data of current file
",112,112,"[7, 16, 20]",[]
158c6d1cffe863fde284d4e5eeeb8129d40ce0e9,"KWSys 2014-08-04 (e787837a)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ e787837a | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 65b36ede..e787837a
Ben Boeckel (4):
      9927862c SystemTools: more string replacements
      b3d598b0 strings: remove unnecessary c_str calls
      ffe94132 SystemTools: use char instead of const char*
      f29fec7c Directory: accept strings in methods

Rashad M (1):
      e787837a SharedForward: Cast away const to call execvp on MinGW 64-bit

Change-Id: I96437b332971670cfcd953717c5563e9ba0f2b99",[],Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_321.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_321.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_603.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_603.cpp,"  return _findclose(srchHandle) != -1;
}

unsigned long Directory::GetNumberOfFilesInDirectory(const char* name)
{
#if _MSC_VER < 1300
  long srchHandle;
#else
  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = strlen(name);
  if ( name[n - 1] == '/' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }
  else
    {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name);
    }
  struct _wfinddata_t data;      // data of current file

","  return _findclose(srchHandle) != -1;
}

unsigned long Directory::GetNumberOfFilesInDirectory(const kwsys_stl::string& name)
{
#if _MSC_VER < 1300
  long srchHandle;
#else
  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
    }
  struct _wfinddata_t data;      // data of current file

",153,153,"[15, 20]",[]
71c981a213a463d05b4bdc73dfb445c80ce2a476,"Encoding: Fix potential encoding issues with libarchive on Windows.

Because the 8bit string encoding in libarchive can be different than
the 8bit string encoding in CMake, change to call the wide version
of libarchive functions.  They are different if CMake is configured
to use UTF-8 as the internal encoding.

Create helper functions for some libarchive calls to use wstring
internally on platforms supporting it.",[],Source/cmSystemTools.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_322.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_322.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_604.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_604.cpp,"    }
  strftime(tmp, sizeof(tmp), fmt, localtime(&tim));
  fprintf(out, "" %s "", tmp);
  fprintf(out, ""%s"", archive_entry_pathname(entry));

  /* Extra information for links. */
  if (archive_entry_hardlink(entry)) /* Hard link */
","    }
  strftime(tmp, sizeof(tmp), fmt, localtime(&tim));
  fprintf(out, "" %s "", tmp);
  fprintf(out, ""%s"", cm_archive_entry_pathname(entry).c_str());

  /* Extra information for links. */
  if (archive_entry_hardlink(entry)) /* Hard link */
",1581,1606,"[2, 3]",[]
