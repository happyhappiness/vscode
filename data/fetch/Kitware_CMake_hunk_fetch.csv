sha,message,issue,file_name,old_file,new_file,old_hunk_file,new_hunk_file,old_hunk,new_hunk,old_hunk_loc,new_hunk_loc,old_log_loc,new_log_loc
47b3a57c9bc5c7db608bc3b59b139a902535255f,"Display subproject timing summary

Use the '--no-subproject-summary' option to disable timing summary.",[],Source/CTest/cmCTestTestHandler.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_0.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_0.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_1.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_1.cpp,"                 << static_cast<int>(percent + .5f) << ""% tests passed, ""
                 << failed.size() << "" tests failed out of "" << total
                 << std::endl);
    if (this->CTest->GetLabelSummary()) {
      this->PrintLabelSummary();
    }
    char realBuf[1024];
    sprintf(realBuf, ""%6.2f sec"", (double)(clock_finish - clock_start));
    cmCTestOptionalLog(this->CTest, HANDLER_OUTPUT,
","                 << static_cast<int>(percent + .5f) << ""% tests passed, ""
                 << failed.size() << "" tests failed out of "" << total
                 << std::endl);

    if (!this->CTest->GetLabelsForSubprojects().empty() &&
        this->CTest->GetSubprojectSummary()) {
      this->PrintSubprojectSummary();
    } else if (this->CTest->GetLabelSummary()) {
      this->PrintLabelSummary();
    }

    char realBuf[1024];
    sprintf(realBuf, ""%6.2f sec"", (double)(clock_finish - clock_start));
    cmCTestOptionalLog(this->CTest, HANDLER_OUTPUT,
",536,536,[7],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_1.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_1.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_2.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    char header[80];
    snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, header, 0);
    if(result)
      return result;

",475,473,[3],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_1.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_1.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_3.cpp,"      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
","      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(header, sizeof(header),
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
",492,491,[3],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_4.cpp,"      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      char *buf = data->state.buffer;
      if(6 == sscanf(buf+4, ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
","      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      if(6 == sscanf(&data->state.buffer[4], ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        char timebuf[24];
        time_t secs=time(NULL);

        snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(timebuf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
",2101,2100,[9],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_5.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_5.cpp,"          return result;

        /* format: ""Tue, 15 Nov 1994 12:45:26"" */
        snprintf(buf, BUFSIZE-1,
                 ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
                 Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
                 tm->tm_mday,
","          return result;

        /* format: ""Tue, 15 Nov 1994 12:45:26"" */
        snprintf(headerbuf, sizeof(headerbuf),
                 ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
                 Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
                 tm->tm_mday,
",2131,2131,[3],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_6.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_6.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      char clbuf[128];
      snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, clbuf, 0);
      if(result)
        return result;
    }
",2318,2318,[3],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_7.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_7.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,"[3, 16]",[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_8.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_8.cpp,"   */

  /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
  snprintf(buf, BUFSIZE-1,
           ""%s, %02d %s %4d %02d:%02d:%02d GMT"",
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
           tm->tm_mday,
           Curl_month[tm->tm_mon],
","   */

  /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
  snprintf(datestr, sizeof(datestr),
           ""%s: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
           condp,
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
           tm->tm_mday,
           Curl_month[tm->tm_mon],
",1712,1732,[3],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_9.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE + 2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[++len] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,"[5, 8]",[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_10.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE + 1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(READBUFFER_SIZE + 1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
",644,658,[5],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_11.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_11.cpp,"     * The application kindly asks for a differently sized receive buffer.
     * If it seems reasonable, we'll use it.
     */
    data->set.buffer_size = va_arg(param, long);

    if(data->set.buffer_size > MAX_BUFSIZE)
      data->set.buffer_size = MAX_BUFSIZE; /* huge internal default */
    else if(data->set.buffer_size < 1)
      data->set.buffer_size = BUFSIZE;

    /* Resize only if larger than default buffer size. */
    if(data->set.buffer_size > BUFSIZE) {
      data->state.buffer = realloc(data->state.buffer,
                                   data->set.buffer_size + 1);
      if(!data->state.buffer) {
        DEBUGF(fprintf(stderr, ""Error: realloc of buffer failed\n""));
        result = CURLE_OUT_OF_MEMORY;
      }
    }

    break;

","     * The application kindly asks for a differently sized receive buffer.
     * If it seems reasonable, we'll use it.
     */
    arg = va_arg(param, long);

    if(arg > READBUFFER_MAX)
      arg = READBUFFER_MAX;
    else if(arg < 1)
      arg = READBUFFER_SIZE;
    else if(arg < READBUFFER_MIN)
      arg = READBUFFER_MIN;

    /* Resize if new size */
    if(arg != data->set.buffer_size) {
      char *newbuff = realloc(data->state.buffer, arg + 1);
      if(!newbuff) {
        DEBUGF(fprintf(stderr, ""Error: realloc of buffer failed\n""));
        result = CURLE_OUT_OF_MEMORY;
      }
      else
        data->state.buffer = newbuff;
    }
    data->set.buffer_size = arg;

    break;

",2284,2304,[15],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_6.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_6.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_12.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_12.cpp,"  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
","  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 32 random hex chars, 32 bytes + 1 zero termination */
  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  if(result)
    return result;

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
",387,386,[9],[]
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/vtls/gtls.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_7.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_7.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_13.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_13.cpp,"  return 1;
}

static void showtime(struct Curl_easy *data,
                     const char *text,
                     time_t stamp)
{
  struct tm buffer;
  const struct tm *tm = &buffer;
  CURLcode result = Curl_gmtime(stamp, &buffer);
  if(result)
    return;

  snprintf(data->state.buffer,
           BUFSIZE,
           ""\t %s: %s, %02d %s %4d %02d:%02d:%02d GMT"",
           text,
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
","  return 1;
}

#ifndef CURL_DISABLE_VERBOSE_STRINGS
static void showtime(struct Curl_easy *data,
                     const char *text,
                     time_t stamp)
{
  struct tm buffer;
  const struct tm *tm = &buffer;
  char str[96];
  CURLcode result = Curl_gmtime(stamp, &buffer);
  if(result)
    return;

  snprintf(str,
           sizeof(str),
           ""\t %s: %s, %02d %s %4d %02d:%02d:%02d GMT"",
           text,
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
",211,211,[13],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_8.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_8.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_14.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_14.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    char header[80];
    snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, header, 0);
    if(result)
      return result;

",475,473,[3],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_8.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_8.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_15.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_15.cpp,"      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
","      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(header, sizeof(header),
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
",492,491,[3],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_16.cpp,"      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      char *buf = data->state.buffer;
      if(6 == sscanf(buf+4, ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
","      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      if(6 == sscanf(&data->state.buffer[4], ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        char timebuf[24];
        time_t secs=time(NULL);

        snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(timebuf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
",2101,2100,[9],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_17.cpp,"          return result;

        /* format: ""Tue, 15 Nov 1994 12:45:26"" */
        snprintf(buf, BUFSIZE-1,
                 ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
                 Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
                 tm->tm_mday,
","          return result;

        /* format: ""Tue, 15 Nov 1994 12:45:26"" */
        snprintf(headerbuf, sizeof(headerbuf),
                 ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
                 Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
                 tm->tm_mday,
",2131,2131,[3],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_18.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      char clbuf[128];
      snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, clbuf, 0);
      if(result)
        return result;
    }
",2318,2318,[3],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_19.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,"[3, 16]",[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_20.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_20.cpp,"   */

  /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
  snprintf(buf, BUFSIZE-1,
           ""%s, %02d %s %4d %02d:%02d:%02d GMT"",
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
           tm->tm_mday,
           Curl_month[tm->tm_mon],
","   */

  /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
  snprintf(datestr, sizeof(datestr),
           ""%s: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
           condp,
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
           tm->tm_mday,
           Curl_month[tm->tm_mon],
",1712,1732,[3],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_11.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_11.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_21.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_21.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE + 2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[++len] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,"[5, 8]",[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_12.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_12.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_22.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_22.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE + 1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(READBUFFER_SIZE + 1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
",644,658,[5],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_12.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_12.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_23.cpp,"     * The application kindly asks for a differently sized receive buffer.
     * If it seems reasonable, we'll use it.
     */
    data->set.buffer_size = va_arg(param, long);

    if(data->set.buffer_size > MAX_BUFSIZE)
      data->set.buffer_size = MAX_BUFSIZE; /* huge internal default */
    else if(data->set.buffer_size < 1)
      data->set.buffer_size = BUFSIZE;

    /* Resize only if larger than default buffer size. */
    if(data->set.buffer_size > BUFSIZE) {
      data->state.buffer = realloc(data->state.buffer,
                                   data->set.buffer_size + 1);
      if(!data->state.buffer) {
        DEBUGF(fprintf(stderr, ""Error: realloc of buffer failed\n""));
        result = CURLE_OUT_OF_MEMORY;
      }
    }

    break;

","     * The application kindly asks for a differently sized receive buffer.
     * If it seems reasonable, we'll use it.
     */
    arg = va_arg(param, long);

    if(arg > READBUFFER_MAX)
      arg = READBUFFER_MAX;
    else if(arg < 1)
      arg = READBUFFER_SIZE;
    else if(arg < READBUFFER_MIN)
      arg = READBUFFER_MIN;

    /* Resize if new size */
    if(arg != data->set.buffer_size) {
      char *newbuff = realloc(data->state.buffer, arg + 1);
      if(!newbuff) {
        DEBUGF(fprintf(stderr, ""Error: realloc of buffer failed\n""));
        result = CURLE_OUT_OF_MEMORY;
      }
      else
        data->state.buffer = newbuff;
    }
    data->set.buffer_size = arg;

    break;

",2284,2304,[15],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_13.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_13.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_24.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_24.cpp,"  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
","  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 32 random hex chars, 32 bytes + 1 zero termination */
  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  if(result)
    return result;

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
",387,386,[9],[]
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/vtls/gtls.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_14.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_14.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_25.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_25.cpp,"  return 1;
}

static void showtime(struct Curl_easy *data,
                     const char *text,
                     time_t stamp)
{
  struct tm buffer;
  const struct tm *tm = &buffer;
  CURLcode result = Curl_gmtime(stamp, &buffer);
  if(result)
    return;

  snprintf(data->state.buffer,
           BUFSIZE,
           ""\t %s: %s, %02d %s %4d %02d:%02d:%02d GMT"",
           text,
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
","  return 1;
}

#ifndef CURL_DISABLE_VERBOSE_STRINGS
static void showtime(struct Curl_easy *data,
                     const char *text,
                     time_t stamp)
{
  struct tm buffer;
  const struct tm *tm = &buffer;
  char str[96];
  CURLcode result = Curl_gmtime(stamp, &buffer);
  if(result)
    return;

  snprintf(str,
           sizeof(str),
           ""\t %s: %s, %02d %s %4d %02d:%02d:%02d GMT"",
           text,
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
",211,211,[13],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_15.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_15.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_26.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_26.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    char header[80];
    snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, header, 0);
    if(result)
      return result;

",475,473,[3],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_15.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_15.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_27.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_27.cpp,"      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
","      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(header, sizeof(header),
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
",492,491,[3],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_28.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_28.cpp,"      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      char *buf = data->state.buffer;
      if(6 == sscanf(buf+4, ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
","      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      if(6 == sscanf(&data->state.buffer[4], ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        char timebuf[24];
        time_t secs=time(NULL);

        snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(timebuf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
",2101,2100,[9],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_29.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_29.cpp,"          return result;

        /* format: ""Tue, 15 Nov 1994 12:45:26"" */
        snprintf(buf, BUFSIZE-1,
                 ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
                 Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
                 tm->tm_mday,
","          return result;

        /* format: ""Tue, 15 Nov 1994 12:45:26"" */
        snprintf(headerbuf, sizeof(headerbuf),
                 ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
                 Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
                 tm->tm_mday,
",2131,2131,[3],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_30.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_30.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      char clbuf[128];
      snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, clbuf, 0);
      if(result)
        return result;
    }
",2318,2318,[3],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_31.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,"[3, 16]",[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_32.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_32.cpp,"   */

  /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
  snprintf(buf, BUFSIZE-1,
           ""%s, %02d %s %4d %02d:%02d:%02d GMT"",
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
           tm->tm_mday,
           Curl_month[tm->tm_mon],
","   */

  /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
  snprintf(datestr, sizeof(datestr),
           ""%s: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
           condp,
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
           tm->tm_mday,
           Curl_month[tm->tm_mon],
",1712,1732,[3],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_33.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_33.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE + 2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[++len] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,"[5, 8]",[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_34.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_34.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE + 1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(READBUFFER_SIZE + 1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
",644,658,[5],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_35.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_35.cpp,"     * The application kindly asks for a differently sized receive buffer.
     * If it seems reasonable, we'll use it.
     */
    data->set.buffer_size = va_arg(param, long);

    if(data->set.buffer_size > MAX_BUFSIZE)
      data->set.buffer_size = MAX_BUFSIZE; /* huge internal default */
    else if(data->set.buffer_size < 1)
      data->set.buffer_size = BUFSIZE;

    /* Resize only if larger than default buffer size. */
    if(data->set.buffer_size > BUFSIZE) {
      data->state.buffer = realloc(data->state.buffer,
                                   data->set.buffer_size + 1);
      if(!data->state.buffer) {
        DEBUGF(fprintf(stderr, ""Error: realloc of buffer failed\n""));
        result = CURLE_OUT_OF_MEMORY;
      }
    }

    break;

","     * The application kindly asks for a differently sized receive buffer.
     * If it seems reasonable, we'll use it.
     */
    arg = va_arg(param, long);

    if(arg > READBUFFER_MAX)
      arg = READBUFFER_MAX;
    else if(arg < 1)
      arg = READBUFFER_SIZE;
    else if(arg < READBUFFER_MIN)
      arg = READBUFFER_MIN;

    /* Resize if new size */
    if(arg != data->set.buffer_size) {
      char *newbuff = realloc(data->state.buffer, arg + 1);
      if(!newbuff) {
        DEBUGF(fprintf(stderr, ""Error: realloc of buffer failed\n""));
        result = CURLE_OUT_OF_MEMORY;
      }
      else
        data->state.buffer = newbuff;
    }
    data->set.buffer_size = arg;

    break;

",2284,2304,[15],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_20.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_20.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_36.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_36.cpp,"  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
","  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 32 random hex chars, 32 bytes + 1 zero termination */
  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  if(result)
    return result;

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
",387,386,[9],[]
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/vtls/gtls.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_21.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_21.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_37.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_37.cpp,"  return 1;
}

static void showtime(struct Curl_easy *data,
                     const char *text,
                     time_t stamp)
{
  struct tm buffer;
  const struct tm *tm = &buffer;
  CURLcode result = Curl_gmtime(stamp, &buffer);
  if(result)
    return;

  snprintf(data->state.buffer,
           BUFSIZE,
           ""\t %s: %s, %02d %s %4d %02d:%02d:%02d GMT"",
           text,
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
","  return 1;
}

#ifndef CURL_DISABLE_VERBOSE_STRINGS
static void showtime(struct Curl_easy *data,
                     const char *text,
                     time_t stamp)
{
  struct tm buffer;
  const struct tm *tm = &buffer;
  char str[96];
  CURLcode result = Curl_gmtime(stamp, &buffer);
  if(result)
    return;

  snprintf(str,
           sizeof(str),
           ""\t %s: %s, %02d %s %4d %02d:%02d:%02d GMT"",
           text,
           Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
",211,211,[13],[]
d6051ca39e2ac8e5afc8f6308fd1bda7d1e8c17b,"execute_process: Add option to get results of every child

Add a `RESULTS_VARIABLE` option to get the results of all children
in a pipeline of one or more `COMMAND`s.",[],Source/cmExecuteProcessCommand.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_22.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_22.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_38.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_38.cpp,"    switch (cmsysProcess_GetState(cp)) {
      case cmsysProcess_State_Exited: {
        int v = cmsysProcess_GetExitValue(cp);
        char buf[100];
        sprintf(buf, ""%d"", v);
        this->Makefile->AddDefinition(result_variable, buf);
      } break;
","    switch (cmsysProcess_GetState(cp)) {
      case cmsysProcess_State_Exited: {
        int v = cmsysProcess_GetExitValue(cp);
        char buf[16];
        sprintf(buf, ""%d"", v);
        this->Makefile->AddDefinition(result_variable, buf);
      } break;
",287,297,[4],[]
16ebd9f6152fedd1804f13c91ed14e8963e53d3f,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2017-05-16 (fe1f22ce)",[],Source/kwsys/ProcessUNIX.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_23.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_23.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_39.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_39.cpp,"#endif
#endif
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/*--------------------------------------------------------------------------*/
/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
","#endif
#endif
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
",2243,2273,[4],[]
16ebd9f6152fedd1804f13c91ed14e8963e53d3f,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2017-05-16 (fe1f22ce)",[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_24.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_24.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_40.cpp,"
    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);
      break;
  }
}
","
    case STATUS_NO_MEMORY:
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);
      break;
  }
}
",2120,2142,[4],[]
16ebd9f6152fedd1804f13c91ed14e8963e53d3f,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2017-05-16 (fe1f22ce)",[],Source/kwsys/Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_25.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_25.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_41.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_41.cpp,"                                         FILE* stream, int color);
#endif

/*--------------------------------------------------------------------------*/
void kwsysTerminal_cfprintf(int color, FILE* stream, const char* format, ...)
{
  /* Setup the stream with the given color if possible.  */
","                                         FILE* stream, int color);
#endif

void kwsysTerminal_cfprintf(int color, FILE* stream, const char* format, ...)
{
  /* Setup the stream with the given color if possible.  */
",47,44,[4],[]
7be70ca6cc888df532d2f1560e74d13642730ee5,"KWSys 2017-05-16 (fe1f22ce)

Code extracted from:

    https://gitlab.kitware.com/utils/kwsys.git

at commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).

Upstream Shortlog
-----------------

Adam Weisi (3):
      8a799e36 Process: Improve definition ordering in header file
      7d56ef24 Process: Save results from all children internally
      b7eba998 Process: Add APIs to get results of individual processes

Ben Boeckel (2):
      cea71543 style: remove separator comments
      874dc559 style: help clang-format near macros",[],ProcessUNIX.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_26.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_26.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_42.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_42.cpp,"#endif
#endif
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/*--------------------------------------------------------------------------*/
/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
","#endif
#endif
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
",2243,2273,[4],[]
7be70ca6cc888df532d2f1560e74d13642730ee5,"KWSys 2017-05-16 (fe1f22ce)

Code extracted from:

    https://gitlab.kitware.com/utils/kwsys.git

at commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).

Upstream Shortlog
-----------------

Adam Weisi (3):
      8a799e36 Process: Improve definition ordering in header file
      7d56ef24 Process: Save results from all children internally
      b7eba998 Process: Add APIs to get results of individual processes

Ben Boeckel (2):
      cea71543 style: remove separator comments
      874dc559 style: help clang-format near macros",[],ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_27.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_27.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_43.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_43.cpp,"
    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);
      break;
  }
}
","
    case STATUS_NO_MEMORY:
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);
      break;
  }
}
",2120,2142,[4],[]
7be70ca6cc888df532d2f1560e74d13642730ee5,"KWSys 2017-05-16 (fe1f22ce)

Code extracted from:

    https://gitlab.kitware.com/utils/kwsys.git

at commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).

Upstream Shortlog
-----------------

Adam Weisi (3):
      8a799e36 Process: Improve definition ordering in header file
      7d56ef24 Process: Save results from all children internally
      b7eba998 Process: Add APIs to get results of individual processes

Ben Boeckel (2):
      cea71543 style: remove separator comments
      874dc559 style: help clang-format near macros",[],Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_28.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_28.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_44.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_44.cpp,"                                         FILE* stream, int color);
#endif

/*--------------------------------------------------------------------------*/
void kwsysTerminal_cfprintf(int color, FILE* stream, const char* format, ...)
{
  /* Setup the stream with the given color if possible.  */
","                                         FILE* stream, int color);
#endif

void kwsysTerminal_cfprintf(int color, FILE* stream, const char* format, ...)
{
  /* Setup the stream with the given color if possible.  */
",47,44,[4],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/conncache.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_29.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_29.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_45.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_45.cpp,"  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}

/* Look up the bundle with all the connections to the same host this
","  else
    hostname = conn->host.name;

  DEBUGASSERT(len > 32);

  /* put the number first so that the hostname gets cut off if too long */
  snprintf(buf, len, ""%ld%s"", conn->port, hostname);
}

/* Look up the bundle with all the connections to the same host this
",141,136,[3],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_30.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_30.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_46.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_46.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
",476,475,[3],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_47.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_47.cpp,"        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
","        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
",2107,2107,[3],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_48.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
",2318,2318,[3],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_49.cpp,"  case CURLWC_DOWNLOADING: {
    /* filelist has at least one file, lets get first one */
    struct ftp_conn *ftpc = &conn->proto.ftpc;
    struct curl_fileinfo *finfo = wildcard->filelist->head->ptr;

    char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename);
    if(!tmp_path)
","  case CURLWC_DOWNLOADING: {
    /* filelist has at least one file, lets get first one */
    struct ftp_conn *ftpc = &conn->proto.ftpc;
    struct curl_fileinfo *finfo = wildcard->filelist.head->ptr;

    char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename);
    if(!tmp_path)
",3916,3912,[5],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_32.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_32.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_50.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_50.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
","    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
",297,297,[3],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_33.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_33.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_51.cpp,"    info.buffer[info.len] = 0; /* we terminate this with a zero byte */
    return info.buffer;
  }
  else
    return strdup("""");
}

char *curl_mvaprintf(const char *format, va_list ap_save)
","    info.buffer[info.len] = 0; /* we terminate this with a zero byte */
    return info.buffer;
  }
  return strdup("""");
}

char *curl_mvaprintf(const char *format, va_list ap_save)
",1092,1092,[7],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_34.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_34.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_52.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_52.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.headerbuff = malloc(HEADERSIZE);
  if(!data->state.headerbuff) {
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE + 1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }

  data->state.headerbuff = malloc(HEADERSIZE);
  if(!data->state.headerbuff) {
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
",641,644,[5],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/vtls/axtls.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_35.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_35.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_53.cpp,"  return snprintf(buffer, size, ""axTLS/%s"", ssl_version());
}

int Curl_axtls_random(struct Curl_easy *data,
                      unsigned char *entropy,
                      size_t length)
{
  static bool ssl_seeded = FALSE;
  (void)data;
","  return snprintf(buffer, size, ""axTLS/%s"", ssl_version());
}

CURLcode Curl_axtls_random(struct Curl_easy *data,
                           unsigned char *entropy,
                           size_t length)
{
  static bool ssl_seeded = FALSE;
  (void)data;
",680,686,[0],[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/vtls/cyassl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_36.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_36.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_54.cpp,"
size_t Curl_cyassl_version(char *buffer, size_t size)
{
#ifdef WOLFSSL_VERSION
  return snprintf(buffer, size, ""wolfSSL/%s"", WOLFSSL_VERSION);
#elif defined(CYASSL_VERSION)
  return snprintf(buffer, size, ""CyaSSL/%s"", CYASSL_VERSION);
","
size_t Curl_cyassl_version(char *buffer, size_t size)
{
#if LIBCYASSL_VERSION_HEX >= 0x03006000
  return snprintf(buffer, size, ""wolfSSL/%s"", wolfSSL_lib_version());
#elif defined(WOLFSSL_VERSION)
  return snprintf(buffer, size, ""wolfSSL/%s"", WOLFSSL_VERSION);
#elif defined(CYASSL_VERSION)
  return snprintf(buffer, size, ""CyaSSL/%s"", CYASSL_VERSION);
",720,741,"[4, 6]",[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_37.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_37.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_55.cpp,"        {
          const BIGNUM *n;
          const BIGNUM *e;
          const BIGNUM *d;
          const BIGNUM *p;
          const BIGNUM *q;
          const BIGNUM *dmp1;
          const BIGNUM *dmq1;
          const BIGNUM *iqmp;

          RSA_get0_key(rsa, &n, &e, &d);
          RSA_get0_factors(rsa, &p, &q);
          RSA_get0_crt_params(rsa, &dmp1, &dmq1, &iqmp);
          BN_print(mem, n);
          push_certinfo(""RSA Public Key"", i);
          print_pubkey_BN(rsa, n, i);
          print_pubkey_BN(rsa, e, i);
          print_pubkey_BN(rsa, d, i);
          print_pubkey_BN(rsa, p, i);
          print_pubkey_BN(rsa, q, i);
          print_pubkey_BN(rsa, dmp1, i);
          print_pubkey_BN(rsa, dmq1, i);
          print_pubkey_BN(rsa, iqmp, i);
        }
#else
        BIO_printf(mem, ""%d"", BN_num_bits(rsa->n));
        push_certinfo(""RSA Public Key"", i);
        print_pubkey_BN(rsa, n, i);
        print_pubkey_BN(rsa, e, i);
        print_pubkey_BN(rsa, d, i);
        print_pubkey_BN(rsa, p, i);
        print_pubkey_BN(rsa, q, i);
        print_pubkey_BN(rsa, dmp1, i);
        print_pubkey_BN(rsa, dmq1, i);
        print_pubkey_BN(rsa, iqmp, i);
#endif

        break;
      }
      case EVP_PKEY_DSA:
      {
        DSA *dsa;
#ifdef HAVE_OPAQUE_EVP_PKEY
        dsa = EVP_PKEY_get0_DSA(pubkey);
","        {
          const BIGNUM *n;
          const BIGNUM *e;

          RSA_get0_key(rsa, &n, &e, NULL);
          BN_print(mem, n);
          push_certinfo(""RSA Public Key"", i);
          print_pubkey_BN(rsa, n, i);
          print_pubkey_BN(rsa, e, i);
        }
#else
        BIO_printf(mem, ""%d"", BN_num_bits(rsa->n));
        push_certinfo(""RSA Public Key"", i);
        print_pubkey_BN(rsa, n, i);
        print_pubkey_BN(rsa, e, i);
#endif

        break;
      }
      case EVP_PKEY_DSA:
      {
#ifndef OPENSSL_NO_DSA
        DSA *dsa;
#ifdef HAVE_OPAQUE_EVP_PKEY
        dsa = EVP_PKEY_get0_DSA(pubkey);
",2554,2628,[25],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/conncache.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_38.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_38.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_56.cpp,"  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}

/* Look up the bundle with all the connections to the same host this
","  else
    hostname = conn->host.name;

  DEBUGASSERT(len > 32);

  /* put the number first so that the hostname gets cut off if too long */
  snprintf(buf, len, ""%ld%s"", conn->port, hostname);
}

/* Look up the bundle with all the connections to the same host this
",141,136,[3],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_39.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_39.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_57.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_57.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
",476,475,[3],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_58.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_58.cpp,"        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
","        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
",2107,2107,[3],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_59.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
",2318,2318,[3],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_60.cpp,"  case CURLWC_DOWNLOADING: {
    /* filelist has at least one file, lets get first one */
    struct ftp_conn *ftpc = &conn->proto.ftpc;
    struct curl_fileinfo *finfo = wildcard->filelist->head->ptr;

    char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename);
    if(!tmp_path)
","  case CURLWC_DOWNLOADING: {
    /* filelist has at least one file, lets get first one */
    struct ftp_conn *ftpc = &conn->proto.ftpc;
    struct curl_fileinfo *finfo = wildcard->filelist.head->ptr;

    char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename);
    if(!tmp_path)
",3915,3911,[5],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_41.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_41.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_61.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_61.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
","    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
",297,297,[3],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_42.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_42.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_62.cpp,"    info.buffer[info.len] = 0; /* we terminate this with a zero byte */
    return info.buffer;
  }
  else
    return strdup("""");
}

char *curl_mvaprintf(const char *format, va_list ap_save)
","    info.buffer[info.len] = 0; /* we terminate this with a zero byte */
    return info.buffer;
  }
  return strdup("""");
}

char *curl_mvaprintf(const char *format, va_list ap_save)
",1096,1096,[7],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_43.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_43.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_63.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_63.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.headerbuff = malloc(HEADERSIZE);
  if(!data->state.headerbuff) {
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE + 1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }

  data->state.headerbuff = malloc(HEADERSIZE);
  if(!data->state.headerbuff) {
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
",641,644,[5],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/vtls/axtls.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_44.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_44.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_64.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_64.cpp,"  return snprintf(buffer, size, ""axTLS/%s"", ssl_version());
}

int Curl_axtls_random(struct Curl_easy *data,
                      unsigned char *entropy,
                      size_t length)
{
  static bool ssl_seeded = FALSE;
  (void)data;
","  return snprintf(buffer, size, ""axTLS/%s"", ssl_version());
}

CURLcode Curl_axtls_random(struct Curl_easy *data,
                           unsigned char *entropy,
                           size_t length)
{
  static bool ssl_seeded = FALSE;
  (void)data;
",680,686,[0],[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/vtls/cyassl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_45.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_45.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_65.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_65.cpp,"
size_t Curl_cyassl_version(char *buffer, size_t size)
{
#ifdef WOLFSSL_VERSION
  return snprintf(buffer, size, ""wolfSSL/%s"", WOLFSSL_VERSION);
#elif defined(CYASSL_VERSION)
  return snprintf(buffer, size, ""CyaSSL/%s"", CYASSL_VERSION);
","
size_t Curl_cyassl_version(char *buffer, size_t size)
{
#if LIBCYASSL_VERSION_HEX >= 0x03006000
  return snprintf(buffer, size, ""wolfSSL/%s"", wolfSSL_lib_version());
#elif defined(WOLFSSL_VERSION)
  return snprintf(buffer, size, ""wolfSSL/%s"", WOLFSSL_VERSION);
#elif defined(CYASSL_VERSION)
  return snprintf(buffer, size, ""CyaSSL/%s"", CYASSL_VERSION);
",720,741,"[4, 6]",[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_46.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_46.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_66.cpp,"        {
          const BIGNUM *n;
          const BIGNUM *e;
          const BIGNUM *d;
          const BIGNUM *p;
          const BIGNUM *q;
          const BIGNUM *dmp1;
          const BIGNUM *dmq1;
          const BIGNUM *iqmp;

          RSA_get0_key(rsa, &n, &e, &d);
          RSA_get0_factors(rsa, &p, &q);
          RSA_get0_crt_params(rsa, &dmp1, &dmq1, &iqmp);
          BN_print(mem, n);
          push_certinfo(""RSA Public Key"", i);
          print_pubkey_BN(rsa, n, i);
          print_pubkey_BN(rsa, e, i);
          print_pubkey_BN(rsa, d, i);
          print_pubkey_BN(rsa, p, i);
          print_pubkey_BN(rsa, q, i);
          print_pubkey_BN(rsa, dmp1, i);
          print_pubkey_BN(rsa, dmq1, i);
          print_pubkey_BN(rsa, iqmp, i);
        }
#else
        BIO_printf(mem, ""%d"", BN_num_bits(rsa->n));
        push_certinfo(""RSA Public Key"", i);
        print_pubkey_BN(rsa, n, i);
        print_pubkey_BN(rsa, e, i);
        print_pubkey_BN(rsa, d, i);
        print_pubkey_BN(rsa, p, i);
        print_pubkey_BN(rsa, q, i);
        print_pubkey_BN(rsa, dmp1, i);
        print_pubkey_BN(rsa, dmq1, i);
        print_pubkey_BN(rsa, iqmp, i);
#endif

        break;
      }
      case EVP_PKEY_DSA:
      {
        DSA *dsa;
#ifdef HAVE_OPAQUE_EVP_PKEY
        dsa = EVP_PKEY_get0_DSA(pubkey);
","        {
          const BIGNUM *n;
          const BIGNUM *e;

          RSA_get0_key(rsa, &n, &e, NULL);
          BN_print(mem, n);
          push_certinfo(""RSA Public Key"", i);
          print_pubkey_BN(rsa, n, i);
          print_pubkey_BN(rsa, e, i);
        }
#else
        BIO_printf(mem, ""%d"", BN_num_bits(rsa->n));
        push_certinfo(""RSA Public Key"", i);
        print_pubkey_BN(rsa, n, i);
        print_pubkey_BN(rsa, e, i);
#endif

        break;
      }
      case EVP_PKEY_DSA:
      {
#ifndef OPENSSL_NO_DSA
        DSA *dsa;
#ifdef HAVE_OPAQUE_EVP_PKEY
        dsa = EVP_PKEY_get0_DSA(pubkey);
",2554,2628,[25],[]
48fa291469e5e8b3ae88fb846750df72468eb58a,"bindexplib: add ARM support

Fixes: #16728",[u'https://gitlab.kitware.com/cmake/cmake/issues/16728'],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_47.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_47.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_67.cpp,"    fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
    return false;
  }
  /* Does it look like a i386 COFF OBJ file??? */
  else if (((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64)) &&
           (dosHeader->e_sp == 0)) {
    /*
    * The two tests above aren't what they look like.  They're
","    fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
    return false;
  }
  /* Does it look like a COFF OBJ file??? */
  else if (((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_ARMNT)) &&
           (dosHeader->e_sp == 0)) {
    /*
    * The two tests above aren't what they look like.  They're
",323,326,[0],[]
7a8860afbc614f2215e083adadb25963fe8f4dfe,bindexplib: clang-format,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_68.cpp,"   *      Dumps a COFF symbol table from an OBJ.
   *----------------------------------------------------------------------
   */
  void DumpExternalsObjects() {
    unsigned i;
    PSTR stringTable;
    std::string symbol;
    DWORD SectChar;
    /*
     * The string table apparently starts right after the symbol table
     */
    stringTable = (PSTR)&this->SymbolTable[this->SymbolCount];
    SymbolTableType* pSymbolTable = this->SymbolTable;
    for ( i=0; i < this->SymbolCount; i++ ) {
      if (pSymbolTable->SectionNumber > 0 &&
          ( pSymbolTable->Type == 0x20 || pSymbolTable->Type == 0x0)) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            /*
            *    The name of the Function entry points
            */
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)pSymbolTable->N.ShortName, 8);
            } else {
               symbol = stringTable + pSymbolTable->N.Name.Long;
            }

            // clear out any leading spaces
            while (isspace(symbol[0])) symbol.erase(0,1);
            // if it starts with _ and has an @ then it is a __cdecl
            // so remove the @ stuff for the export
            if(symbol[0] == '_') {
               std::string::size_type posAt = symbol.find('@');
               if (posAt != std::string::npos) {
                  symbol.erase(posAt);
               }
            }
            // For 64 bit builds we don't need to remove _
            if(!this->Is64Bit)
              {
              if (symbol[0] == '_')
                {
                symbol.erase(0,1);
                }
              }
            /*
            Check whether it is ""Scalar deleting destructor"" and
            ""Vector deleting destructor""
            */
            const char *scalarPrefix = ""??_G"";
            const char *vectorPrefix = ""??_E"";
            // original code had a check for
            // symbol.find(""real@"") == std::string::npos)
            // but if this disallows memmber functions with the name real
            // if scalarPrefix and vectorPrefix are not found then print
            // the symbol
            if (symbol.compare(0, 4, scalarPrefix) &&
                symbol.compare(0, 4, vectorPrefix) )
            {
               SectChar =
                 this->
                 SectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  this->DataSymbols.insert(symbol);
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ) ||
                       (SectChar & IMAGE_SCN_MEM_EXECUTE)) {
                     this->Symbols.insert(symbol);
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
               }
            }
         }
      }
      else if (pSymbolTable->SectionNumber == IMAGE_SYM_UNDEFINED &&
               !pSymbolTable->Type && 0) {
         /*
         *    The IMPORT global variable entry points
         */
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            symbol = stringTable + pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            this->DataSymbols.insert(symbol);
         }
      }

      /*
","   *      Dumps a COFF symbol table from an OBJ.
   *----------------------------------------------------------------------
   */
  void DumpExternalsObjects()
  {
    unsigned i;
    PSTR stringTable;
    std::string symbol;
    DWORD SectChar;
    /*
     * The string table apparently starts right after the symbol table
     */
    stringTable = (PSTR) & this->SymbolTable[this->SymbolCount];
    SymbolTableType* pSymbolTable = this->SymbolTable;
    for (i = 0; i < this->SymbolCount; i++) {
      if (pSymbolTable->SectionNumber > 0 &&
          (pSymbolTable->Type == 0x20 || pSymbolTable->Type == 0x0)) {
        if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
          /*
          *    The name of the Function entry points
          */
          if (pSymbolTable->N.Name.Short != 0) {
            symbol = """";
            symbol.insert(0, (const char*)pSymbolTable->N.ShortName, 8);
          } else {
            symbol = stringTable + pSymbolTable->N.Name.Long;
          }

          // clear out any leading spaces
          while (isspace(symbol[0]))
            symbol.erase(0, 1);
          // if it starts with _ and has an @ then it is a __cdecl
          // so remove the @ stuff for the export
          if (symbol[0] == '_') {
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) {
              symbol.erase(posAt);
            }
          }
          // For 64 bit builds we don't need to remove _
          if (!this->Is64Bit) {
            if (symbol[0] == '_') {
              symbol.erase(0, 1);
            }
          }
          /*
          Check whether it is ""Scalar deleting destructor"" and
          ""Vector deleting destructor""
          */
          const char* scalarPrefix = ""??_G"";
          const char* vectorPrefix = ""??_E"";
          // original code had a check for
          // symbol.find(""real@"") == std::string::npos)
          // but if this disallows memmber functions with the name real
          // if scalarPrefix and vectorPrefix are not found then print
          // the symbol
          if (symbol.compare(0, 4, scalarPrefix) &&
              symbol.compare(0, 4, vectorPrefix)) {
            SectChar = this->SectionHeaders[pSymbolTable->SectionNumber - 1]
                         .Characteristics;
            if (!pSymbolTable->Type && (SectChar & IMAGE_SCN_MEM_WRITE)) {
              // Read only (i.e. constants) must be excluded
              this->DataSymbols.insert(symbol);
            } else {
              if (pSymbolTable->Type || !(SectChar & IMAGE_SCN_MEM_READ) ||
                  (SectChar & IMAGE_SCN_MEM_EXECUTE)) {
                this->Symbols.insert(symbol);
              } else {
                // printf("" strange symbol: %s \n"",symbol.c_str());
              }
            }
          }
        }
      } else if (pSymbolTable->SectionNumber == IMAGE_SYM_UNDEFINED &&
                 !pSymbolTable->Type && 0) {
        /*
        *    The IMPORT global variable entry points
        */
        if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
          symbol = stringTable + pSymbolTable->N.Name.Long;
          while (isspace(symbol[0]))
            symbol.erase(0, 1);
          if (symbol[0] == '_')
            symbol.erase(0, 1);
          this->DataSymbols.insert(symbol);
        }
      }

      /*
",244,249,[71],[]
7a8860afbc614f2215e083adadb25963fe8f4dfe,bindexplib: clang-format,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_69.cpp,"      pSymbolTable++;
    }
  }
private:
  std::set<std::string>& Symbols;
  std::set<std::string>& DataSymbols;
  DWORD_PTR SymbolCount;
  PIMAGE_SECTION_HEADER SectionHeaders;
  ObjectHeaderType* ObjectImageHeader;
  SymbolTableType*  SymbolTable;
  bool Is64Bit;
};

bool
DumpFile(const char* filename,
         std::set<std::string>& symbols,
         std::set<std::string>& dataSymbols)
{
   HANDLE hFile;
   HANDLE hFileMapping;
   LPVOID lpFileBase;
   PIMAGE_DOS_HEADER dosHeader;

   hFile = CreateFileW(cmsys::Encoding::ToWide(filename).c_str(),
                       GENERIC_READ, FILE_SHARE_READ, NULL,
      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
      return false;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return false;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return false;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return false;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
           ((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64))
           && (dosHeader->e_sp == 0)
           ) {
      /*
      * The two tests above aren't what they look like.  They're
      * really checking for IMAGE_FILE_HEADER.Machine == i386 (0x14C)
      * and IMAGE_FILE_HEADER.SizeOfOptionalHeader == 0;
      */
      DumpSymbols<IMAGE_FILE_HEADER, IMAGE_SYMBOL>
        symbolDumper((PIMAGE_FILE_HEADER) lpFileBase, symbols, dataSymbols,
                     (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64));
      symbolDumper.DumpObjFile();
   } else {
      // check for /bigobj format
      cmANON_OBJECT_HEADER_BIGOBJ* h =
        (cmANON_OBJECT_HEADER_BIGOBJ*) lpFileBase;
      if(h->Sig1 == 0x0 && h->Sig2 == 0xffff) {
         DumpSymbols<cmANON_OBJECT_HEADER_BIGOBJ, cmIMAGE_SYMBOL_EX>
           symbolDumper((cmANON_OBJECT_HEADER_BIGOBJ*) lpFileBase, symbols,
                        dataSymbols,
                        (h->Machine == IMAGE_FILE_MACHINE_AMD64));
         symbolDumper.DumpObjFile();
      } else {
         printf(""unrecognized file format in '%s'\n"", filename);
         return false;
      }
   }
   UnmapViewOfFile(lpFileBase);
   CloseHandle(hFileMapping);
   CloseHandle(hFile);
   return true;
}

bool bindexplib::AddObjectFile(const char* filename)
","      pSymbolTable++;
    }
  }

private:
  std::set<std::string>& Symbols;
  std::set<std::string>& DataSymbols;
  DWORD_PTR SymbolCount;
  PIMAGE_SECTION_HEADER SectionHeaders;
  ObjectHeaderType* ObjectImageHeader;
  SymbolTableType* SymbolTable;
  bool Is64Bit;
};

bool DumpFile(const char* filename, std::set<std::string>& symbols,
              std::set<std::string>& dataSymbols)
{
  HANDLE hFile;
  HANDLE hFileMapping;
  LPVOID lpFileBase;
  PIMAGE_DOS_HEADER dosHeader;

  hFile = CreateFileW(cmsys::Encoding::ToWide(filename).c_str(), GENERIC_READ,
                      FILE_SHARE_READ, NULL, OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL, 0);

  if (hFile == INVALID_HANDLE_VALUE) {
    fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
    return false;
  }

  hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
  if (hFileMapping == 0) {
    CloseHandle(hFile);
    fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
    return false;
  }

  lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
  if (lpFileBase == 0) {
    CloseHandle(hFileMapping);
    CloseHandle(hFile);
    fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
    return false;
  }

  dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
  if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
    fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
    return false;
  }
  /* Does it look like a i386 COFF OBJ file??? */
  else if (((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64)) &&
           (dosHeader->e_sp == 0)) {
    /*
    * The two tests above aren't what they look like.  They're
    * really checking for IMAGE_FILE_HEADER.Machine == i386 (0x14C)
    * and IMAGE_FILE_HEADER.SizeOfOptionalHeader == 0;
    */
    DumpSymbols<IMAGE_FILE_HEADER, IMAGE_SYMBOL> symbolDumper(
      (PIMAGE_FILE_HEADER)lpFileBase, symbols, dataSymbols,
      (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64));
    symbolDumper.DumpObjFile();
  } else {
    // check for /bigobj format
    cmANON_OBJECT_HEADER_BIGOBJ* h = (cmANON_OBJECT_HEADER_BIGOBJ*)lpFileBase;
    if (h->Sig1 == 0x0 && h->Sig2 == 0xffff) {
      DumpSymbols<cmANON_OBJECT_HEADER_BIGOBJ, cmIMAGE_SYMBOL_EX> symbolDumper(
        (cmANON_OBJECT_HEADER_BIGOBJ*)lpFileBase, symbols, dataSymbols,
        (h->Machine == IMAGE_FILE_MACHINE_AMD64));
      symbolDumper.DumpObjFile();
    } else {
      printf(""unrecognized file format in '%s'\n"", filename);
      return false;
    }
  }
  UnmapViewOfFile(lpFileBase);
  CloseHandle(hFileMapping);
  CloseHandle(hFile);
  return true;
}

bool bindexplib::AddObjectFile(const char* filename)
",339,342,"[28, 35, 43, 49, 78]",[]
62d0e22325d36e5f9d61ccfbef0d68cfe1935f1b,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-25 (d6b1bb9f)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_70.cpp,"int
archive_read_disk_set_atime_restored(struct archive *_a)
{
#ifndef HAVE_UTIMES
	static int warning_done = 0;
#endif
	struct archive_read_disk *a = (struct archive_read_disk *)_a;
	archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
	a->restore_time = 1;
	if (a->tree != NULL)
		a->tree->flags |= needsRestoreTimes;
	return (ARCHIVE_OK);
#else
	if (warning_done)
		/* Warning was already emitted; suppress further warnings. */
		return (ARCHIVE_OK);

	archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"");
	warning_done = 1;
	return (ARCHIVE_WARN);
#endif
}
","int
archive_read_disk_set_atime_restored(struct archive *_a)
{
	struct archive_read_disk *a = (struct archive_read_disk *)_a;
	archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
	a->flags |= ARCHIVE_READDISK_RESTORE_ATIME;
	if (a->tree != NULL)
		a->tree->flags |= needsRestoreTimes;
	return (ARCHIVE_OK);
#else
	/* Display warning and unset flag */
	archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"");
	a->flags &= ~ARCHIVE_READDISK_RESTORE_ATIME;
	return (ARCHIVE_WARN);
#endif
}
",563,562,[19],[]
62d0e22325d36e5f9d61ccfbef0d68cfe1935f1b,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-25 (d6b1bb9f)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_71.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_71.cpp,"	struct archive_read_disk *a = (struct archive_read_disk *)_a;

	if (a->tree != NULL)
		a->tree = tree_reopen(a->tree, pathname, a->restore_time);
	else
		a->tree = tree_open(pathname, a->symlink_mode,
		    a->restore_time);
	if (a->tree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"");
","	struct archive_read_disk *a = (struct archive_read_disk *)_a;

	if (a->tree != NULL)
		a->tree = tree_reopen(a->tree, pathname,
		    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
	else
		a->tree = tree_open(pathname, a->symlink_mode,
		    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
	if (a->tree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"");
",1340,1329,[8],[]
62d0e22325d36e5f9d61ccfbef0d68cfe1935f1b,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-25 (d6b1bb9f)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_50.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_50.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_72.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_72.cpp,"	struct archive_read_disk *a = (struct archive_read_disk *)_a;

	if (a->tree != NULL)
		a->tree = tree_reopen(a->tree, pathname, a->restore_time);
	else
		a->tree = tree_open(pathname, a->symlink_mode, a->restore_time);
	if (a->tree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"");
","	struct archive_read_disk *a = (struct archive_read_disk *)_a;

	if (a->tree != NULL)
		a->tree = tree_reopen(a->tree, pathname,
		    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
	else
		a->tree = tree_open(pathname, a->symlink_mode,
		    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
	if (a->tree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"");
",1219,1207,[7],[]
059aa805c9c0cb34c92eb69abf66febc40ab62db,"LibArchive 2017-02-25 (d6b1bb9f)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit d6b1bb9f7ea7bc153b7356e8e345c9e48005821a (v3.3.1).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_73.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_73.cpp,"int
archive_read_disk_set_atime_restored(struct archive *_a)
{
#ifndef HAVE_UTIMES
	static int warning_done = 0;
#endif
	struct archive_read_disk *a = (struct archive_read_disk *)_a;
	archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
	a->restore_time = 1;
	if (a->tree != NULL)
		a->tree->flags |= needsRestoreTimes;
	return (ARCHIVE_OK);
#else
	if (warning_done)
		/* Warning was already emitted; suppress further warnings. */
		return (ARCHIVE_OK);

	archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"");
	warning_done = 1;
	return (ARCHIVE_WARN);
#endif
}
","int
archive_read_disk_set_atime_restored(struct archive *_a)
{
	struct archive_read_disk *a = (struct archive_read_disk *)_a;
	archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
	a->flags |= ARCHIVE_READDISK_RESTORE_ATIME;
	if (a->tree != NULL)
		a->tree->flags |= needsRestoreTimes;
	return (ARCHIVE_OK);
#else
	/* Display warning and unset flag */
	archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"");
	a->flags &= ~ARCHIVE_READDISK_RESTORE_ATIME;
	return (ARCHIVE_WARN);
#endif
}
",563,562,[19],[]
059aa805c9c0cb34c92eb69abf66febc40ab62db,"LibArchive 2017-02-25 (d6b1bb9f)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit d6b1bb9f7ea7bc153b7356e8e345c9e48005821a (v3.3.1).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_74.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_74.cpp,"	struct archive_read_disk *a = (struct archive_read_disk *)_a;

	if (a->tree != NULL)
		a->tree = tree_reopen(a->tree, pathname, a->restore_time);
	else
		a->tree = tree_open(pathname, a->symlink_mode,
		    a->restore_time);
	if (a->tree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"");
","	struct archive_read_disk *a = (struct archive_read_disk *)_a;

	if (a->tree != NULL)
		a->tree = tree_reopen(a->tree, pathname,
		    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
	else
		a->tree = tree_open(pathname, a->symlink_mode,
		    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
	if (a->tree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"");
",1340,1329,[8],[]
059aa805c9c0cb34c92eb69abf66febc40ab62db,"LibArchive 2017-02-25 (d6b1bb9f)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit d6b1bb9f7ea7bc153b7356e8e345c9e48005821a (v3.3.1).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_52.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_52.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_75.cpp,"	struct archive_read_disk *a = (struct archive_read_disk *)_a;

	if (a->tree != NULL)
		a->tree = tree_reopen(a->tree, pathname, a->restore_time);
	else
		a->tree = tree_open(pathname, a->symlink_mode, a->restore_time);
	if (a->tree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"");
","	struct archive_read_disk *a = (struct archive_read_disk *)_a;

	if (a->tree != NULL)
		a->tree = tree_reopen(a->tree, pathname,
		    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
	else
		a->tree = tree_open(pathname, a->symlink_mode,
		    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
	if (a->tree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"");
",1219,1207,[7],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_76.cpp,"	name = archive_entry_sourcepath(entry);
	if (name == NULL)
		name = archive_entry_pathname(entry);
	if (name == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"");
		return (ARCHIVE_WARN);
	}

	if (a->tree != NULL) {
		if (a->tree_enter_working_dir(a->tree) != 0) {
			archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");
				return (ARCHIVE_FAILED);
		}
	}

	/* Short-circuit if there's nothing to do. */
	have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
	if (have_attrs == -1) {
","	name = archive_entry_sourcepath(entry);
	if (name == NULL)
		name = archive_entry_pathname(entry);
	else if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {
		archive_set_error(&a->archive, errno,
			    ""Can't change dir to read extended attributes"");
			return (ARCHIVE_FAILED);
	}
	if (name == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"");
		return (ARCHIVE_WARN);
	}

	/* Short-circuit if there's nothing to do. */
	have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
	if (have_attrs == -1) {
",302,321,"[4, 11]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_77.cpp,"	const char *path;
	ssize_t list_size;

	path = archive_entry_sourcepath(entry);
	if (path == NULL)
		path = archive_entry_pathname(entry);

	if (*fd < 0 && a->tree != NULL) {
		if (a->follow_symlinks ||
		    archive_entry_filetype(entry) != AE_IFLNK)
			*fd = a->open_on_current_dir(a->tree, path,
				O_RDONLY | O_NONBLOCK);
		if (*fd < 0) {
			if (a->tree_enter_working_dir(a->tree) != 0) {
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}
		}
	}

","	const char *path;
	ssize_t list_size;

	path = NULL;

	if (*fd < 0) {
		path = archive_entry_sourcepath(entry);
		if (path == NULL || (a->tree != NULL &&
		    a->tree_enter_working_dir(a->tree) != 0))
			path = archive_entry_pathname(entry);
		if (path == NULL) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");
			return (ARCHIVE_WARN);
		}
		if (a->tree != NULL && (a->follow_symlinks ||
		    archive_entry_filetype(entry) != AE_IFLNK)) {
			*fd = a->open_on_current_dir(a->tree,
			    path, O_RDONLY | O_NONBLOCK);
		}
	}

",772,1486,[14],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_78.cpp,"	const char *path;
	int namespace = EXTATTR_NAMESPACE_USER;

	path = archive_entry_sourcepath(entry);
	if (path == NULL)
		path = archive_entry_pathname(entry);

	if (*fd < 0 && a->tree != NULL) {
		if (a->follow_symlinks ||
		    archive_entry_filetype(entry) != AE_IFLNK)
			*fd = a->open_on_current_dir(a->tree, path,
				O_RDONLY | O_NONBLOCK);
		if (*fd < 0) {
			if (a->tree_enter_working_dir(a->tree) != 0) {
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}
		}
	}

","	const char *path;
	int namespace = EXTATTR_NAMESPACE_USER;

	path = NULL;

	if (*fd < 0) {
		path = archive_entry_sourcepath(entry);
		if (path == NULL || (a->tree != NULL &&
		    a->tree_enter_working_dir(a->tree) != 0))
			path = archive_entry_pathname(entry);
		if (path == NULL) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");
			return (ARCHIVE_WARN);
		}
		if (a->tree != NULL && (a->follow_symlinks ||
		    archive_entry_filetype(entry) != AE_IFLNK)) {
			*fd = a->open_on_current_dir(a->tree,
			    path, O_RDONLY | O_NONBLOCK);
		}
	}

",932,1645,[14],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_79.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_79.cpp,"		if (path == NULL)
			path = archive_entry_pathname(entry);
			
		if (pathconf(path, _PC_MIN_HOLE_SIZE) <= 0)
			return (ARCHIVE_OK);
		*fd = open(path, O_RDONLY | O_NONBLOCK | O_CLOEXEC);
		if (*fd < 0) {
			archive_set_error(&a->archive, errno,
","		if (path == NULL)
			path = archive_entry_pathname(entry);
			
#ifdef _PC_MIN_HOLE_SIZE
		if (pathconf(path, _PC_MIN_HOLE_SIZE) <= 0)
			return (ARCHIVE_OK);
#endif
		*fd = open(path, O_RDONLY | O_NONBLOCK | O_CLOEXEC);
		if (*fd < 0) {
			archive_set_error(&a->archive, errno,
",1180,1907,[7],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_80.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_80.cpp,"		r = archive_match_path_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_path_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",938,938,[2],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_81.cpp,"		r = archive_match_time_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_time_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",1041,1041,[2],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_82.cpp,"		r = archive_match_owner_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_owner_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",1067,1067,[2],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_83.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_83.cpp,"		archive_set_error(&a->archive, errno, ""statvfs failed"");
		return (ARCHIVE_FAILED);
	} else if (xr == 1) {
		/* Usuall come here unless NetBSD supports _PC_REC_XFER_ALIGN
		 * for pathconf() function. */
		t->current_filesystem->xfer_align = sfs.f_frsize;
		t->current_filesystem->max_xfer_size = -1;
","		archive_set_error(&a->archive, errno, ""statvfs failed"");
		return (ARCHIVE_FAILED);
	} else if (xr == 1) {
		/* Usually come here unless NetBSD supports _PC_REC_XFER_ALIGN
		 * for pathconf() function. */
		t->current_filesystem->xfer_align = sfs.f_frsize;
		t->current_filesystem->max_xfer_size = -1;
",1643,1656,[0],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_84.cpp,"		r = archive_match_path_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_path_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",803,802,[2],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_85.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_85.cpp,"		r = archive_match_time_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_time_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",875,874,[2],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_86.cpp,"		r = archive_match_owner_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_owner_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",901,900,[2],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_87.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_87.cpp,"#else
		archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"");
		return (ARCHIVE_FATAL);
#endif
	}
	if (fstat(fd, &st) != 0) {
","#else
		archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"");
		goto fail;
#endif
	}
	if (fstat(fd, &st) != 0) {
",277,277,[1],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_88.cpp,"		else
			archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename);
		return (ARCHIVE_FATAL);
	}

	/*
","		else
			archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename);
		goto fail;
	}

	/*
",287,287,[1],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_89.cpp,"		mine->block_size = new_block_size;
	}
	buffer = malloc(mine->block_size);
	if (mine == NULL || buffer == NULL) {
		archive_set_error(a, ENOMEM, ""No memory"");
		free(mine);
		free(buffer);
		return (ARCHIVE_FATAL);
	}
	mine->buffer = buffer;
	mine->fd = fd;
","		mine->block_size = new_block_size;
	}
	buffer = malloc(mine->block_size);
	if (buffer == NULL) {
		archive_set_error(a, ENOMEM, ""No memory"");
		goto fail;
	}
	mine->buffer = buffer;
	mine->fd = fd;
",356,356,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_lz4.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_57.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_57.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_90.cpp,"#endif
	}

	/* Check if an error happend in decompression process. */
	if (uncompressed_size < 0) {
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC, ""lz4 decompression failed"");
","#endif
	}

	/* Check if an error occurred in the decompression process. */
	if (uncompressed_size < 0) {
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC, ""lz4 decompression failed"");
",595,595,[5],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_58.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_58.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_91.cpp,"	    &state->child_stdout);
	if (child == -1) {
		free(state->out_buf);
		free(state);
		archive_set_error(&self->archive->archive, EINVAL,
		    ""Can't initialize filter; unable to run program \""%s\"""",
","	    &state->child_stdout);
	if (child == -1) {
		free(state->out_buf);
		archive_string_free(&state->description);
		free(state);
		archive_set_error(&self->archive->archive, EINVAL,
		    ""Can't initialize filter; unable to run program \""%s\"""",
",430,430,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_92.cpp,"	bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
	return (ARCHIVE_OK);
#elif HAVE_LZMADEC_H && HAVE_LIBLZMADEC
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"");
","	bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"");
",178,163,[6],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
	struct private_data *state;
	size_t decompressed;
	ssize_t avail_in, ret;

	state = (struct private_data *)self->data;

	/* Empty our output buffer. */
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Try to fill the output buffer. */
	while (state->stream.avail_out > 0 && !state->eof) {
		state->stream.next_in = (unsigned char *)(uintptr_t)
		    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
		if (state->stream.next_in == NULL && avail_in < 0) {
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}
		state->stream.avail_in = avail_in;

		/* Decompress as much as we can in one pass. */
		ret = lzmadec_decode(&(state->stream), avail_in == 0);
		switch (ret) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}
	}

	decompressed = state->stream.next_out - state->out_block;
	state->total_out += decompressed;
	if (decompressed == 0)
		*p = NULL;
	else
		*p = state->out_block;
	return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
	struct private_data *state;
	int ret;

	state = (struct private_data *)self->data;
	ret = ARCHIVE_OK;
	switch (lzmadec_end(&(state->stream))) {
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}

	free(state->out_block);
	free(state);
	return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,"[27, 58, 64, 70, 103, 121, 127, 158]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_94.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_94.cpp,"	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_ar"");

	ar = (struct ar *)malloc(sizeof(*ar));
	if (ar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"");
		return (ARCHIVE_FATAL);
	}
	memset(ar, 0, sizeof(*ar));
	ar->strtab = NULL;

	r = __archive_read_register_format(a,
","	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_ar"");

	ar = (struct ar *)calloc(1, sizeof(*ar));
	if (ar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"");
		return (ARCHIVE_FATAL);
	}
	ar->strtab = NULL;

	r = __archive_read_register_format(a,
",104,104,[5],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_95.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_95.cpp,"		archive_entry_set_filetype(entry, AE_IFREG);
		/* Get the size of the filename table. */
		number = ar_atol10(h + AR_size_offset, AR_size_size);
		if (number > SIZE_MAX) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"");
			return (ARCHIVE_FATAL);
","		archive_entry_set_filetype(entry, AE_IFREG);
		/* Get the size of the filename table. */
		number = ar_atol10(h + AR_size_offset, AR_size_size);
		if (number > SIZE_MAX || number > 1024 * 1024 * 1024) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"");
			return (ARCHIVE_FATAL);
",260,259,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_96.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_96.cpp,"		 * If we can't look up the real name, warn and return
		 * the entry with the wrong name.
		 */
		if (ar->strtab == NULL || number > ar->strtab_size) {
			archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for GNU/SVR4 archive entry"");
			archive_entry_copy_pathname(entry, filename);
","		 * If we can't look up the real name, warn and return
		 * the entry with the wrong name.
		 */
		if (ar->strtab == NULL || number >= ar->strtab_size) {
			archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for GNU/SVR4 archive entry"");
			archive_entry_copy_pathname(entry, filename);
",316,315,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_cpio.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_61.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_61.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_97.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_97.cpp,"			    ""Rejecting malformed cpio archive: symlink contents exceed 1 megabyte"");
			return (ARCHIVE_FATAL);
		}
		h = __archive_read_ahead(a,
			(size_t)cpio->entry_bytes_remaining, NULL);
		if (h == NULL)
			return (ARCHIVE_FATAL);
		if (archive_entry_copy_symlink_l(entry, (const char *)h,
		    (size_t)cpio->entry_bytes_remaining, sconv) != 0) {
			if (errno == ENOMEM) {
				archive_set_error(&a->archive, ENOMEM,
","			    ""Rejecting malformed cpio archive: symlink contents exceed 1 megabyte"");
			return (ARCHIVE_FATAL);
		}
		hl = __archive_read_ahead(a,
			(size_t)cpio->entry_bytes_remaining, NULL);
		if (hl == NULL)
			return (ARCHIVE_FATAL);
		if (archive_entry_copy_symlink_l(entry, (const char *)hl,
		    (size_t)cpio->entry_bytes_remaining, sconv) != 0) {
			if (errno == ENOMEM) {
				archive_set_error(&a->archive, ENOMEM,
",406,406,[10],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_98.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_98.cpp,"		if ((file->utf16be_name = malloc(name_len)) == NULL) {
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"");
			return (NULL);
		}
		memcpy(file->utf16be_name, p, name_len);
		file->utf16be_bytes = name_len;
","		if ((file->utf16be_name = malloc(name_len)) == NULL) {
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"");
			goto fail;
		}
		memcpy(file->utf16be_name, p, name_len);
		file->utf16be_bytes = name_len;
",1864,1864,[1],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_99.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_99.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				return (NULL);
			}
			/*
			 * Sanity check: file does not have ""CL"" extension.
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				goto fail;
			}
			/*
			 * Sanity check: file does not have ""CL"" extension.
",1990,1988,[0],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_100.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_100.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"");
				return (NULL);
			}
			/*
			 * Sanity check: The file type must be a directory.
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"");
				goto fail;
			}
			/*
			 * Sanity check: The file type must be a directory.
",1999,1997,[0],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_101.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_101.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				return (NULL);
			}
		} else if (parent != NULL && parent->rr_moved)
			file->rr_moved_has_re_only = 0;
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				goto fail;
			}
		} else if (parent != NULL && parent->rr_moved)
			file->rr_moved_has_re_only = 0;
",2008,2006,[0],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_102.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_102.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}
			/*
			 * Sanity check: The file type must be a regular file.
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				goto fail;
			}
			/*
			 * Sanity check: The file type must be a regular file.
",2022,2020,[0],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_103.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_103.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}
			parent->subdirs++;
			/* Overwrite an offset and a number of this ""CL"" entry
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				goto fail;
			}
			parent->subdirs++;
			/* Overwrite an offset and a number of this ""CL"" entry
",2031,2029,[0],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_104.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_104.cpp,"					archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"");
					return (NULL);
				}
			}
			if (file->cl_offset == file->offset ||
			    parent->rr_moved) {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}
		}
	}
","					archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"");
					goto fail;
				}
			}
			if (file->cl_offset == file->offset ||
			    parent->rr_moved) {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				goto fail;
			}
		}
	}
",2049,2047,"[0, 8]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_63.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_63.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_105.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_105.cpp,"	/* Get a real compressed file size. */
	lha->compsize -= extdsize - 2;

	if (sum_calculated != headersum) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"");
","	/* Get a real compressed file size. */
	lha->compsize -= extdsize - 2;

	if (lha->compsize < 0)
		goto invalid;	/* Invalid compressed file size */

	if (sum_calculated != headersum) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"");
",924,924,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_64.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_64.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_106.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_106.cpp,"	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_mtree"");

	mtree = (struct mtree *)malloc(sizeof(*mtree));
	if (mtree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"");
		return (ARCHIVE_FATAL);
	}
	memset(mtree, 0, sizeof(*mtree));
	mtree->fd = -1;

	r = __archive_read_register_format(a, mtree, ""mtree"",
","	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_mtree"");

	mtree = (struct mtree *)calloc(1, sizeof(*mtree));
	if (mtree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"");
		return (ARCHIVE_FATAL);
	}
	mtree->fd = -1;

	r = __archive_read_register_format(a, mtree, ""mtree"",
",223,229,[5],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_64.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_64.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_107.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_107.cpp,"    struct mtree_option **global, const char *line, ssize_t line_len,
    struct mtree_entry **last_entry, int is_form_d)
{
	struct mtree_entry *entry;
	struct mtree_option *iter;
	const char *next, *eq, *name, *end;
	size_t name_len, len;
	int r, i;

	if ((entry = malloc(sizeof(*entry))) == NULL) {
		archive_set_error(&a->archive, errno, ""Can't allocate memory"");
","    struct mtree_option **global, const char *line, ssize_t line_len,
    struct mtree_entry **last_entry, int is_form_d)
{
	struct mtree_entry *entry, *ht_iter;
	struct mtree_option *iter;
	const char *next, *eq, *name, *end;
	size_t name_len, len;
	int r, i;
	unsigned int ht_idx;

	if ((entry = malloc(sizeof(*entry))) == NULL) {
		archive_set_error(&a->archive, errno, ""Can't allocate memory"");
",853,867,[10],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_65.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_65.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_108.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_108.cpp,"  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,
                      ""archive_read_support_format_rar"");

  rar = (struct rar *)malloc(sizeof(*rar));
  if (rar == NULL)
  {
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }
  memset(rar, 0, sizeof(*rar));

	/*
	 * Until enough data has been read, we cannot tell about
","  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,
                      ""archive_read_support_format_rar"");

  rar = (struct rar *)calloc(sizeof(*rar), 1);
  if (rar == NULL)
  {
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }

	/*
	 * Until enough data has been read, we cannot tell about
",647,647,[6],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_109.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_109.cpp,"				tar->sparse_gnu_pending = 0;
				/* Read initial sparse map. */
				bytes_read = gnu_sparse_10_read(a, tar, unconsumed);
				tar->entry_bytes_remaining -= bytes_read;
				if (bytes_read < 0)
					return ((int)bytes_read);
			} else {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
","				tar->sparse_gnu_pending = 0;
				/* Read initial sparse map. */
				bytes_read = gnu_sparse_10_read(a, tar, unconsumed);
				if (bytes_read < 0)
					return ((int)bytes_read);
				tar->entry_bytes_remaining -= bytes_read;
			} else {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
",793,847,[7],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_110.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_110.cpp,"	switch ((int)type & ~0777777) {
	case 01000000:
		/* POSIX.1e ACL */
		break;
	case 03000000:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");
		return (ARCHIVE_WARN);
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Malformed Solaris ACL attribute (unsupported type %o)"",
","	switch ((int)type & ~0777777) {
	case 01000000:
		/* POSIX.1e ACL */
		acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;
		break;
	case 03000000:
		/* NFSv4 ACL */
		acl_type = ARCHIVE_ENTRY_ACL_TYPE_NFS4;
		break;
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Malformed Solaris ACL attribute (unsupported type %o)"",
",935,989,"[5, 9]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_111.cpp,"			return (ARCHIVE_FATAL);
	}
	archive_strncpy(&(tar->localname), acl, p - acl);
	err = archive_acl_parse_l(archive_entry_acl(entry),
	    tar->localname.s, ARCHIVE_ENTRY_ACL_TYPE_ACCESS, tar->sconv_acl);
	if (err != ARCHIVE_OK) {
		if (errno == ENOMEM) {
			archive_set_error(&a->archive, ENOMEM,
","			return (ARCHIVE_FATAL);
	}
	archive_strncpy(&(tar->localname), acl, p - acl);
	err = archive_acl_from_text_l(archive_entry_acl(entry),
	    tar->localname.s, acl_type, tar->sconv_acl);
	if (err != ARCHIVE_OK) {
		if (errno == ENOMEM) {
			archive_set_error(&a->archive, ENOMEM,
",968,1023,[7],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_112.cpp,"	if (tar->entry_bytes_remaining < 0) {
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");
		err = ARCHIVE_WARN;
	}
	tar->realsize = tar->entry_bytes_remaining;
	archive_entry_set_size(entry, tar->entry_bytes_remaining);
","	if (tar->entry_bytes_remaining < 0) {
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size"");
		return (ARCHIVE_FATAL);
	}
	if (tar->entry_bytes_remaining == INT64_MAX) {
		/* Note: tar_atol returns INT64_MAX on overflow */
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry size overflow"");
		return (ARCHIVE_FATAL);
	}
	tar->realsize = tar->entry_bytes_remaining;
	archive_entry_set_size(entry, tar->entry_bytes_remaining);
",1128,1183,[2],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_113.cpp,"	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
","	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,"[17, 22, 41, 46]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_114.cpp,"{
	struct sparse_block *p;

	p = (struct sparse_block *)malloc(sizeof(*p));
	if (p == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}
	memset(p, 0, sizeof(*p));
	if (tar->sparse_last != NULL)
		tar->sparse_last->next = p;
	else
","{
	struct sparse_block *p;

	p = (struct sparse_block *)calloc(1, sizeof(*p));
	if (p == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}
	if (tar->sparse_last != NULL)
		tar->sparse_last->next = p;
	else
",2116,2227,[5],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_115.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_115.cpp,"	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_warc"");

	if ((w = malloc(sizeof(*w))) == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"");
		return (ARCHIVE_FATAL);
	}
	memset(w, 0, sizeof(*w));

	r = __archive_read_register_format(
		a, w, ""warc"",
","	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_warc"");

	if ((w = calloc(1, sizeof(*w))) == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"");
		return (ARCHIVE_FATAL);
	}

	r = __archive_read_register_format(
		a, w, ""warc"",
",146,146,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_116.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_116.cpp,"			&a->archive, ARCHIVE_ERRNO_MISC,
			""Bad record header"");
		return (ARCHIVE_FATAL);
	} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {
		/* nawww, I wish they promised backward compatibility
		 * anyhoo, in their infinite wisdom the 28500 guys might
		 * come up with something we can't possibly handle so
		 * best end things here */
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");
		return (ARCHIVE_FATAL);
	} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {
		/* nightmare!  the specs say content-length is mandatory
		 * so I don't feel overly bad stopping the reader here */
		archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"");
		return (ARCHIVE_FATAL);
	} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {
		/* record time is mandatory as per WARC/1.0,
		 * so just barf here, fast and loud */
		archive_set_error(
","			&a->archive, ARCHIVE_ERRNO_MISC,
			""Bad record header"");
		return (ARCHIVE_FATAL);
	}
	ver = _warc_rdver(buf, eoh - buf);
	/* we currently support WARC 0.12 to 1.0 */
	if (ver == 0U) {
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Invalid record version"");
		return (ARCHIVE_FATAL);
	} else if (ver < 1200U || ver > 10000U) {
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version: %u.%u"",
			ver / 10000, (ver % 10000) / 100);
		return (ARCHIVE_FATAL);
	}
	cntlen = _warc_rdlen(buf, eoh - buf);
	if (cntlen < 0) {
		/* nightmare!  the specs say content-length is mandatory
		 * so I don't feel overly bad stopping the reader here */
		archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"");
		return (ARCHIVE_FATAL);
	}
	rtime = _warc_rdrtm(buf, eoh - buf);
	if (rtime == (time_t)-1) {
		/* record time is mandatory as per WARC/1.0,
		 * so just barf here, fast and loud */
		archive_set_error(
",255,254,"[8, 15, 22]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_117.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_117.cpp,"	if (ver != w->pver) {
		/* stringify this entry's version */
		archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);
		/* remember the version */
		w->pver = ver;
	}
","	if (ver != w->pver) {
		/* stringify this entry's version */
		archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100);
		/* remember the version */
		w->pver = ver;
	}
",285,293,[2],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_118.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_118.cpp,"		xar->lzstream.total_in = 0;
		xar->lzstream.total_out = 0;
		break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
	case LZMA:
		if (xar->lzstream_valid)
			lzmadec_end(&(xar->lzstream));
		r = lzmadec_init(&(xar->lzstream));
		if (r != LZMADEC_OK) {
			switch (r) {
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}
			return (ARCHIVE_FATAL);
		}
		xar->lzstream_valid = 1;
		xar->lzstream.total_in = 0;
		xar->lzstream.total_out = 0;
		break;
#endif
	/*
	 * Unsupported compression.
","		xar->lzstream.total_in = 0;
		xar->lzstream.total_out = 0;
		break;
#endif
	/*
	 * Unsupported compression.
",1526,1524,"[11, 18]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_119.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_119.cpp,"		*used = avail_in - xar->lzstream.avail_in;
		*outbytes = avail_out - xar->lzstream.avail_out;
		break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
	case LZMA:
		xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
		xar->lzstream.avail_in = avail_in;
		xar->lzstream.next_out = (unsigned char *)outbuff;
		xar->lzstream.avail_out = avail_out;
		r = lzmadec_decode(&(xar->lzstream), 0);
		switch (r) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			switch (lzmadec_end(&(xar->lzstream))) {
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}
			xar->lzstream_valid = 0;
			/* FALLTHROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			break;
		default:
			archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);
			return (ARCHIVE_FATAL);
		}
		*used = avail_in - xar->lzstream.avail_in;
		*outbytes = avail_out - xar->lzstream.avail_out;
		break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
	case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
	case LZMA:
#endif
	case XZ:
#endif
	case NONE:
","		*used = avail_in - xar->lzstream.avail_in;
		*outbytes = avail_out - xar->lzstream.avail_out;
		break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
	case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
	case LZMA:
	case XZ:
#endif
	case NONE:
",1685,1653,"[16, 26]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_120.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_120.cpp," *	id1+size1+data1 + id2+size2+data2 ...
 *  triplets.  id and size are 2 bytes each.
 */
static void
process_extra(const char *p, size_t extra_length, struct zip_entry* zip_entry)
{
	unsigned offset = 0;

	while (offset < extra_length - 4) {
		unsigned short headerid = archive_le16dec(p + offset);
		unsigned short datasize = archive_le16dec(p + offset + 2);

		offset += 4;
		if (offset + datasize > extra_length) {
			break;
		}
#ifdef DEBUG
		fprintf(stderr, ""Header id 0x%04x, length %d\n"",
"," *	id1+size1+data1 + id2+size2+data2 ...
 *  triplets.  id and size are 2 bytes each.
 */
static int
process_extra(struct archive_read *a, const char *p, size_t extra_length, struct zip_entry* zip_entry)
{
	unsigned offset = 0;

	if (extra_length == 0) {
		return ARCHIVE_OK;
	}

	if (extra_length < 4) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Too-small extra data: Need at least 4 bytes, but only found %d bytes"", (int)extra_length);
		return ARCHIVE_FAILED;
	}
	while (offset <= extra_length - 4) {
		unsigned short headerid = archive_le16dec(p + offset);
		unsigned short datasize = archive_le16dec(p + offset + 2);

		offset += 4;
		if (offset + datasize > extra_length) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Extra data overflow: Need %d bytes but only found %d bytes"",
			    (int)datasize, (int)(extra_length - offset));
			return ARCHIVE_FAILED;
		}
#ifdef DEBUG
		fprintf(stderr, ""Header id 0x%04x, length %d\n"",
",418,418,[17],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_121.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_121.cpp,"		}
		offset += datasize;
	}
#ifdef DEBUG
	if (offset != extra_length)
	{
		fprintf(stderr,
		    ""Extra data field contents do not match reported size!\n"");
	}
#endif
}

/*
","		}
		offset += datasize;
	}
	if (offset != extra_length) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Malformed extra data: Consumed %d bytes of %d bytes"",
		    (int)offset, (int)extra_length);
		return ARCHIVE_FAILED;
	}
	return ARCHIVE_OK;
}

/*
",715,739,[6],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_122.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_122.cpp,"	    && bytes_avail > zip->entry_bytes_remaining) {
		bytes_avail = (ssize_t)zip->entry_bytes_remaining;
	}
	if (bytes_avail <= 0) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file body"");
		return (ARCHIVE_FATAL);
","	    && bytes_avail > zip->entry_bytes_remaining) {
		bytes_avail = (ssize_t)zip->entry_bytes_remaining;
	}
	if (bytes_avail < 0) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file body"");
		return (ARCHIVE_FATAL);
",1293,1332,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_123.cpp,"	case 0x6720:/* Blowfish */
	case 0x6721:/* Twofish */
	case 0x6801:/* RC4 */
		/* Suuported encryption algorithm. */
		break;
	default:
		archive_set_error(&a->archive,
","	case 0x6720:/* Blowfish */
	case 0x6721:/* Twofish */
	case 0x6801:/* RC4 */
		/* Supported encryption algorithm. */
		break;
	default:
		archive_set_error(&a->archive,
",1500,1548,[6],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_124.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_124.cpp,"	__archive_read_consume(a, 4);

	/*return (ARCHIVE_OK);
	 * This is not fully implemnted yet.*/
	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
	    ""Encrypted file is unsupported"");
	return (ARCHIVE_FAILED);
","	__archive_read_consume(a, 4);

	/*return (ARCHIVE_OK);
	 * This is not fully implemented yet.*/
	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
	    ""Encrypted file is unsupported"");
	return (ARCHIVE_FAILED);
",1609,1657,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_125.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_125.cpp,"	if (a->restore_pwd >= 0) {
		r = fchdir(a->restore_pwd);
		if (r != 0) {
			archive_set_error(&a->archive, errno, ""chdir() failure"");
			ret = ARCHIVE_FATAL;
		}
		close(a->restore_pwd);
","	if (a->restore_pwd >= 0) {
		r = fchdir(a->restore_pwd);
		if (r != 0) {
			archive_set_error(&a->archive, errno,
			    ""chdir() failure"");
			ret = ARCHIVE_FATAL;
		}
		close(a->restore_pwd);
",637,669,[3],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_126.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_126.cpp,"		bytes_to_write = size;
		/* Seek if necessary to the specified offset. */
		if (a->offset < a->fd_offset) {
			/* Can't support backword move. */
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Seek failed"");
			return (ARCHIVE_FATAL);
","		bytes_to_write = size;
		/* Seek if necessary to the specified offset. */
		if (a->offset < a->fd_offset) {
			/* Can't support backward move. */
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Seek failed"");
			return (ARCHIVE_FATAL);
",1402,1437,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_127.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_127.cpp,"		return (r);
	if ((size_t)r < size) {
		archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);
		return (ARCHIVE_WARN);
	}
#if ARCHIVE_VERSION_NUMBER < 3999000
","		return (r);
	if ((size_t)r < size) {
		archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"",
		    (uintmax_t)a->filesize);
		return (ARCHIVE_WARN);
	}
#if ARCHIVE_VERSION_NUMBER < 3999000
",1468,1503,[2],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_128.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_128.cpp,"
	if (en) {
		/* Everything failed; give up here. */
		archive_set_error(&a->archive, en, ""Can't create '%s'"",
		    a->name);
		return (ARCHIVE_FAILED);
	}

","
	if (en) {
		/* Everything failed; give up here. */
		if ((&a->archive)->error == NULL)
			archive_set_error(&a->archive, en, ""Can't create '%s'"",
			    a->name);
		return (ARCHIVE_FAILED);
	}

",1993,2043,[3],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_129.cpp,"	return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)a; /* UNUSED */
	return (ARCHIVE_OK);
#else
	char *pn;
	char c;
	int r;
	struct stat st;

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 */
	/* Whatever we checked last time doesn't need to be re-checked. */
	pn = a->name;
	if (archive_strlen(&(a->path_safe)) > 0) {
		char *p = a->path_safe.s;
		while ((*pn != '\0') && (*p == *pn))
			++p, ++pn;
	}
	/* Skip the root directory if the path is absolute. */
	if(pn == a->name && pn[0] == '/')
		++pn;
	c = pn[0];
	/* Keep going until we've checked the entire name. */
	while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}
	pn[0] = c;
	/* We've checked and/or cleaned the whole path, so remember it. */
	archive_strcpy(&a->path_safe, a->name);
	return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","	return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
	if (a_eno)
		*a_eno = err;
	if (a_estr)
		archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)path; /* UNUSED */
	(void)error_number; /* UNUSED */
	(void)error_string; /* UNUSED */
	(void)flags; /* UNUSED */
	return (ARCHIVE_OK);
#else
	int res = ARCHIVE_OK;
	char *tail;
	char *head;
	int last;
	char c;
	int r;
	struct stat st;
	int restore_pwd;

	/* Nothing to do here if name is empty */
	if(path[0] == '\0')
	    return (ARCHIVE_OK);

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 *
	 * Walk the filename in chunks separated by '/'.  For each segment:
	 *  - if it doesn't exist, continue
	 *  - if it's symlink, abort or remove it
	 *  - if it's a directory and it's not the last chunk, cd into it
	 * As we go:
	 *  head points to the current (relative) path
	 *  tail points to the temporary \0 terminating the segment we're
	 *      currently examining
	 *  c holds what used to be in *tail
	 *  last is 1 if this is the last tail
	 */
	restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
	__archive_ensure_cloexec_flag(restore_pwd);
	if (restore_pwd < 0)
		return (ARCHIVE_FATAL);
	head = path;
	tail = path;
	last = 0;
	/* TODO: reintroduce a safe cache here? */
	/* Skip the root directory if the path is absolute. */
	if(tail == path && tail[0] == '/')
		++tail;
	/* Keep going until we've checked the entire name.
	 * head, tail, path all alias the same string, which is
	 * temporarily zeroed at tail, so be careful restoring the
	 * stashed (c=tail[0]) for error messages.
	 * Exiting the loop with break is okay; continue is not.
	 */
	while (!last) {
		/*
		 * Skip the separator we just consumed, plus any adjacent ones
		 */
		while (*tail == '/')
		    ++tail;
		/* Skip the next path element. */
		while (*tail != '\0' && *tail != '/')
			++tail;
		/* is this the last path component? */
		last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
		/* temporarily truncate the string here */
		c = tail[0];
		tail[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(head, &st);
		if (r != 0) {
			tail[0] = c;
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT) {
				break;
			} else {
				/*
				 * Treat any other error as fatal - best to be
				 * paranoid here.
				 * Note: This effectively disables deep
				 * directory support when security checks are
				 * enabled. Otherwise, very long pathnames that
				 * trigger an error here could evade the
				 * sandbox.
				 * TODO: We could do better, but it would
				 * probably require merging the symlink checks
				 * with the deep-directory editing.
				 */
				fsobj_error(a_eno, a_estr, errno,
				    ""Could not stat %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		} else if (S_ISDIR(st.st_mode)) {
			if (!last) {
				if (chdir(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not chdir %s"", path);
					res = (ARCHIVE_FATAL);
					break;
				}
				/* Our view is now from inside this dir: */
				head = tail + 1;
			}
		} else if (S_ISLNK(st.st_mode)) {
			if (last) {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(head)) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path);
					res = ARCHIVE_FAILED;
					break;
				}
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				tail[0] = c;
				/*
				 * FIXME:  not sure how important this is to
				 * restore
				 */
				/*
				if (!S_ISLNK(path)) {
					fsobj_error(a_eno, a_estr, 0,
					    ""Removing symlink %s"", path);
				}
				*/
				/* Symlink gone.  No more problem! */
				res = ARCHIVE_OK;
				break;
			} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
				tail[0] = c;
			} else if ((flags &
			    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
				/*
				 * We are not the last element and we want to
				 * follow symlinks if they are a directory.
				 * 
				 * This is needed to extract hardlinks over
				 * symlinks.
				 */
				r = stat(head, &st);
				if (r != 0) {
					tail[0] = c;
					if (errno == ENOENT) {
						break;
					} else {
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not stat %s"", path);
						res = (ARCHIVE_FAILED);
						break;
					}
				} else if (S_ISDIR(st.st_mode)) {
					if (chdir(head) != 0) {
						tail[0] = c;
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path);
						res = (ARCHIVE_FATAL);
						break;
					}
					/*
					 * Our view is now from inside
					 * this dir:
					 */
					head = tail + 1;
				} else {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
			} else {
				tail[0] = c;
				fsobj_error(a_eno, a_estr, 0,
				    ""Cannot extract through symlink %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		}
		/* be sure to always maintain this */
		tail[0] = c;
		if (tail[0] != '\0')
			tail++; /* Advance to the next segment. */
	}
	/* Catches loop exits via break */
	tail[0] = c;
#ifdef HAVE_FCHDIR
	/* If we changed directory above, restore it here. */
	if (restore_pwd >= 0) {
		r = fchdir(restore_pwd);
		if (r != 0) {
			fsobj_error(a_eno, a_estr, errno,
			    ""chdir() failure"", """");
		}
		close(restore_pwd);
		restore_pwd = -1;
		if (r != 0) {
			res = (ARCHIVE_FATAL);
		}
	}
#endif
	/* TODO: reintroduce a safe cache here? */
	return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
	struct archive_string error_string;
	int error_number;
	int rc;
	archive_string_init(&error_string);
	rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
	    a->flags);
	if (rc != ARCHIVE_OK) {
		archive_set_error(&a->archive, error_number, ""%s"",
		    error_string.s);
	}
	archive_string_free(&error_string);
	a->pst = NULL;	/* to be safe */
	return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,"[63, 77, 87, 95]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_130.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_130.cpp," * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
	char *dest, *src;
	char separator = '\0';

	dest = src = a->name;
	if (*src == '\0') {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}

#if defined(__CYGWIN__)
	cleanup_pathname_win(a);
#endif
	/* Skip leading '/'. */
	if (*src == '/') {
		if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}

"," * is set) if the path is absolute.
 */
static int
cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
	char *dest, *src;
	char separator = '\0';

	dest = src = path;
	if (*src == '\0') {
		fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty "", ""pathname"");
		return (ARCHIVE_FAILED);
	}

#if defined(__CYGWIN__)
	cleanup_pathname_win(path);
#endif
	/* Skip leading '/'. */
	if (*src == '/') {
		if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
			fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
			    ""Path is "", ""absolute"");
			return (ARCHIVE_FAILED);
		}

",2534,2807,"[10, 21]",[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_131.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_131.cpp,"			} else if (src[1] == '.') {
				if (src[2] == '/' || src[2] == '\0') {
					/* Conditionally warn about '..' */
					if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}
				}
","			} else if (src[1] == '.') {
				if (src[2] == '/' || src[2] == '\0') {
					/* Conditionally warn about '..' */
					if (flags
					    & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
						fsobj_error(a_eno, a_estr,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains "", ""'..'"");
						return (ARCHIVE_FAILED);
					}
				}
",2580,2854,[4],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_132.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_132.cpp,"		}
	} else if (errno != ENOENT && errno != ENOTDIR) {
		/* Stat failed? */
		archive_set_error(&a->archive, errno, ""Can't test directory '%s'"", path);
		return (ARCHIVE_FAILED);
	} else if (slash != NULL) {
		*slash = '\0';
","		}
	} else if (errno != ENOENT && errno != ENOTDIR) {
		/* Stat failed? */
		archive_set_error(&a->archive, errno,
		    ""Can't test directory '%s'"", path);
		return (ARCHIVE_FAILED);
	} else if (slash != NULL) {
		*slash = '\0';
",2707,2999,[3],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_133.cpp,"				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
","				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
",3753,4051,[3],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_134.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_134.cpp,"				ret = ARCHIVE_WARN;
			}
		} else {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"");
			ret = ARCHIVE_WARN;
		}
","				ret = ARCHIVE_WARN;
			}
		} else {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"");
			ret = ARCHIVE_WARN;
		}
",3764,4063,[3],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_135.cpp,"			errno = 0;
#if HAVE_EXTATTR_SET_FD
			if (a->fd >= 0)
				e = extattr_set_fd(a->fd, namespace, name, value, size);
			else
#endif
			/* TODO: should we use extattr_set_link() instead? */
			{
				e = extattr_set_file(archive_entry_pathname(entry),
				    namespace, name, value, size);
			}
			if (e != (int)size) {
				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
","			errno = 0;
#if HAVE_EXTATTR_SET_FD
			if (a->fd >= 0)
				e = extattr_set_fd(a->fd, namespace, name,
				    value, size);
			else
#endif
			/* TODO: should we use extattr_set_link() instead? */
			{
				e = extattr_set_file(
				    archive_entry_pathname(entry), namespace,
				    name, value, size);
			}
			if (e != (int)size) {
				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
",3808,4108,[15],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_cpio_newc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_71.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_71.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_136.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_136.cpp,"	if (a->format_free != NULL)
		(a->format_free)(a);

	cpio = (struct cpio *)malloc(sizeof(*cpio));
	if (cpio == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
		return (ARCHIVE_FATAL);
	}
	memset(cpio, 0, sizeof(*cpio));
	a->format_data = cpio;
	a->format_name = ""cpio"";
	a->format_options = archive_write_newc_options;
","	if (a->format_free != NULL)
		(a->format_free)(a);

	cpio = (struct cpio *)calloc(1, sizeof(*cpio));
	if (cpio == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
		return (ARCHIVE_FATAL);
	}
	a->format_data = cpio;
	a->format_name = ""cpio"";
	a->format_options = archive_write_newc_options;
",116,116,[5],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_pax.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_72.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_72.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_137.cpp,"	if (a->format_free != NULL)
		(a->format_free)(a);

	pax = (struct pax *)malloc(sizeof(*pax));
	if (pax == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"");
		return (ARCHIVE_FATAL);
	}
	memset(pax, 0, sizeof(*pax));
	a->format_data = pax;
	a->format_name = ""pax"";
	a->format_options = archive_write_pax_options;
","	if (a->format_free != NULL)
		(a->format_free)(a);

	pax = (struct pax *)calloc(1, sizeof(*pax));
	if (pax == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"");
		return (ARCHIVE_FATAL);
	}
	pax->flags = WRITE_LIBARCHIVE_XATTR | WRITE_SCHILY_XATTR;

	a->format_data = pax;
	a->format_name = ""pax"";
	a->format_options = archive_write_pax_options;
",127,137,[5],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_ustar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_73.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_73.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_138.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_138.cpp,"		return (ARCHIVE_FATAL);
	}

	ustar = (struct ustar *)malloc(sizeof(*ustar));
	if (ustar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"");
		return (ARCHIVE_FATAL);
	}
	memset(ustar, 0, sizeof(*ustar));
	a->format_data = ustar;
	a->format_name = ""ustar"";
	a->format_options = archive_write_ustar_options;
","		return (ARCHIVE_FATAL);
	}

	ustar = (struct ustar *)calloc(1, sizeof(*ustar));
	if (ustar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"");
		return (ARCHIVE_FATAL);
	}
	a->format_data = ustar;
	a->format_name = ""ustar"";
	a->format_options = archive_write_ustar_options;
",184,184,[5],[]
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_v7tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_74.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_74.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_139.cpp,"		return (ARCHIVE_FATAL);
	}

	v7tar = (struct v7tar *)malloc(sizeof(*v7tar));
	if (v7tar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"");
		return (ARCHIVE_FATAL);
	}
	memset(v7tar, 0, sizeof(*v7tar));
	a->format_data = v7tar;
	a->format_name = ""tar (non-POSIX)"";
	a->format_options = archive_write_v7tar_options;
","		return (ARCHIVE_FATAL);
	}

	v7tar = (struct v7tar *)calloc(1, sizeof(*v7tar));
	if (v7tar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"");
		return (ARCHIVE_FATAL);
	}
	a->format_data = v7tar;
	a->format_name = ""tar (non-POSIX)"";
	a->format_options = archive_write_v7tar_options;
",161,161,[5],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_140.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_140.cpp,"	name = archive_entry_sourcepath(entry);
	if (name == NULL)
		name = archive_entry_pathname(entry);
	if (name == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"");
		return (ARCHIVE_WARN);
	}

	if (a->tree != NULL) {
		if (a->tree_enter_working_dir(a->tree) != 0) {
			archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");
				return (ARCHIVE_FAILED);
		}
	}

	/* Short-circuit if there's nothing to do. */
	have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
	if (have_attrs == -1) {
","	name = archive_entry_sourcepath(entry);
	if (name == NULL)
		name = archive_entry_pathname(entry);
	else if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {
		archive_set_error(&a->archive, errno,
			    ""Can't change dir to read extended attributes"");
			return (ARCHIVE_FAILED);
	}
	if (name == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"");
		return (ARCHIVE_WARN);
	}

	/* Short-circuit if there's nothing to do. */
	have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
	if (have_attrs == -1) {
",302,321,"[4, 11]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_141.cpp,"	const char *path;
	ssize_t list_size;

	path = archive_entry_sourcepath(entry);
	if (path == NULL)
		path = archive_entry_pathname(entry);

	if (*fd < 0 && a->tree != NULL) {
		if (a->follow_symlinks ||
		    archive_entry_filetype(entry) != AE_IFLNK)
			*fd = a->open_on_current_dir(a->tree, path,
				O_RDONLY | O_NONBLOCK);
		if (*fd < 0) {
			if (a->tree_enter_working_dir(a->tree) != 0) {
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}
		}
	}

","	const char *path;
	ssize_t list_size;

	path = NULL;

	if (*fd < 0) {
		path = archive_entry_sourcepath(entry);
		if (path == NULL || (a->tree != NULL &&
		    a->tree_enter_working_dir(a->tree) != 0))
			path = archive_entry_pathname(entry);
		if (path == NULL) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");
			return (ARCHIVE_WARN);
		}
		if (a->tree != NULL && (a->follow_symlinks ||
		    archive_entry_filetype(entry) != AE_IFLNK)) {
			*fd = a->open_on_current_dir(a->tree,
			    path, O_RDONLY | O_NONBLOCK);
		}
	}

",772,1486,[14],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_142.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_142.cpp,"	const char *path;
	int namespace = EXTATTR_NAMESPACE_USER;

	path = archive_entry_sourcepath(entry);
	if (path == NULL)
		path = archive_entry_pathname(entry);

	if (*fd < 0 && a->tree != NULL) {
		if (a->follow_symlinks ||
		    archive_entry_filetype(entry) != AE_IFLNK)
			*fd = a->open_on_current_dir(a->tree, path,
				O_RDONLY | O_NONBLOCK);
		if (*fd < 0) {
			if (a->tree_enter_working_dir(a->tree) != 0) {
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}
		}
	}

","	const char *path;
	int namespace = EXTATTR_NAMESPACE_USER;

	path = NULL;

	if (*fd < 0) {
		path = archive_entry_sourcepath(entry);
		if (path == NULL || (a->tree != NULL &&
		    a->tree_enter_working_dir(a->tree) != 0))
			path = archive_entry_pathname(entry);
		if (path == NULL) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");
			return (ARCHIVE_WARN);
		}
		if (a->tree != NULL && (a->follow_symlinks ||
		    archive_entry_filetype(entry) != AE_IFLNK)) {
			*fd = a->open_on_current_dir(a->tree,
			    path, O_RDONLY | O_NONBLOCK);
		}
	}

",932,1645,[14],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_143.cpp,"		if (path == NULL)
			path = archive_entry_pathname(entry);
			
		if (pathconf(path, _PC_MIN_HOLE_SIZE) <= 0)
			return (ARCHIVE_OK);
		*fd = open(path, O_RDONLY | O_NONBLOCK | O_CLOEXEC);
		if (*fd < 0) {
			archive_set_error(&a->archive, errno,
","		if (path == NULL)
			path = archive_entry_pathname(entry);
			
#ifdef _PC_MIN_HOLE_SIZE
		if (pathconf(path, _PC_MIN_HOLE_SIZE) <= 0)
			return (ARCHIVE_OK);
#endif
		*fd = open(path, O_RDONLY | O_NONBLOCK | O_CLOEXEC);
		if (*fd < 0) {
			archive_set_error(&a->archive, errno,
",1180,1907,[7],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_144.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_144.cpp,"		r = archive_match_path_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_path_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",938,938,[2],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_145.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_145.cpp,"		r = archive_match_time_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_time_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",1041,1041,[2],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_146.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_146.cpp,"		r = archive_match_owner_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_owner_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",1067,1067,[2],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_147.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_147.cpp,"		archive_set_error(&a->archive, errno, ""statvfs failed"");
		return (ARCHIVE_FAILED);
	} else if (xr == 1) {
		/* Usuall come here unless NetBSD supports _PC_REC_XFER_ALIGN
		 * for pathconf() function. */
		t->current_filesystem->xfer_align = sfs.f_frsize;
		t->current_filesystem->max_xfer_size = -1;
","		archive_set_error(&a->archive, errno, ""statvfs failed"");
		return (ARCHIVE_FAILED);
	} else if (xr == 1) {
		/* Usually come here unless NetBSD supports _PC_REC_XFER_ALIGN
		 * for pathconf() function. */
		t->current_filesystem->xfer_align = sfs.f_frsize;
		t->current_filesystem->max_xfer_size = -1;
",1643,1656,[0],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_148.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_148.cpp,"		r = archive_match_path_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_path_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",803,802,[2],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_149.cpp,"		r = archive_match_time_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_time_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",875,874,[2],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_150.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_150.cpp,"		r = archive_match_owner_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_owner_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",901,900,[2],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_151.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_151.cpp,"#else
		archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"");
		return (ARCHIVE_FATAL);
#endif
	}
	if (fstat(fd, &st) != 0) {
","#else
		archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"");
		goto fail;
#endif
	}
	if (fstat(fd, &st) != 0) {
",277,277,[1],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_152.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_152.cpp,"		else
			archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename);
		return (ARCHIVE_FATAL);
	}

	/*
","		else
			archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename);
		goto fail;
	}

	/*
",287,287,[1],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_153.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_153.cpp,"		mine->block_size = new_block_size;
	}
	buffer = malloc(mine->block_size);
	if (mine == NULL || buffer == NULL) {
		archive_set_error(a, ENOMEM, ""No memory"");
		free(mine);
		free(buffer);
		return (ARCHIVE_FATAL);
	}
	mine->buffer = buffer;
	mine->fd = fd;
","		mine->block_size = new_block_size;
	}
	buffer = malloc(mine->block_size);
	if (buffer == NULL) {
		archive_set_error(a, ENOMEM, ""No memory"");
		goto fail;
	}
	mine->buffer = buffer;
	mine->fd = fd;
",356,356,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_lz4.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_79.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_79.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_154.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_154.cpp,"#endif
	}

	/* Check if an error happend in decompression process. */
	if (uncompressed_size < 0) {
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC, ""lz4 decompression failed"");
","#endif
	}

	/* Check if an error occurred in the decompression process. */
	if (uncompressed_size < 0) {
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC, ""lz4 decompression failed"");
",595,595,[5],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_80.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_80.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_155.cpp,"	    &state->child_stdout);
	if (child == -1) {
		free(state->out_buf);
		free(state);
		archive_set_error(&self->archive->archive, EINVAL,
		    ""Can't initialize filter; unable to run program \""%s\"""",
","	    &state->child_stdout);
	if (child == -1) {
		free(state->out_buf);
		archive_string_free(&state->description);
		free(state);
		archive_set_error(&self->archive->archive, EINVAL,
		    ""Can't initialize filter; unable to run program \""%s\"""",
",430,430,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_156.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_156.cpp,"	bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
	return (ARCHIVE_OK);
#elif HAVE_LZMADEC_H && HAVE_LIBLZMADEC
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"");
","	bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"");
",178,163,[6],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
	struct private_data *state;
	size_t decompressed;
	ssize_t avail_in, ret;

	state = (struct private_data *)self->data;

	/* Empty our output buffer. */
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Try to fill the output buffer. */
	while (state->stream.avail_out > 0 && !state->eof) {
		state->stream.next_in = (unsigned char *)(uintptr_t)
		    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
		if (state->stream.next_in == NULL && avail_in < 0) {
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}
		state->stream.avail_in = avail_in;

		/* Decompress as much as we can in one pass. */
		ret = lzmadec_decode(&(state->stream), avail_in == 0);
		switch (ret) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}
	}

	decompressed = state->stream.next_out - state->out_block;
	state->total_out += decompressed;
	if (decompressed == 0)
		*p = NULL;
	else
		*p = state->out_block;
	return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
	struct private_data *state;
	int ret;

	state = (struct private_data *)self->data;
	ret = ARCHIVE_OK;
	switch (lzmadec_end(&(state->stream))) {
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}

	free(state->out_block);
	free(state);
	return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,"[27, 58, 64, 70, 103, 121, 127, 158]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_158.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_158.cpp,"	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_ar"");

	ar = (struct ar *)malloc(sizeof(*ar));
	if (ar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"");
		return (ARCHIVE_FATAL);
	}
	memset(ar, 0, sizeof(*ar));
	ar->strtab = NULL;

	r = __archive_read_register_format(a,
","	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_ar"");

	ar = (struct ar *)calloc(1, sizeof(*ar));
	if (ar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"");
		return (ARCHIVE_FATAL);
	}
	ar->strtab = NULL;

	r = __archive_read_register_format(a,
",104,104,[5],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_159.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_159.cpp,"		archive_entry_set_filetype(entry, AE_IFREG);
		/* Get the size of the filename table. */
		number = ar_atol10(h + AR_size_offset, AR_size_size);
		if (number > SIZE_MAX) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"");
			return (ARCHIVE_FATAL);
","		archive_entry_set_filetype(entry, AE_IFREG);
		/* Get the size of the filename table. */
		number = ar_atol10(h + AR_size_offset, AR_size_size);
		if (number > SIZE_MAX || number > 1024 * 1024 * 1024) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"");
			return (ARCHIVE_FATAL);
",260,259,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_160.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_160.cpp,"		 * If we can't look up the real name, warn and return
		 * the entry with the wrong name.
		 */
		if (ar->strtab == NULL || number > ar->strtab_size) {
			archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for GNU/SVR4 archive entry"");
			archive_entry_copy_pathname(entry, filename);
","		 * If we can't look up the real name, warn and return
		 * the entry with the wrong name.
		 */
		if (ar->strtab == NULL || number >= ar->strtab_size) {
			archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for GNU/SVR4 archive entry"");
			archive_entry_copy_pathname(entry, filename);
",316,315,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_cpio.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_83.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_83.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_161.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_161.cpp,"			    ""Rejecting malformed cpio archive: symlink contents exceed 1 megabyte"");
			return (ARCHIVE_FATAL);
		}
		h = __archive_read_ahead(a,
			(size_t)cpio->entry_bytes_remaining, NULL);
		if (h == NULL)
			return (ARCHIVE_FATAL);
		if (archive_entry_copy_symlink_l(entry, (const char *)h,
		    (size_t)cpio->entry_bytes_remaining, sconv) != 0) {
			if (errno == ENOMEM) {
				archive_set_error(&a->archive, ENOMEM,
","			    ""Rejecting malformed cpio archive: symlink contents exceed 1 megabyte"");
			return (ARCHIVE_FATAL);
		}
		hl = __archive_read_ahead(a,
			(size_t)cpio->entry_bytes_remaining, NULL);
		if (hl == NULL)
			return (ARCHIVE_FATAL);
		if (archive_entry_copy_symlink_l(entry, (const char *)hl,
		    (size_t)cpio->entry_bytes_remaining, sconv) != 0) {
			if (errno == ENOMEM) {
				archive_set_error(&a->archive, ENOMEM,
",406,406,[10],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_162.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_162.cpp,"		if ((file->utf16be_name = malloc(name_len)) == NULL) {
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"");
			return (NULL);
		}
		memcpy(file->utf16be_name, p, name_len);
		file->utf16be_bytes = name_len;
","		if ((file->utf16be_name = malloc(name_len)) == NULL) {
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"");
			goto fail;
		}
		memcpy(file->utf16be_name, p, name_len);
		file->utf16be_bytes = name_len;
",1864,1864,[1],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_163.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_163.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				return (NULL);
			}
			/*
			 * Sanity check: file does not have ""CL"" extension.
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				goto fail;
			}
			/*
			 * Sanity check: file does not have ""CL"" extension.
",1990,1988,[0],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_164.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_164.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"");
				return (NULL);
			}
			/*
			 * Sanity check: The file type must be a directory.
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"");
				goto fail;
			}
			/*
			 * Sanity check: The file type must be a directory.
",1999,1997,[0],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_165.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_165.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				return (NULL);
			}
		} else if (parent != NULL && parent->rr_moved)
			file->rr_moved_has_re_only = 0;
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				goto fail;
			}
		} else if (parent != NULL && parent->rr_moved)
			file->rr_moved_has_re_only = 0;
",2008,2006,[0],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_166.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_166.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}
			/*
			 * Sanity check: The file type must be a regular file.
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				goto fail;
			}
			/*
			 * Sanity check: The file type must be a regular file.
",2022,2020,[0],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_167.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_167.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}
			parent->subdirs++;
			/* Overwrite an offset and a number of this ""CL"" entry
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				goto fail;
			}
			parent->subdirs++;
			/* Overwrite an offset and a number of this ""CL"" entry
",2031,2029,[0],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_168.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_168.cpp,"					archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"");
					return (NULL);
				}
			}
			if (file->cl_offset == file->offset ||
			    parent->rr_moved) {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}
		}
	}
","					archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"");
					goto fail;
				}
			}
			if (file->cl_offset == file->offset ||
			    parent->rr_moved) {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				goto fail;
			}
		}
	}
",2049,2047,"[0, 8]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_85.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_85.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_169.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_169.cpp,"	/* Get a real compressed file size. */
	lha->compsize -= extdsize - 2;

	if (sum_calculated != headersum) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"");
","	/* Get a real compressed file size. */
	lha->compsize -= extdsize - 2;

	if (lha->compsize < 0)
		goto invalid;	/* Invalid compressed file size */

	if (sum_calculated != headersum) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"");
",924,924,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_170.cpp,"	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_mtree"");

	mtree = (struct mtree *)malloc(sizeof(*mtree));
	if (mtree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"");
		return (ARCHIVE_FATAL);
	}
	memset(mtree, 0, sizeof(*mtree));
	mtree->fd = -1;

	r = __archive_read_register_format(a, mtree, ""mtree"",
","	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_mtree"");

	mtree = (struct mtree *)calloc(1, sizeof(*mtree));
	if (mtree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"");
		return (ARCHIVE_FATAL);
	}
	mtree->fd = -1;

	r = __archive_read_register_format(a, mtree, ""mtree"",
",223,229,[5],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_171.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_171.cpp,"    struct mtree_option **global, const char *line, ssize_t line_len,
    struct mtree_entry **last_entry, int is_form_d)
{
	struct mtree_entry *entry;
	struct mtree_option *iter;
	const char *next, *eq, *name, *end;
	size_t name_len, len;
	int r, i;

	if ((entry = malloc(sizeof(*entry))) == NULL) {
		archive_set_error(&a->archive, errno, ""Can't allocate memory"");
","    struct mtree_option **global, const char *line, ssize_t line_len,
    struct mtree_entry **last_entry, int is_form_d)
{
	struct mtree_entry *entry, *ht_iter;
	struct mtree_option *iter;
	const char *next, *eq, *name, *end;
	size_t name_len, len;
	int r, i;
	unsigned int ht_idx;

	if ((entry = malloc(sizeof(*entry))) == NULL) {
		archive_set_error(&a->archive, errno, ""Can't allocate memory"");
",853,867,[10],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_87.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_87.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_172.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_172.cpp,"  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,
                      ""archive_read_support_format_rar"");

  rar = (struct rar *)malloc(sizeof(*rar));
  if (rar == NULL)
  {
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }
  memset(rar, 0, sizeof(*rar));

	/*
	 * Until enough data has been read, we cannot tell about
","  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,
                      ""archive_read_support_format_rar"");

  rar = (struct rar *)calloc(sizeof(*rar), 1);
  if (rar == NULL)
  {
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }

	/*
	 * Until enough data has been read, we cannot tell about
",647,647,[6],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_173.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_173.cpp,"				tar->sparse_gnu_pending = 0;
				/* Read initial sparse map. */
				bytes_read = gnu_sparse_10_read(a, tar, unconsumed);
				tar->entry_bytes_remaining -= bytes_read;
				if (bytes_read < 0)
					return ((int)bytes_read);
			} else {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
","				tar->sparse_gnu_pending = 0;
				/* Read initial sparse map. */
				bytes_read = gnu_sparse_10_read(a, tar, unconsumed);
				if (bytes_read < 0)
					return ((int)bytes_read);
				tar->entry_bytes_remaining -= bytes_read;
			} else {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
",793,847,[7],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_174.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_174.cpp,"	switch ((int)type & ~0777777) {
	case 01000000:
		/* POSIX.1e ACL */
		break;
	case 03000000:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");
		return (ARCHIVE_WARN);
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Malformed Solaris ACL attribute (unsupported type %o)"",
","	switch ((int)type & ~0777777) {
	case 01000000:
		/* POSIX.1e ACL */
		acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;
		break;
	case 03000000:
		/* NFSv4 ACL */
		acl_type = ARCHIVE_ENTRY_ACL_TYPE_NFS4;
		break;
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Malformed Solaris ACL attribute (unsupported type %o)"",
",935,989,"[5, 9]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_175.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_175.cpp,"			return (ARCHIVE_FATAL);
	}
	archive_strncpy(&(tar->localname), acl, p - acl);
	err = archive_acl_parse_l(archive_entry_acl(entry),
	    tar->localname.s, ARCHIVE_ENTRY_ACL_TYPE_ACCESS, tar->sconv_acl);
	if (err != ARCHIVE_OK) {
		if (errno == ENOMEM) {
			archive_set_error(&a->archive, ENOMEM,
","			return (ARCHIVE_FATAL);
	}
	archive_strncpy(&(tar->localname), acl, p - acl);
	err = archive_acl_from_text_l(archive_entry_acl(entry),
	    tar->localname.s, acl_type, tar->sconv_acl);
	if (err != ARCHIVE_OK) {
		if (errno == ENOMEM) {
			archive_set_error(&a->archive, ENOMEM,
",968,1023,[7],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_176.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_176.cpp,"	if (tar->entry_bytes_remaining < 0) {
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");
		err = ARCHIVE_WARN;
	}
	tar->realsize = tar->entry_bytes_remaining;
	archive_entry_set_size(entry, tar->entry_bytes_remaining);
","	if (tar->entry_bytes_remaining < 0) {
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size"");
		return (ARCHIVE_FATAL);
	}
	if (tar->entry_bytes_remaining == INT64_MAX) {
		/* Note: tar_atol returns INT64_MAX on overflow */
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry size overflow"");
		return (ARCHIVE_FATAL);
	}
	tar->realsize = tar->entry_bytes_remaining;
	archive_entry_set_size(entry, tar->entry_bytes_remaining);
",1128,1183,[2],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_177.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_177.cpp,"	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
","	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,"[17, 22, 41, 46]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_178.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_178.cpp,"{
	struct sparse_block *p;

	p = (struct sparse_block *)malloc(sizeof(*p));
	if (p == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}
	memset(p, 0, sizeof(*p));
	if (tar->sparse_last != NULL)
		tar->sparse_last->next = p;
	else
","{
	struct sparse_block *p;

	p = (struct sparse_block *)calloc(1, sizeof(*p));
	if (p == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}
	if (tar->sparse_last != NULL)
		tar->sparse_last->next = p;
	else
",2116,2227,[5],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_179.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_179.cpp,"	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_warc"");

	if ((w = malloc(sizeof(*w))) == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"");
		return (ARCHIVE_FATAL);
	}
	memset(w, 0, sizeof(*w));

	r = __archive_read_register_format(
		a, w, ""warc"",
","	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_warc"");

	if ((w = calloc(1, sizeof(*w))) == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"");
		return (ARCHIVE_FATAL);
	}

	r = __archive_read_register_format(
		a, w, ""warc"",
",146,146,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_180.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_180.cpp,"			&a->archive, ARCHIVE_ERRNO_MISC,
			""Bad record header"");
		return (ARCHIVE_FATAL);
	} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {
		/* nawww, I wish they promised backward compatibility
		 * anyhoo, in their infinite wisdom the 28500 guys might
		 * come up with something we can't possibly handle so
		 * best end things here */
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");
		return (ARCHIVE_FATAL);
	} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {
		/* nightmare!  the specs say content-length is mandatory
		 * so I don't feel overly bad stopping the reader here */
		archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"");
		return (ARCHIVE_FATAL);
	} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {
		/* record time is mandatory as per WARC/1.0,
		 * so just barf here, fast and loud */
		archive_set_error(
","			&a->archive, ARCHIVE_ERRNO_MISC,
			""Bad record header"");
		return (ARCHIVE_FATAL);
	}
	ver = _warc_rdver(buf, eoh - buf);
	/* we currently support WARC 0.12 to 1.0 */
	if (ver == 0U) {
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Invalid record version"");
		return (ARCHIVE_FATAL);
	} else if (ver < 1200U || ver > 10000U) {
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version: %u.%u"",
			ver / 10000, (ver % 10000) / 100);
		return (ARCHIVE_FATAL);
	}
	cntlen = _warc_rdlen(buf, eoh - buf);
	if (cntlen < 0) {
		/* nightmare!  the specs say content-length is mandatory
		 * so I don't feel overly bad stopping the reader here */
		archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"");
		return (ARCHIVE_FATAL);
	}
	rtime = _warc_rdrtm(buf, eoh - buf);
	if (rtime == (time_t)-1) {
		/* record time is mandatory as per WARC/1.0,
		 * so just barf here, fast and loud */
		archive_set_error(
",255,254,"[8, 15, 22]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_181.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_181.cpp,"	if (ver != w->pver) {
		/* stringify this entry's version */
		archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);
		/* remember the version */
		w->pver = ver;
	}
","	if (ver != w->pver) {
		/* stringify this entry's version */
		archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100);
		/* remember the version */
		w->pver = ver;
	}
",285,293,[2],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_182.cpp,"		xar->lzstream.total_in = 0;
		xar->lzstream.total_out = 0;
		break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
	case LZMA:
		if (xar->lzstream_valid)
			lzmadec_end(&(xar->lzstream));
		r = lzmadec_init(&(xar->lzstream));
		if (r != LZMADEC_OK) {
			switch (r) {
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}
			return (ARCHIVE_FATAL);
		}
		xar->lzstream_valid = 1;
		xar->lzstream.total_in = 0;
		xar->lzstream.total_out = 0;
		break;
#endif
	/*
	 * Unsupported compression.
","		xar->lzstream.total_in = 0;
		xar->lzstream.total_out = 0;
		break;
#endif
	/*
	 * Unsupported compression.
",1526,1524,"[11, 18]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_183.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_183.cpp,"		*used = avail_in - xar->lzstream.avail_in;
		*outbytes = avail_out - xar->lzstream.avail_out;
		break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
	case LZMA:
		xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
		xar->lzstream.avail_in = avail_in;
		xar->lzstream.next_out = (unsigned char *)outbuff;
		xar->lzstream.avail_out = avail_out;
		r = lzmadec_decode(&(xar->lzstream), 0);
		switch (r) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			switch (lzmadec_end(&(xar->lzstream))) {
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}
			xar->lzstream_valid = 0;
			/* FALLTHROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			break;
		default:
			archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);
			return (ARCHIVE_FATAL);
		}
		*used = avail_in - xar->lzstream.avail_in;
		*outbytes = avail_out - xar->lzstream.avail_out;
		break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
	case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
	case LZMA:
#endif
	case XZ:
#endif
	case NONE:
","		*used = avail_in - xar->lzstream.avail_in;
		*outbytes = avail_out - xar->lzstream.avail_out;
		break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
	case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
	case LZMA:
	case XZ:
#endif
	case NONE:
",1685,1653,"[16, 26]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_184.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_184.cpp," *	id1+size1+data1 + id2+size2+data2 ...
 *  triplets.  id and size are 2 bytes each.
 */
static void
process_extra(const char *p, size_t extra_length, struct zip_entry* zip_entry)
{
	unsigned offset = 0;

	while (offset < extra_length - 4) {
		unsigned short headerid = archive_le16dec(p + offset);
		unsigned short datasize = archive_le16dec(p + offset + 2);

		offset += 4;
		if (offset + datasize > extra_length) {
			break;
		}
#ifdef DEBUG
		fprintf(stderr, ""Header id 0x%04x, length %d\n"",
"," *	id1+size1+data1 + id2+size2+data2 ...
 *  triplets.  id and size are 2 bytes each.
 */
static int
process_extra(struct archive_read *a, const char *p, size_t extra_length, struct zip_entry* zip_entry)
{
	unsigned offset = 0;

	if (extra_length == 0) {
		return ARCHIVE_OK;
	}

	if (extra_length < 4) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Too-small extra data: Need at least 4 bytes, but only found %d bytes"", (int)extra_length);
		return ARCHIVE_FAILED;
	}
	while (offset <= extra_length - 4) {
		unsigned short headerid = archive_le16dec(p + offset);
		unsigned short datasize = archive_le16dec(p + offset + 2);

		offset += 4;
		if (offset + datasize > extra_length) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Extra data overflow: Need %d bytes but only found %d bytes"",
			    (int)datasize, (int)(extra_length - offset));
			return ARCHIVE_FAILED;
		}
#ifdef DEBUG
		fprintf(stderr, ""Header id 0x%04x, length %d\n"",
",418,418,[17],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_185.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_185.cpp,"		}
		offset += datasize;
	}
#ifdef DEBUG
	if (offset != extra_length)
	{
		fprintf(stderr,
		    ""Extra data field contents do not match reported size!\n"");
	}
#endif
}

/*
","		}
		offset += datasize;
	}
	if (offset != extra_length) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Malformed extra data: Consumed %d bytes of %d bytes"",
		    (int)offset, (int)extra_length);
		return ARCHIVE_FAILED;
	}
	return ARCHIVE_OK;
}

/*
",715,739,[6],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_186.cpp,"	    && bytes_avail > zip->entry_bytes_remaining) {
		bytes_avail = (ssize_t)zip->entry_bytes_remaining;
	}
	if (bytes_avail <= 0) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file body"");
		return (ARCHIVE_FATAL);
","	    && bytes_avail > zip->entry_bytes_remaining) {
		bytes_avail = (ssize_t)zip->entry_bytes_remaining;
	}
	if (bytes_avail < 0) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file body"");
		return (ARCHIVE_FATAL);
",1293,1332,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_187.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_187.cpp,"	case 0x6720:/* Blowfish */
	case 0x6721:/* Twofish */
	case 0x6801:/* RC4 */
		/* Suuported encryption algorithm. */
		break;
	default:
		archive_set_error(&a->archive,
","	case 0x6720:/* Blowfish */
	case 0x6721:/* Twofish */
	case 0x6801:/* RC4 */
		/* Supported encryption algorithm. */
		break;
	default:
		archive_set_error(&a->archive,
",1500,1548,[6],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_188.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_188.cpp,"	__archive_read_consume(a, 4);

	/*return (ARCHIVE_OK);
	 * This is not fully implemnted yet.*/
	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
	    ""Encrypted file is unsupported"");
	return (ARCHIVE_FAILED);
","	__archive_read_consume(a, 4);

	/*return (ARCHIVE_OK);
	 * This is not fully implemented yet.*/
	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
	    ""Encrypted file is unsupported"");
	return (ARCHIVE_FAILED);
",1609,1657,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_189.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_189.cpp,"	if (a->restore_pwd >= 0) {
		r = fchdir(a->restore_pwd);
		if (r != 0) {
			archive_set_error(&a->archive, errno, ""chdir() failure"");
			ret = ARCHIVE_FATAL;
		}
		close(a->restore_pwd);
","	if (a->restore_pwd >= 0) {
		r = fchdir(a->restore_pwd);
		if (r != 0) {
			archive_set_error(&a->archive, errno,
			    ""chdir() failure"");
			ret = ARCHIVE_FATAL;
		}
		close(a->restore_pwd);
",637,669,[3],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_190.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_190.cpp,"		bytes_to_write = size;
		/* Seek if necessary to the specified offset. */
		if (a->offset < a->fd_offset) {
			/* Can't support backword move. */
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Seek failed"");
			return (ARCHIVE_FATAL);
","		bytes_to_write = size;
		/* Seek if necessary to the specified offset. */
		if (a->offset < a->fd_offset) {
			/* Can't support backward move. */
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Seek failed"");
			return (ARCHIVE_FATAL);
",1402,1437,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_191.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_191.cpp,"		return (r);
	if ((size_t)r < size) {
		archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);
		return (ARCHIVE_WARN);
	}
#if ARCHIVE_VERSION_NUMBER < 3999000
","		return (r);
	if ((size_t)r < size) {
		archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"",
		    (uintmax_t)a->filesize);
		return (ARCHIVE_WARN);
	}
#if ARCHIVE_VERSION_NUMBER < 3999000
",1468,1503,[2],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_192.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_192.cpp,"
	if (en) {
		/* Everything failed; give up here. */
		archive_set_error(&a->archive, en, ""Can't create '%s'"",
		    a->name);
		return (ARCHIVE_FAILED);
	}

","
	if (en) {
		/* Everything failed; give up here. */
		if ((&a->archive)->error == NULL)
			archive_set_error(&a->archive, en, ""Can't create '%s'"",
			    a->name);
		return (ARCHIVE_FAILED);
	}

",1993,2043,[3],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_193.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_193.cpp,"	return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)a; /* UNUSED */
	return (ARCHIVE_OK);
#else
	char *pn;
	char c;
	int r;
	struct stat st;

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 */
	/* Whatever we checked last time doesn't need to be re-checked. */
	pn = a->name;
	if (archive_strlen(&(a->path_safe)) > 0) {
		char *p = a->path_safe.s;
		while ((*pn != '\0') && (*p == *pn))
			++p, ++pn;
	}
	/* Skip the root directory if the path is absolute. */
	if(pn == a->name && pn[0] == '/')
		++pn;
	c = pn[0];
	/* Keep going until we've checked the entire name. */
	while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}
	pn[0] = c;
	/* We've checked and/or cleaned the whole path, so remember it. */
	archive_strcpy(&a->path_safe, a->name);
	return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","	return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
	if (a_eno)
		*a_eno = err;
	if (a_estr)
		archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)path; /* UNUSED */
	(void)error_number; /* UNUSED */
	(void)error_string; /* UNUSED */
	(void)flags; /* UNUSED */
	return (ARCHIVE_OK);
#else
	int res = ARCHIVE_OK;
	char *tail;
	char *head;
	int last;
	char c;
	int r;
	struct stat st;
	int restore_pwd;

	/* Nothing to do here if name is empty */
	if(path[0] == '\0')
	    return (ARCHIVE_OK);

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 *
	 * Walk the filename in chunks separated by '/'.  For each segment:
	 *  - if it doesn't exist, continue
	 *  - if it's symlink, abort or remove it
	 *  - if it's a directory and it's not the last chunk, cd into it
	 * As we go:
	 *  head points to the current (relative) path
	 *  tail points to the temporary \0 terminating the segment we're
	 *      currently examining
	 *  c holds what used to be in *tail
	 *  last is 1 if this is the last tail
	 */
	restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
	__archive_ensure_cloexec_flag(restore_pwd);
	if (restore_pwd < 0)
		return (ARCHIVE_FATAL);
	head = path;
	tail = path;
	last = 0;
	/* TODO: reintroduce a safe cache here? */
	/* Skip the root directory if the path is absolute. */
	if(tail == path && tail[0] == '/')
		++tail;
	/* Keep going until we've checked the entire name.
	 * head, tail, path all alias the same string, which is
	 * temporarily zeroed at tail, so be careful restoring the
	 * stashed (c=tail[0]) for error messages.
	 * Exiting the loop with break is okay; continue is not.
	 */
	while (!last) {
		/*
		 * Skip the separator we just consumed, plus any adjacent ones
		 */
		while (*tail == '/')
		    ++tail;
		/* Skip the next path element. */
		while (*tail != '\0' && *tail != '/')
			++tail;
		/* is this the last path component? */
		last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
		/* temporarily truncate the string here */
		c = tail[0];
		tail[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(head, &st);
		if (r != 0) {
			tail[0] = c;
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT) {
				break;
			} else {
				/*
				 * Treat any other error as fatal - best to be
				 * paranoid here.
				 * Note: This effectively disables deep
				 * directory support when security checks are
				 * enabled. Otherwise, very long pathnames that
				 * trigger an error here could evade the
				 * sandbox.
				 * TODO: We could do better, but it would
				 * probably require merging the symlink checks
				 * with the deep-directory editing.
				 */
				fsobj_error(a_eno, a_estr, errno,
				    ""Could not stat %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		} else if (S_ISDIR(st.st_mode)) {
			if (!last) {
				if (chdir(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not chdir %s"", path);
					res = (ARCHIVE_FATAL);
					break;
				}
				/* Our view is now from inside this dir: */
				head = tail + 1;
			}
		} else if (S_ISLNK(st.st_mode)) {
			if (last) {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(head)) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path);
					res = ARCHIVE_FAILED;
					break;
				}
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				tail[0] = c;
				/*
				 * FIXME:  not sure how important this is to
				 * restore
				 */
				/*
				if (!S_ISLNK(path)) {
					fsobj_error(a_eno, a_estr, 0,
					    ""Removing symlink %s"", path);
				}
				*/
				/* Symlink gone.  No more problem! */
				res = ARCHIVE_OK;
				break;
			} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
				tail[0] = c;
			} else if ((flags &
			    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
				/*
				 * We are not the last element and we want to
				 * follow symlinks if they are a directory.
				 * 
				 * This is needed to extract hardlinks over
				 * symlinks.
				 */
				r = stat(head, &st);
				if (r != 0) {
					tail[0] = c;
					if (errno == ENOENT) {
						break;
					} else {
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not stat %s"", path);
						res = (ARCHIVE_FAILED);
						break;
					}
				} else if (S_ISDIR(st.st_mode)) {
					if (chdir(head) != 0) {
						tail[0] = c;
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path);
						res = (ARCHIVE_FATAL);
						break;
					}
					/*
					 * Our view is now from inside
					 * this dir:
					 */
					head = tail + 1;
				} else {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
			} else {
				tail[0] = c;
				fsobj_error(a_eno, a_estr, 0,
				    ""Cannot extract through symlink %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		}
		/* be sure to always maintain this */
		tail[0] = c;
		if (tail[0] != '\0')
			tail++; /* Advance to the next segment. */
	}
	/* Catches loop exits via break */
	tail[0] = c;
#ifdef HAVE_FCHDIR
	/* If we changed directory above, restore it here. */
	if (restore_pwd >= 0) {
		r = fchdir(restore_pwd);
		if (r != 0) {
			fsobj_error(a_eno, a_estr, errno,
			    ""chdir() failure"", """");
		}
		close(restore_pwd);
		restore_pwd = -1;
		if (r != 0) {
			res = (ARCHIVE_FATAL);
		}
	}
#endif
	/* TODO: reintroduce a safe cache here? */
	return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
	struct archive_string error_string;
	int error_number;
	int rc;
	archive_string_init(&error_string);
	rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
	    a->flags);
	if (rc != ARCHIVE_OK) {
		archive_set_error(&a->archive, error_number, ""%s"",
		    error_string.s);
	}
	archive_string_free(&error_string);
	a->pst = NULL;	/* to be safe */
	return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,"[63, 77, 87, 95]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_194.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_194.cpp," * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
	char *dest, *src;
	char separator = '\0';

	dest = src = a->name;
	if (*src == '\0') {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}

#if defined(__CYGWIN__)
	cleanup_pathname_win(a);
#endif
	/* Skip leading '/'. */
	if (*src == '/') {
		if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}

"," * is set) if the path is absolute.
 */
static int
cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
	char *dest, *src;
	char separator = '\0';

	dest = src = path;
	if (*src == '\0') {
		fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty "", ""pathname"");
		return (ARCHIVE_FAILED);
	}

#if defined(__CYGWIN__)
	cleanup_pathname_win(path);
#endif
	/* Skip leading '/'. */
	if (*src == '/') {
		if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
			fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
			    ""Path is "", ""absolute"");
			return (ARCHIVE_FAILED);
		}

",2534,2807,"[10, 21]",[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_195.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_195.cpp,"			} else if (src[1] == '.') {
				if (src[2] == '/' || src[2] == '\0') {
					/* Conditionally warn about '..' */
					if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}
				}
","			} else if (src[1] == '.') {
				if (src[2] == '/' || src[2] == '\0') {
					/* Conditionally warn about '..' */
					if (flags
					    & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
						fsobj_error(a_eno, a_estr,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains "", ""'..'"");
						return (ARCHIVE_FAILED);
					}
				}
",2580,2854,[4],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_196.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_196.cpp,"		}
	} else if (errno != ENOENT && errno != ENOTDIR) {
		/* Stat failed? */
		archive_set_error(&a->archive, errno, ""Can't test directory '%s'"", path);
		return (ARCHIVE_FAILED);
	} else if (slash != NULL) {
		*slash = '\0';
","		}
	} else if (errno != ENOENT && errno != ENOTDIR) {
		/* Stat failed? */
		archive_set_error(&a->archive, errno,
		    ""Can't test directory '%s'"", path);
		return (ARCHIVE_FAILED);
	} else if (slash != NULL) {
		*slash = '\0';
",2707,2999,[3],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_197.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_197.cpp,"				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
","				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
",3753,4051,[3],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_198.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_198.cpp,"				ret = ARCHIVE_WARN;
			}
		} else {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"");
			ret = ARCHIVE_WARN;
		}
","				ret = ARCHIVE_WARN;
			}
		} else {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"");
			ret = ARCHIVE_WARN;
		}
",3764,4063,[3],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_199.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_199.cpp,"			errno = 0;
#if HAVE_EXTATTR_SET_FD
			if (a->fd >= 0)
				e = extattr_set_fd(a->fd, namespace, name, value, size);
			else
#endif
			/* TODO: should we use extattr_set_link() instead? */
			{
				e = extattr_set_file(archive_entry_pathname(entry),
				    namespace, name, value, size);
			}
			if (e != (int)size) {
				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
","			errno = 0;
#if HAVE_EXTATTR_SET_FD
			if (a->fd >= 0)
				e = extattr_set_fd(a->fd, namespace, name,
				    value, size);
			else
#endif
			/* TODO: should we use extattr_set_link() instead? */
			{
				e = extattr_set_file(
				    archive_entry_pathname(entry), namespace,
				    name, value, size);
			}
			if (e != (int)size) {
				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
",3808,4108,[15],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_set_format_cpio_newc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_200.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_200.cpp,"	if (a->format_free != NULL)
		(a->format_free)(a);

	cpio = (struct cpio *)malloc(sizeof(*cpio));
	if (cpio == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
		return (ARCHIVE_FATAL);
	}
	memset(cpio, 0, sizeof(*cpio));
	a->format_data = cpio;
	a->format_name = ""cpio"";
	a->format_options = archive_write_newc_options;
","	if (a->format_free != NULL)
		(a->format_free)(a);

	cpio = (struct cpio *)calloc(1, sizeof(*cpio));
	if (cpio == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
		return (ARCHIVE_FATAL);
	}
	a->format_data = cpio;
	a->format_name = ""cpio"";
	a->format_options = archive_write_newc_options;
",116,116,[5],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_set_format_pax.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_94.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_94.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_201.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_201.cpp,"	if (a->format_free != NULL)
		(a->format_free)(a);

	pax = (struct pax *)malloc(sizeof(*pax));
	if (pax == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"");
		return (ARCHIVE_FATAL);
	}
	memset(pax, 0, sizeof(*pax));
	a->format_data = pax;
	a->format_name = ""pax"";
	a->format_options = archive_write_pax_options;
","	if (a->format_free != NULL)
		(a->format_free)(a);

	pax = (struct pax *)calloc(1, sizeof(*pax));
	if (pax == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"");
		return (ARCHIVE_FATAL);
	}
	pax->flags = WRITE_LIBARCHIVE_XATTR | WRITE_SCHILY_XATTR;

	a->format_data = pax;
	a->format_name = ""pax"";
	a->format_options = archive_write_pax_options;
",127,137,[5],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_set_format_ustar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_95.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_95.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_202.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_202.cpp,"		return (ARCHIVE_FATAL);
	}

	ustar = (struct ustar *)malloc(sizeof(*ustar));
	if (ustar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"");
		return (ARCHIVE_FATAL);
	}
	memset(ustar, 0, sizeof(*ustar));
	a->format_data = ustar;
	a->format_name = ""ustar"";
	a->format_options = archive_write_ustar_options;
","		return (ARCHIVE_FATAL);
	}

	ustar = (struct ustar *)calloc(1, sizeof(*ustar));
	if (ustar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"");
		return (ARCHIVE_FATAL);
	}
	a->format_data = ustar;
	a->format_name = ""ustar"";
	a->format_options = archive_write_ustar_options;
",184,184,[5],[]
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_set_format_v7tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_96.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_96.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_203.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_203.cpp,"		return (ARCHIVE_FATAL);
	}

	v7tar = (struct v7tar *)malloc(sizeof(*v7tar));
	if (v7tar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"");
		return (ARCHIVE_FATAL);
	}
	memset(v7tar, 0, sizeof(*v7tar));
	a->format_data = v7tar;
	a->format_name = ""tar (non-POSIX)"";
	a->format_options = archive_write_v7tar_options;
","		return (ARCHIVE_FATAL);
	}

	v7tar = (struct v7tar *)calloc(1, sizeof(*v7tar));
	if (v7tar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"");
		return (ARCHIVE_FATAL);
	}
	a->format_data = v7tar;
	a->format_name = ""tar (non-POSIX)"";
	a->format_options = archive_write_v7tar_options;
",161,161,[5],[]
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_97.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_97.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_204.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_204.cpp,"        *fptr = 0;

        if(width >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr += len;
          left -= len;
        }
        if(prec >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr += len;
","        *fptr = 0;

        if(width >= 0) {
          if(width >= (long)sizeof(work))
            width = sizeof(work)-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr += len;
          left -= len;
        }
        if(prec >= 0) {
          /* for each digit in the integer part, we can have one less
             precision */
          size_t maxprec = sizeof(work) - 2;
          double val = p->data.dnum;
          while(val >= 10.0) {
            val /= 10;
            maxprec--;
          }

          if(prec > (long)maxprec)
            prec = (long)maxprec-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr += len;
",913,913,"[4, 10]",[]
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/socks_gssapi.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_205.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_205.cpp,"
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.value = malloc(strlen(serviceptr));
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr);
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(strlen(serviceptr) +strlen(conn->proxy.name)+2);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr) +strlen(conn->proxy.name)+1;
    snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
","
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.length = serviceptr_length;
    service.value = malloc(service.length);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(serviceptr_length +
                           strlen(conn->socks_proxy.host.name)+2);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = serviceptr_length + strlen(conn->socks_proxy.host.name)+1;
    snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->socks_proxy.host.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
",134,135,[17],[]
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/telnet.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_99.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_99.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_206.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_206.cpp,"  struct TELNET *tn = (struct TELNET *)data->req.protop;

  printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn)+2);
  switch (CURL_SB_GET(tn)) {
    case CURL_TELOPT_TTYPE:
      len = strlen(tn->subopt_ttype) + 4 + 2;
      snprintf((char *)temp, sizeof(temp),
","  struct TELNET *tn = (struct TELNET *)data->req.protop;

  printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn)+2);
  switch(CURL_SB_GET(tn)) {
    case CURL_TELOPT_TTYPE:
      len = strlen(tn->subopt_ttype) + 4 + 2;
      snprintf((char *)temp, sizeof(temp),
",935,935,[6],[]
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_100.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_100.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_207.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_207.cpp,"    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
","    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
",387,388,[9],[]
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/vtls/darwinssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_101.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_101.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_208.cpp,"    else {
      CURLcode result;
      ssl_sessionid =
        aprintf(""%s:%d:%d:%s:%hu"", data->set.str[STRING_SSL_CAFILE],
                data->set.ssl.verifypeer, data->set.ssl.verifyhost,
                conn->host.name, conn->remote_port);
      ssl_sessionid_len = strlen(ssl_sessionid);

      err = SSLSetPeerID(connssl->ssl_ctx, ssl_sessionid, ssl_sessionid_len);
","    else {
      CURLcode result;
      ssl_sessionid =
        aprintf(""%s:%d:%d:%s:%hu"", ssl_cafile,
                verifypeer, SSL_CONN_CONFIG(verifyhost), hostname, port);
      ssl_sessionid_len = strlen(ssl_sessionid);

      err = SSLSetPeerID(connssl->ssl_ctx, ssl_sessionid, ssl_sessionid_len);
",1504,1563,[3],[]
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_102.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_102.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_209.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_209.cpp,"    else
      tls_rt_name = """";

    msg_type = *(char*)buf;
    msg_name = ssl_msg_type(ssl_ver, msg_type);

    txt_len = snprintf(ssl_buf, sizeof(ssl_buf), ""%s (%s), %s, %s (%d):\n"",
","    else
      tls_rt_name = """";

    msg_type = *(char *)buf;
    msg_name = ssl_msg_type(ssl_ver, msg_type);

    txt_len = snprintf(ssl_buf, sizeof(ssl_buf), ""%s (%s), %s, %s (%d):\n"",
",1571,1567,[6],[]
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_102.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_102.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_210.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_210.cpp,"
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
","
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          *certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
",2198,2255,[4],[]
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/x509asn1.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_103.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_103.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_211.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_211.cpp,"  return strdup(*beg? ""TRUE"": ""FALSE"");
}

static const char * octet2str(const char * beg, const char * end)
{
  size_t n = end - beg;
  char * buf;

  /* Convert an ASN.1 octet string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */

  buf = malloc(3 * n + 1);
  if(buf)
    for(n = 0; beg < end; n += 3)
      snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++);
  return buf;
}

static const char * bit2str(const char * beg, const char * end)
{
  /* Convert an ASN.1 bit string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */
","  return strdup(*beg? ""TRUE"": ""FALSE"");
}

static const char *octet2str(const char *beg, const char *end)
{
  size_t n = end - beg;
  char *buf = NULL;

  /* Convert an ASN.1 octet string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */

  if(n <= (CURL_SIZE_T_MAX - 1) / 3) {
    buf = malloc(3 * n + 1);
    if(buf)
      for(n = 0; beg < end; n += 3)
        snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++);
  }
  return buf;
}

static const char *bit2str(const char *beg, const char *end)
{
  /* Convert an ASN.1 bit string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */
",195,198,[14],[]
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_104.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_104.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_212.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_212.cpp,"        *fptr = 0;

        if(width >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr += len;
          left -= len;
        }
        if(prec >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr += len;
","        *fptr = 0;

        if(width >= 0) {
          if(width >= (long)sizeof(work))
            width = sizeof(work)-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr += len;
          left -= len;
        }
        if(prec >= 0) {
          /* for each digit in the integer part, we can have one less
             precision */
          size_t maxprec = sizeof(work) - 2;
          double val = p->data.dnum;
          while(val >= 10.0) {
            val /= 10;
            maxprec--;
          }

          if(prec > (long)maxprec)
            prec = (long)maxprec-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr += len;
",917,917,"[4, 10]",[]
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/socks_gssapi.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_105.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_105.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_213.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_213.cpp,"
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.value = malloc(strlen(serviceptr));
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr);
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(strlen(serviceptr) +strlen(conn->proxy.name)+2);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr) +strlen(conn->proxy.name)+1;
    snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
","
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.length = serviceptr_length;
    service.value = malloc(service.length);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(serviceptr_length +
                           strlen(conn->socks_proxy.host.name)+2);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = serviceptr_length + strlen(conn->socks_proxy.host.name)+1;
    snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->socks_proxy.host.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
",134,135,[17],[]
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/telnet.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_106.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_106.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_214.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_214.cpp,"  struct TELNET *tn = (struct TELNET *)data->req.protop;

  printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn)+2);
  switch (CURL_SB_GET(tn)) {
    case CURL_TELOPT_TTYPE:
      len = strlen(tn->subopt_ttype) + 4 + 2;
      snprintf((char *)temp, sizeof(temp),
","  struct TELNET *tn = (struct TELNET *)data->req.protop;

  printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn)+2);
  switch(CURL_SB_GET(tn)) {
    case CURL_TELOPT_TTYPE:
      len = strlen(tn->subopt_ttype) + 4 + 2;
      snprintf((char *)temp, sizeof(temp),
",935,935,[6],[]
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_107.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_107.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_215.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_215.cpp,"    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
","    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
",387,388,[9],[]
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/vtls/darwinssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_108.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_108.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_216.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_216.cpp,"    else {
      CURLcode result;
      ssl_sessionid =
        aprintf(""%s:%d:%d:%s:%hu"", data->set.str[STRING_SSL_CAFILE],
                data->set.ssl.verifypeer, data->set.ssl.verifyhost,
                conn->host.name, conn->remote_port);
      ssl_sessionid_len = strlen(ssl_sessionid);

      err = SSLSetPeerID(connssl->ssl_ctx, ssl_sessionid, ssl_sessionid_len);
","    else {
      CURLcode result;
      ssl_sessionid =
        aprintf(""%s:%d:%d:%s:%hu"", ssl_cafile,
                verifypeer, SSL_CONN_CONFIG(verifyhost), hostname, port);
      ssl_sessionid_len = strlen(ssl_sessionid);

      err = SSLSetPeerID(connssl->ssl_ctx, ssl_sessionid, ssl_sessionid_len);
",1504,1563,[3],[]
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_109.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_109.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_217.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_217.cpp,"    else
      tls_rt_name = """";

    msg_type = *(char*)buf;
    msg_name = ssl_msg_type(ssl_ver, msg_type);

    txt_len = snprintf(ssl_buf, sizeof(ssl_buf), ""%s (%s), %s, %s (%d):\n"",
","    else
      tls_rt_name = """";

    msg_type = *(char *)buf;
    msg_name = ssl_msg_type(ssl_ver, msg_type);

    txt_len = snprintf(ssl_buf, sizeof(ssl_buf), ""%s (%s), %s, %s (%d):\n"",
",1571,1567,[6],[]
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_109.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_109.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_218.cpp,"
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
","
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          *certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
",2198,2255,[4],[]
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/x509asn1.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_110.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_110.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_219.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_219.cpp,"  return strdup(*beg? ""TRUE"": ""FALSE"");
}

static const char * octet2str(const char * beg, const char * end)
{
  size_t n = end - beg;
  char * buf;

  /* Convert an ASN.1 octet string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */

  buf = malloc(3 * n + 1);
  if(buf)
    for(n = 0; beg < end; n += 3)
      snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++);
  return buf;
}

static const char * bit2str(const char * beg, const char * end)
{
  /* Convert an ASN.1 bit string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */
","  return strdup(*beg? ""TRUE"": ""FALSE"");
}

static const char *octet2str(const char *beg, const char *end)
{
  size_t n = end - beg;
  char *buf = NULL;

  /* Convert an ASN.1 octet string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */

  if(n <= (CURL_SIZE_T_MAX - 1) / 3) {
    buf = malloc(3 * n + 1);
    if(buf)
      for(n = 0; beg < end; n += 3)
        snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++);
  }
  return buf;
}

static const char *bit2str(const char *beg, const char *end)
{
  /* Convert an ASN.1 bit string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */
",195,198,[14],[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_220.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_220.cpp,"
/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO fwrite( yytext, yyleng, 1, yyout )
#endif

/* Gets input and stuffs it into ""buf"".  number of characters read, or YY_NULL,
 * is returned in ""result"".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
        if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
                { \
                int c = '*'; \
                size_t n; \
                for ( n = 0; n < max_size && \
                             (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
                        buf[n] = (char) c; \
                if ( c == '\n' ) \
                        buf[n++] = (char) c; \
                if ( c == EOF && ferror( yyin ) ) \
                        YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
                result = n; \
                } \
        else \
                { \
                errno=0; \
                while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
                        { \
                        if( errno != EINTR) \
                                { \
                                YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
                                break; \
                                } \
                        errno=0; \
                        clearerr(yyin); \
                        } \
                }\
\

#endif
","
/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
#endif

/* Gets input and stuffs it into ""buf"".  number of characters read, or YY_NULL,
 * is returned in ""result"".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
		{ \
		int c = '*'; \
		size_t n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = (int) fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
				break; \
				} \
			errno=0; \
			clearerr(yyin); \
			} \
		}\
\

#endif
",615,600,"[29, 39]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_221.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_221.cpp,"
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
        YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
        yy_state_type yy_current_state;
        char *yy_cp, *yy_bp;
        int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 64 ""cmCommandArgumentLexer.in.l""


#line 732 ""cmCommandArgumentLexer.cxx""

        if ( !yyg->yy_init )
                {
                yyg->yy_init = 1;

#ifdef YY_USER_INIT
                YY_USER_INIT;
#endif

                if ( ! yyg->yy_start )
                        yyg->yy_start = 1;      /* first start state */

                if ( ! yyin )
                        yyin = stdin;

                if ( ! yyout )
                        yyout = stdout;

                if ( ! YY_CURRENT_BUFFER ) {
                        cmCommandArgument_yyensure_buffer_stack (yyscanner);
                        YY_CURRENT_BUFFER_LVALUE =
                                cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
                }

                cmCommandArgument_yy_load_buffer_state(yyscanner );
                }

        for(;;)             /* loops until end-of-file is reached */
                {
                yy_cp = yyg->yy_c_buf_p;

                /* Support of yytext. */
                *yy_cp = yyg->yy_hold_char;

                /* yy_bp points to the position in yy_ch_buf of the start of
                 * the current run.
                 */
                yy_bp = yy_cp;

                yy_current_state = yyg->yy_start;
yy_match:
                do
                        {
                        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
                        if ( yy_accept[yy_current_state] )
                                {
                                yyg->yy_last_accepting_state = yy_current_state;
                                yyg->yy_last_accepting_cpos = yy_cp;
                                }
                        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                                {
                                yy_current_state = (int) yy_def[yy_current_state];
                                if ( yy_current_state >= 30 )
                                        yy_c = yy_meta[(unsigned int) yy_c];
                                }
                        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
                        ++yy_cp;
                        }
                while ( yy_base[yy_current_state] != 41 );

yy_find_action:
                yy_act = yy_accept[yy_current_state];
                if ( yy_act == 0 )
                        { /* have to back up */
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        yy_act = yy_accept[yy_current_state];
                        }

                YY_DO_BEFORE_ACTION;

do_action:      /* This label is used only to access EOF actions. */

                switch ( yy_act )
        { /* beginning of action switch */
                        case 0: /* must back up */
                        /* undo the effects of YY_DO_BEFORE_ACTION */
                        *yy_cp = yyg->yy_hold_char;
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 66 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ENVCURLY;
}
case 2:
YY_RULE_SETUP
#line 72 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_NCURLY;
}
case 3:
YY_RULE_SETUP
#line 78 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ATNAME;
}
case 4:
YY_RULE_SETUP
#line 84 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
case 5:
YY_RULE_SETUP
#line 91 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
case 6:
YY_RULE_SETUP
#line 98 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
case 7:
YY_RULE_SETUP
#line 105 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
case 8:
YY_RULE_SETUP
#line 111 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytext+1)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 119 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
case 10:
YY_RULE_SETUP
#line 125 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
case 11:
YY_RULE_SETUP
#line 131 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
case 12:
YY_RULE_SETUP
#line 137 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
case 13:
YY_RULE_SETUP
#line 143 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
case 14:
YY_RULE_SETUP
#line 149 ""cmCommandArgumentLexer.in.l""
ECHO;
        YY_BREAK
#line 943 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
        yyterminate();

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmCommandArgument_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ++yyg->yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmCommandArgument_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr + yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
return 0; /* this should not happen but it quiets some compilers */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ++i )
                *(dest++) = *(source++);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        int num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size += b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, (size_t) num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmCommandArgument_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars += number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;

        for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 30 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 30 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 29);

        return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if ( !yyg->yy_init )
		{
		yyg->yy_init = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yyg->yy_start )
			yyg->yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			cmCommandArgument_yyensure_buffer_stack (yyscanner);
			YY_CURRENT_BUFFER_LVALUE =
				cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
		}

		cmCommandArgument_yy_load_buffer_state(yyscanner );
		}

	{
#line 42 ""cmCommandArgumentLexer.in.l""


#line 740 ""cmCommandArgumentLexer.cxx""

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yyg->yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yyg->yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yyg->yy_start;
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				yyg->yy_last_accepting_state = yy_current_state;
				yyg->yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 30 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 41 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yyg->yy_hold_char;
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 44 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ENVCURLY;
}
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 50 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_NCURLY;
}
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 56 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ATNAME;
}
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 62 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 69 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 76 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 83 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 89 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytext+1)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
	YY_BREAK
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 97 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 103 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 109 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 115 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 121 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 127 ""cmCommandArgumentLexer.in.l""
ECHO;
	YY_BREAK
#line 925 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yyg->yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * cmCommandArgument_yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p ""<="" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state( yyscanner );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yyg->yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yyg->yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer( yyscanner ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yyg->yy_did_buffer_switch_on_eof = 0;

				if ( cmCommandArgument_yywrap(yyscanner ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yyg->yy_c_buf_p =
					yyg->yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yyg->yy_c_buf_p =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			""fatal flex scanner internal error--no action found"" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = yyg->yytext_ptr;
	yy_size_t number_to_move, i;
	int ret_val;

	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
		YY_FATAL_ERROR(
		""fatal flex scanner internal error--end of buffer missed"" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				""fatal error - scanner input buffer overflow"" );

			yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			yyg->yy_n_chars, num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	if ( yyg->yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			cmCommandArgument_yyrestart(yyin  ,yyscanner);
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((int) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
	}

	yyg->yy_n_chars += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
	yy_state_type yy_current_state;
	char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	yy_current_state = yyg->yy_start;

	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yyg->yy_last_accepting_state = yy_current_state;
			yyg->yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 30 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
	int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
	char *yy_cp = yyg->yy_c_buf_p;

	YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yyg->yy_last_accepting_state = yy_current_state;
		yyg->yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 30 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
	yy_is_jam = (yy_current_state == 29);

	(void)yyg;
	return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",702,692,"[348, 371, 439, 483]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_222.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_222.cpp," */
    YY_BUFFER_STATE cmCommandArgument_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

        b->yy_buf_size = size;

        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        b->yy_ch_buf = (char *) cmCommandArgument_yyalloc(b->yy_buf_size + 2 ,yyscanner );
        if ( ! b->yy_ch_buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

        b->yy_is_our_buffer = 1;

        cmCommandArgument_yy_init_buffer(b,file ,yyscanner);

        return b;
}

/** Destroy the buffer.
"," */
    YY_BUFFER_STATE cmCommandArgument_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

	b->yy_buf_size = (yy_size_t)size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) cmCommandArgument_yyalloc(b->yy_buf_size + 2 ,yyscanner );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

	b->yy_is_our_buffer = 1;

	cmCommandArgument_yy_init_buffer(b,file ,yyscanner);

	return b;
}

/** Destroy the buffer.
",1400,1409,"[7, 16]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_223.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_223.cpp,"void cmCommandArgument_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        if (!YY_CURRENT_BUFFER)
                return;

        cmCommandArgument_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
        YY_CURRENT_BUFFER_LVALUE = NULL;
        if (yyg->yy_buffer_stack_top > 0)
                --yyg->yy_buffer_stack_top;

        if (YY_CURRENT_BUFFER) {
                cmCommandArgument_yy_load_buffer_state(yyscanner );
                yyg->yy_did_buffer_switch_on_eof = 1;
        }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmCommandArgument_yyensure_buffer_stack (yyscan_t yyscanner)
{
        int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (!yyg->yy_buffer_stack) {

                /* First allocation is just for 2 elements, since we don't know if this
                 * scanner will even need a stack. We use 2 instead of 1 to avoid an
                 * immediate realloc on the next call.
         */
                num_to_alloc = 1;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyalloc
                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

                yyg->yy_buffer_stack_max = num_to_alloc;
                yyg->yy_buffer_stack_top = 0;
                return;
        }

        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

                /* Increase the buffer to prepare for a possible push. */
                int grow_size = 8 /* arbitrary grow size */;

                num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyrealloc
                                                                (yyg->yy_buffer_stack,
                                                                num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

                /* zero only the new slots.*/
                memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
                yyg->yy_buffer_stack_max = num_to_alloc;
        }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
","void cmCommandArgument_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	if (!YY_CURRENT_BUFFER)
		return;

	cmCommandArgument_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if (yyg->yy_buffer_stack_top > 0)
		--yyg->yy_buffer_stack_top;

	if (YY_CURRENT_BUFFER) {
		cmCommandArgument_yy_load_buffer_state(yyscanner );
		yyg->yy_did_buffer_switch_on_eof = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmCommandArgument_yyensure_buffer_stack (yyscan_t yyscanner)
{
	int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if (!yyg->yy_buffer_stack) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
		yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

		yyg->yy_buffer_stack_max = num_to_alloc;
		yyg->yy_buffer_stack_top = 0;
		return;
	}

	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
		yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyrealloc
								(yyg->yy_buffer_stack,
								num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

		/* zero only the new slots.*/
		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
		yyg->yy_buffer_stack_max = num_to_alloc;
	}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
",1543,1548,"[36, 56]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_224.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_224.cpp," */
YY_BUFFER_STATE cmCommandArgument_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        if ( size < 2 ||
             base[size-2] != YY_END_OF_BUFFER_CHAR ||
             base[size-1] != YY_END_OF_BUFFER_CHAR )
                /* They forgot to leave room for the EOB's. */
                return 0;

        b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_buffer()"" );

        b->yy_buf_size = size - 2;      /* ""- 2"" to take care of EOB's */
        b->yy_buf_pos = b->yy_ch_buf = base;
        b->yy_is_our_buffer = 0;
        b->yy_input_file = 0;
        b->yy_n_chars = b->yy_buf_size;
        b->yy_is_interactive = 0;
        b->yy_at_bol = 1;
        b->yy_fill_buffer = 0;
        b->yy_buffer_status = YY_BUFFER_NEW;

        cmCommandArgument_yy_switch_to_buffer(b ,yyscanner );

        return b;
}

/** Setup the input buffer state to scan a string. The next call to cmCommandArgument_yylex() will
"," */
YY_BUFFER_STATE cmCommandArgument_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;

	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return NULL;

	b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_buffer()"" );

	b->yy_buf_size = size - 2;	/* ""- 2"" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = NULL;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	cmCommandArgument_yy_switch_to_buffer(b ,yyscanner );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to cmCommandArgument_yylex() will
",1612,1617,[13],[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_225.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_225.cpp,"YY_BUFFER_STATE cmCommandArgument_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

        return cmCommandArgument_yy_scan_bytes(yystr,strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmCommandArgument_yylex() will
 * scan from a @e copy of @a yybytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmCommandArgument_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;
        char *buf;
        yy_size_t n;
        int i;

        /* Get memory for full buffer, including space for trailing EOB's. */
        n = _yybytes_len + 2;
        buf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );
        if ( ! buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" );

        for ( i = 0; i < _yybytes_len; ++i )
                buf[i] = yybytes[i];

        buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

        b = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);
        if ( ! b )
                YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" );

        /* It's okay to grow etc. this buffer, and we should throw it
         * away when we're done.
         */
        b->yy_is_our_buffer = 1;

        return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
                yytext[yyleng] = yyg->yy_hold_char; \
                yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
                yyg->yy_hold_char = *yyg->yy_c_buf_p; \
                *yyg->yy_c_buf_p = '\0'; \
                yyleng = yyless_macro_arg; \
                } \
        while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

","YY_BUFFER_STATE cmCommandArgument_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

	return cmCommandArgument_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmCommandArgument_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmCommandArgument_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	yy_size_t i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (yy_size_t) _yybytes_len + 2;
	buf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );
	if ( ! buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" );

	for ( i = 0; i < (size_t)_yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);
	if ( ! b )
		YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	(void) fprintf( stderr, ""%s\n"", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = yyg->yy_hold_char; \
		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
		*yyg->yy_c_buf_p = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1650,1655,"[24, 33, 49]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_226.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_226.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmCommandArgument_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmCommandArgument_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmCommandArgument_yy_switch_to_buffer
 */
void cmCommandArgument_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmCommandArgument_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmCommandArgument_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmCommandArgument_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmCommandArgument_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmCommandArgument_yy_switch_to_buffer
 */
void cmCommandArgument_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmCommandArgument_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmCommandArgument_yyget_debug  (yyscan_t yyscanner)
",1802,1809,"[12, 27]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_227.cpp,"
/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
#endif

/* Gets input and stuffs it into ""buf"".  number of characters read, or YY_NULL,
 * is returned in ""result"".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
  if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
    { \
    int c = '*'; \
    size_t n; \
    for ( n = 0; n < max_size && \
           (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
      buf[n] = (char) c; \
    if ( c == '\n' ) \
      buf[n++] = (char) c; \
    if ( c == EOF && ferror( yyin ) ) \
      YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
    result = n; \
    } \
  else \
    { \
    errno=0; \
    while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
      { \
      if( errno != EINTR) \
        { \
        YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
        break; \
        } \
      errno=0; \
      clearerr(yyin); \
      } \
    }\
\

#endif
","
/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
#endif

/* Gets input and stuffs it into ""buf"".  number of characters read, or YY_NULL,
 * is returned in ""result"".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
		{ \
		int c = '*'; \
		size_t n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = (int) fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
				break; \
				} \
			errno=0; \
			clearerr(yyin); \
			} \
		}\
\

#endif
",589,592,"[29, 39]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_228.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_228.cpp,"
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
  YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
  yy_state_type yy_current_state;
  char *yy_cp, *yy_bp;
  int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 86 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""


#line 736 ""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx""

  if ( yyg->yy_init )
    {
    yyg->yy_init = 0;

#ifdef YY_USER_INIT
    YY_USER_INIT;
#endif

    if ( ! yyg->yy_start )
      yyg->yy_start = 1;  /* first start state */

    if ( ! yyin )
      yyin = stdin;

    if ( ! yyout )
      yyout = stdout;

    if ( ! YY_CURRENT_BUFFER ) {
      cmExpr_yyensure_buffer_stack (yyscanner);
      YY_CURRENT_BUFFER_LVALUE =
        cmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
    }

    cmExpr_yy_load_buffer_state(yyscanner );
    }

  for(;;)    /* loops until end-of-file is reached */
    {
    yy_cp = yyg->yy_c_buf_p;

    /* Support of yytext. */
    *yy_cp = yyg->yy_hold_char;

    /* yy_bp points to the position in yy_ch_buf of the start of
     * the current run.
     */
    yy_bp = yy_cp;

    yy_current_state = yyg->yy_start;
yy_match:
    do
      {
      YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
      if ( yy_accept[yy_current_state] )
        {
        yyg->yy_last_accepting_state = yy_current_state;
        yyg->yy_last_accepting_cpos = yy_cp;
        }
      while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        {
        yy_current_state = (int) yy_def[yy_current_state];
        if ( yy_current_state >= 23 )
          yy_c = yy_meta[(unsigned int) yy_c];
        }
      yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
      ++yy_cp;
      }
    while ( yy_base[yy_current_state] != 21 );

yy_find_action:
    yy_act = yy_accept[yy_current_state];
    if ( yy_act == 0 )
      { /* have to back up */
      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;
      yy_act = yy_accept[yy_current_state];
      }

    YY_DO_BEFORE_ACTION;

do_action:  /* This label is used only to access EOF actions. */

    switch ( yy_act )
  { /* beginning of action switch */
      case 0: /* must back up */
      /* undo the effects of YY_DO_BEFORE_ACTION */
      *yy_cp = yyg->yy_hold_char;
      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;
      goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 88 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ yylvalp->Number = atoi(yytext); return exp_NUMBER; }
case 2:
YY_RULE_SETUP
#line 90 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_PLUS; }
case 3:
YY_RULE_SETUP
#line 91 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_MINUS; }
case 4:
YY_RULE_SETUP
#line 92 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_TIMES; }
case 5:
YY_RULE_SETUP
#line 93 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_DIVIDE; }
case 6:
YY_RULE_SETUP
#line 94 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_MOD; }
case 7:
YY_RULE_SETUP
#line 95 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_OR; }
case 8:
YY_RULE_SETUP
#line 96 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_AND; }
case 9:
YY_RULE_SETUP
#line 97 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_XOR; }
case 10:
YY_RULE_SETUP
#line 98 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_NOT; }
case 11:
YY_RULE_SETUP
#line 99 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_SHIFTLEFT; }
case 12:
YY_RULE_SETUP
#line 100 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_SHIFTRIGHT; }
case 13:
YY_RULE_SETUP
#line 101 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_OPENPARENT; }
case 14:
YY_RULE_SETUP
#line 102 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_CLOSEPARENT; }
case 15:
YY_RULE_SETUP
#line 104 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
ECHO;
  YY_BREAK
#line 894 ""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx""
case YY_STATE_EOF(INITIAL):
  yyterminate();

  case YY_END_OF_BUFFER:
    {
    /* Amount of text matched not including the EOB char. */
    int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

    /* Undo the effects of YY_DO_BEFORE_ACTION. */
    *yy_cp = yyg->yy_hold_char;
    YY_RESTORE_YY_MORE_OFFSET

    if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
      {
      /* We're scanning a new file or input source.  It's
       * possible that this happened because the user
       * just pointed yyin at a new source and called
       * cmExpr_yylex().  If so, then we have to assure
       * consistency between YY_CURRENT_BUFFER and our
       * globals.  Here is the right place to do so, because
       * this is the first action (other than possibly a
       * back-up) that will match for the new input source.
       */
      yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
      YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
      }

    /* Note that here we test for yy_c_buf_p ""<="" to the position
     * of the first EOB in the buffer, since yy_c_buf_p will
     * already have been incremented past the NUL character
     * (since all states make transitions on EOB to the
     * end-of-buffer state).  Contrast this with the test
     * in input().
     */
    if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
      { /* This was really a NUL. */
      yy_state_type yy_next_state;

      yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

      yy_current_state = yy_get_previous_state( yyscanner );

      /* Okay, we're now positioned to make the NUL
       * transition.  We couldn't have
       * yy_get_previous_state() go ahead and do it
       * for us because it doesn't know how to deal
       * with the possibility of jamming (and we don't
       * want to build jamming into it because then it
       * will run more slowly).
       */

      yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

      yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

      if ( yy_next_state )
        {
        /* Consume the NUL. */
        yy_cp = ++yyg->yy_c_buf_p;
        yy_current_state = yy_next_state;
        goto yy_match;
        }

      else
        {
        yy_cp = yyg->yy_c_buf_p;
        goto yy_find_action;
        }
      }

    else switch ( yy_get_next_buffer( yyscanner ) )
      {
      case EOB_ACT_END_OF_FILE:
        {
        yyg->yy_did_buffer_switch_on_eof = 0;

        if ( cmExpr_yywrap(yyscanner ) )
          {
          /* Note: because we've taken care in
           * yy_get_next_buffer() to have set up
           * yytext, we can now set up
           * yy_c_buf_p so that if some total
           * hoser (like flex itself) wants to
           * call the scanner after we return the
           * YY_NULL, it'll still work - another
           * YY_NULL will get returned.
           */
          yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

          yy_act = YY_STATE_EOF(YY_START);
          goto do_action;
          }

        else
          {
          if ( ! yyg->yy_did_buffer_switch_on_eof )
            YY_NEW_FILE;
          }
        break;
        }

      case EOB_ACT_CONTINUE_SCAN:
        yyg->yy_c_buf_p =
          yyg->yytext_ptr + yy_amount_of_matched_text;

        yy_current_state = yy_get_previous_state( yyscanner );

        yy_cp = yyg->yy_c_buf_p;
        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
        goto yy_match;

      case EOB_ACT_LAST_MATCH:
        yyg->yy_c_buf_p =
        &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

        yy_current_state = yy_get_previous_state( yyscanner );

        yy_cp = yyg->yy_c_buf_p;
        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
        goto yy_find_action;
      }
    break;
    }

  default:
    YY_FATAL_ERROR(
      ""fatal flex scanner internal error--no action found"" );
  } /* end of action switch */
    } /* end of scanning one token */
return 0; /* this should not happen but it quiets some compilers */
} /* end of cmExpr_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  char *source = yyg->yytext_ptr;
  int number_to_move, i;
  int ret_val;

  if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
    YY_FATAL_ERROR(
    ""fatal flex scanner internal error--end of buffer missed"" );

  if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
    { /* Don't try to fill the buffer, so this is an EOF. */
    if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
      {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
      }

    else
      {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
      }
    }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

  for ( i = 0; i < number_to_move; ++i )
    *(dest++) = *(source++);

  if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

  else
    {
      size_t nuto_read =
      YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

    while ( nuto_read <= 0 )
      { /* Not enough room in the buffer - grow it. */

      /* just a shorter name for the current buffer */
      YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

      int yy_c_buf_p_offset =
        (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

      if ( b->yy_is_our_buffer )
        {
        int new_size = b->yy_buf_size * 2;

        if ( new_size <= 0 )
          b->yy_buf_size += b->yy_buf_size / 8;
        else
          b->yy_buf_size *= 2;

        b->yy_ch_buf = (char *)
          /* Include room in for 2 EOB chars. */
          cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
        }
      else
        /* Can't grow it, we don't own it. */
        b->yy_ch_buf = 0;

      if ( ! b->yy_ch_buf )
        YY_FATAL_ERROR(
        ""fatal error - scanner input buffer overflow"" );

      yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

      nuto_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
            number_to_move - 1;

      }

    if ( nuto_read > YY_READ_BUF_SIZE )
      nuto_read = YY_READ_BUF_SIZE;

    /* Read in more data. */
    YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
      yyg->yy_n_chars, nuto_read );

    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
    }

  if ( yyg->yy_n_chars == 0 )
    {
    if ( number_to_move == YY_MORE_ADJ )
      {
      ret_val = EOB_ACT_END_OF_FILE;
      cmExpr_yyrestart(yyin  ,yyscanner);
      }

    else
      {
      ret_val = EOB_ACT_LAST_MATCH;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
        YY_BUFFER_EOF_PENDING;
      }
    }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  yyg->yy_n_chars += number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

  yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was
   reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
  yy_state_type yy_current_state;
  char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

  yy_current_state = yyg->yy_start;

  for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
    {
    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    if ( yy_accept[yy_current_state] )
      {
      yyg->yy_last_accepting_state = yy_current_state;
      yyg->yy_last_accepting_cpos = yy_cp;
      }
    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
      {
      yy_current_state = (int) yy_def[yy_current_state];
      if ( yy_current_state >= 23 )
        yy_c = yy_meta[(unsigned int) yy_c];
      }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
    }

  return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
  int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  char *yy_cp = yyg->yy_c_buf_p;

  YY_CHAR yy_c = 1;
  if ( yy_accept[yy_current_state] )
    {
    yyg->yy_last_accepting_state = yy_current_state;
    yyg->yy_last_accepting_cpos = yy_cp;
    }
  while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
    {
    yy_current_state = (int) yy_def[yy_current_state];
    if ( yy_current_state >= 23 )
      yy_c = yy_meta[(unsigned int) yy_c];
    }
  yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
  yy_is_jam = (yy_current_state == 22);

  return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if ( !yyg->yy_init )
		{
		yyg->yy_init = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yyg->yy_start )
			yyg->yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			cmExpr_yyensure_buffer_stack (yyscanner);
			YY_CURRENT_BUFFER_LVALUE =
				cmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
		}

		cmExpr_yy_load_buffer_state(yyscanner );
		}

	{
#line 39 ""cmExprLexer.in.l""


#line 732 ""cmExprLexer.cxx""

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yyg->yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yyg->yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yyg->yy_start;
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				yyg->yy_last_accepting_state = yy_current_state;
				yyg->yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 23 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 21 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yyg->yy_hold_char;
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 41 ""cmExprLexer.in.l""
{ yylvalp->Number = atoi(yytext); return exp_NUMBER; }
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 43 ""cmExprLexer.in.l""
{ return exp_PLUS; }
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 44 ""cmExprLexer.in.l""
{ return exp_MINUS; }
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 45 ""cmExprLexer.in.l""
{ return exp_TIMES; }
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 46 ""cmExprLexer.in.l""
{ return exp_DIVIDE; }
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 47 ""cmExprLexer.in.l""
{ return exp_MOD; }
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 48 ""cmExprLexer.in.l""
{ return exp_OR; }
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 49 ""cmExprLexer.in.l""
{ return exp_AND; }
	YY_BREAK
case 9:
YY_RULE_SETUP
#line 50 ""cmExprLexer.in.l""
{ return exp_XOR; }
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 51 ""cmExprLexer.in.l""
{ return exp_NOT; }
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 52 ""cmExprLexer.in.l""
{ return exp_SHIFTLEFT; }
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 53 ""cmExprLexer.in.l""
{ return exp_SHIFTRIGHT; }
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 54 ""cmExprLexer.in.l""
{ return exp_OPENPARENT; }
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 55 ""cmExprLexer.in.l""
{ return exp_CLOSEPARENT; }
	YY_BREAK
case 15:
YY_RULE_SETUP
#line 57 ""cmExprLexer.in.l""
ECHO;
	YY_BREAK
#line 864 ""cmExprLexer.cxx""
case YY_STATE_EOF(INITIAL):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yyg->yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * cmExpr_yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p ""<="" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state( yyscanner );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yyg->yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yyg->yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer( yyscanner ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yyg->yy_did_buffer_switch_on_eof = 0;

				if ( cmExpr_yywrap(yyscanner ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yyg->yy_c_buf_p =
					yyg->yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yyg->yy_c_buf_p =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			""fatal flex scanner internal error--no action found"" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of cmExpr_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = yyg->yytext_ptr;
	yy_size_t number_to_move, i;
	int ret_val;

	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
		YY_FATAL_ERROR(
		""fatal flex scanner internal error--end of buffer missed"" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				""fatal error - scanner input buffer overflow"" );

			yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			yyg->yy_n_chars, num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	if ( yyg->yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			cmExpr_yyrestart(yyin  ,yyscanner);
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((int) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmExpr_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
	}

	yyg->yy_n_chars += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
	yy_state_type yy_current_state;
	char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	yy_current_state = yyg->yy_start;

	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yyg->yy_last_accepting_state = yy_current_state;
			yyg->yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 23 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
	int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
	char *yy_cp = yyg->yy_c_buf_p;

	YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yyg->yy_last_accepting_state = yy_current_state;
		yyg->yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 23 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
	yy_is_jam = (yy_current_state == 22);

	(void)yyg;
	return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
	char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

	/* undo effects of setting up yytext */
	*yy_cp = yyg->yy_hold_char;

	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		int number_to_move = yyg->yy_n_chars + 2;
		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
		char *source =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
		}

	*--yy_cp = (char) c;

	yyg->yytext_ptr = yy_bp;
	yyg->yy_hold_char = *yy_cp;
	yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",676,684,"[292, 315, 383]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_229.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_229.cpp," */
    YY_BUFFER_STATE cmExpr_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;

  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
  if ( ! b )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->yy_ch_buf = (char *) cmExpr_yyalloc(b->yy_buf_size + 2 ,yyscanner );
  if ( ! b->yy_ch_buf )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

  b->yy_is_our_buffer = 1;

  cmExpr_yy_init_buffer(b,file ,yyscanner);

  return b;
}

/** Destroy the buffer.
"," */
    YY_BUFFER_STATE cmExpr_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

	b->yy_buf_size = (yy_size_t)size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) cmExpr_yyalloc(b->yy_buf_size + 2 ,yyscanner );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

	b->yy_is_our_buffer = 1;

	cmExpr_yy_init_buffer(b,file ,yyscanner);

	return b;
}

/** Destroy the buffer.
",1311,1384,"[7, 16]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_230.cpp," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;

  if ( size < 2 ||
       base[size-2] != YY_END_OF_BUFFER_CHAR ||
       base[size-1] != YY_END_OF_BUFFER_CHAR )
    /* They forgot to leave room for the EOB's. */
    return 0;

  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
  if ( ! b )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

  b->yy_buf_size = size - 2;  /* ""- 2"" to take care of EOB's */
  b->yy_buf_pos = b->yy_ch_buf = base;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = 0;
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = YY_BUFFER_NEW;

  cmExpr_yy_switch_to_buffer(b ,yyscanner );

  return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a yy_str.
 * @param yy_str a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yy_str , yyscan_t yyscanner)
{

  return cmExpr_yy_scan_bytes(yy_str,strlen(yy_str) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param bytes the byte buffer to scan
 * @param len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * bytes, int  len , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;
  char *buf;
  yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = len + 2;
  buf = (char *) cmExpr_yyalloc(n ,yyscanner );
  if ( ! buf )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

  for ( i = 0; i < len; ++i )
    buf[i] = bytes[i];

  buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;

  b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
  if ( ! b )
    YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->yy_is_our_buffer = 1;

  return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
      (void) fprintf( stderr, ""%s\n"", msg );
  exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
  do \
    { \
    /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
    yytext[yyleng] = yyg->yy_hold_char; \
    yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
    yyg->yy_hold_char = *yyg->yy_c_buf_p; \
    *yyg->yy_c_buf_p = '\0'; \
    yyleng = yyless_macro_arg; \
    } \
  while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

"," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;

	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return NULL;

	b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

	b->yy_buf_size = size - 2;	/* ""- 2"" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = NULL;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	cmExpr_yy_switch_to_buffer(b ,yyscanner );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

	return cmExpr_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	yy_size_t i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (yy_size_t) _yybytes_len + 2;
	buf = (char *) cmExpr_yyalloc(n ,yyscanner );
	if ( ! buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

	for ( i = 0; i < (size_t)_yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
	if ( ! b )
		YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	(void) fprintf( stderr, ""%s\n"", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = yyg->yy_hold_char; \
		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
		*yyg->yy_c_buf_p = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1519,1592,"[13, 62, 71, 87]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_231.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmExpr_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmExpr_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmExpr_yy_switch_to_buffer
 */
void cmExpr_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmExpr_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmExpr_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmExpr_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmExpr_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmExpr_yy_switch_to_buffer
 */
void cmExpr_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmExpr_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmExpr_yyget_debug  (yyscan_t yyscanner)
",1709,1784,"[12, 27]",[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_232.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_232.cpp,"				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = 0;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
","				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
",1421,1415,[6],[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_233.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_233.cpp,"		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
","		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
",1567,1561,[6],[]
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_234.cpp," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	yy_size_t i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = _yybytes_len + 2;
	buf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );
	if ( ! buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" );

	for ( i = 0; i < _yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
"," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	yy_size_t i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (yy_size_t) _yybytes_len + 2;
	buf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );
	if ( ! buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" );

	for ( i = 0; i < (size_t)_yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
",1996,1990,[14],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_235.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_235.cpp,"  return CURLE_OK;
}

#ifdef USE_LIBIDN
/*
 * Initialise use of IDNA library.
 * It falls back to ASCII if $CHARSET isn't defined. This doesn't work for
 * idna_to_ascii_lz().
 */
static void idna_init (void)
{
#ifdef WIN32
  char buf[60];
  UINT cp = GetACP();

  if(!getenv(""CHARSET"") && cp > 0) {
    snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);
    putenv(buf);
  }
#else
  /* to do? */
#endif
}
#endif  /* USE_LIBIDN */

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
","  return CURLE_OK;
}

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
",144,143,[16],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_236.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_236.cpp,"  }
#endif

#ifdef USE_LIBIDN
  idna_init();
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
","  }
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
",262,239,[8],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/formdata.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_115.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_115.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_237.cpp,"                             curl_off_t *size,
                             const char *fmt, ...)
{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(s, sizeof(s), fmt, ap);
  va_end(ap);

  return AddFormData(formp, FORM_DATA, s, 0, size);
}

/*
","                             curl_off_t *size,
                             const char *fmt, ...)
{
  char *s;
  CURLcode result;
  va_list ap;
  va_start(ap, fmt);
  s = curl_mvaprintf(fmt, ap);
  va_end(ap);

  if(!s)
    return CURLE_OUT_OF_MEMORY;

  result = AddFormData(formp, FORM_DATAMEM, s, 0, size);
  if(result)
    free(s);

  return result;
}

/*
",906,914,[6],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_116.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_116.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_238.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_238.cpp,"  enum protection_level data_sec = conn->data_prot;
#endif

  va_list ap;
  va_start(ap, fmt);
  write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);
  va_end(ap);

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len +=2;
","  enum protection_level data_sec = conn->data_prot;
#endif

  write_len = strlen(cmd);
  if(write_len > (sizeof(s) -3))
    return CURLE_BAD_FUNCTION_ARGUMENT;

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len +=2;
",4107,4103,[5],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/security.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_117.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_117.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_239.cpp,"  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsendf(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
","  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsend(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
",122,122,[0],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/ssh.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_118.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_118.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_240.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_240.cpp,"        sshc->acceptfail = TRUE;
      }

      if(curl_strequal(""pwd"", cmd)) {
        /* output debug output if that is requested */
        char *tmp = aprintf(""257 \""%s\"" is current directory.\n"",
                            sftp_scp->path);
","        sshc->acceptfail = TRUE;
      }

      if(strcasecompare(""pwd"", cmd)) {
        /* output debug output if that is requested */
        char *tmp = aprintf(""257 \""%s\"" is current directory.\n"",
                            sftp_scp->path);
",1233,1233,[5],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/tftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_119.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_119.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_241.cpp,"    /* As RFC3617 describes the separator slash is not actually part of the
       file name so we skip the always-present first letter of the path
       string. */
    filename = curl_easy_unescape(data, &state->conn->data->state.path[1], 0,
                                  NULL);
    if(!filename)
      return CURLE_OUT_OF_MEMORY;

    snprintf((char *)state->spacket.data+2,
             state->blksize,
","    /* As RFC3617 describes the separator slash is not actually part of the
       file name so we skip the always-present first letter of the path
       string. */
    result = Curl_urldecode(data, &state->conn->data->state.path[1], 0,
                            &filename, NULL, FALSE);
    if(result)
      return result;

    snprintf((char *)state->spacket.data+2,
             state->blksize,
",484,485,[8],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_120.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_120.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_242.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_242.cpp,"
  md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
","
  md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath);

  if(digest->qop && strcasecompare(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
",730,744,[1],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/version.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_121.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_121.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_243.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_243.cpp,"  left -= len;
  ptr += len;
#endif
#ifdef USE_LIBIDN
  if(stringprep_check_version(LIBIDN_REQUIRED_VERSION)) {
    len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));
    left -= len;
    ptr += len;
  }
","  left -= len;
  ptr += len;
#endif
#ifdef USE_LIBIDN2
  if(idn2_check_version(IDN2_VERSION)) {
    len = snprintf(ptr, left, "" libidn2/%s"", idn2_check_version(NULL));
    left -= len;
    ptr += len;
  }
",111,111,[5],[]
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_122.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_122.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_244.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_244.cpp,"
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
","
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
",2178,2198,[3],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_245.cpp,"  return CURLE_OK;
}

#ifdef USE_LIBIDN
/*
 * Initialise use of IDNA library.
 * It falls back to ASCII if $CHARSET isn't defined. This doesn't work for
 * idna_to_ascii_lz().
 */
static void idna_init (void)
{
#ifdef WIN32
  char buf[60];
  UINT cp = GetACP();

  if(!getenv(""CHARSET"") && cp > 0) {
    snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);
    putenv(buf);
  }
#else
  /* to do? */
#endif
}
#endif  /* USE_LIBIDN */

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
","  return CURLE_OK;
}

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
",144,143,[16],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_246.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_246.cpp,"  }
#endif

#ifdef USE_LIBIDN
  idna_init();
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
","  }
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
",262,239,[8],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/formdata.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_124.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_124.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_247.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_247.cpp,"                             curl_off_t *size,
                             const char *fmt, ...)
{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(s, sizeof(s), fmt, ap);
  va_end(ap);

  return AddFormData(formp, FORM_DATA, s, 0, size);
}

/*
","                             curl_off_t *size,
                             const char *fmt, ...)
{
  char *s;
  CURLcode result;
  va_list ap;
  va_start(ap, fmt);
  s = curl_mvaprintf(fmt, ap);
  va_end(ap);

  if(!s)
    return CURLE_OUT_OF_MEMORY;

  result = AddFormData(formp, FORM_DATAMEM, s, 0, size);
  if(result)
    free(s);

  return result;
}

/*
",906,914,[6],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_125.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_125.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_248.cpp,"  enum protection_level data_sec = conn->data_prot;
#endif

  va_list ap;
  va_start(ap, fmt);
  write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);
  va_end(ap);

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len +=2;
","  enum protection_level data_sec = conn->data_prot;
#endif

  write_len = strlen(cmd);
  if(write_len > (sizeof(s) -3))
    return CURLE_BAD_FUNCTION_ARGUMENT;

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len +=2;
",4106,4102,[5],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/security.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_126.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_126.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_249.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_249.cpp,"  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsendf(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
","  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsend(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
",122,122,[0],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/ssh.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_127.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_127.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_250.cpp,"        sshc->acceptfail = TRUE;
      }

      if(curl_strequal(""pwd"", cmd)) {
        /* output debug output if that is requested */
        char *tmp = aprintf(""257 \""%s\"" is current directory.\n"",
                            sftp_scp->path);
","        sshc->acceptfail = TRUE;
      }

      if(strcasecompare(""pwd"", cmd)) {
        /* output debug output if that is requested */
        char *tmp = aprintf(""257 \""%s\"" is current directory.\n"",
                            sftp_scp->path);
",1233,1233,[5],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/tftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_128.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_128.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_251.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_251.cpp,"    /* As RFC3617 describes the separator slash is not actually part of the
       file name so we skip the always-present first letter of the path
       string. */
    filename = curl_easy_unescape(data, &state->conn->data->state.path[1], 0,
                                  NULL);
    if(!filename)
      return CURLE_OUT_OF_MEMORY;

    snprintf((char *)state->spacket.data+2,
             state->blksize,
","    /* As RFC3617 describes the separator slash is not actually part of the
       file name so we skip the always-present first letter of the path
       string. */
    result = Curl_urldecode(data, &state->conn->data->state.path[1], 0,
                            &filename, NULL, FALSE);
    if(result)
      return result;

    snprintf((char *)state->spacket.data+2,
             state->blksize,
",484,485,[8],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_252.cpp,"
  md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
","
  md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath);

  if(digest->qop && strcasecompare(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
",730,744,[1],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/version.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_130.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_130.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_253.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_253.cpp,"  left -= len;
  ptr += len;
#endif
#ifdef USE_LIBIDN
  if(stringprep_check_version(LIBIDN_REQUIRED_VERSION)) {
    len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));
    left -= len;
    ptr += len;
  }
","  left -= len;
  ptr += len;
#endif
#ifdef USE_LIBIDN2
  if(idn2_check_version(IDN2_VERSION)) {
    len = snprintf(ptr, left, "" libidn2/%s"", idn2_check_version(NULL));
    left -= len;
    ptr += len;
  }
",111,111,[5],[]
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_131.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_131.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_254.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_254.cpp,"
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
","
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
",2178,2198,[3],[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/CommandLineArguments.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_132.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_132.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_255.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_255.cpp,"  maxlen += 4; // For the space before and after the option

  // Print help for each option
  for ( mpit = mp.begin();
    mpit != mp.end();
    mpit ++ )
    {
    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for ( sit = mpit->second.begin(); sit != mpit->second.end(); sit++ )
      {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
        {
        case CommandLineArguments::NO_ARGUMENT: break;
        case CommandLineArguments::CONCAT_ARGUMENT: strcat(argument, ""opt""); break;
        case CommandLineArguments::SPACE_ARGUMENT:  strcat(argument, "" opt""); break;
        case CommandLineArguments::EQUAL_ARGUMENT:  strcat(argument, ""=opt""); break;
        case CommandLineArguments::MULTI_ARGUMENT:  strcat(argument, "" opt opt ...""); break;
        }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
      }
    const char* ptr = this->Internals->Callbacks[mpit->first].Help;
    size_t len = strlen(ptr);
    int cnt = 0;
    while ( len > 0)
      {
      // If argument with help is longer than line length, split it on previous
      // space (or tab) and continue on the next line
      CommandLineArguments::Internal::String::size_type cc;
      for ( cc = 0; ptr[cc]; cc ++ )
        {
        if ( *ptr == ' ' || *ptr == '\t' )
          {
          ptr ++;
          len --;
          }
        }
      if ( cnt > 0 )
        {
        for ( cc = 0; cc < maxlen; cc ++ )
          {
          str << "" "";
          }
        }
      CommandLineArguments::Internal::String::size_type skip = len;
      if ( skip > this->LineLength - maxlen )
        {
        skip = this->LineLength - maxlen;
        for ( cc = skip-1; cc > 0; cc -- )
          {
          if ( ptr[cc] == ' ' || ptr[cc] == '\t' )
            {
            break;
            }
          }
        if ( cc != 0 )
          {
          skip = cc;
          }
        }
      str.write(ptr, static_cast<std::streamsize>(skip));
      str << std::endl;
      ptr += skip;
      len -= skip;
      cnt ++;
      }
    }
  /*
  // This can help debugging help string
  str << endl;
","  maxlen += 4; // For the space before and after the option

  // Print help for each option
  for (mpit = mp.begin(); mpit != mp.end(); mpit++) {
    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for (sit = mpit->second.begin(); sit != mpit->second.end(); sit++) {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch (this->Internals->Callbacks[*sit].ArgumentType) {
        case CommandLineArguments::NO_ARGUMENT:
          break;
        case CommandLineArguments::CONCAT_ARGUMENT:
          strcat(argument, ""opt"");
          break;
        case CommandLineArguments::SPACE_ARGUMENT:
          strcat(argument, "" opt"");
          break;
        case CommandLineArguments::EQUAL_ARGUMENT:
          strcat(argument, ""=opt"");
          break;
        case CommandLineArguments::MULTI_ARGUMENT:
          strcat(argument, "" opt opt ..."");
          break;
      }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
    }
    const char* ptr = this->Internals->Callbacks[mpit->first].Help;
    size_t len = strlen(ptr);
    int cnt = 0;
    while (len > 0) {
      // If argument with help is longer than line length, split it on previous
      // space (or tab) and continue on the next line
      CommandLineArguments::Internal::String::size_type cc;
      for (cc = 0; ptr[cc]; cc++) {
        if (*ptr == ' ' || *ptr == '\t') {
          ptr++;
          len--;
        }
      }
      if (cnt > 0) {
        for (cc = 0; cc < maxlen; cc++) {
          str << "" "";
        }
      }
      CommandLineArguments::Internal::String::size_type skip = len;
      if (skip > this->LineLength - maxlen) {
        skip = this->LineLength - maxlen;
        for (cc = skip - 1; cc > 0; cc--) {
          if (ptr[cc] == ' ' || ptr[cc] == '\t') {
            break;
          }
        }
        if (cc != 0) {
          skip = cc;
        }
      }
      str.write(ptr, static_cast<std::streamsize>(skip));
      str << std::endl;
      ptr += skip;
      len -= skip;
      cnt++;
    }
  }
  /*
  // This can help debugging help string
  str << endl;
",595,557,"[12, 22]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_256.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_256.cpp,"#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' || *name.rbegin() == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( name.find('\\') != name.npos )
      {
      sprintf(buf, ""%s\\*"", name.c_str());
      }
    else
      {
      sprintf(buf, ""%s/*"", name.c_str());
      }
    }
  struct _wfinddata_t data;      // data of current file

  // Now put them into the file array
  srchHandle = _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete [] buf;

  if ( srchHandle == -1 )
    {
    return 0;
    }

  // Loop through names
  do
    {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
    }
  while ( _wfindnext_func(srchHandle, &data) != -1 );
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
","#endif
  char* buf;
  size_t n = name.size();
  if (*name.rbegin() == '/' || *name.rbegin() == '\\') {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
  } else {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if (name.find('\\') != name.npos) {
      sprintf(buf, ""%s\\*"", name.c_str());
    } else {
      sprintf(buf, ""%s/*"", name.c_str());
    }
  }
  struct _wfinddata_t data; // data of current file

  // Now put them into the file array
  srchHandle =
    _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete[] buf;

  if (srchHandle == -1) {
    return 0;
  }

  // Loop through names
  do {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
  } while (_wfindnext_func(srchHandle, &data) != -1);
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
",120,109,"[6, 15, 19]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_257.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_257.cpp,"#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
    }
  struct _wfinddata_t data;      // data of current file

  // Now put them into the file array
  srchHandle = _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete [] buf;

  if ( srchHandle == -1 )
    {
    return 0;
    }

  // Loop through names
  unsigned long count = 0;
  do
    {
    count++;
    }
  while ( _wfindnext_func(srchHandle, &data) != -1 );
  _findclose(srchHandle);
  return count;
}
","#endif
  char* buf;
  size_t n = name.size();
  if (*name.rbegin() == '/') {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
  } else {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
  }
  struct _wfinddata_t data; // data of current file

  // Now put them into the file array
  srchHandle =
    _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete[] buf;

  if (srchHandle == -1) {
    return 0;
  }

  // Loop through names
  unsigned long count = 0;
  do {
    count++;
  } while (_wfindnext_func(srchHandle, &data) != -1);
  _findclose(srchHandle);
  return count;
}
",170,151,"[6, 11]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/IOStream.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_134.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_134.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_258.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_258.cpp,"
// Read an integer value from an input stream.
template <class T>
std::istream&
IOStreamScanTemplate(std::istream& is, T& value, char type)
{
  int state = std::ios_base::goodbit;

  // Skip leading whitespace.
  std::istream::sentry okay(is);

  if(okay)
    {
    try {
    // Copy the string to a buffer and construct the format string.
    char buffer[KWSYS_IOS_INT64_MAX_DIG];
#   if defined(_MSC_VER)
    char format[] = ""%I64_"";
    const int typeIndex = 4;
#   else
    char format[] = ""%ll_"";
    const int typeIndex = 3;
#   endif
    switch(IOStreamScanStream(is, buffer))
      {
      case 8: format[typeIndex] = 'o'; break;
      case 0: // Default to decimal if not told otherwise.
      case 10: format[typeIndex] = type; break;
      case 16: format[typeIndex] = 'x'; break;
      };

    // Use sscanf to parse the number from the buffer.
    T result;
    int success = (sscanf(buffer, format, &result) == 1)?1:0;

    // Set flags for resulting state.
    if(is.peek() == EOF) { state |= std::ios_base::eofbit; }
    if(!success) { state |= std::ios_base::failbit; }
    else { value = result; }
    } catch(...) { state |= std::ios_base::badbit; }
    }

  is.setstate(std::ios_base::iostate(state));
  return is;
}

// Print an integer value to an output stream.
template <class T>
std::ostream&
IOStreamPrintTemplate(std::ostream& os, T value, char type)
{
  std::ostream::sentry okay(os);
  if(okay)
    {
    try {
    // Construct the format string.
    char format[8];
    char* f = format;
    *f++ = '%';
    if(os.flags() & std::ios_base::showpos) { *f++ = '+'; }
    if(os.flags() & std::ios_base::showbase) { *f++ = '#'; }
#   if defined(_MSC_VER)
    *f++ = 'I'; *f++ = '6'; *f++ = '4';
#   else
    *f++ = 'l'; *f++ = 'l';
#   endif
    long bflags = os.flags() & std::ios_base::basefield;
    if(bflags == std::ios_base::oct) { *f++ = 'o'; }
    else if(bflags != std::ios_base::hex) { *f++ = type; }
    else if(os.flags() & std::ios_base::uppercase) { *f++ = 'X'; }
    else { *f++ = 'x'; }
    *f = '\0';

    // Use sprintf to print to a buffer and then write the
    // buffer to the stream.
    char buffer[2*KWSYS_IOS_INT64_MAX_DIG];
    sprintf(buffer, format, value);
    os << buffer;
    } catch(...) { os.clear(os.rdstate() | std::ios_base::badbit); }
    }
  return os;
}

# if !KWSYS_IOS_HAS_ISTREAM_LONG_LONG
// Implement input stream operator for IOStreamSLL.
std::istream& IOStreamScan(std::istream& is, IOStreamSLL& value)
{
","
// Read an integer value from an input stream.
template <class T>
std::istream& IOStreamScanTemplate(std::istream& is, T& value, char type)
{
  int state = std::ios_base::goodbit;

  // Skip leading whitespace.
  std::istream::sentry okay(is);

  if (okay) {
    try {
      // Copy the string to a buffer and construct the format string.
      char buffer[KWSYS_IOS_INT64_MAX_DIG];
#if defined(_MSC_VER)
      char format[] = ""%I64_"";
      const int typeIndex = 4;
#else
      char format[] = ""%ll_"";
      const int typeIndex = 3;
#endif
      switch (IOStreamScanStream(is, buffer)) {
        case 8:
          format[typeIndex] = 'o';
          break;
        case 0: // Default to decimal if not told otherwise.
        case 10:
          format[typeIndex] = type;
          break;
        case 16:
          format[typeIndex] = 'x';
          break;
      };

      // Use sscanf to parse the number from the buffer.
      T result;
      int success = (sscanf(buffer, format, &result) == 1) ? 1 : 0;

      // Set flags for resulting state.
      if (is.peek() == EOF) {
        state |= std::ios_base::eofbit;
      }
      if (!success) {
        state |= std::ios_base::failbit;
      } else {
        value = result;
      }
    } catch (...) {
      state |= std::ios_base::badbit;
    }
  }

  is.setstate(std::ios_base::iostate(state));
  return is;
}

// Print an integer value to an output stream.
template <class T>
std::ostream& IOStreamPrintTemplate(std::ostream& os, T value, char type)
{
  std::ostream::sentry okay(os);
  if (okay) {
    try {
      // Construct the format string.
      char format[8];
      char* f = format;
      *f++ = '%';
      if (os.flags() & std::ios_base::showpos) {
        *f++ = '+';
      }
      if (os.flags() & std::ios_base::showbase) {
        *f++ = '#';
      }
#if defined(_MSC_VER)
      *f++ = 'I';
      *f++ = '6';
      *f++ = '4';
#else
      *f++ = 'l';
      *f++ = 'l';
#endif
      long bflags = os.flags() & std::ios_base::basefield;
      if (bflags == std::ios_base::oct) {
        *f++ = 'o';
      } else if (bflags != std::ios_base::hex) {
        *f++ = type;
      } else if (os.flags() & std::ios_base::uppercase) {
        *f++ = 'X';
      } else {
        *f++ = 'x';
      }
      *f = '\0';

      // Use sprintf to print to a buffer and then write the
      // buffer to the stream.
      char buffer[2 * KWSYS_IOS_INT64_MAX_DIG];
      sprintf(buffer, format, value);
      os << buffer;
    } catch (...) {
      os.clear(os.rdstate() | std::ios_base::badbit);
    }
  }
  return os;
}

#if !KWSYS_IOS_HAS_ISTREAM_LONG_LONG
// Implement input stream operator for IOStreamSLL.
std::istream& IOStreamScan(std::istream& is, IOStreamSLL& value)
{
",123,107,[76],[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_259.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_259.cpp,"#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  CONSOLE_SCREEN_BUFFER_INFO hOutInfo;
  HANDLE hOut = kwsysTerminalGetStreamHandle(stream);
  if(GetConsoleScreenBufferInfo(hOut, &hOutInfo))
    {
    pipeIsConsole = 1;
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream, color);
    }
#endif
  if(!pipeIsConsole && kwsysTerminalStreamIsVT100(stream,
                                                  default_vt100, default_tty))
    {
    pipeIsVT100 = 1;
    kwsysTerminalSetVT100Color(stream, color);
    }

  /* Format the text into the stream.  */
  {
  va_list var_args;
  va_start(var_args, format);
  vfprintf(stream, format, var_args);
  va_end(var_args);
  }

  /* Restore the normal color state for the stream.  */
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  if(pipeIsConsole)
    {
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream,
                                 kwsysTerminal_Color_Normal);
    }
#endif
  if(pipeIsVT100)
    {
    kwsysTerminalSetVT100Color(stream, kwsysTerminal_Color_Normal);
    }
}

/*--------------------------------------------------------------------------*/
","#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  CONSOLE_SCREEN_BUFFER_INFO hOutInfo;
  HANDLE hOut = kwsysTerminalGetStreamHandle(stream);
  if (GetConsoleScreenBufferInfo(hOut, &hOutInfo)) {
    pipeIsConsole = 1;
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream, color);
  }
#endif
  if (!pipeIsConsole &&
      kwsysTerminalStreamIsVT100(stream, default_vt100, default_tty)) {
    pipeIsVT100 = 1;
    kwsysTerminalSetVT100Color(stream, color);
  }

  /* Format the text into the stream.  */
  {
    va_list var_args;
    va_start(var_args, format);
    vfprintf(stream, format, var_args);
    va_end(var_args);
  }

/* Restore the normal color state for the stream.  */
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  if (pipeIsConsole) {
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream,
                                 kwsysTerminal_Color_Normal);
  }
#endif
  if (pipeIsVT100) {
    kwsysTerminalSetVT100Color(stream, kwsysTerminal_Color_Normal);
  }
}

/*--------------------------------------------------------------------------*/
",68,58,[20],[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_260.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_260.cpp,"
/*--------------------------------------------------------------------------*/
/* VT100 escape sequence strings.  */
#define KWSYS_TERMINAL_VT100_NORMAL              ""\33[0m""
#define KWSYS_TERMINAL_VT100_BOLD                ""\33[1m""
#define KWSYS_TERMINAL_VT100_UNDERLINE           ""\33[4m""
#define KWSYS_TERMINAL_VT100_BLINK               ""\33[5m""
#define KWSYS_TERMINAL_VT100_INVERSE             ""\33[7m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLACK    ""\33[30m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_RED      ""\33[31m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_GREEN    ""\33[32m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_YELLOW   ""\33[33m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLUE     ""\33[34m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_MAGENTA  ""\33[35m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_CYAN     ""\33[36m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_WHITE    ""\33[37m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLACK    ""\33[40m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_RED      ""\33[41m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_GREEN    ""\33[42m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_YELLOW   ""\33[43m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLUE     ""\33[44m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_MAGENTA  ""\33[45m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_CYAN     ""\33[46m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_WHITE    ""\33[47m""

/*--------------------------------------------------------------------------*/
/* Write VT100 escape sequences to the stream for the given color.  */
static void kwsysTerminalSetVT100Color(FILE* stream, int color)
{
  if(color == kwsysTerminal_Color_Normal)
    {
    fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
    return;
    }

  switch(color & kwsysTerminal_Color_ForegroundMask)
    {
    case kwsysTerminal_Color_Normal:
      fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
      break;
","
/*--------------------------------------------------------------------------*/
/* VT100 escape sequence strings.  */
#define KWSYS_TERMINAL_VT100_NORMAL ""\33[0m""
#define KWSYS_TERMINAL_VT100_BOLD ""\33[1m""
#define KWSYS_TERMINAL_VT100_UNDERLINE ""\33[4m""
#define KWSYS_TERMINAL_VT100_BLINK ""\33[5m""
#define KWSYS_TERMINAL_VT100_INVERSE ""\33[7m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLACK ""\33[30m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_RED ""\33[31m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_GREEN ""\33[32m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_YELLOW ""\33[33m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLUE ""\33[34m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_MAGENTA ""\33[35m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_CYAN ""\33[36m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_WHITE ""\33[37m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLACK ""\33[40m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_RED ""\33[41m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_GREEN ""\33[42m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_YELLOW ""\33[43m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLUE ""\33[44m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_MAGENTA ""\33[45m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_CYAN ""\33[46m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_WHITE ""\33[47m""

/*--------------------------------------------------------------------------*/
/* Write VT100 escape sequences to the stream for the given color.  */
static void kwsysTerminalSetVT100Color(FILE* stream, int color)
{
  if (color == kwsysTerminal_Color_Normal) {
    fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
    return;
  }

  switch (color & kwsysTerminal_Color_ForegroundMask) {
    case kwsysTerminal_Color_Normal:
      fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
      break;
",237,214,"[31, 38]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_261.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_261.cpp,"    case kwsysTerminal_Color_ForegroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_FOREGROUND_WHITE);
      break;
    }
  switch(color & kwsysTerminal_Color_BackgroundMask)
    {
    case kwsysTerminal_Color_BackgroundBlack:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_BLACK);
      break;
","    case kwsysTerminal_Color_ForegroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_FOREGROUND_WHITE);
      break;
  }
  switch (color & kwsysTerminal_Color_BackgroundMask) {
    case kwsysTerminal_Color_BackgroundBlack:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_BLACK);
      break;
",298,273,"[1, 7]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_262.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_262.cpp,"    case kwsysTerminal_Color_BackgroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_WHITE);
      break;
    }
  if(color & kwsysTerminal_Color_ForegroundBold)
    {
    fprintf(stream, KWSYS_TERMINAL_VT100_BOLD);
    }
}

/*--------------------------------------------------------------------------*/
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)

# define KWSYS_TERMINAL_MASK_FOREGROUND \
  (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY)
# define KWSYS_TERMINAL_MASK_BACKGROUND \
  (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY)

/* Get the Windows handle for a FILE stream.  */
","    case kwsysTerminal_Color_BackgroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_WHITE);
      break;
  }
  if (color & kwsysTerminal_Color_ForegroundBold) {
    fprintf(stream, KWSYS_TERMINAL_VT100_BOLD);
  }
}

/*--------------------------------------------------------------------------*/
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)

#define KWSYS_TERMINAL_MASK_FOREGROUND                                        \
  (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY)
#define KWSYS_TERMINAL_MASK_BACKGROUND                                        \
  (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY)

/* Get the Windows handle for a FILE stream.  */
",325,299,"[1, 6]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testEncode.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_136.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_136.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_263.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_263.cpp,"  printf(""md5sum 1: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output1, md5out);
  return (strcmp(md5out, testMD5output1) != 0)? 1:0;
}

static int testMD5_2(kwsysMD5* md5)
","  printf(""md5sum 1: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output1, md5out);
  return (strcmp(md5out, testMD5output1) != 0) ? 1 : 0;
}

static int testMD5_2(kwsysMD5* md5)
",40,31,[0],[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testEncode.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_136.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_136.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_264.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_264.cpp,"  printf(""md5sum 2: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output2, md5out);
  return (strcmp(md5out, testMD5output2) != 0)? 1:0;
}

int testEncode(int argc, char* argv[])
","  printf(""md5sum 2: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output2, md5out);
  return (strcmp(md5out, testMD5output2) != 0) ? 1 : 0;
}

int testEncode(int argc, char* argv[])
",55,46,[0],[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_265.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_265.cpp,"     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
","     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
",85,75,"[4, 5, 12, 13, 20, 21]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_266.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_266.cpp,"  /* Avoid error diagnostic popups since we are crashing on purpose.  */
  disable_debugger(1);
#endif
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");
  fflush(stdout);
","  /* Avoid error diagnostic popups since we are crashing on purpose.  */
  disable_debugger(1);
#endif
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");
  fflush(stdout);
",129,122,"[4, 5]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_267.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_267.cpp,"  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096*2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE+1];
  (void)argc; (void)argv;
  for(i=0;i < TEST6_SIZE;++i)
    {
    runaway[i] = '.';
    }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for(;;)
    {
    fwrite(runaway, 1, TEST6_SIZE+1, stdout);
    fflush(stdout);
    }
}

/* Define MINPOLL to be one more than the number of times output is
","  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception, kwsysProcess_Exception_Fault,
               1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096 * 2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE + 1];
  (void)argc;
  (void)argv;
  for (i = 0; i < TEST6_SIZE; ++i) {
    runaway[i] = '.';
  }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for (;;) {
    fwrite(runaway, 1, TEST6_SIZE + 1, stdout);
    fflush(stdout);
  }
}

/* Define MINPOLL to be one more than the number of times output is
",155,149,"[0, 5, 6]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_268.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_268.cpp,"#define MAXPOLL 20
static int test7(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
","#define MAXPOLL 20
static int test7(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
",191,184,"[4, 5]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_269.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_269.cpp,"
static int test8_grandchild(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
","
static int test8_grandchild(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
",231,225,"[4, 5]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_270.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_270.cpp,"  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exited,
               kwsysProcess_Exception_None,
               0, 1, 1, 0, 30, 0, 1, 0, 0, 0);
  /* This sleep will avoid a race condition between this function exiting
     normally and our Ctrl+C handler exiting abnormally after the process
     exits.  */
","  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exited, kwsysProcess_Exception_None, 0,
               1, 1, 0, 30, 0, 1, 0, 0, 0);
  /* This sleep will avoid a race condition between this function exiting
     normally and our Ctrl+C handler exiting abnormally after the process
     exits.  */
",266,261,[0],[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_271.cpp,"static int test9_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc; (void)argv;
#if defined(_WIN32)
  if(!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE))
    {
    return 1;
    }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if(sigaction(SIGINT, &sa, 0) < 0)
    {
    return 1;
    }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
","static int test9_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc;
  (void)argv;
#if defined(_WIN32)
  if (!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE)) {
    return 1;
  }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if (sigaction(SIGINT, &sa, 0) < 0) {
    return 1;
  }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
",294,288,"[19, 20]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_272.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_272.cpp,"  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Interrupt,
               0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
","  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r =
    runChild(cmd, kwsysProcess_State_Exception,
             kwsysProcess_Exception_Interrupt, 0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
",341,334,"[0, 6, 7]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_273.cpp,"static int test10_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
","static int test10_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
",354,347,"[4, 5]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_274.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,"[54, 61, 99, 101, 103, 105, 110, 112, 117, 119, 127, 133, 141, 151]",[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_275.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_275.cpp," *                  BEFORE any reading/polling of pipes occurs and before any
 *                  detachment occurs.
 */
int runChild(const char* cmd[], int state, int exception, int value,
             int share, int output, int delay, double timeout,
             int poll, int repeat, int disown, int createNewGroup,
             unsigned int interruptDelay)
{
  int result = 1;
  kwsysProcess* kp = kwsysProcess_New();
  if(!kp)
    {
    fprintf(stderr, ""kwsysProcess_New returned NULL!\n"");
    return 1;
    }
  while(repeat-- > 0)
    {
    result = runChild2(kp, cmd, state, exception, value, share,
                       output, delay, timeout, poll, disown, createNewGroup,
                       interruptDelay);
    if(result)
      {
      break;
      }
    }
  kwsysProcess_Delete(kp);
  return result;
}
"," *                  BEFORE any reading/polling of pipes occurs and before any
 *                  detachment occurs.
 */
int runChild(const char* cmd[], int state, int exception, int value, int share,
             int output, int delay, double timeout, int poll, int repeat,
             int disown, int createNewGroup, unsigned int interruptDelay)
{
  int result = 1;
  kwsysProcess* kp = kwsysProcess_New();
  if (!kp) {
    fprintf(stderr, ""kwsysProcess_New returned NULL!\n"");
    return 1;
  }
  while (repeat-- > 0) {
    result = runChild2(kp, cmd, state, exception, value, share, output, delay,
                       timeout, poll, disown, createNewGroup, interruptDelay);
    if (result) {
      break;
    }
  }
  kwsysProcess_Delete(kp);
  return result;
}
",551,526,[12],[]
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_276.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_276.cpp,"    SetStdHandle(STD_ERROR_HANDLE, out);
    }
#endif
  if(argc == 2)
    {
    n = atoi(argv[1]);
    }
  else if(argc == 3 && strcmp(argv[1], ""run"") == 0)
    {
    n = atoi(argv[2]);
    }
  /* Check arguments.  */
  if(((n >= 1 && n <= 10) || n == 108 || n == 109 || n == 110) && argc == 3)
    {
    /* This is the child process for a requested test number.  */
    switch (n)
      {
      case 1: return test1(argc, argv);
      case 2: return test2(argc, argv);
      case 3: return test3(argc, argv);
      case 4: return test4(argc, argv);
      case 5: return test5(argc, argv);
      case 6: test6(argc, argv); return 0;
      case 7: return test7(argc, argv);
      case 8: return test8(argc, argv);
      case 9: return test9(argc, argv);
      case 10: return test10(argc, argv);
      case 108: return test8_grandchild(argc, argv);
      case 109: return test9_grandchild(argc, argv);
      case 110: return test10_grandchild(argc, argv);
      }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
    }
  else if(n >= 1 && n <= 10)
    {
    /* This is the parent process for a requested test number.  */
    int states[10] =
    {
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,
      kwsysProcess_State_Exception,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Expired, /* Ctrl+C handler test */
      kwsysProcess_State_Exception /* Process group test */
    };
    int exceptions[10] =
    {
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_Fault,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_Interrupt
    };
    int values[10] = {0, 123, 1, 1, 0, 0, 0, 0, 1, 1};
    int shares[10] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1};
    int outputs[10] = {1, 1, 1, 1, 1, 0, 1, 1, 1, 1};
    int delays[10] = {0, 0, 0, 0, 0, 1, 0, 0, 0, 0};
    double timeouts[10] = {10, 10, 10, 30, 30, 10, -1, 10, 6, 4};
    int polls[10] = {0, 0, 0, 0, 0, 0, 1, 0, 0, 0};
    int repeat[10] = {257, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    int createNewGroups[10] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1};
    unsigned int interruptDelays[10] = {0, 0, 0, 0, 0, 0, 0, 0, 3, 2};
    int r;
    const char* cmd[4];
#ifdef _WIN32
    char* argv0 = 0;
#endif
    char* test1IterationsStr = getenv(""KWSYS_TEST_PROCESS_1_COUNT"");
    if(test1IterationsStr)
      {
      long int test1Iterations = strtol(test1IterationsStr, 0, 10);
      if(test1Iterations > 10 && test1Iterations != LONG_MAX)
        {
        repeat[0] = (int)test1Iterations;
        }
      }
#ifdef _WIN32
    if(n == 0 && (argv0 = strdup(argv[0])))
      {
      /* Try converting to forward slashes to see if it works.  */
      char* c;
      for(c=argv0; *c; ++c)
        {
        if(*c == '\\')
          {
          *c = '/';
          }
        }
      cmd[0] = argv0;
      }
    else
      {
      cmd[0] = argv[0];
      }
#else
    cmd[0] = argv[0];
#endif
","    SetStdHandle(STD_ERROR_HANDLE, out);
    }
#endif
  if (argc == 2) {
    n = atoi(argv[1]);
  } else if (argc == 3 && strcmp(argv[1], ""run"") == 0) {
    n = atoi(argv[2]);
  }
  /* Check arguments.  */
  if (((n >= 1 && n <= 10) || n == 108 || n == 109 || n == 110) && argc == 3) {
    /* This is the child process for a requested test number.  */
    switch (n) {
      case 1:
        return test1(argc, argv);
      case 2:
        return test2(argc, argv);
      case 3:
        return test3(argc, argv);
      case 4:
        return test4(argc, argv);
      case 5:
        return test5(argc, argv);
      case 6:
        test6(argc, argv);
        return 0;
      case 7:
        return test7(argc, argv);
      case 8:
        return test8(argc, argv);
      case 9:
        return test9(argc, argv);
      case 10:
        return test10(argc, argv);
      case 108:
        return test8_grandchild(argc, argv);
      case 109:
        return test9_grandchild(argc, argv);
      case 110:
        return test10_grandchild(argc, argv);
    }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
  } else if (n >= 1 && n <= 10) {
    /* This is the parent process for a requested test number.  */
    int states[10] = {
      kwsysProcess_State_Exited,   kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,  kwsysProcess_State_Exception,
      kwsysProcess_State_Exited,   kwsysProcess_State_Expired,
      kwsysProcess_State_Exited,   kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,  /* Ctrl+C handler test */
      kwsysProcess_State_Exception /* Process group test */
    };
    int exceptions[10] = {
      kwsysProcess_Exception_None, kwsysProcess_Exception_None,
      kwsysProcess_Exception_None, kwsysProcess_Exception_Fault,
      kwsysProcess_Exception_None, kwsysProcess_Exception_None,
      kwsysProcess_Exception_None, kwsysProcess_Exception_None,
      kwsysProcess_Exception_None, kwsysProcess_Exception_Interrupt
    };
    int values[10] = { 0, 123, 1, 1, 0, 0, 0, 0, 1, 1 };
    int shares[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1 };
    int outputs[10] = { 1, 1, 1, 1, 1, 0, 1, 1, 1, 1 };
    int delays[10] = { 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 };
    double timeouts[10] = { 10, 10, 10, 30, 30, 10, -1, 10, 6, 4 };
    int polls[10] = { 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 };
    int repeat[10] = { 257, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    int createNewGroups[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1 };
    unsigned int interruptDelays[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 2 };
    int r;
    const char* cmd[4];
#ifdef _WIN32
    char* argv0 = 0;
#endif
    char* test1IterationsStr = getenv(""KWSYS_TEST_PROCESS_1_COUNT"");
    if (test1IterationsStr) {
      long int test1Iterations = strtol(test1IterationsStr, 0, 10);
      if (test1Iterations > 10 && test1Iterations != LONG_MAX) {
        repeat[0] = (int)test1Iterations;
      }
    }
#ifdef _WIN32
    if (n == 0 && (argv0 = strdup(argv[0]))) {
      /* Try converting to forward slashes to see if it works.  */
      char* c;
      for (c = argv0; *c; ++c) {
        if (*c == '\\') {
          *c = '/';
        }
      }
      cmd[0] = argv0;
    } else {
      cmd[0] = argv[0];
    }
#else
    cmd[0] = argv[0];
#endif
",609,578,[31],[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],CommandLineArguments.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_138.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_138.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_277.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_277.cpp,"  maxlen += 4; // For the space before and after the option

  // Print help for each option
  for ( mpit = mp.begin();
    mpit != mp.end();
    mpit ++ )
    {
    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for ( sit = mpit->second.begin(); sit != mpit->second.end(); sit++ )
      {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
        {
        case CommandLineArguments::NO_ARGUMENT: break;
        case CommandLineArguments::CONCAT_ARGUMENT: strcat(argument, ""opt""); break;
        case CommandLineArguments::SPACE_ARGUMENT:  strcat(argument, "" opt""); break;
        case CommandLineArguments::EQUAL_ARGUMENT:  strcat(argument, ""=opt""); break;
        case CommandLineArguments::MULTI_ARGUMENT:  strcat(argument, "" opt opt ...""); break;
        }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
      }
    const char* ptr = this->Internals->Callbacks[mpit->first].Help;
    size_t len = strlen(ptr);
    int cnt = 0;
    while ( len > 0)
      {
      // If argument with help is longer than line length, split it on previous
      // space (or tab) and continue on the next line
      CommandLineArguments::Internal::String::size_type cc;
      for ( cc = 0; ptr[cc]; cc ++ )
        {
        if ( *ptr == ' ' || *ptr == '\t' )
          {
          ptr ++;
          len --;
          }
        }
      if ( cnt > 0 )
        {
        for ( cc = 0; cc < maxlen; cc ++ )
          {
          str << "" "";
          }
        }
      CommandLineArguments::Internal::String::size_type skip = len;
      if ( skip > this->LineLength - maxlen )
        {
        skip = this->LineLength - maxlen;
        for ( cc = skip-1; cc > 0; cc -- )
          {
          if ( ptr[cc] == ' ' || ptr[cc] == '\t' )
            {
            break;
            }
          }
        if ( cc != 0 )
          {
          skip = cc;
          }
        }
      str.write(ptr, static_cast<std::streamsize>(skip));
      str << std::endl;
      ptr += skip;
      len -= skip;
      cnt ++;
      }
    }
  /*
  // This can help debugging help string
  str << endl;
","  maxlen += 4; // For the space before and after the option

  // Print help for each option
  for (mpit = mp.begin(); mpit != mp.end(); mpit++) {
    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for (sit = mpit->second.begin(); sit != mpit->second.end(); sit++) {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch (this->Internals->Callbacks[*sit].ArgumentType) {
        case CommandLineArguments::NO_ARGUMENT:
          break;
        case CommandLineArguments::CONCAT_ARGUMENT:
          strcat(argument, ""opt"");
          break;
        case CommandLineArguments::SPACE_ARGUMENT:
          strcat(argument, "" opt"");
          break;
        case CommandLineArguments::EQUAL_ARGUMENT:
          strcat(argument, ""=opt"");
          break;
        case CommandLineArguments::MULTI_ARGUMENT:
          strcat(argument, "" opt opt ..."");
          break;
      }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
    }
    const char* ptr = this->Internals->Callbacks[mpit->first].Help;
    size_t len = strlen(ptr);
    int cnt = 0;
    while (len > 0) {
      // If argument with help is longer than line length, split it on previous
      // space (or tab) and continue on the next line
      CommandLineArguments::Internal::String::size_type cc;
      for (cc = 0; ptr[cc]; cc++) {
        if (*ptr == ' ' || *ptr == '\t') {
          ptr++;
          len--;
        }
      }
      if (cnt > 0) {
        for (cc = 0; cc < maxlen; cc++) {
          str << "" "";
        }
      }
      CommandLineArguments::Internal::String::size_type skip = len;
      if (skip > this->LineLength - maxlen) {
        skip = this->LineLength - maxlen;
        for (cc = skip - 1; cc > 0; cc--) {
          if (ptr[cc] == ' ' || ptr[cc] == '\t') {
            break;
          }
        }
        if (cc != 0) {
          skip = cc;
        }
      }
      str.write(ptr, static_cast<std::streamsize>(skip));
      str << std::endl;
      ptr += skip;
      len -= skip;
      cnt++;
    }
  }
  /*
  // This can help debugging help string
  str << endl;
",595,557,"[12, 22]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_278.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_278.cpp,"#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' || *name.rbegin() == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( name.find('\\') != name.npos )
      {
      sprintf(buf, ""%s\\*"", name.c_str());
      }
    else
      {
      sprintf(buf, ""%s/*"", name.c_str());
      }
    }
  struct _wfinddata_t data;      // data of current file

  // Now put them into the file array
  srchHandle = _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete [] buf;

  if ( srchHandle == -1 )
    {
    return 0;
    }

  // Loop through names
  do
    {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
    }
  while ( _wfindnext_func(srchHandle, &data) != -1 );
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
","#endif
  char* buf;
  size_t n = name.size();
  if (*name.rbegin() == '/' || *name.rbegin() == '\\') {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
  } else {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if (name.find('\\') != name.npos) {
      sprintf(buf, ""%s\\*"", name.c_str());
    } else {
      sprintf(buf, ""%s/*"", name.c_str());
    }
  }
  struct _wfinddata_t data; // data of current file

  // Now put them into the file array
  srchHandle =
    _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete[] buf;

  if (srchHandle == -1) {
    return 0;
  }

  // Loop through names
  do {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
  } while (_wfindnext_func(srchHandle, &data) != -1);
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
",120,109,"[6, 15, 19]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_279.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_279.cpp,"#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
    }
  struct _wfinddata_t data;      // data of current file

  // Now put them into the file array
  srchHandle = _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete [] buf;

  if ( srchHandle == -1 )
    {
    return 0;
    }

  // Loop through names
  unsigned long count = 0;
  do
    {
    count++;
    }
  while ( _wfindnext_func(srchHandle, &data) != -1 );
  _findclose(srchHandle);
  return count;
}
","#endif
  char* buf;
  size_t n = name.size();
  if (*name.rbegin() == '/') {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
  } else {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
  }
  struct _wfinddata_t data; // data of current file

  // Now put them into the file array
  srchHandle =
    _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete[] buf;

  if (srchHandle == -1) {
    return 0;
  }

  // Loop through names
  unsigned long count = 0;
  do {
    count++;
  } while (_wfindnext_func(srchHandle, &data) != -1);
  _findclose(srchHandle);
  return count;
}
",170,151,"[6, 11]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],IOStream.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_140.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_140.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_280.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_280.cpp,"
// Read an integer value from an input stream.
template <class T>
std::istream&
IOStreamScanTemplate(std::istream& is, T& value, char type)
{
  int state = std::ios_base::goodbit;

  // Skip leading whitespace.
  std::istream::sentry okay(is);

  if(okay)
    {
    try {
    // Copy the string to a buffer and construct the format string.
    char buffer[KWSYS_IOS_INT64_MAX_DIG];
#   if defined(_MSC_VER)
    char format[] = ""%I64_"";
    const int typeIndex = 4;
#   else
    char format[] = ""%ll_"";
    const int typeIndex = 3;
#   endif
    switch(IOStreamScanStream(is, buffer))
      {
      case 8: format[typeIndex] = 'o'; break;
      case 0: // Default to decimal if not told otherwise.
      case 10: format[typeIndex] = type; break;
      case 16: format[typeIndex] = 'x'; break;
      };

    // Use sscanf to parse the number from the buffer.
    T result;
    int success = (sscanf(buffer, format, &result) == 1)?1:0;

    // Set flags for resulting state.
    if(is.peek() == EOF) { state |= std::ios_base::eofbit; }
    if(!success) { state |= std::ios_base::failbit; }
    else { value = result; }
    } catch(...) { state |= std::ios_base::badbit; }
    }

  is.setstate(std::ios_base::iostate(state));
  return is;
}

// Print an integer value to an output stream.
template <class T>
std::ostream&
IOStreamPrintTemplate(std::ostream& os, T value, char type)
{
  std::ostream::sentry okay(os);
  if(okay)
    {
    try {
    // Construct the format string.
    char format[8];
    char* f = format;
    *f++ = '%';
    if(os.flags() & std::ios_base::showpos) { *f++ = '+'; }
    if(os.flags() & std::ios_base::showbase) { *f++ = '#'; }
#   if defined(_MSC_VER)
    *f++ = 'I'; *f++ = '6'; *f++ = '4';
#   else
    *f++ = 'l'; *f++ = 'l';
#   endif
    long bflags = os.flags() & std::ios_base::basefield;
    if(bflags == std::ios_base::oct) { *f++ = 'o'; }
    else if(bflags != std::ios_base::hex) { *f++ = type; }
    else if(os.flags() & std::ios_base::uppercase) { *f++ = 'X'; }
    else { *f++ = 'x'; }
    *f = '\0';

    // Use sprintf to print to a buffer and then write the
    // buffer to the stream.
    char buffer[2*KWSYS_IOS_INT64_MAX_DIG];
    sprintf(buffer, format, value);
    os << buffer;
    } catch(...) { os.clear(os.rdstate() | std::ios_base::badbit); }
    }
  return os;
}

# if !KWSYS_IOS_HAS_ISTREAM_LONG_LONG
// Implement input stream operator for IOStreamSLL.
std::istream& IOStreamScan(std::istream& is, IOStreamSLL& value)
{
","
// Read an integer value from an input stream.
template <class T>
std::istream& IOStreamScanTemplate(std::istream& is, T& value, char type)
{
  int state = std::ios_base::goodbit;

  // Skip leading whitespace.
  std::istream::sentry okay(is);

  if (okay) {
    try {
      // Copy the string to a buffer and construct the format string.
      char buffer[KWSYS_IOS_INT64_MAX_DIG];
#if defined(_MSC_VER)
      char format[] = ""%I64_"";
      const int typeIndex = 4;
#else
      char format[] = ""%ll_"";
      const int typeIndex = 3;
#endif
      switch (IOStreamScanStream(is, buffer)) {
        case 8:
          format[typeIndex] = 'o';
          break;
        case 0: // Default to decimal if not told otherwise.
        case 10:
          format[typeIndex] = type;
          break;
        case 16:
          format[typeIndex] = 'x';
          break;
      };

      // Use sscanf to parse the number from the buffer.
      T result;
      int success = (sscanf(buffer, format, &result) == 1) ? 1 : 0;

      // Set flags for resulting state.
      if (is.peek() == EOF) {
        state |= std::ios_base::eofbit;
      }
      if (!success) {
        state |= std::ios_base::failbit;
      } else {
        value = result;
      }
    } catch (...) {
      state |= std::ios_base::badbit;
    }
  }

  is.setstate(std::ios_base::iostate(state));
  return is;
}

// Print an integer value to an output stream.
template <class T>
std::ostream& IOStreamPrintTemplate(std::ostream& os, T value, char type)
{
  std::ostream::sentry okay(os);
  if (okay) {
    try {
      // Construct the format string.
      char format[8];
      char* f = format;
      *f++ = '%';
      if (os.flags() & std::ios_base::showpos) {
        *f++ = '+';
      }
      if (os.flags() & std::ios_base::showbase) {
        *f++ = '#';
      }
#if defined(_MSC_VER)
      *f++ = 'I';
      *f++ = '6';
      *f++ = '4';
#else
      *f++ = 'l';
      *f++ = 'l';
#endif
      long bflags = os.flags() & std::ios_base::basefield;
      if (bflags == std::ios_base::oct) {
        *f++ = 'o';
      } else if (bflags != std::ios_base::hex) {
        *f++ = type;
      } else if (os.flags() & std::ios_base::uppercase) {
        *f++ = 'X';
      } else {
        *f++ = 'x';
      }
      *f = '\0';

      // Use sprintf to print to a buffer and then write the
      // buffer to the stream.
      char buffer[2 * KWSYS_IOS_INT64_MAX_DIG];
      sprintf(buffer, format, value);
      os << buffer;
    } catch (...) {
      os.clear(os.rdstate() | std::ios_base::badbit);
    }
  }
  return os;
}

#if !KWSYS_IOS_HAS_ISTREAM_LONG_LONG
// Implement input stream operator for IOStreamSLL.
std::istream& IOStreamScan(std::istream& is, IOStreamSLL& value)
{
",123,107,[76],[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_281.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_281.cpp,"#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  CONSOLE_SCREEN_BUFFER_INFO hOutInfo;
  HANDLE hOut = kwsysTerminalGetStreamHandle(stream);
  if(GetConsoleScreenBufferInfo(hOut, &hOutInfo))
    {
    pipeIsConsole = 1;
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream, color);
    }
#endif
  if(!pipeIsConsole && kwsysTerminalStreamIsVT100(stream,
                                                  default_vt100, default_tty))
    {
    pipeIsVT100 = 1;
    kwsysTerminalSetVT100Color(stream, color);
    }

  /* Format the text into the stream.  */
  {
  va_list var_args;
  va_start(var_args, format);
  vfprintf(stream, format, var_args);
  va_end(var_args);
  }

  /* Restore the normal color state for the stream.  */
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  if(pipeIsConsole)
    {
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream,
                                 kwsysTerminal_Color_Normal);
    }
#endif
  if(pipeIsVT100)
    {
    kwsysTerminalSetVT100Color(stream, kwsysTerminal_Color_Normal);
    }
}

/*--------------------------------------------------------------------------*/
","#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  CONSOLE_SCREEN_BUFFER_INFO hOutInfo;
  HANDLE hOut = kwsysTerminalGetStreamHandle(stream);
  if (GetConsoleScreenBufferInfo(hOut, &hOutInfo)) {
    pipeIsConsole = 1;
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream, color);
  }
#endif
  if (!pipeIsConsole &&
      kwsysTerminalStreamIsVT100(stream, default_vt100, default_tty)) {
    pipeIsVT100 = 1;
    kwsysTerminalSetVT100Color(stream, color);
  }

  /* Format the text into the stream.  */
  {
    va_list var_args;
    va_start(var_args, format);
    vfprintf(stream, format, var_args);
    va_end(var_args);
  }

/* Restore the normal color state for the stream.  */
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  if (pipeIsConsole) {
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream,
                                 kwsysTerminal_Color_Normal);
  }
#endif
  if (pipeIsVT100) {
    kwsysTerminalSetVT100Color(stream, kwsysTerminal_Color_Normal);
  }
}

/*--------------------------------------------------------------------------*/
",68,58,[20],[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_282.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_282.cpp,"
/*--------------------------------------------------------------------------*/
/* VT100 escape sequence strings.  */
#define KWSYS_TERMINAL_VT100_NORMAL              ""\33[0m""
#define KWSYS_TERMINAL_VT100_BOLD                ""\33[1m""
#define KWSYS_TERMINAL_VT100_UNDERLINE           ""\33[4m""
#define KWSYS_TERMINAL_VT100_BLINK               ""\33[5m""
#define KWSYS_TERMINAL_VT100_INVERSE             ""\33[7m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLACK    ""\33[30m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_RED      ""\33[31m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_GREEN    ""\33[32m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_YELLOW   ""\33[33m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLUE     ""\33[34m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_MAGENTA  ""\33[35m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_CYAN     ""\33[36m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_WHITE    ""\33[37m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLACK    ""\33[40m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_RED      ""\33[41m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_GREEN    ""\33[42m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_YELLOW   ""\33[43m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLUE     ""\33[44m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_MAGENTA  ""\33[45m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_CYAN     ""\33[46m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_WHITE    ""\33[47m""

/*--------------------------------------------------------------------------*/
/* Write VT100 escape sequences to the stream for the given color.  */
static void kwsysTerminalSetVT100Color(FILE* stream, int color)
{
  if(color == kwsysTerminal_Color_Normal)
    {
    fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
    return;
    }

  switch(color & kwsysTerminal_Color_ForegroundMask)
    {
    case kwsysTerminal_Color_Normal:
      fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
      break;
","
/*--------------------------------------------------------------------------*/
/* VT100 escape sequence strings.  */
#define KWSYS_TERMINAL_VT100_NORMAL ""\33[0m""
#define KWSYS_TERMINAL_VT100_BOLD ""\33[1m""
#define KWSYS_TERMINAL_VT100_UNDERLINE ""\33[4m""
#define KWSYS_TERMINAL_VT100_BLINK ""\33[5m""
#define KWSYS_TERMINAL_VT100_INVERSE ""\33[7m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLACK ""\33[30m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_RED ""\33[31m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_GREEN ""\33[32m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_YELLOW ""\33[33m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLUE ""\33[34m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_MAGENTA ""\33[35m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_CYAN ""\33[36m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_WHITE ""\33[37m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLACK ""\33[40m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_RED ""\33[41m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_GREEN ""\33[42m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_YELLOW ""\33[43m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLUE ""\33[44m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_MAGENTA ""\33[45m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_CYAN ""\33[46m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_WHITE ""\33[47m""

/*--------------------------------------------------------------------------*/
/* Write VT100 escape sequences to the stream for the given color.  */
static void kwsysTerminalSetVT100Color(FILE* stream, int color)
{
  if (color == kwsysTerminal_Color_Normal) {
    fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
    return;
  }

  switch (color & kwsysTerminal_Color_ForegroundMask) {
    case kwsysTerminal_Color_Normal:
      fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
      break;
",237,214,"[31, 38]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_283.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_283.cpp,"    case kwsysTerminal_Color_ForegroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_FOREGROUND_WHITE);
      break;
    }
  switch(color & kwsysTerminal_Color_BackgroundMask)
    {
    case kwsysTerminal_Color_BackgroundBlack:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_BLACK);
      break;
","    case kwsysTerminal_Color_ForegroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_FOREGROUND_WHITE);
      break;
  }
  switch (color & kwsysTerminal_Color_BackgroundMask) {
    case kwsysTerminal_Color_BackgroundBlack:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_BLACK);
      break;
",298,273,"[1, 7]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_284.cpp,"    case kwsysTerminal_Color_BackgroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_WHITE);
      break;
    }
  if(color & kwsysTerminal_Color_ForegroundBold)
    {
    fprintf(stream, KWSYS_TERMINAL_VT100_BOLD);
    }
}

/*--------------------------------------------------------------------------*/
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)

# define KWSYS_TERMINAL_MASK_FOREGROUND \
  (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY)
# define KWSYS_TERMINAL_MASK_BACKGROUND \
  (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY)

/* Get the Windows handle for a FILE stream.  */
","    case kwsysTerminal_Color_BackgroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_WHITE);
      break;
  }
  if (color & kwsysTerminal_Color_ForegroundBold) {
    fprintf(stream, KWSYS_TERMINAL_VT100_BOLD);
  }
}

/*--------------------------------------------------------------------------*/
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)

#define KWSYS_TERMINAL_MASK_FOREGROUND                                        \
  (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY)
#define KWSYS_TERMINAL_MASK_BACKGROUND                                        \
  (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY)

/* Get the Windows handle for a FILE stream.  */
",325,299,"[1, 6]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testEncode.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_142.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_142.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_285.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_285.cpp,"  printf(""md5sum 1: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output1, md5out);
  return (strcmp(md5out, testMD5output1) != 0)? 1:0;
}

static int testMD5_2(kwsysMD5* md5)
","  printf(""md5sum 1: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output1, md5out);
  return (strcmp(md5out, testMD5output1) != 0) ? 1 : 0;
}

static int testMD5_2(kwsysMD5* md5)
",40,31,[0],[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testEncode.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_142.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_142.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_286.cpp,"  printf(""md5sum 2: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output2, md5out);
  return (strcmp(md5out, testMD5output2) != 0)? 1:0;
}

int testEncode(int argc, char* argv[])
","  printf(""md5sum 2: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output2, md5out);
  return (strcmp(md5out, testMD5output2) != 0) ? 1 : 0;
}

int testEncode(int argc, char* argv[])
",55,46,[0],[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_287.cpp,"     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
","     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
",85,75,"[4, 5, 12, 13, 20, 21]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_288.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_288.cpp,"  /* Avoid error diagnostic popups since we are crashing on purpose.  */
  disable_debugger(1);
#endif
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");
  fflush(stdout);
","  /* Avoid error diagnostic popups since we are crashing on purpose.  */
  disable_debugger(1);
#endif
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");
  fflush(stdout);
",129,122,"[4, 5]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_289.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_289.cpp,"  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096*2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE+1];
  (void)argc; (void)argv;
  for(i=0;i < TEST6_SIZE;++i)
    {
    runaway[i] = '.';
    }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for(;;)
    {
    fwrite(runaway, 1, TEST6_SIZE+1, stdout);
    fflush(stdout);
    }
}

/* Define MINPOLL to be one more than the number of times output is
","  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception, kwsysProcess_Exception_Fault,
               1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096 * 2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE + 1];
  (void)argc;
  (void)argv;
  for (i = 0; i < TEST6_SIZE; ++i) {
    runaway[i] = '.';
  }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for (;;) {
    fwrite(runaway, 1, TEST6_SIZE + 1, stdout);
    fflush(stdout);
  }
}

/* Define MINPOLL to be one more than the number of times output is
",155,149,"[0, 5, 6]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_290.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_290.cpp,"#define MAXPOLL 20
static int test7(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
","#define MAXPOLL 20
static int test7(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
",191,184,"[4, 5]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_291.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_291.cpp,"
static int test8_grandchild(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
","
static int test8_grandchild(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
",231,225,"[4, 5]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_292.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_292.cpp,"  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exited,
               kwsysProcess_Exception_None,
               0, 1, 1, 0, 30, 0, 1, 0, 0, 0);
  /* This sleep will avoid a race condition between this function exiting
     normally and our Ctrl+C handler exiting abnormally after the process
     exits.  */
","  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exited, kwsysProcess_Exception_None, 0,
               1, 1, 0, 30, 0, 1, 0, 0, 0);
  /* This sleep will avoid a race condition between this function exiting
     normally and our Ctrl+C handler exiting abnormally after the process
     exits.  */
",266,261,[0],[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_293.cpp,"static int test9_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc; (void)argv;
#if defined(_WIN32)
  if(!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE))
    {
    return 1;
    }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if(sigaction(SIGINT, &sa, 0) < 0)
    {
    return 1;
    }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
","static int test9_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc;
  (void)argv;
#if defined(_WIN32)
  if (!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE)) {
    return 1;
  }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if (sigaction(SIGINT, &sa, 0) < 0) {
    return 1;
  }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
",294,288,"[19, 20]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_294.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_294.cpp,"  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Interrupt,
               0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
","  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r =
    runChild(cmd, kwsysProcess_State_Exception,
             kwsysProcess_Exception_Interrupt, 0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
",341,334,"[0, 6, 7]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_295.cpp,"static int test10_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
","static int test10_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
",354,347,"[4, 5]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_296.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,"[54, 61, 99, 101, 103, 105, 110, 112, 117, 119, 127, 133, 141, 151]",[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_297.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_297.cpp," *                  BEFORE any reading/polling of pipes occurs and before any
 *                  detachment occurs.
 */
int runChild(const char* cmd[], int state, int exception, int value,
             int share, int output, int delay, double timeout,
             int poll, int repeat, int disown, int createNewGroup,
             unsigned int interruptDelay)
{
  int result = 1;
  kwsysProcess* kp = kwsysProcess_New();
  if(!kp)
    {
    fprintf(stderr, ""kwsysProcess_New returned NULL!\n"");
    return 1;
    }
  while(repeat-- > 0)
    {
    result = runChild2(kp, cmd, state, exception, value, share,
                       output, delay, timeout, poll, disown, createNewGroup,
                       interruptDelay);
    if(result)
      {
      break;
      }
    }
  kwsysProcess_Delete(kp);
  return result;
}
"," *                  BEFORE any reading/polling of pipes occurs and before any
 *                  detachment occurs.
 */
int runChild(const char* cmd[], int state, int exception, int value, int share,
             int output, int delay, double timeout, int poll, int repeat,
             int disown, int createNewGroup, unsigned int interruptDelay)
{
  int result = 1;
  kwsysProcess* kp = kwsysProcess_New();
  if (!kp) {
    fprintf(stderr, ""kwsysProcess_New returned NULL!\n"");
    return 1;
  }
  while (repeat-- > 0) {
    result = runChild2(kp, cmd, state, exception, value, share, output, delay,
                       timeout, poll, disown, createNewGroup, interruptDelay);
    if (result) {
      break;
    }
  }
  kwsysProcess_Delete(kp);
  return result;
}
",551,526,[12],[]
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_298.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_298.cpp,"    SetStdHandle(STD_ERROR_HANDLE, out);
    }
#endif
  if(argc == 2)
    {
    n = atoi(argv[1]);
    }
  else if(argc == 3 && strcmp(argv[1], ""run"") == 0)
    {
    n = atoi(argv[2]);
    }
  /* Check arguments.  */
  if(((n >= 1 && n <= 10) || n == 108 || n == 109 || n == 110) && argc == 3)
    {
    /* This is the child process for a requested test number.  */
    switch (n)
      {
      case 1: return test1(argc, argv);
      case 2: return test2(argc, argv);
      case 3: return test3(argc, argv);
      case 4: return test4(argc, argv);
      case 5: return test5(argc, argv);
      case 6: test6(argc, argv); return 0;
      case 7: return test7(argc, argv);
      case 8: return test8(argc, argv);
      case 9: return test9(argc, argv);
      case 10: return test10(argc, argv);
      case 108: return test8_grandchild(argc, argv);
      case 109: return test9_grandchild(argc, argv);
      case 110: return test10_grandchild(argc, argv);
      }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
    }
  else if(n >= 1 && n <= 10)
    {
    /* This is the parent process for a requested test number.  */
    int states[10] =
    {
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,
      kwsysProcess_State_Exception,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Expired, /* Ctrl+C handler test */
      kwsysProcess_State_Exception /* Process group test */
    };
    int exceptions[10] =
    {
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_Fault,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_Interrupt
    };
    int values[10] = {0, 123, 1, 1, 0, 0, 0, 0, 1, 1};
    int shares[10] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1};
    int outputs[10] = {1, 1, 1, 1, 1, 0, 1, 1, 1, 1};
    int delays[10] = {0, 0, 0, 0, 0, 1, 0, 0, 0, 0};
    double timeouts[10] = {10, 10, 10, 30, 30, 10, -1, 10, 6, 4};
    int polls[10] = {0, 0, 0, 0, 0, 0, 1, 0, 0, 0};
    int repeat[10] = {257, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    int createNewGroups[10] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1};
    unsigned int interruptDelays[10] = {0, 0, 0, 0, 0, 0, 0, 0, 3, 2};
    int r;
    const char* cmd[4];
#ifdef _WIN32
    char* argv0 = 0;
#endif
    char* test1IterationsStr = getenv(""KWSYS_TEST_PROCESS_1_COUNT"");
    if(test1IterationsStr)
      {
      long int test1Iterations = strtol(test1IterationsStr, 0, 10);
      if(test1Iterations > 10 && test1Iterations != LONG_MAX)
        {
        repeat[0] = (int)test1Iterations;
        }
      }
#ifdef _WIN32
    if(n == 0 && (argv0 = strdup(argv[0])))
      {
      /* Try converting to forward slashes to see if it works.  */
      char* c;
      for(c=argv0; *c; ++c)
        {
        if(*c == '\\')
          {
          *c = '/';
          }
        }
      cmd[0] = argv0;
      }
    else
      {
      cmd[0] = argv[0];
      }
#else
    cmd[0] = argv[0];
#endif
","    SetStdHandle(STD_ERROR_HANDLE, out);
    }
#endif
  if (argc == 2) {
    n = atoi(argv[1]);
  } else if (argc == 3 && strcmp(argv[1], ""run"") == 0) {
    n = atoi(argv[2]);
  }
  /* Check arguments.  */
  if (((n >= 1 && n <= 10) || n == 108 || n == 109 || n == 110) && argc == 3) {
    /* This is the child process for a requested test number.  */
    switch (n) {
      case 1:
        return test1(argc, argv);
      case 2:
        return test2(argc, argv);
      case 3:
        return test3(argc, argv);
      case 4:
        return test4(argc, argv);
      case 5:
        return test5(argc, argv);
      case 6:
        test6(argc, argv);
        return 0;
      case 7:
        return test7(argc, argv);
      case 8:
        return test8(argc, argv);
      case 9:
        return test9(argc, argv);
      case 10:
        return test10(argc, argv);
      case 108:
        return test8_grandchild(argc, argv);
      case 109:
        return test9_grandchild(argc, argv);
      case 110:
        return test10_grandchild(argc, argv);
    }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
  } else if (n >= 1 && n <= 10) {
    /* This is the parent process for a requested test number.  */
    int states[10] = {
      kwsysProcess_State_Exited,   kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,  kwsysProcess_State_Exception,
      kwsysProcess_State_Exited,   kwsysProcess_State_Expired,
      kwsysProcess_State_Exited,   kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,  /* Ctrl+C handler test */
      kwsysProcess_State_Exception /* Process group test */
    };
    int exceptions[10] = {
      kwsysProcess_Exception_None, kwsysProcess_Exception_None,
      kwsysProcess_Exception_None, kwsysProcess_Exception_Fault,
      kwsysProcess_Exception_None, kwsysProcess_Exception_None,
      kwsysProcess_Exception_None, kwsysProcess_Exception_None,
      kwsysProcess_Exception_None, kwsysProcess_Exception_Interrupt
    };
    int values[10] = { 0, 123, 1, 1, 0, 0, 0, 0, 1, 1 };
    int shares[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1 };
    int outputs[10] = { 1, 1, 1, 1, 1, 0, 1, 1, 1, 1 };
    int delays[10] = { 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 };
    double timeouts[10] = { 10, 10, 10, 30, 30, 10, -1, 10, 6, 4 };
    int polls[10] = { 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 };
    int repeat[10] = { 257, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    int createNewGroups[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1 };
    unsigned int interruptDelays[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 2 };
    int r;
    const char* cmd[4];
#ifdef _WIN32
    char* argv0 = 0;
#endif
    char* test1IterationsStr = getenv(""KWSYS_TEST_PROCESS_1_COUNT"");
    if (test1IterationsStr) {
      long int test1Iterations = strtol(test1IterationsStr, 0, 10);
      if (test1Iterations > 10 && test1Iterations != LONG_MAX) {
        repeat[0] = (int)test1Iterations;
      }
    }
#ifdef _WIN32
    if (n == 0 && (argv0 = strdup(argv[0]))) {
      /* Try converting to forward slashes to see if it works.  */
      char* c;
      for (c = argv0; *c; ++c) {
        if (*c == '\\') {
          *c = '/';
        }
      }
      cmd[0] = argv0;
    } else {
      cmd[0] = argv[0];
    }
#else
    cmd[0] = argv[0];
#endif
",609,578,[31],[]
2fe3e55d53989c909be595b00a4749b75886accf,"cmState: Move CacheEntryType enum to separate namespace

Port dependent code to the change.",[],Source/cmCacheManager.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_144.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_144.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_299.cpp,"  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"",
                      cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"",
                      cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"",
                      cmState::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
","  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"",
                      cmStateEnums::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"",
                      cmStateEnums::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"",
                      cmStateEnums::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
",244,244,"[4, 9]",[]
2fe3e55d53989c909be595b00a4749b75886accf,"cmState: Move CacheEntryType enum to separate namespace

Port dependent code to the change.",[],Source/cmGlobalGenerator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_145.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_145.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_300.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_300.cpp,"  sprintf(num, ""%d"", static_cast<int>(this->Makefiles.size()));
  this->GetCMakeInstance()->AddCacheEntry(""CMAKE_NUMBER_OF_MAKEFILES"", num,
                                          ""number of local generators"",
                                          cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
  // and for infinite loops
","  sprintf(num, ""%d"", static_cast<int>(this->Makefiles.size()));
  this->GetCMakeInstance()->AddCacheEntry(""CMAKE_NUMBER_OF_MAKEFILES"", num,
                                          ""number of local generators"",
                                          cmStateEnums::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
  // and for infinite loops
",1103,1103,[0],[]
a49751fb2eed0ca6415b243c35b23201b8060597,cmState: Move TargetType enum to separate namespace,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_146.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_146.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_301.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_301.cpp,"              ? ""NEW""
              : ""OLD"");

    if (targetType == cmState::EXECUTABLE) {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
    } else // if (targetType == cmState::STATIC_LIBRARY)
    {
      /* Put the static library at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
","              ? ""NEW""
              : ""OLD"");

    if (targetType == cmStateEnums::EXECUTABLE) {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
    } else // if (targetType == cmStateEnums::STATIC_LIBRARY)
    {
      /* Put the static library at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
",481,482,"[5, 8, 12]",[]
7aaed265ade4c3b38967e83095497280a7a55153,"cmExprParser: Port to bison 3

Use %-directives to specify the scanner/lexer arguments and update the
yyerror signature.  Reduce the list of post-bison modifications needed.",[],Source/cmExprParser.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_147.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_147.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_302.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_302.cpp,"#  define YYFPRINTF fprintf
# endif

# define YYDPRINTF(Args)      \
do {            \
  if (yydebug)          \
    YYFPRINTF Args;        \
} while (0)

# define YYDSYMPRINT(Args)      \
do {            \
  if (yydebug)          \
    yysymprint Args;        \
} while (0)

# define YYDSYMPRINTF(Title, Token, Value, Location)    \
do {                \
  if (yydebug)              \
    {                \
      YYFPRINTF (stderr, ""%s "", Title);        \
      yysymprint (stderr,           \
                  Token, Value);  \
      YYFPRINTF (stderr, ""\n"");          \
    }                \
} while (0)

/*------------------------------------------------------------------.
| yy_stack_print -- Print the state stack from its BOTTOM up to its |
| TOP (included).                                                   |
`------------------------------------------------------------------*/

#if defined (__STDC__) || defined (__cplusplus)
static void
yy_stack_print (short int *bottom, short int *top)
#else
static void
yy_stack_print (bottom, top)
    short int *bottom;
    short int *top;
#endif
{
  YYFPRINTF (stderr, ""Stack now"");
  for (/* Nothing. */; bottom <= top; ++bottom)
    YYFPRINTF (stderr, "" %d"", *bottom);
  YYFPRINTF (stderr, ""\n"");
}

# define YY_STACK_PRINT(Bottom, Top)        \
do {                \
  if (yydebug)              \
    yy_stack_print ((Bottom), (Top));        \
} while (0)


/*------------------------------------------------.
| Report that the YYRULE is going to be reduced.  |
`------------------------------------------------*/

#if defined (__STDC__) || defined (__cplusplus)
static void
yy_reduce_print (int yyrule)
#else
static void
yy_reduce_print (yyrule)
    int yyrule;
#endif
{
  int yyi;
  unsigned int yylno = yyrline[yyrule];
  YYFPRINTF (stderr, ""Reducing stack by rule %d (line %u), "",
             yyrule - 1, yylno);
  /* Print the symbols being reduced, and their result.  */
  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
    YYFPRINTF (stderr, ""%s "", yytname [yyrhs[yyi]]);
  YYFPRINTF (stderr, ""-> %s\n"", yytname [yyr1[yyrule]]);
}

# define YY_REDUCE_PRINT(Rule)    \
do {          \
  if (yydebug)        \
    yy_reduce_print (Rule);    \
} while (0)

/* Nonzero means print parse trace.  It is left uninitialized so that
   multiple parsers can coexist.  */
int yydebug;
#else /* !YYDEBUG */
# define YYDPRINTF(Args)
# define YYDSYMPRINT(Args)
# define YYDSYMPRINTF(Title, Token, Value, Location)
# define YY_STACK_PRINT(Bottom, Top)
# define YY_REDUCE_PRINT(Rule)
#endif /* !YYDEBUG */


/* YYINITDEPTH -- initial size of the parser's stacks.  */
#ifndef  YYINITDEPTH
# define YYINITDEPTH 200
#endif

/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
   if the built-in stack extension method is used).

   Do not make this value too large; the results are undefined if
   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
   evaluated with infinite-precision integer arithmetic.  */

#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
# undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
# define YYMAXDEPTH 10000
#endif



#if YYERROR_VERBOSE

# ifndef yystrlen
#  if defined (__GLIBC__) && defined (_STRING_H)
#   define yystrlen strlen
#  else
/* Return the length of YYSTR.  */
static YYSIZE_T
#   if defined (__STDC__) || defined (__cplusplus)
yystrlen (const char *yystr)
#   else
yystrlen (yystr)
     const char *yystr;
#   endif
{
  const char *yys = yystr;

  while (*yys++ != '\0')
    continue;

  return yys - yystr - 1;
}
#  endif
# endif

# ifndef yystpcpy
#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
#   define yystpcpy stpcpy
#  else
/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
   YYDEST.  */
static char *
#   if defined (__STDC__) || defined (__cplusplus)
yystpcpy (char *yydest, const char *yysrc)
#   else
yystpcpy (yydest, yysrc)
     char *yydest;
     const char *yysrc;
#   endif
{
  char *yyd = yydest;
  const char *yys = yysrc;
","#  define YYFPRINTF fprintf
# endif

# define YYDPRINTF(Args)                        \
do {                                            \
  if (yydebug)                                  \
    YYFPRINTF Args;                             \
} while (0)

/* This macro is provided for backward compatibility. */
#ifndef YY_LOCATION_PRINT
# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
#endif


# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
do {                                                                      \
  if (yydebug)                                                            \
    {                                                                     \
      YYFPRINTF (stderr, ""%s "", Title);                                   \
      yy_symbol_print (stderr,                                            \
                  Type, Value, yyscanner); \
      YYFPRINTF (stderr, ""\n"");                                           \
    }                                                                     \
} while (0)


/*----------------------------------------.
| Print this symbol's value on YYOUTPUT.  |
`----------------------------------------*/

static void
yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, yyscan_t yyscanner)
{
  FILE *yyo = yyoutput;
  YYUSE (yyo);
  YYUSE (yyscanner);
  if (!yyvaluep)
    return;
# ifdef YYPRINT
  if (yytype < YYNTOKENS)
    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
# endif
  YYUSE (yytype);
}


/*--------------------------------.
| Print this symbol on YYOUTPUT.  |
`--------------------------------*/

static void
yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, yyscan_t yyscanner)
{
  YYFPRINTF (yyoutput, ""%s %s ("",
             yytype < YYNTOKENS ? ""token"" : ""nterm"", yytname[yytype]);

  yy_symbol_value_print (yyoutput, yytype, yyvaluep, yyscanner);
  YYFPRINTF (yyoutput, "")"");
}

/*------------------------------------------------------------------.
| yy_stack_print -- Print the state stack from its BOTTOM up to its |
| TOP (included).                                                   |
`------------------------------------------------------------------*/

static void
yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
{
  YYFPRINTF (stderr, ""Stack now"");
  for (; yybottom <= yytop; yybottom++)
    {
      int yybot = *yybottom;
      YYFPRINTF (stderr, "" %d"", yybot);
    }
  YYFPRINTF (stderr, ""\n"");
}

# define YY_STACK_PRINT(Bottom, Top)                            \
do {                                                            \
  if (yydebug)                                                  \
    yy_stack_print ((Bottom), (Top));                           \
} while (0)


/*------------------------------------------------.
| Report that the YYRULE is going to be reduced.  |
`------------------------------------------------*/

static void
yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule, yyscan_t yyscanner)
{
  unsigned long int yylno = yyrline[yyrule];
  int yynrhs = yyr2[yyrule];
  int yyi;
  YYFPRINTF (stderr, ""Reducing stack by rule %d (line %lu):\n"",
             yyrule - 1, yylno);
  /* The symbols being reduced.  */
  for (yyi = 0; yyi < yynrhs; yyi++)
    {
      YYFPRINTF (stderr, ""   $%d = "", yyi + 1);
      yy_symbol_print (stderr,
                       yystos[yyssp[yyi + 1 - yynrhs]],
                       &(yyvsp[(yyi + 1) - (yynrhs)])
                                              , yyscanner);
      YYFPRINTF (stderr, ""\n"");
    }
}

# define YY_REDUCE_PRINT(Rule)          \
do {                                    \
  if (yydebug)                          \
    yy_reduce_print (yyssp, yyvsp, Rule, yyscanner); \
} while (0)

/* Nonzero means print parse trace.  It is left uninitialized so that
   multiple parsers can coexist.  */
int yydebug;
#else /* !YYDEBUG */
# define YYDPRINTF(Args)
# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
# define YY_STACK_PRINT(Bottom, Top)
# define YY_REDUCE_PRINT(Rule)
#endif /* !YYDEBUG */


/* YYINITDEPTH -- initial size of the parser's stacks.  */
#ifndef YYINITDEPTH
# define YYINITDEPTH 200
#endif

/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
   if the built-in stack extension method is used).

   Do not make this value too large; the results are undefined if
   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
   evaluated with infinite-precision integer arithmetic.  */

#ifndef YYMAXDEPTH
# define YYMAXDEPTH 10000
#endif


#if YYERROR_VERBOSE

# ifndef yystrlen
#  if defined __GLIBC__ && defined _STRING_H
#   define yystrlen strlen
#  else
/* Return the length of YYSTR.  */
static YYSIZE_T
yystrlen (const char *yystr)
{
  YYSIZE_T yylen;
  for (yylen = 0; yystr[yylen]; yylen++)
    continue;
  return yylen;
}
#  endif
# endif

# ifndef yystpcpy
#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
#   define yystpcpy stpcpy
#  else
/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
   YYDEST.  */
static char *
yystpcpy (char *yydest, const char *yysrc)
{
  char *yyd = yydest;
  const char *yys = yysrc;
",552,640,"[3, 15, 87, 89]",[]
