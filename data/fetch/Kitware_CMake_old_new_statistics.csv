sha,message,issue,file_name,old_file,new_file,old_hunk_file,new_hunk_file,old_hunk,new_hunk,old_hunk_loc,new_hunk_loc,old_loc,new_loc,old_log,new_log,action_type,old_log_file,old_block,old_block_file,old_block_feature,new_log_file,old_log_type,old_log_time,old_log_author,cluster
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_1.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_1.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_2.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    char header[80];
    snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, header, 0);
    if(result)
      return result;

",475,473,478,477,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);","snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_0.cpp,"{
    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

    result = Curl_client_write(conn, CLIENTWRITE_BOTH,
                               (char *)""Accept-ranges: bytes\r\n"", 0);
    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_0.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 1, 86, 0, 0, 3, 3, 0, 0, 1, 11, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 1, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 5, 5, 1, 0, 8, 0, 0, 8, 0, 31, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_0.cpp,"name****name****expr****argument
name****name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****argument
literal****name****literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T19:10:28,Brad King,80
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_4.cpp,"      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      char *buf = data->state.buffer;
      if(6 == sscanf(bufï¿½, ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
","      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      if(6 == sscanf(&data->state.buffer[4], ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        char timebuf[24];
        time_t secs=time(NULL);

        snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(timebuf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
",2101,2100,2110,2109,"snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);","snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_1.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_1.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 26, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_1.cpp,"name****name****expr****argument
name****name****operator****name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****argument
literal****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T19:10:28,Brad King,13
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_6.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_6.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      char clbuf[128];
      snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, clbuf, 0);
      if(result)
        return result;
    }
",2318,2318,2321,2322,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);","snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_2.cpp,"{
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_2.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_2.cpp,"name****name****expr****argument
name****name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****argument
literal****name****literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T19:10:28,Brad King,80
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_7.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_7.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,300,301,"f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);","= aprintf(""%s:%s"", user, pwd);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_3.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_3.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 90, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_3.cpp,"name****name****operator****name****operator****name****name****expr****argument
name****name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****argument
literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T19:10:28,Brad King,14
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_9.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[ï©ï¿½] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[ï©ï¿½] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,248,249,"vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);","vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_4.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_4.cpp,"[3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 71, 0, 0, 2, 2, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 3, 0, 0, 6, 0, 0, 9, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_4.cpp,"name****name****operator****name****operator****name****name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T19:10:28,Brad King,15
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_9.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[ï©ï¿½] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[ï©ï¿½] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,251,253,"snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);","strcpy(data->set.errorbuffer, error);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_5.cpp,"{
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_5.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_5.cpp,"name****name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T19:10:28,Brad King,16
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_6.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_6.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_12.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_12.cpp,"  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
","  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 32 random hex chars, 32 bytes  1 zero termination */
  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  if(result)
    return result;

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
",387,386,396,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_6.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challenge message */
  result = auth_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = auth_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_auth_build_spn(service, realm, NULL);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_6.cpp,"[11, 0, 3, 0, 0, 0, 12, 0, 0, 0, 15, 0, 0, 0, 24, 349, 0, 0, 19, 19, 0, 0, 9, 61, 0, 0, 0, 0, 3, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118, 0, 272, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 24, 0, 14, 11, 0, 0, 74, 0, 0, 46, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_6.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T19:10:28,Brad King,89
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_8.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_8.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_14.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_14.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    char header[80];
    snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, header, 0);
    if(result)
      return result;

",475,473,478,477,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);","snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_7.cpp,"{
    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

    result = Curl_client_write(conn, CLIENTWRITE_BOTH,
                               (char *)""Accept-ranges: bytes\r\n"", 0);
    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_7.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 1, 86, 0, 0, 3, 3, 0, 0, 1, 11, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 1, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 5, 5, 1, 0, 8, 0, 0, 8, 0, 31, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_7.cpp,"name****name****expr****argument
name****name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****argument
literal****name****literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T15:10:22,Brad King,80
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_16.cpp,"      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      char *buf = data->state.buffer;
      if(6 == sscanf(bufï¿½, ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
","      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      if(6 == sscanf(&data->state.buffer[4], ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        char timebuf[24];
        time_t secs=time(NULL);

        snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(timebuf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
",2101,2100,2110,2109,"snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);","snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_8.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_8.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 26, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_8.cpp,"name****name****expr****argument
name****name****operator****name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****argument
literal****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T15:10:22,Brad King,13
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_18.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      char clbuf[128];
      snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, clbuf, 0);
      if(result)
        return result;
    }
",2318,2318,2321,2322,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);","snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_9.cpp,"{
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_9.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_9.cpp,"name****name****expr****argument
name****name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****argument
literal****name****literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T15:10:22,Brad King,80
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_19.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,300,301,"f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);","= aprintf(""%s:%s"", user, pwd);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_10.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_10.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 90, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_10.cpp,"name****name****operator****name****operator****name****name****expr****argument
name****name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****argument
literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T15:10:22,Brad King,14
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_11.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_11.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_21.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_21.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[ï©ï¿½] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[ï©ï¿½] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,248,249,"vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);","vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_11.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_11.cpp,"[3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 71, 0, 0, 2, 2, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 3, 0, 0, 6, 0, 0, 9, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_11.cpp,"name****name****operator****name****operator****name****name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T15:10:22,Brad King,15
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_11.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_11.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_21.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_21.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[ï©ï¿½] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[ï©ï¿½] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,251,253,"snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);","strcpy(data->set.errorbuffer, error);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_12.cpp,"{
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_12.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_12.cpp,"name****name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T15:10:22,Brad King,16
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_13.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_13.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_24.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_24.cpp,"  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
","  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 32 random hex chars, 32 bytes  1 zero termination */
  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  if(result)
    return result;

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
",387,386,396,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_13.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challenge message */
  result = auth_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = auth_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_auth_build_spn(service, realm, NULL);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_13.cpp,"[11, 0, 3, 0, 0, 0, 12, 0, 0, 0, 15, 0, 0, 0, 24, 349, 0, 0, 19, 19, 0, 0, 9, 61, 0, 0, 0, 0, 3, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118, 0, 272, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 24, 0, 14, 11, 0, 0, 74, 0, 0, 46, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_13.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T15:10:22,Brad King,89
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_15.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_15.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_26.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_26.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    char header[80];
    snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, header, 0);
    if(result)
      return result;

",475,473,478,477,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);","snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_14.cpp,"{
    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

    result = Curl_client_write(conn, CLIENTWRITE_BOTH,
                               (char *)""Accept-ranges: bytes\r\n"", 0);
    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_14.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 1, 86, 0, 0, 3, 3, 0, 0, 1, 11, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 1, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 5, 5, 1, 0, 8, 0, 0, 8, 0, 31, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_14.cpp,"name****name****expr****argument
name****name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****argument
literal****name****literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T14:46:35,Brad King,80
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_28.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_28.cpp,"      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      char *buf = data->state.buffer;
      if(6 == sscanf(bufï¿½, ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
","      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      if(6 == sscanf(&data->state.buffer[4], ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        char timebuf[24];
        time_t secs=time(NULL);

        snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(timebuf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
",2101,2100,2110,2109,"snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);","snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_15.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_15.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 26, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_15.cpp,"name****name****expr****argument
name****name****operator****name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****argument
literal****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T14:46:35,Brad King,13
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_30.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_30.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      char clbuf[128];
      snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, clbuf, 0);
      if(result)
        return result;
    }
",2318,2318,2321,2322,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);","snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_16.cpp,"{
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_16.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_16.cpp,"name****name****expr****argument
name****name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****argument
literal****name****literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T14:46:35,Brad King,80
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_31.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,300,301,"f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);","= aprintf(""%s:%s"", user, pwd);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_17.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_17.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 90, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_17.cpp,"name****name****operator****name****operator****name****name****expr****argument
name****name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****argument
literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T14:46:35,Brad King,14
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_33.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_33.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[ï©ï¿½] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[ï©ï¿½] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,248,249,"vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);","vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_18.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_18.cpp,"[3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 71, 0, 0, 2, 2, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 3, 0, 0, 6, 0, 0, 9, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_18.cpp,"name****name****operator****name****operator****name****name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T14:46:35,Brad King,15
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_33.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_33.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[ï©ï¿½] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[ï©ï¿½] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,251,253,"snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);","strcpy(data->set.errorbuffer, error);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_19.cpp,"{
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_19.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_19.cpp,"name****name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T14:46:35,Brad King,16
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_20.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_20.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_36.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_36.cpp,"  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
","  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 32 random hex chars, 32 bytes  1 zero termination */
  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  if(result)
    return result;

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
",387,386,396,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_20.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challenge message */
  result = auth_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = auth_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_auth_build_spn(service, realm, NULL);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_20.cpp,"[11, 0, 3, 0, 0, 0, 12, 0, 0, 0, 15, 0, 0, 0, 24, 349, 0, 0, 19, 19, 0, 0, 9, 61, 0, 0, 0, 0, 3, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118, 0, 272, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 24, 0, 14, 11, 0, 0, 74, 0, 0, 46, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_20.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-06-14T14:46:35,Brad King,89
16ebd9f6152fedd1804f13c91ed14e8963e53d3f,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2017-05-16 (fe1f22ce)",[],Source/kwsys/ProcessUNIX.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_23.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_23.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_39.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_39.cpp,"#endif
#endif
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/*--------------------------------------------------------------------------*/
/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
","#endif
#endif
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
",2243,2273,2247,2277,"sprintf(cp->ExitExceptionString, ""Signal %d"", sig);","sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_21.cpp,"{
#ifdef SIGSEGV
    case SIGSEGV:
      KWSYSPE_CASE(Fault, ""Segmentation fault"");
      break;
#endif
#ifdef SIGBUS
#if !defined(SIGSEGV) || SIGBUS != SIGSEGV
    case SIGBUS:
      KWSYSPE_CASE(Fault, ""Bus error"");
      break;
#endif
#endif
#ifdef SIGFPE
    case SIGFPE:
      KWSYSPE_CASE(Numerical, ""Floating-point exception"");
      break;
#endif
#ifdef SIGILL
    case SIGILL:
      KWSYSPE_CASE(Illegal, ""Illegal instruction"");
      break;
#endif
#ifdef SIGINT
    case SIGINT:
      KWSYSPE_CASE(Interrupt, ""User interrupt"");
      break;
#endif
#ifdef SIGABRT
    case SIGABRT:
      KWSYSPE_CASE(Other, ""Child aborted"");
      break;
#endif
#ifdef SIGKILL
    case SIGKILL:
      KWSYSPE_CASE(Other, ""Child killed"");
      break;
#endif
#ifdef SIGTERM
    case SIGTERM:
      KWSYSPE_CASE(Other, ""Child terminated"");
      break;
#endif
#ifdef SIGHUP
    case SIGHUP:
      KWSYSPE_CASE(Other, ""SIGHUP"");
      break;
#endif
#ifdef SIGQUIT
    case SIGQUIT:
      KWSYSPE_CASE(Other, ""SIGQUIT"");
      break;
#endif
#ifdef SIGTRAP
    case SIGTRAP:
      KWSYSPE_CASE(Other, ""SIGTRAP"");
      break;
#endif
#ifdef SIGIOT
#if !defined(SIGABRT) || SIGIOT != SIGABRT
    case SIGIOT:
      KWSYSPE_CASE(Other, ""SIGIOT"");
      break;
#endif
#endif
#ifdef SIGUSR1
    case SIGUSR1:
      KWSYSPE_CASE(Other, ""SIGUSR1"");
      break;
#endif
#ifdef SIGUSR2
    case SIGUSR2:
      KWSYSPE_CASE(Other, ""SIGUSR2"");
      break;
#endif
#ifdef SIGPIPE
    case SIGPIPE:
      KWSYSPE_CASE(Other, ""SIGPIPE"");
      break;
#endif
#ifdef SIGALRM
    case SIGALRM:
      KWSYSPE_CASE(Other, ""SIGALRM"");
      break;
#endif
#ifdef SIGSTKFLT
    case SIGSTKFLT:
      KWSYSPE_CASE(Other, ""SIGSTKFLT"");
      break;
#endif
#ifdef SIGCHLD
    case SIGCHLD:
      KWSYSPE_CASE(Other, ""SIGCHLD"");
      break;
#elif defined(SIGCLD)
    case SIGCLD:
      KWSYSPE_CASE(Other, ""SIGCLD"");
      break;
#endif
#ifdef SIGCONT
    case SIGCONT:
      KWSYSPE_CASE(Other, ""SIGCONT"");
      break;
#endif
#ifdef SIGSTOP
    case SIGSTOP:
      KWSYSPE_CASE(Other, ""SIGSTOP"");
      break;
#endif
#ifdef SIGTSTP
    case SIGTSTP:
      KWSYSPE_CASE(Other, ""SIGTSTP"");
      break;
#endif
#ifdef SIGTTIN
    case SIGTTIN:
      KWSYSPE_CASE(Other, ""SIGTTIN"");
      break;
#endif
#ifdef SIGTTOU
    case SIGTTOU:
      KWSYSPE_CASE(Other, ""SIGTTOU"");
      break;
#endif
#ifdef SIGURG
    case SIGURG:
      KWSYSPE_CASE(Other, ""SIGURG"");
      break;
#endif
#ifdef SIGXCPU
    case SIGXCPU:
      KWSYSPE_CASE(Other, ""SIGXCPU"");
      break;
#endif
#ifdef SIGXFSZ
    case SIGXFSZ:
      KWSYSPE_CASE(Other, ""SIGXFSZ"");
      break;
#endif
#ifdef SIGVTALRM
    case SIGVTALRM:
      KWSYSPE_CASE(Other, ""SIGVTALRM"");
      break;
#endif
#ifdef SIGPROF
    case SIGPROF:
      KWSYSPE_CASE(Other, ""SIGPROF"");
      break;
#endif
#ifdef SIGWINCH
    case SIGWINCH:
      KWSYSPE_CASE(Other, ""SIGWINCH"");
      break;
#endif
#ifdef SIGPOLL
    case SIGPOLL:
      KWSYSPE_CASE(Other, ""SIGPOLL"");
      break;
#endif
#ifdef SIGIO
#if !defined(SIGPOLL) || SIGIO != SIGPOLL
    case SIGIO:
      KWSYSPE_CASE(Other, ""SIGIO"");
      break;
#endif
#endif
#ifdef SIGPWR
    case SIGPWR:
      KWSYSPE_CASE(Other, ""SIGPWR"");
      break;
#endif
#ifdef SIGSYS
    case SIGSYS:
      KWSYSPE_CASE(Other, ""SIGSYS"");
      break;
#endif
#ifdef SIGUNUSED
#if !defined(SIGSYS) || SIGUNUSED != SIGSYS
    case SIGUNUSED:
      KWSYSPE_CASE(Other, ""SIGUNUSED"");
      break;
#endif
#endif
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Signal %d"", sig);
      break;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_21.cpp,"[4, 0, 0, 0, 36, 0, 0, 0, 35, 1, 1, 0, 0, 0, 0, 166, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 0, 0, 37, 0, 78, 77, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_21.cpp,"name****name****operator****name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-05-16T15:39:01,Brad King,17
16ebd9f6152fedd1804f13c91ed14e8963e53d3f,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2017-05-16 (fe1f22ce)",[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_24.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_24.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_40.cpp,"
    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);
      break;
  }
}
","
    case STATUS_NO_MEMORY:
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);
      break;
  }
}
",2120,2142,2124,2146,"_snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);","_snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_22.cpp,"{
    case STATUS_CONTROL_C_EXIT:
      KWSYSPE_CASE(Interrupt, ""User interrupt"");
      break;

    case STATUS_FLOAT_DENORMAL_OPERAND:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (denormal operand)"");
      break;
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Divide-by-zero"");
      break;
    case STATUS_FLOAT_INEXACT_RESULT:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (inexact result)"");
      break;
    case STATUS_FLOAT_INVALID_OPERATION:
      KWSYSPE_CASE(Numerical, ""Invalid floating-point operation"");
      break;
    case STATUS_FLOAT_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point overflow"");
      break;
    case STATUS_FLOAT_STACK_CHECK:
      KWSYSPE_CASE(Numerical, ""Floating-point stack check failed"");
      break;
    case STATUS_FLOAT_UNDERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point underflow"");
      break;
#ifdef STATUS_FLOAT_MULTIPLE_FAULTS
    case STATUS_FLOAT_MULTIPLE_FAULTS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple faults)"");
      break;
#endif
#ifdef STATUS_FLOAT_MULTIPLE_TRAPS
    case STATUS_FLOAT_MULTIPLE_TRAPS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple traps)"");
      break;
#endif
    case STATUS_INTEGER_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Integer divide-by-zero"");
      break;
    case STATUS_INTEGER_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Integer overflow"");
      break;

    case STATUS_DATATYPE_MISALIGNMENT:
      KWSYSPE_CASE(Fault, ""Datatype misalignment"");
      break;
    case STATUS_ACCESS_VIOLATION:
      KWSYSPE_CASE(Fault, ""Access violation"");
      break;
    case STATUS_IN_PAGE_ERROR:
      KWSYSPE_CASE(Fault, ""In-page error"");
      break;
    case STATUS_INVALID_HANDLE:
      KWSYSPE_CASE(Fault, ""Invalid hanlde"");
      break;
    case STATUS_NONCONTINUABLE_EXCEPTION:
      KWSYSPE_CASE(Fault, ""Noncontinuable exception"");
      break;
    case STATUS_INVALID_DISPOSITION:
      KWSYSPE_CASE(Fault, ""Invalid disposition"");
      break;
    case STATUS_ARRAY_BOUNDS_EXCEEDED:
      KWSYSPE_CASE(Fault, ""Array bounds exceeded"");
      break;
    case STATUS_STACK_OVERFLOW:
      KWSYSPE_CASE(Fault, ""Stack overflow"");
      break;

    case STATUS_ILLEGAL_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Illegal instruction"");
      break;
    case STATUS_PRIVILEGED_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Privileged instruction"");
      break;

    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);
      break;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_22.cpp,"[0, 0, 0, 0, 23, 0, 0, 0, 23, 1, 1, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 24, 0, 48, 4, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_22.cpp,"name****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-05-16T15:39:01,Brad King,18
7be70ca6cc888df532d2f1560e74d13642730ee5,"KWSys 2017-05-16 (fe1f22ce)

Code extracted from:

    https://gitlab.kitware.com/utils/kwsys.git

at commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).

Upstream Shortlog
-----------------

Adam Weisi (3):
      8a799e36 Process: Improve definition ordering in header file
      7d56ef24 Process: Save results from all children internally
      b7eba998 Process: Add APIs to get results of individual processes

Ben Boeckel (2):
      cea71543 style: remove separator comments
      874dc559 style: help clang-format near macros",[],ProcessUNIX.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_26.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_26.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_42.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_42.cpp,"#endif
#endif
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/*--------------------------------------------------------------------------*/
/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
","#endif
#endif
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
",2243,2273,2247,2277,"sprintf(cp->ExitExceptionString, ""Signal %d"", sig);","sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_23.cpp,"{
#ifdef SIGSEGV
    case SIGSEGV:
      KWSYSPE_CASE(Fault, ""Segmentation fault"");
      break;
#endif
#ifdef SIGBUS
#if !defined(SIGSEGV) || SIGBUS != SIGSEGV
    case SIGBUS:
      KWSYSPE_CASE(Fault, ""Bus error"");
      break;
#endif
#endif
#ifdef SIGFPE
    case SIGFPE:
      KWSYSPE_CASE(Numerical, ""Floating-point exception"");
      break;
#endif
#ifdef SIGILL
    case SIGILL:
      KWSYSPE_CASE(Illegal, ""Illegal instruction"");
      break;
#endif
#ifdef SIGINT
    case SIGINT:
      KWSYSPE_CASE(Interrupt, ""User interrupt"");
      break;
#endif
#ifdef SIGABRT
    case SIGABRT:
      KWSYSPE_CASE(Other, ""Child aborted"");
      break;
#endif
#ifdef SIGKILL
    case SIGKILL:
      KWSYSPE_CASE(Other, ""Child killed"");
      break;
#endif
#ifdef SIGTERM
    case SIGTERM:
      KWSYSPE_CASE(Other, ""Child terminated"");
      break;
#endif
#ifdef SIGHUP
    case SIGHUP:
      KWSYSPE_CASE(Other, ""SIGHUP"");
      break;
#endif
#ifdef SIGQUIT
    case SIGQUIT:
      KWSYSPE_CASE(Other, ""SIGQUIT"");
      break;
#endif
#ifdef SIGTRAP
    case SIGTRAP:
      KWSYSPE_CASE(Other, ""SIGTRAP"");
      break;
#endif
#ifdef SIGIOT
#if !defined(SIGABRT) || SIGIOT != SIGABRT
    case SIGIOT:
      KWSYSPE_CASE(Other, ""SIGIOT"");
      break;
#endif
#endif
#ifdef SIGUSR1
    case SIGUSR1:
      KWSYSPE_CASE(Other, ""SIGUSR1"");
      break;
#endif
#ifdef SIGUSR2
    case SIGUSR2:
      KWSYSPE_CASE(Other, ""SIGUSR2"");
      break;
#endif
#ifdef SIGPIPE
    case SIGPIPE:
      KWSYSPE_CASE(Other, ""SIGPIPE"");
      break;
#endif
#ifdef SIGALRM
    case SIGALRM:
      KWSYSPE_CASE(Other, ""SIGALRM"");
      break;
#endif
#ifdef SIGSTKFLT
    case SIGSTKFLT:
      KWSYSPE_CASE(Other, ""SIGSTKFLT"");
      break;
#endif
#ifdef SIGCHLD
    case SIGCHLD:
      KWSYSPE_CASE(Other, ""SIGCHLD"");
      break;
#elif defined(SIGCLD)
    case SIGCLD:
      KWSYSPE_CASE(Other, ""SIGCLD"");
      break;
#endif
#ifdef SIGCONT
    case SIGCONT:
      KWSYSPE_CASE(Other, ""SIGCONT"");
      break;
#endif
#ifdef SIGSTOP
    case SIGSTOP:
      KWSYSPE_CASE(Other, ""SIGSTOP"");
      break;
#endif
#ifdef SIGTSTP
    case SIGTSTP:
      KWSYSPE_CASE(Other, ""SIGTSTP"");
      break;
#endif
#ifdef SIGTTIN
    case SIGTTIN:
      KWSYSPE_CASE(Other, ""SIGTTIN"");
      break;
#endif
#ifdef SIGTTOU
    case SIGTTOU:
      KWSYSPE_CASE(Other, ""SIGTTOU"");
      break;
#endif
#ifdef SIGURG
    case SIGURG:
      KWSYSPE_CASE(Other, ""SIGURG"");
      break;
#endif
#ifdef SIGXCPU
    case SIGXCPU:
      KWSYSPE_CASE(Other, ""SIGXCPU"");
      break;
#endif
#ifdef SIGXFSZ
    case SIGXFSZ:
      KWSYSPE_CASE(Other, ""SIGXFSZ"");
      break;
#endif
#ifdef SIGVTALRM
    case SIGVTALRM:
      KWSYSPE_CASE(Other, ""SIGVTALRM"");
      break;
#endif
#ifdef SIGPROF
    case SIGPROF:
      KWSYSPE_CASE(Other, ""SIGPROF"");
      break;
#endif
#ifdef SIGWINCH
    case SIGWINCH:
      KWSYSPE_CASE(Other, ""SIGWINCH"");
      break;
#endif
#ifdef SIGPOLL
    case SIGPOLL:
      KWSYSPE_CASE(Other, ""SIGPOLL"");
      break;
#endif
#ifdef SIGIO
#if !defined(SIGPOLL) || SIGIO != SIGPOLL
    case SIGIO:
      KWSYSPE_CASE(Other, ""SIGIO"");
      break;
#endif
#endif
#ifdef SIGPWR
    case SIGPWR:
      KWSYSPE_CASE(Other, ""SIGPWR"");
      break;
#endif
#ifdef SIGSYS
    case SIGSYS:
      KWSYSPE_CASE(Other, ""SIGSYS"");
      break;
#endif
#ifdef SIGUNUSED
#if !defined(SIGSYS) || SIGUNUSED != SIGSYS
    case SIGUNUSED:
      KWSYSPE_CASE(Other, ""SIGUNUSED"");
      break;
#endif
#endif
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Signal %d"", sig);
      break;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_23.cpp,"[4, 0, 0, 0, 36, 0, 0, 0, 35, 1, 1, 0, 0, 0, 0, 166, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 0, 0, 37, 0, 78, 77, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_23.cpp,"name****name****operator****name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-05-16T15:39:00,Brad King,17
7be70ca6cc888df532d2f1560e74d13642730ee5,"KWSys 2017-05-16 (fe1f22ce)

Code extracted from:

    https://gitlab.kitware.com/utils/kwsys.git

at commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).

Upstream Shortlog
-----------------

Adam Weisi (3):
      8a799e36 Process: Improve definition ordering in header file
      7d56ef24 Process: Save results from all children internally
      b7eba998 Process: Add APIs to get results of individual processes

Ben Boeckel (2):
      cea71543 style: remove separator comments
      874dc559 style: help clang-format near macros",[],ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_27.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_27.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_43.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_43.cpp,"
    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);
      break;
  }
}
","
    case STATUS_NO_MEMORY:
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);
      break;
  }
}
",2120,2142,2124,2146,"_snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);","_snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_24.cpp,"{
    case STATUS_CONTROL_C_EXIT:
      KWSYSPE_CASE(Interrupt, ""User interrupt"");
      break;

    case STATUS_FLOAT_DENORMAL_OPERAND:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (denormal operand)"");
      break;
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Divide-by-zero"");
      break;
    case STATUS_FLOAT_INEXACT_RESULT:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (inexact result)"");
      break;
    case STATUS_FLOAT_INVALID_OPERATION:
      KWSYSPE_CASE(Numerical, ""Invalid floating-point operation"");
      break;
    case STATUS_FLOAT_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point overflow"");
      break;
    case STATUS_FLOAT_STACK_CHECK:
      KWSYSPE_CASE(Numerical, ""Floating-point stack check failed"");
      break;
    case STATUS_FLOAT_UNDERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point underflow"");
      break;
#ifdef STATUS_FLOAT_MULTIPLE_FAULTS
    case STATUS_FLOAT_MULTIPLE_FAULTS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple faults)"");
      break;
#endif
#ifdef STATUS_FLOAT_MULTIPLE_TRAPS
    case STATUS_FLOAT_MULTIPLE_TRAPS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple traps)"");
      break;
#endif
    case STATUS_INTEGER_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Integer divide-by-zero"");
      break;
    case STATUS_INTEGER_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Integer overflow"");
      break;

    case STATUS_DATATYPE_MISALIGNMENT:
      KWSYSPE_CASE(Fault, ""Datatype misalignment"");
      break;
    case STATUS_ACCESS_VIOLATION:
      KWSYSPE_CASE(Fault, ""Access violation"");
      break;
    case STATUS_IN_PAGE_ERROR:
      KWSYSPE_CASE(Fault, ""In-page error"");
      break;
    case STATUS_INVALID_HANDLE:
      KWSYSPE_CASE(Fault, ""Invalid hanlde"");
      break;
    case STATUS_NONCONTINUABLE_EXCEPTION:
      KWSYSPE_CASE(Fault, ""Noncontinuable exception"");
      break;
    case STATUS_INVALID_DISPOSITION:
      KWSYSPE_CASE(Fault, ""Invalid disposition"");
      break;
    case STATUS_ARRAY_BOUNDS_EXCEEDED:
      KWSYSPE_CASE(Fault, ""Array bounds exceeded"");
      break;
    case STATUS_STACK_OVERFLOW:
      KWSYSPE_CASE(Fault, ""Stack overflow"");
      break;

    case STATUS_ILLEGAL_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Illegal instruction"");
      break;
    case STATUS_PRIVILEGED_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Privileged instruction"");
      break;

    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);
      break;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_24.cpp,"[0, 0, 0, 0, 23, 0, 0, 0, 23, 1, 1, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 24, 0, 48, 4, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_24.cpp,"name****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-05-16T15:39:00,Brad King,18
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/conncache.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_29.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_29.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_45.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_45.cpp,"  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}

/* Look up the bundle with all the connections to the same host this
","  else
    hostname = conn->host.name;

  DEBUGASSERT(len > 32);

  /* put the number first so that the hostname gets cut off if too long */
  snprintf(buf, len, ""%ld%s"", conn->port, hostname);
}

/* Look up the bundle with all the connections to the same host this
",141,136,144,142,"aprintf(""%s:%d"", hostname, conn->port);","snprintf(buf, len, ""%ld%s"", conn->port, hostname);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_25.cpp,"{
  const char *hostname;

  if(conn->bits.socksproxy)
    hostname = conn->socks_proxy.host.name;
  else if(conn->bits.httpproxy)
    hostname = conn->http_proxy.host.name;
  else if(conn->bits.conn_to_host)
    hostname = conn->conn_to_host.name;
  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_25.cpp,"[3, 0, 0, 0, 0, 0, 1, 0, 0, 0, 5, 0, 0, 0, 1, 41, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 3, 1, 0, 1, 0, 0, 4, 2, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_25.cpp,"name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-05-11T15:27:21,Brad King,19
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_30.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_30.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_46.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_46.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
",476,475,479,478,"snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_26.cpp,"{
    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

    result = Curl_client_write(conn, CLIENTWRITE_BOTH,
                               (char *)""Accept-ranges: bytes\r\n"", 0);
    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_26.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 1, 85, 0, 0, 3, 3, 0, 0, 1, 11, 0, 0, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 1, 53, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 5, 5, 1, 0, 8, 0, 0, 8, 0, 31, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_26.cpp,"name****name****expr****argument
name****operator****name****operator****name****name****expr****argument
argument_list****sizeof****expr****argument
literal****name****literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-05-11T15:27:21,Brad King,81
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_47.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_47.cpp,"        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
","        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
",2107,2107,2110,2110,"snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);","snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_27.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_27.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 25, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_27.cpp,"name****name****expr****argument
name****operator****name****operator****name****operator****name****name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-05-11T15:27:21,Brad King,20
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_48.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
",2318,2318,2321,2321,"snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_28.cpp,"{
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_28.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_28.cpp,"name****name****expr****argument
name****operator****name****operator****name****name****expr****argument
argument_list****sizeof****expr****argument
literal****name****literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-05-11T15:27:21,Brad King,81
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_32.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_32.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_50.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_50.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
","    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
",297,297,300,300,"f(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);","f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_29.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_29.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 89, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_29.cpp,"name****name****operator****name****operator****name****name****expr****argument
name****operator****name****operator****name****name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-05-11T15:27:21,Brad King,21
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/conncache.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_38.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_38.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_56.cpp,"  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}

/* Look up the bundle with all the connections to the same host this
","  else
    hostname = conn->host.name;

  DEBUGASSERT(len > 32);

  /* put the number first so that the hostname gets cut off if too long */
  snprintf(buf, len, ""%ld%s"", conn->port, hostname);
}

/* Look up the bundle with all the connections to the same host this
",141,136,144,142,"aprintf(""%s:%d"", hostname, conn->port);","snprintf(buf, len, ""%ld%s"", conn->port, hostname);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_30.cpp,"{
  const char *hostname;

  if(conn->bits.socksproxy)
    hostname = conn->socks_proxy.host.name;
  else if(conn->bits.httpproxy)
    hostname = conn->http_proxy.host.name;
  else if(conn->bits.conn_to_host)
    hostname = conn->conn_to_host.name;
  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_30.cpp,"[3, 0, 0, 0, 0, 0, 1, 0, 0, 0, 5, 0, 0, 0, 1, 41, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 3, 1, 0, 1, 0, 0, 4, 2, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_30.cpp,"name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-05-11T15:26:45,Brad King,19
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_39.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_39.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_57.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_57.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
",476,475,479,478,"snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_31.cpp,"{
    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

    result = Curl_client_write(conn, CLIENTWRITE_BOTH,
                               (char *)""Accept-ranges: bytes\r\n"", 0);
    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_31.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 1, 85, 0, 0, 3, 3, 0, 0, 1, 11, 0, 0, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 1, 53, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 5, 5, 1, 0, 8, 0, 0, 8, 0, 31, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_31.cpp,"name****name****expr****argument
name****operator****name****operator****name****name****expr****argument
argument_list****sizeof****expr****argument
literal****name****literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-05-11T15:26:45,Brad King,81
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_58.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_58.cpp,"        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
","        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
",2107,2107,2110,2110,"snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);","snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_32.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_32.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 25, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_32.cpp,"name****name****expr****argument
name****operator****name****operator****name****operator****name****name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-05-11T15:26:45,Brad King,20
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_59.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
",2318,2318,2321,2321,"snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_33.cpp,"{
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_33.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_33.cpp,"name****name****expr****argument
name****operator****name****operator****name****name****expr****argument
argument_list****sizeof****expr****argument
literal****name****literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-05-11T15:26:45,Brad King,81
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_41.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_41.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_61.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_61.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
","    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
",297,297,300,300,"f(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);","f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_34.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_34.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 89, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_34.cpp,"name****name****operator****name****operator****name****name****expr****argument
name****operator****name****operator****name****name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-05-11T15:26:45,Brad King,21
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_76.cpp,"name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

if (a->tree != NULL) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't change dir"");
return (ARCHIVE_FAILED);
}
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
","name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
else if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't change dir to read extended attributes"");
return (ARCHIVE_FAILED);
}
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
",302,321,313,325,"archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");","archive_set_error(&a->archive, errno,
			    ""Can't change dir to read extended attributes"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_35.cpp,"{
			archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");
				return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_35.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_35.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,111
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_77.cpp,"const char *path;
ssize_t list_size;

path = archive_entry_sourcepath(entry);
if (path == NULL)
path = archive_entry_pathname(entry);

if (*fd < 0 && a->tree != NULL) {
if (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)
*fd = a->open_on_current_dir(a->tree, path,
O_RDONLY | O_NONBLOCK);
if (*fd < 0) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't access %s"", path);
return (ARCHIVE_FAILED);
}
}
}

","const char *path;
ssize_t list_size;

path = NULL;

if (*fd < 0) {
path = archive_entry_sourcepath(entry);
if (path == NULL || (a->tree != NULL &&
    a->tree_enter_working_dir(a->tree) != 0))
path = archive_entry_pathname(entry);
if (path == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Couldn't determine file path to read ""
    ""extended attributes"");
return (ARCHIVE_WARN);
}
if (a->tree != NULL && (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)) {
*fd = a->open_on_current_dir(a->tree,
    path, O_RDONLY | O_NONBLOCK);
}
}

",772,1486,786,1497,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_36.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_36.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_36.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,82
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_78.cpp,"const char *path;
int namespace = EXTATTR_NAMESPACE_USER;

path = archive_entry_sourcepath(entry);
if (path == NULL)
path = archive_entry_pathname(entry);

if (*fd < 0 && a->tree != NULL) {
if (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)
*fd = a->open_on_current_dir(a->tree, path,
O_RDONLY | O_NONBLOCK);
if (*fd < 0) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't access %s"", path);
return (ARCHIVE_FAILED);
}
}
}

","const char *path;
int namespace = EXTATTR_NAMESPACE_USER;

path = NULL;

if (*fd < 0) {
path = archive_entry_sourcepath(entry);
if (path == NULL || (a->tree != NULL &&
    a->tree_enter_working_dir(a->tree) != 0))
path = archive_entry_pathname(entry);
if (path == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Couldn't determine file path to read ""
    ""extended attributes"");
return (ARCHIVE_WARN);
}
if (a->tree != NULL && (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)) {
*fd = a->open_on_current_dir(a->tree,
    path, O_RDONLY | O_NONBLOCK);
}
}

",932,1645,946,1656,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_37.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_37.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_37.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,82
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_80.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_80.cpp,"r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",938,938,940,940,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_38.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_38.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_38.cpp,"name****operator****operator****name****operator****name****name****operator****expr****argument
name****expr****argument
literal****expr****argument
name****name****operator****name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,104
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_81.cpp,"r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",1041,1041,1043,1043,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_39.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_39.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_39.cpp,"name****operator****operator****name****operator****name****name****operator****expr****argument
name****expr****argument
literal****expr****argument
name****name****operator****name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,104
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_82.cpp,"r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",1067,1067,1069,1069,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_40.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_40.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_40.cpp,"name****operator****operator****name****operator****name****name****operator****expr****argument
name****expr****argument
literal****expr****argument
name****name****operator****name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,104
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_84.cpp,"r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",803,802,805,804,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_41.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_41.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_41.cpp,"name****operator****operator****name****operator****name****name****operator****expr****argument
name****expr****argument
literal****expr****argument
name****name****operator****name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,104
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_85.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_85.cpp,"r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",875,874,877,876,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_42.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_42.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_42.cpp,"name****operator****operator****name****operator****name****name****operator****expr****argument
name****expr****argument
literal****expr****argument
name****name****operator****name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,104
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_86.cpp,"r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",901,900,903,902,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_43.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_43.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_43.cpp,"name****operator****operator****name****operator****name****name****operator****expr****argument
name****expr****argument
literal****expr****argument
name****name****operator****name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,104
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,790,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_44.cpp,"{
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_44.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_44.cpp,"name****operator****name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,103
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,821,-1,"archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_45.cpp,"{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_45.cpp,"[3, 0, 0, 0, 2, 0, 4, 1, 2, 0, 5, 0, 0, 0, 2, 152, 0, 0, 4, 5, 0, 0, 1, 11, 0, 0, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 0, 62, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 4, 3, 0, 0, 14, 0, 0, 25, 0, 26, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_45.cpp,"name****operator****name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,103
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,827,-1,"archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_46.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_46.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_46.cpp,"name****operator****name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,83
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,833,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_47.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_47.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_47.cpp,"name****operator****name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,83
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,866,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_48.cpp,"{
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_48.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_48.cpp,"name****operator****name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,103
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,884,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_49.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_49.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_49.cpp,"name****operator****name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,103
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,890,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_50.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_50.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_50.cpp,"name****operator****name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,103
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,921,-1,"archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_51.cpp,"{
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_51.cpp,"[0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_51.cpp,"name****operator****operator****name****operator****name****operator****name****name****operator****expr****argument
name****expr****argument
literal****expr****argument
name****operator****name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,22
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_110.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_110.cpp,"switch ((int)type & ~0777777) {
case 01000000:
/* POSIX.1e ACL */
break;
case 03000000:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Solaris NFSv4 ACLs not supported"");
return (ARCHIVE_WARN);
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Malformed Solaris ACL attribute (unsupported type %o)"",
","switch ((int)type & ~0777777) {
case 01000000:
/* POSIX.1e ACL */
acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;
break;
case 03000000:
/* NFSv4 ACL */
acl_type = ARCHIVE_ENTRY_ACL_TYPE_NFS4;
break;
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Malformed Solaris ACL attribute (unsupported type %o)"",
",935,989,940,992,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");",acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_52.cpp,"{
	case 01000000:
		/* POSIX.1e ACL */
		break;
	case 03000000:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");
		return (ARCHIVE_WARN);
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Malformed Solaris ACL attribute (unsupported type %o)"",
		    (int)type);
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_52.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 2, 1, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_52.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,23
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_112.cpp,"if (tar->entry_bytes_remaining < 0) {
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry has negative size?"");
err = ARCHIVE_WARN;
}
tar->realsize = tar->entry_bytes_remaining;
archive_entry_set_size(entry, tar->entry_bytes_remaining);
","if (tar->entry_bytes_remaining < 0) {
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry has negative size"");
return (ARCHIVE_FATAL);
}
if (tar->entry_bytes_remaining == INT64_MAX) {
/* Note: tar_atol returns INT64_MAX on overflow */
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry size overflow"");
return (ARCHIVE_FATAL);
}
tar->realsize = tar->entry_bytes_remaining;
archive_entry_set_size(entry, tar->entry_bytes_remaining);
",1128,1183,1130,1185,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_53.cpp,"{
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");
		err = ARCHIVE_WARN;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_53.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_53.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,111
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_113.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1820,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_54.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_54.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_54.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,84
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_113.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1825,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_55.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_55.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_55.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,109
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_113.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1844,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_56.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_56.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_56.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,84
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_113.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1849,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_57.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_57.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_57.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,109
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_116.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_116.cpp,"&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {
/* nawww, I wish they promised backward compatibility
 * anyhoo, in their infinite wisdom the 28500 guys might
 * come up with something we can't possibly handle so
 * best end things here */
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version"");
return (ARCHIVE_FATAL);
} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
","&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
}
ver = _warc_rdver(buf, eoh - buf);
/* we currently support WARC 0.12 to 1.0 */
if (ver == 0U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Invalid record version"");
return (ARCHIVE_FATAL);
} else if (ver < 1200U || ver > 10000U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version: %u.%u"",
ver / 10000, (ver % 10000) / 100);
return (ARCHIVE_FATAL);
}
cntlen = _warc_rdlen(buf, eoh - buf);
if (cntlen < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
}
rtime = _warc_rdrtm(buf, eoh - buf);
if (rtime == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
",255,254,263,261,"archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");","archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Invalid record version"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_58.cpp,"{
		/* nawww, I wish they promised backward compatibility
		 * anyhoo, in their infinite wisdom the 28500 guys might
		 * come up with something we can't possibly handle so
		 * best end things here */
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_58.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_58.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,111
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_117.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_117.cpp,"if (ver != w->pver) {
/* stringify this entry's version */
archive_string_sprintf(&w->sver,
""WARC/%u.%u"", ver / 10000, ver % 10000);
/* remember the version */
w->pver = ver;
}
","if (ver != w->pver) {
/* stringify this entry's version */
archive_string_sprintf(&w->sver,
""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100);
/* remember the version */
w->pver = ver;
}
",285,293,287,295,"archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);","archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_59.cpp,"{
		/* stringify this entry's version */
		archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);
		/* remember the version */
		w->pver = ver;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_59.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_59.cpp,"name****operator****name****operator****name****name****expr****argument
literal****expr****argument
name****operator****literal****expr****argument
name****operator****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,24
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_118.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_118.cpp,"xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
if (xar->lzstream_valid)
lzmadec_end(&(xar->lzstream));
r = lzmadec_init(&(xar->lzstream));
if (r != LZMADEC_OK) {
switch (r) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing ""
    ""compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&a->archive,
    ENOMEM,
    ""Internal error initializing ""
    ""compression library: ""
    ""out of memory"");
break;
}
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 1;
xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
","xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
",1526,1524,1537,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_60.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_60.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_60.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****literal****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,85
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_118.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_118.cpp,"xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
if (xar->lzstream_valid)
lzmadec_end(&(xar->lzstream));
r = lzmadec_init(&(xar->lzstream));
if (r != LZMADEC_OK) {
switch (r) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing ""
    ""compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&a->archive,
    ENOMEM,
    ""Internal error initializing ""
    ""compression library: ""
    ""out of memory"");
break;
}
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 1;
xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
","xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
",1526,1524,1544,-1,"archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_61.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_61.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_61.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****literal****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,85
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_119.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_119.cpp,"*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
xar->lzstream.avail_in = avail_in;
xar->lzstream.next_out = (unsigned char *)outbuff;
xar->lzstream.avail_out = avail_out;
r = lzmadec_decode(&(xar->lzstream), 0);
switch (r) {
case LZMADEC_STREAM_END: /* Found end of stream. */
switch (lzmadec_end(&(xar->lzstream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up lzmadec decompressor"");
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 0;
/* FALLTHROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""lzmadec decompression failed(%d)"",
    r);
return (ARCHIVE_FATAL);
}
*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
case LZMA:
#endif
case XZ:
#endif
case NONE:
","*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
case LZMA:
case XZ:
#endif
case NONE:
",1685,1653,1701,-1,"archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_62.cpp,"{
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_62.cpp,"[0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_62.cpp,"name****operator****operator****name****operator****name****name****operator****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,25
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_119.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_119.cpp,"*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
xar->lzstream.avail_in = avail_in;
xar->lzstream.next_out = (unsigned char *)outbuff;
xar->lzstream.avail_out = avail_out;
r = lzmadec_decode(&(xar->lzstream), 0);
switch (r) {
case LZMADEC_STREAM_END: /* Found end of stream. */
switch (lzmadec_end(&(xar->lzstream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up lzmadec decompressor"");
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 0;
/* FALLTHROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""lzmadec decompression failed(%d)"",
    r);
return (ARCHIVE_FATAL);
}
*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
case LZMA:
#endif
case XZ:
#endif
case NONE:
","*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
case LZMA:
case XZ:
#endif
case NONE:
",1685,1653,1711,-1,"archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_63.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			switch (lzmadec_end(&(xar->lzstream))) {
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}
			xar->lzstream_valid = 0;
			/* FALLTHROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			break;
		default:
			archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_63.cpp,"[0, 0, 0, 0, 2, 0, 2, 1, 3, 2, 2, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_63.cpp,"name****operator****operator****name****operator****name****name****operator****expr****argument
name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,26
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_121.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_121.cpp,"}
offset = datasize;
}
#ifdef DEBUG
if (offset != extra_length)
{
fprintf(stderr,
    ""Extra data field contents do not match reported size!\n"");
}
#endif
}

/*
","}
offset = datasize;
}
if (offset != extra_length) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Malformed extra data: Consumed %d bytes of %d bytes"",
    (int)offset, (int)extra_length);
return ARCHIVE_FAILED;
}
return ARCHIVE_OK;
}

/*
",715,739,721,743,"fprintf(stderr,
		    ""Extra data field contents do not match reported size!\n"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Malformed extra data: Consumed %d bytes of %d bytes"",
		    (int)offset, (int)extra_length);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_64.cpp,"{
		fprintf(stderr,
		    ""Extra data field contents do not match reported size!\n"");
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_64.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_64.cpp,"name****name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,27
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_129.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2414,2599,"archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);","fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_65.cpp,"{
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_65.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_65.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,28
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_129.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2428,2629,"archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_66.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_66.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_66.cpp,"name****operator****name****operator****name****name****expr****argument
literal****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,86
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_129.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2438,2660,"archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);","fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_67.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_67.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_67.cpp,"name****operator****name****operator****name****name****expr****argument
literal****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,29
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_129.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2446,2673,"archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_68.cpp,"{
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_68.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_68.cpp,"name****operator****name****operator****name****name****expr****argument
literal****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,86
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_130.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_130.cpp," * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
char *dest, *src;
char separator = '\0';

dest = src = a->name;
if (*src == '\0') {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Invalid empty pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(a);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
                  ""Path is absolute"");
return (ARCHIVE_FAILED);
}

"," * is set) if the path is absolute.
 */
static int
cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
char *dest, *src;
char separator = '\0';

dest = src = path;
if (*src == '\0') {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Invalid empty "", ""pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(path);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Path is "", ""absolute"");
return (ARCHIVE_FAILED);
}

",2534,2807,2544,2818,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");","fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty "", ""pathname"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_69.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_69.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_69.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,87
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_130.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_130.cpp," * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
char *dest, *src;
char separator = '\0';

dest = src = a->name;
if (*src == '\0') {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Invalid empty pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(a);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
                  ""Path is absolute"");
return (ARCHIVE_FAILED);
}

"," * is set) if the path is absolute.
 */
static int
cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
char *dest, *src;
char separator = '\0';

dest = src = path;
if (*src == '\0') {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Invalid empty "", ""pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(path);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Path is "", ""absolute"");
return (ARCHIVE_FAILED);
}

",2534,2807,2555,2829,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");","fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
			    ""Path is "", ""absolute"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_70.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_70.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_70.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,87
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_131.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_131.cpp,"} else if (src[1] == '.') {
if (src[2] == '/' || src[2] == '\0') {
/* Conditionally warn about '..' */
if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Path contains '..'"");
return (ARCHIVE_FAILED);
}
}
","} else if (src[1] == '.') {
if (src[2] == '/' || src[2] == '\0') {
/* Conditionally warn about '..' */
if (flags
    & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
fsobj_error(a_eno, a_estr,
    ARCHIVE_ERRNO_MISC,
    ""Path contains "", ""'..'"");
return (ARCHIVE_FAILED);
}
}
",2580,2854,2584,2859,"archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");","fsobj_error(a_eno, a_estr,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains "", ""'..'"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_71.cpp,"{
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_71.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_71.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T13:04:00,Brad King,87
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_140.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_140.cpp,"name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

if (a->tree != NULL) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't change dir"");
return (ARCHIVE_FAILED);
}
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
","name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
else if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't change dir to read extended attributes"");
return (ARCHIVE_FAILED);
}
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
",302,321,313,325,"archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");","archive_set_error(&a->archive, errno,
			    ""Can't change dir to read extended attributes"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_72.cpp,"{
			archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");
				return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_72.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_72.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,111
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_141.cpp,"const char *path;
ssize_t list_size;

path = archive_entry_sourcepath(entry);
if (path == NULL)
path = archive_entry_pathname(entry);

if (*fd < 0 && a->tree != NULL) {
if (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)
*fd = a->open_on_current_dir(a->tree, path,
O_RDONLY | O_NONBLOCK);
if (*fd < 0) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't access %s"", path);
return (ARCHIVE_FAILED);
}
}
}

","const char *path;
ssize_t list_size;

path = NULL;

if (*fd < 0) {
path = archive_entry_sourcepath(entry);
if (path == NULL || (a->tree != NULL &&
    a->tree_enter_working_dir(a->tree) != 0))
path = archive_entry_pathname(entry);
if (path == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Couldn't determine file path to read ""
    ""extended attributes"");
return (ARCHIVE_WARN);
}
if (a->tree != NULL && (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)) {
*fd = a->open_on_current_dir(a->tree,
    path, O_RDONLY | O_NONBLOCK);
}
}

",772,1486,786,1497,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_73.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_73.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_73.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,82
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_142.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_142.cpp,"const char *path;
int namespace = EXTATTR_NAMESPACE_USER;

path = archive_entry_sourcepath(entry);
if (path == NULL)
path = archive_entry_pathname(entry);

if (*fd < 0 && a->tree != NULL) {
if (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)
*fd = a->open_on_current_dir(a->tree, path,
O_RDONLY | O_NONBLOCK);
if (*fd < 0) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't access %s"", path);
return (ARCHIVE_FAILED);
}
}
}

","const char *path;
int namespace = EXTATTR_NAMESPACE_USER;

path = NULL;

if (*fd < 0) {
path = archive_entry_sourcepath(entry);
if (path == NULL || (a->tree != NULL &&
    a->tree_enter_working_dir(a->tree) != 0))
path = archive_entry_pathname(entry);
if (path == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Couldn't determine file path to read ""
    ""extended attributes"");
return (ARCHIVE_WARN);
}
if (a->tree != NULL && (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)) {
*fd = a->open_on_current_dir(a->tree,
    path, O_RDONLY | O_NONBLOCK);
}
}

",932,1645,946,1656,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_74.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_74.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_74.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,82
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_144.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_144.cpp,"r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",938,938,940,940,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_75.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_75.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_75.cpp,"name****operator****operator****name****operator****name****name****operator****expr****argument
name****expr****argument
literal****expr****argument
name****name****operator****name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,104
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_145.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_145.cpp,"r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",1041,1041,1043,1043,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_76.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_76.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_76.cpp,"name****operator****operator****name****operator****name****name****operator****expr****argument
name****expr****argument
literal****expr****argument
name****name****operator****name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,104
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_146.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_146.cpp,"r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",1067,1067,1069,1069,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_77.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_77.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_77.cpp,"name****operator****operator****name****operator****name****name****operator****expr****argument
name****expr****argument
literal****expr****argument
name****name****operator****name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,104
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_148.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_148.cpp,"r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",803,802,805,804,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_78.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_78.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_78.cpp,"name****operator****operator****name****operator****name****name****operator****expr****argument
name****expr****argument
literal****expr****argument
name****name****operator****name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,104
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_149.cpp,"r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",875,874,877,876,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_79.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_79.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_79.cpp,"name****operator****operator****name****operator****name****name****operator****expr****argument
name****expr****argument
literal****expr****argument
name****name****operator****name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,104
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_150.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_150.cpp,"r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",901,900,903,902,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_80.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_80.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_80.cpp,"name****operator****operator****name****operator****name****name****operator****expr****argument
name****expr****argument
literal****expr****argument
name****name****operator****name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,104
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,790,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_81.cpp,"{
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_81.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_81.cpp,"name****operator****name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,103
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,821,-1,"archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_82.cpp,"{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_82.cpp,"[3, 0, 0, 0, 2, 0, 4, 1, 2, 0, 5, 0, 0, 0, 2, 152, 0, 0, 4, 5, 0, 0, 1, 11, 0, 0, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 0, 62, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 4, 3, 0, 0, 14, 0, 0, 25, 0, 26, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_82.cpp,"name****operator****name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,103
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,827,-1,"archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_83.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_83.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_83.cpp,"name****operator****name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,83
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,833,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_84.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_84.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_84.cpp,"name****operator****name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,83
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,866,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_85.cpp,"{
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_85.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_85.cpp,"name****operator****name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,103
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,884,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_86.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_86.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_86.cpp,"name****operator****name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,103
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,890,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_87.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_87.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_87.cpp,"name****operator****name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,103
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,921,-1,"archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_88.cpp,"{
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_88.cpp,"[0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_88.cpp,"name****operator****operator****name****operator****name****operator****name****name****operator****expr****argument
name****expr****argument
literal****expr****argument
name****operator****name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,22
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_174.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_174.cpp,"switch ((int)type & ~0777777) {
case 01000000:
/* POSIX.1e ACL */
break;
case 03000000:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Solaris NFSv4 ACLs not supported"");
return (ARCHIVE_WARN);
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Malformed Solaris ACL attribute (unsupported type %o)"",
","switch ((int)type & ~0777777) {
case 01000000:
/* POSIX.1e ACL */
acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;
break;
case 03000000:
/* NFSv4 ACL */
acl_type = ARCHIVE_ENTRY_ACL_TYPE_NFS4;
break;
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Malformed Solaris ACL attribute (unsupported type %o)"",
",935,989,940,992,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");",acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_89.cpp,"{
	case 01000000:
		/* POSIX.1e ACL */
		break;
	case 03000000:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");
		return (ARCHIVE_WARN);
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Malformed Solaris ACL attribute (unsupported type %o)"",
		    (int)type);
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_89.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 2, 1, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_89.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,23
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_176.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_176.cpp,"if (tar->entry_bytes_remaining < 0) {
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry has negative size?"");
err = ARCHIVE_WARN;
}
tar->realsize = tar->entry_bytes_remaining;
archive_entry_set_size(entry, tar->entry_bytes_remaining);
","if (tar->entry_bytes_remaining < 0) {
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry has negative size"");
return (ARCHIVE_FATAL);
}
if (tar->entry_bytes_remaining == INT64_MAX) {
/* Note: tar_atol returns INT64_MAX on overflow */
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry size overflow"");
return (ARCHIVE_FATAL);
}
tar->realsize = tar->entry_bytes_remaining;
archive_entry_set_size(entry, tar->entry_bytes_remaining);
",1128,1183,1130,1185,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_90.cpp,"{
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");
		err = ARCHIVE_WARN;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_90.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_90.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,111
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_177.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_177.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1820,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_91.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_91.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_91.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,84
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_177.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_177.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1825,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_92.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_92.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_92.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,109
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_177.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_177.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1844,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_93.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_93.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_93.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,84
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_177.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_177.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1849,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_94.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_94.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_94.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,109
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_180.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_180.cpp,"&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {
/* nawww, I wish they promised backward compatibility
 * anyhoo, in their infinite wisdom the 28500 guys might
 * come up with something we can't possibly handle so
 * best end things here */
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version"");
return (ARCHIVE_FATAL);
} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
","&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
}
ver = _warc_rdver(buf, eoh - buf);
/* we currently support WARC 0.12 to 1.0 */
if (ver == 0U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Invalid record version"");
return (ARCHIVE_FATAL);
} else if (ver < 1200U || ver > 10000U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version: %u.%u"",
ver / 10000, (ver % 10000) / 100);
return (ARCHIVE_FATAL);
}
cntlen = _warc_rdlen(buf, eoh - buf);
if (cntlen < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
}
rtime = _warc_rdrtm(buf, eoh - buf);
if (rtime == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
",255,254,263,261,"archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");","archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Invalid record version"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_95.cpp,"{
		/* nawww, I wish they promised backward compatibility
		 * anyhoo, in their infinite wisdom the 28500 guys might
		 * come up with something we can't possibly handle so
		 * best end things here */
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_95.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_95.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,111
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_181.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_181.cpp,"if (ver != w->pver) {
/* stringify this entry's version */
archive_string_sprintf(&w->sver,
""WARC/%u.%u"", ver / 10000, ver % 10000);
/* remember the version */
w->pver = ver;
}
","if (ver != w->pver) {
/* stringify this entry's version */
archive_string_sprintf(&w->sver,
""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100);
/* remember the version */
w->pver = ver;
}
",285,293,287,295,"archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);","archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_96.cpp,"{
		/* stringify this entry's version */
		archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);
		/* remember the version */
		w->pver = ver;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_96.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_96.cpp,"name****operator****name****operator****name****name****expr****argument
literal****expr****argument
name****operator****literal****expr****argument
name****operator****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,24
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_182.cpp,"xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
if (xar->lzstream_valid)
lzmadec_end(&(xar->lzstream));
r = lzmadec_init(&(xar->lzstream));
if (r != LZMADEC_OK) {
switch (r) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing ""
    ""compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&a->archive,
    ENOMEM,
    ""Internal error initializing ""
    ""compression library: ""
    ""out of memory"");
break;
}
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 1;
xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
","xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
",1526,1524,1537,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_97.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_97.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_97.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****literal****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,85
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_182.cpp,"xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
if (xar->lzstream_valid)
lzmadec_end(&(xar->lzstream));
r = lzmadec_init(&(xar->lzstream));
if (r != LZMADEC_OK) {
switch (r) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing ""
    ""compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&a->archive,
    ENOMEM,
    ""Internal error initializing ""
    ""compression library: ""
    ""out of memory"");
break;
}
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 1;
xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
","xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
",1526,1524,1544,-1,"archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_98.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_98.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_98.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****literal****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,85
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_183.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_183.cpp,"*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
xar->lzstream.avail_in = avail_in;
xar->lzstream.next_out = (unsigned char *)outbuff;
xar->lzstream.avail_out = avail_out;
r = lzmadec_decode(&(xar->lzstream), 0);
switch (r) {
case LZMADEC_STREAM_END: /* Found end of stream. */
switch (lzmadec_end(&(xar->lzstream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up lzmadec decompressor"");
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 0;
/* FALLTHROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""lzmadec decompression failed(%d)"",
    r);
return (ARCHIVE_FATAL);
}
*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
case LZMA:
#endif
case XZ:
#endif
case NONE:
","*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
case LZMA:
case XZ:
#endif
case NONE:
",1685,1653,1701,-1,"archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_99.cpp,"{
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_99.cpp,"[0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_99.cpp,"name****operator****operator****name****operator****name****name****operator****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,25
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_183.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_183.cpp,"*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
xar->lzstream.avail_in = avail_in;
xar->lzstream.next_out = (unsigned char *)outbuff;
xar->lzstream.avail_out = avail_out;
r = lzmadec_decode(&(xar->lzstream), 0);
switch (r) {
case LZMADEC_STREAM_END: /* Found end of stream. */
switch (lzmadec_end(&(xar->lzstream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up lzmadec decompressor"");
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 0;
/* FALLTHROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""lzmadec decompression failed(%d)"",
    r);
return (ARCHIVE_FATAL);
}
*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
case LZMA:
#endif
case XZ:
#endif
case NONE:
","*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
case LZMA:
case XZ:
#endif
case NONE:
",1685,1653,1711,-1,"archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_100.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			switch (lzmadec_end(&(xar->lzstream))) {
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}
			xar->lzstream_valid = 0;
			/* FALLTHROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			break;
		default:
			archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_100.cpp,"[0, 0, 0, 0, 2, 0, 2, 1, 3, 2, 2, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_100.cpp,"name****operator****operator****name****operator****name****name****operator****expr****argument
name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,26
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_185.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_185.cpp,"}
offset = datasize;
}
#ifdef DEBUG
if (offset != extra_length)
{
fprintf(stderr,
    ""Extra data field contents do not match reported size!\n"");
}
#endif
}

/*
","}
offset = datasize;
}
if (offset != extra_length) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Malformed extra data: Consumed %d bytes of %d bytes"",
    (int)offset, (int)extra_length);
return ARCHIVE_FAILED;
}
return ARCHIVE_OK;
}

/*
",715,739,721,743,"fprintf(stderr,
		    ""Extra data field contents do not match reported size!\n"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Malformed extra data: Consumed %d bytes of %d bytes"",
		    (int)offset, (int)extra_length);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_101.cpp,"{
		fprintf(stderr,
		    ""Extra data field contents do not match reported size!\n"");
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_101.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_101.cpp,"name****name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,27
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_193.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_193.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2414,2599,"archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);","fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_102.cpp,"{
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_102.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_102.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,28
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_193.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_193.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2428,2629,"archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_103.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_103.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_103.cpp,"name****operator****name****operator****name****name****expr****argument
literal****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,86
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_193.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_193.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2438,2660,"archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);","fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_104.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_104.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_104.cpp,"name****operator****name****operator****name****name****expr****argument
literal****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,29
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_193.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_193.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2446,2673,"archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_105.cpp,"{
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_105.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_105.cpp,"name****operator****name****operator****name****name****expr****argument
literal****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,86
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_194.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_194.cpp," * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
char *dest, *src;
char separator = '\0';

dest = src = a->name;
if (*src == '\0') {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Invalid empty pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(a);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
                  ""Path is absolute"");
return (ARCHIVE_FAILED);
}

"," * is set) if the path is absolute.
 */
static int
cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
char *dest, *src;
char separator = '\0';

dest = src = path;
if (*src == '\0') {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Invalid empty "", ""pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(path);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Path is "", ""absolute"");
return (ARCHIVE_FAILED);
}

",2534,2807,2544,2818,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");","fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty "", ""pathname"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_106.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_106.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_106.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,87
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_194.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_194.cpp," * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
char *dest, *src;
char separator = '\0';

dest = src = a->name;
if (*src == '\0') {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Invalid empty pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(a);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
                  ""Path is absolute"");
return (ARCHIVE_FAILED);
}

"," * is set) if the path is absolute.
 */
static int
cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
char *dest, *src;
char separator = '\0';

dest = src = path;
if (*src == '\0') {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Invalid empty "", ""pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(path);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Path is "", ""absolute"");
return (ARCHIVE_FAILED);
}

",2534,2807,2555,2829,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");","fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
			    ""Path is "", ""absolute"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_107.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_107.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_107.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,87
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_195.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_195.cpp,"} else if (src[1] == '.') {
if (src[2] == '/' || src[2] == '\0') {
/* Conditionally warn about '..' */
if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Path contains '..'"");
return (ARCHIVE_FAILED);
}
}
","} else if (src[1] == '.') {
if (src[2] == '/' || src[2] == '\0') {
/* Conditionally warn about '..' */
if (flags
    & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
fsobj_error(a_eno, a_estr,
    ARCHIVE_ERRNO_MISC,
    ""Path contains "", ""'..'"");
return (ARCHIVE_FAILED);
}
}
",2580,2854,2584,2859,"archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");","fsobj_error(a_eno, a_estr,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains "", ""'..'"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_108.cpp,"{
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_108.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_108.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-20T12:50:48,Brad King,87
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/socks_gssapi.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_205.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_205.cpp,"
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.value = malloc(strlen(serviceptr));
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr);
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(strlen(serviceptr) ëîºï¿½(conn->proxy.name)ï¿½);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr) ëîºï¿½(conn->proxy.name)ï¿½;
    snprintf(service.value, service.lengthï¿½, ""%s@%s"",
             serviceptr, conn->proxy.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
","
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.length = serviceptr_length;
    service.value = malloc(service.length);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(serviceptr_length 
                           strlen(conn->socks_proxy.host.name)ï¿½);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = serviceptr_length  strlen(conn->socks_proxy.host.name)ï¿½;
    snprintf(service.value, service.lengthï¿½, ""%s@%s"",
             serviceptr, conn->socks_proxy.host.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
",134,135,151,153,"snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name);","snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->socks_proxy.host.name);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_109.cpp,"{
    service.value = malloc(strlen(serviceptr) +strlen(conn->proxy.name)+2);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr) +strlen(conn->proxy.name)+1;
    snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_109.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 43, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 7, 0, 0, 4, 0, 14, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_109.cpp,"name****name****operator****name****name****expr****argument
name****operator****name****name****operator****literal****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-07T16:38:00,Brad King,30
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/socks_gssapi.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_105.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_105.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_213.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_213.cpp,"
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.value = malloc(strlen(serviceptr));
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr);
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(strlen(serviceptr) ëîºï¿½(conn->proxy.name)ï¿½);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr) ëîºï¿½(conn->proxy.name)ï¿½;
    snprintf(service.value, service.lengthï¿½, ""%s@%s"",
             serviceptr, conn->proxy.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
","
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.length = serviceptr_length;
    service.value = malloc(service.length);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(serviceptr_length 
                           strlen(conn->socks_proxy.host.name)ï¿½);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = serviceptr_length  strlen(conn->socks_proxy.host.name)ï¿½;
    snprintf(service.value, service.lengthï¿½, ""%s@%s"",
             serviceptr, conn->socks_proxy.host.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
",134,135,151,153,"snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name);","snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->socks_proxy.host.name);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_110.cpp,"{
    service.value = malloc(strlen(serviceptr) +strlen(conn->proxy.name)+2);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr) +strlen(conn->proxy.name)+1;
    snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_110.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 43, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 7, 0, 0, 4, 0, 14, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_110.cpp,"name****name****operator****name****name****expr****argument
name****operator****name****name****operator****literal****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2017-02-07T16:37:30,Brad King,30
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_226.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_226.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmCommandArgument_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmCommandArgument_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmCommandArgument_yy_switch_to_buffer
 */
void cmCommandArgument_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmCommandArgument_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmCommandArgument_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmCommandArgument_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmCommandArgument_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmCommandArgument_yy_switch_to_buffer
 */
void cmCommandArgument_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmCommandArgument_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmCommandArgument_yyget_debug  (yyscan_t yyscanner)
",1802,1809,1814,1821,"yy_fatal_error( ""cmCommandArgument_yyset_lineno called with no buffer"" , yyscanner);","YY_FATAL_ERROR( ""cmCommandArgument_yyset_lineno called with no buffer"" );",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_111.cpp,"yy_fatal_error( ""cmCommandArgument_yyset_lineno called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_111.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_111.cpp,"name****literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-12-14T14:40:33,Brad King,105
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_226.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_226.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmCommandArgument_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmCommandArgument_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmCommandArgument_yy_switch_to_buffer
 */
void cmCommandArgument_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmCommandArgument_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmCommandArgument_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmCommandArgument_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmCommandArgument_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmCommandArgument_yy_switch_to_buffer
 */
void cmCommandArgument_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmCommandArgument_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmCommandArgument_yyget_debug  (yyscan_t yyscanner)
",1802,1809,1829,1836,"yy_fatal_error( ""cmCommandArgument_yyset_column called with no buffer"" , yyscanner);","YY_FATAL_ERROR( ""cmCommandArgument_yyset_column called with no buffer"" );",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_112.cpp,"yy_fatal_error( ""cmCommandArgument_yyset_column called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_112.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_112.cpp,"name****literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-12-14T14:40:33,Brad King,105
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_231.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmExpr_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmExpr_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmExpr_yy_switch_to_buffer
 */
void cmExpr_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmExpr_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmExpr_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmExpr_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmExpr_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmExpr_yy_switch_to_buffer
 */
void cmExpr_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmExpr_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmExpr_yyget_debug  (yyscan_t yyscanner)
",1709,1784,1721,1796,"yy_fatal_error( ""cmExpr_yyset_lineno called with no buffer"" , yyscanner);","YY_FATAL_ERROR( ""cmExpr_yyset_lineno called with no buffer"" );",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_113.cpp,"yy_fatal_error( ""cmExpr_yyset_lineno called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_113.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_113.cpp,"name****literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-12-14T14:40:33,Brad King,105
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_231.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmExpr_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmExpr_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmExpr_yy_switch_to_buffer
 */
void cmExpr_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmExpr_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmExpr_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmExpr_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmExpr_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmExpr_yy_switch_to_buffer
 */
void cmExpr_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmExpr_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmExpr_yyget_debug  (yyscan_t yyscanner)
",1709,1784,1736,1811,"yy_fatal_error( ""cmExpr_yyset_column called with no buffer"" , yyscanner);","YY_FATAL_ERROR( ""cmExpr_yyset_column called with no buffer"" );",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_114.cpp,"yy_fatal_error( ""cmExpr_yyset_column called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_114.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_114.cpp,"name****literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-12-14T14:40:33,Brad King,105
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_235.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_235.cpp,"  return CURLE_OK;
}

#ifdef USE_LIBIDN
/*
 * Initialise use of IDNA library.
 * It falls back to ASCII if $CHARSET isn't defined. This doesn't work for
 * idna_to_ascii_lz().
 */
static void idna_init (void)
{
#ifdef WIN32
  char buf[60];
  UINT cp = GetACP();

  if(!getenv(""CHARSET"") && cp > 0) {
    snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);
    putenv(buf);
  }
#else
  /* to do? */
#endif
}
#endif  /* USE_LIBIDN */

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
","  return CURLE_OK;
}

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
",144,143,160,-1,"snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_115.cpp,"{
    snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);
    putenv(buf);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_115.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_115.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-12-05T16:50:43,Brad King,88
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_236.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_236.cpp,"  }
#endif

#ifdef USE_LIBIDN
  idna_init();
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
","  }
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
",262,239,270,242,"DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));","f(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;;",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_116.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_116.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_116.cpp,"name****name****name****expr****argument
literal****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-12-05T16:50:43,Brad King,31
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/formdata.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_115.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_115.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_237.cpp,"                             curl_off_t *size,
                             const char *fmt, ...)
{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(s, sizeof(s), fmt, ap);
  va_end(ap);

  return AddFormData(formp, FORM_DATA, s, 0, size);
}

/*
","                             curl_off_t *size,
                             const char *fmt, ...)
{
  char *s;
  CURLcode result;
  va_list ap;
  va_start(ap, fmt);
  s = curl_mvaprintf(fmt, ap);
  va_end(ap);

  if(!s)
    return CURLE_OUT_OF_MEMORY;

  result = AddFormData(formp, FORM_DATAMEM, s, 0, size);
  if(result)
    free(s);

  return result;
}

/*
",906,914,912,921,"vsnprintf(s, sizeof(s), fmt, ap);","s = curl_mvaprintf(fmt, ap);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_117.cpp,"{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(s, sizeof(s), fmt, ap);
  va_end(ap);

  return AddFormData(formp, FORM_DATA, s, 0, size);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_117.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 5, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_117.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-12-05T16:50:43,Brad King,32
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_116.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_116.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_238.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_238.cpp,"  enum protection_level data_sec = conn->data_prot;
#endif

  va_list ap;
  va_start(ap, fmt);
  write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);
  va_end(ap);

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len =2;
","  enum protection_level data_sec = conn->data_prot;
#endif

  write_len = strlen(cmd);
  if(write_len > (sizeof(s) -3))
    return CURLE_BAD_FUNCTION_ARGUMENT;

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len =2;
",4107,4103,4112,-1,"write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_118.cpp,"{
  ssize_t bytes_written;
#define SBUF_SIZE 1024
  char s[SBUF_SIZE];
  size_t write_len;
  char *sptr=s;
  CURLcode result = CURLE_OK;
#ifdef HAVE_GSSAPI
  enum protection_level data_sec = conn->data_prot;
#endif

  va_list ap;
  va_start(ap, fmt);
  write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);
  va_end(ap);

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len +=2;

  bytes_written=0;

  result = Curl_convert_to_network(conn->data, s, write_len);
  /* Curl_convert_to_network calls failf if unsuccessful */
  if(result)
    return result;

  for(;;) {
#ifdef HAVE_GSSAPI
    conn->data_prot = PROT_CMD;
#endif
    result = Curl_write(conn, conn->sock[FIRSTSOCKET], sptr, write_len,
                        &bytes_written);
#ifdef HAVE_GSSAPI
    DEBUGASSERT(data_sec > PROT_NONE && data_sec < PROT_LAST);
    conn->data_prot = data_sec;
#endif

    if(result)
      break;

    if(conn->data->set.verbose)
      Curl_debug(conn->data, CURLINFO_HEADER_OUT,
                 sptr, (size_t)bytes_written, conn);

    if(bytes_written != (ssize_t)write_len) {
      write_len -= bytes_written;
      sptr += bytes_written;
    }
    else
      break;
  }

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_118.cpp,"[4, 0, 1, 0, 2, 0, 2, 0, 0, 0, 7, 0, 0, 0, 0, 99, 0, 0, 7, 7, 0, 0, 4, 4, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 3, 0, 5, 4, 1, 0, 8, 0, 0, 14, 0, 23, 7, 1, 1, 1, 1, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_118.cpp,"name****operator****name****name****expr****argument
name****operator****literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-12-05T16:50:43,Brad King,33
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/version.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_121.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_121.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_243.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_243.cpp,"  left -= len;
  ptr = len;
#endif
#ifdef USE_LIBIDN
  if(stringprep_check_version(LIBIDN_REQUIRED_VERSION)) {
    len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));
    left -= len;
    ptr = len;
  }
","  left -= len;
  ptr = len;
#endif
#ifdef USE_LIBIDN2
  if(idn2_check_version(IDN2_VERSION)) {
    len = snprintf(ptr, left, "" libidn2/%s"", idn2_check_version(NULL));
    left -= len;
    ptr = len;
  }
",111,111,116,116,"len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));","len = snprintf(ptr, left, "" libidn2/%s"", idn2_check_version(NULL));",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_119.cpp,"{
    len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));
    left -= len;
    ptr += len;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_119.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_119.cpp,"name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-12-05T16:50:43,Brad King,34
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_245.cpp,"  return CURLE_OK;
}

#ifdef USE_LIBIDN
/*
 * Initialise use of IDNA library.
 * It falls back to ASCII if $CHARSET isn't defined. This doesn't work for
 * idna_to_ascii_lz().
 */
static void idna_init (void)
{
#ifdef WIN32
  char buf[60];
  UINT cp = GetACP();

  if(!getenv(""CHARSET"") && cp > 0) {
    snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);
    putenv(buf);
  }
#else
  /* to do? */
#endif
}
#endif  /* USE_LIBIDN */

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
","  return CURLE_OK;
}

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
",144,143,160,-1,"snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_120.cpp,"{
    snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);
    putenv(buf);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_120.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_120.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-12-05T16:39:32,Brad King,88
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_246.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_246.cpp,"  }
#endif

#ifdef USE_LIBIDN
  idna_init();
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
","  }
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
",262,239,270,242,"DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));","f(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;;",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_121.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_121.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_121.cpp,"name****name****name****expr****argument
literal****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-12-05T16:39:32,Brad King,31
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/formdata.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_124.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_124.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_247.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_247.cpp,"                             curl_off_t *size,
                             const char *fmt, ...)
{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(s, sizeof(s), fmt, ap);
  va_end(ap);

  return AddFormData(formp, FORM_DATA, s, 0, size);
}

/*
","                             curl_off_t *size,
                             const char *fmt, ...)
{
  char *s;
  CURLcode result;
  va_list ap;
  va_start(ap, fmt);
  s = curl_mvaprintf(fmt, ap);
  va_end(ap);

  if(!s)
    return CURLE_OUT_OF_MEMORY;

  result = AddFormData(formp, FORM_DATAMEM, s, 0, size);
  if(result)
    free(s);

  return result;
}

/*
",906,914,912,921,"vsnprintf(s, sizeof(s), fmt, ap);","s = curl_mvaprintf(fmt, ap);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_122.cpp,"{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(s, sizeof(s), fmt, ap);
  va_end(ap);

  return AddFormData(formp, FORM_DATA, s, 0, size);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_122.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 5, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_122.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-12-05T16:39:32,Brad King,32
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_125.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_125.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_248.cpp,"  enum protection_level data_sec = conn->data_prot;
#endif

  va_list ap;
  va_start(ap, fmt);
  write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);
  va_end(ap);

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len =2;
","  enum protection_level data_sec = conn->data_prot;
#endif

  write_len = strlen(cmd);
  if(write_len > (sizeof(s) -3))
    return CURLE_BAD_FUNCTION_ARGUMENT;

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len =2;
",4106,4102,4111,-1,"write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_123.cpp,"{
  ssize_t bytes_written;
#define SBUF_SIZE 1024
  char s[SBUF_SIZE];
  size_t write_len;
  char *sptr=s;
  CURLcode result = CURLE_OK;
#ifdef HAVE_GSSAPI
  enum protection_level data_sec = conn->data_prot;
#endif

  va_list ap;
  va_start(ap, fmt);
  write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);
  va_end(ap);

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len +=2;

  bytes_written=0;

  result = Curl_convert_to_network(conn->data, s, write_len);
  /* Curl_convert_to_network calls failf if unsuccessful */
  if(result)
    return result;

  for(;;) {
#ifdef HAVE_GSSAPI
    conn->data_prot = PROT_CMD;
#endif
    result = Curl_write(conn, conn->sock[FIRSTSOCKET], sptr, write_len,
                        &bytes_written);
#ifdef HAVE_GSSAPI
    DEBUGASSERT(data_sec > PROT_NONE && data_sec < PROT_LAST);
    conn->data_prot = data_sec;
#endif

    if(result)
      break;

    if(conn->data->set.verbose)
      Curl_debug(conn->data, CURLINFO_HEADER_OUT,
                 sptr, (size_t)bytes_written, conn);

    if(bytes_written != (ssize_t)write_len) {
      write_len -= bytes_written;
      sptr += bytes_written;
    }
    else
      break;
  }

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_123.cpp,"[4, 0, 1, 0, 2, 0, 2, 0, 0, 0, 7, 0, 0, 0, 0, 99, 0, 0, 7, 7, 0, 0, 4, 4, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 3, 0, 5, 4, 1, 0, 8, 0, 0, 14, 0, 23, 7, 1, 1, 1, 1, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_123.cpp,"name****operator****name****name****expr****argument
name****operator****literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-12-05T16:39:32,Brad King,33
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/version.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_130.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_130.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_253.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_253.cpp,"  left -= len;
  ptr = len;
#endif
#ifdef USE_LIBIDN
  if(stringprep_check_version(LIBIDN_REQUIRED_VERSION)) {
    len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));
    left -= len;
    ptr = len;
  }
","  left -= len;
  ptr = len;
#endif
#ifdef USE_LIBIDN2
  if(idn2_check_version(IDN2_VERSION)) {
    len = snprintf(ptr, left, "" libidn2/%s"", idn2_check_version(NULL));
    left -= len;
    ptr = len;
  }
",111,111,116,116,"len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));","len = snprintf(ptr, left, "" libidn2/%s"", idn2_check_version(NULL));",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_124.cpp,"{
    len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));
    left -= len;
    ptr += len;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_124.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_124.cpp,"name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-12-05T16:39:32,Brad King,34
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/conncache.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_153.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_153.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_316.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_316.cpp,"/* returns an allocated key to find a bundle for this connection */
static char *hashkey(struct connectdata *conn)
{
  return aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);
}

/* Look up the bundle with all the connections to the same host this
","/* returns an allocated key to find a bundle for this connection */
static char *hashkey(struct connectdata *conn)
{
  const char *hostname;

  if(conn->bits.proxy)
    hostname = conn->proxy.name;
  else if(conn->bits.conn_to_host)
    hostname = conn->conn_to_host.name;
  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}

/* Look up the bundle with all the connections to the same host this
",132,131,135,-1,"aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_125.cpp,"{
  return aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_125.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_125.cpp,"name****literal****expr****argument
name****operator****name****operator****name****name****expr****condition****name****operator****name****operator****name****name****expr****then****name****operator****name****operator****name****name****expr****else****ternary****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,35
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,169,-1,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_126.cpp,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_126.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_126.cpp,"name****operator****name****operator****operator****operator****name****name****operator****literal****expr****index****name****expr****argument
literal****expr****argument
literal****expr****argument
name****name****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,91
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,278,-1,"aprintf(""%s/%s"", service, host);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_127.cpp,"{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_127.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_127.cpp,"name****literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,108
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,475,-1,"response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_128.cpp,"{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_128.cpp,"[4, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 2, 86, 0, 0, 5, 5, 0, 0, 2, 20, 0, 0, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 17, 0, 4, 4, 0, 0, 10, 0, 0, 7, 0, 36, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_128.cpp,"name****operator****name****literal****expr****argument
name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,36
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,637,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_129.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_129.cpp,"[10, 0, 3, 0, 0, 0, 11, 0, 0, 0, 14, 0, 0, 0, 24, 357, 0, 0, 19, 19, 0, 0, 9, 63, 0, 0, 0, 0, 3, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120, 0, 276, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 27, 0, 13, 10, 0, 0, 77, 0, 0, 49, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_129.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,89
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,670,-1,"snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_130.cpp,"snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_130.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_130.cpp,"name****operator****name****literal****operator****name****expr****index****name****expr****argument
literal****expr****argument
literal****expr****argument
name****name****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,106
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,693,-1,"snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_131.cpp,"snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_131.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_131.cpp,"name****operator****name****literal****operator****name****expr****index****name****expr****argument
literal****expr****argument
literal****expr****argument
name****name****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,106
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,723,-1,"snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_132.cpp,"snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_132.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_132.cpp,"name****operator****name****literal****operator****name****expr****index****name****expr****argument
literal****expr****argument
literal****expr****argument
name****name****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,106
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,726,-1,"response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_133.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_133.cpp,"[10, 0, 3, 0, 0, 0, 11, 0, 0, 0, 14, 0, 0, 0, 24, 357, 0, 0, 19, 19, 0, 0, 9, 63, 0, 0, 0, 0, 3, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120, 0, 276, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 27, 0, 13, 10, 0, 0, 77, 0, 0, 49, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_133.cpp,"name****operator****name****literal****literal****literal****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,37
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,922,-1,"snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_134.cpp,"{
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_134.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 23, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 8, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_134.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,92
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,946,-1,"(""%s:%s:%s"";",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_135.cpp,"{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_135.cpp,"[18, 0, 0, 0, 0, 0, 10, 0, 0, 0, 21, 0, 0, 0, 0, 287, 0, 0, 13, 13, 0, 0, 5, 32, 0, 0, 0, 0, 6, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 180, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 5, 0, 18, 18, 2, 0, 42, 0, 0, 40, 0, 102, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_135.cpp,operator****literal****expr****expr_stmt****unit****,2016-08-03T19:08:56,Brad King,107
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,957,-1,"tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_136.cpp,"{
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_136.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 5, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_136.cpp,"name****operator****name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,93
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,980,-1,"md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_137.cpp,"{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_137.cpp,"[18, 0, 0, 0, 0, 0, 10, 0, 0, 0, 21, 0, 0, 0, 0, 287, 0, 0, 13, 13, 0, 0, 5, 32, 0, 0, 0, 0, 6, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 180, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 5, 0, 18, 18, 2, 0, 42, 0, 0, 40, 0, 102, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_137.cpp,"name****operator****operator****name****name****operator****operator****name****literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,38
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,986,-1,"(""%s:%s"";",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_138.cpp,"{
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_138.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_138.cpp,operator****literal****expr****expr_stmt****unit****,2016-08-03T19:08:56,Brad King,107
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1000,-1,"md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_139.cpp,"{
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_139.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_139.cpp,"name****operator****operator****name****name****operator****operator****name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,39
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1009,-1,"md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_140.cpp,"{
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_140.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_140.cpp,"name****operator****operator****name****name****operator****operator****name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,40
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1041,-1,"response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_141.cpp,"{
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_141.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_141.cpp,"name****operator****name****literal****literal****literal****literal****literal****literal****literal****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,41
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1064,-1,"response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_142.cpp,"{
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_142.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_142.cpp,"name****operator****name****literal****literal****literal****literal****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,42
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1082,-1,"tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_143.cpp,"{
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_143.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_143.cpp,"name****operator****name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,97
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1092,-1,"tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_144.cpp,"{
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_144.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_144.cpp,"name****operator****name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,97
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1181,-1,"xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_145.cpp,"{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_145.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 23, 0, 0, 2, 2, 0, 0, 2, 1, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 0, 0, 4, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_145.cpp,"name****operator****name****literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,43
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_156.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_156.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_319.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_319.cpp,"    return CURLE_FAILED_INIT;
  }

#if defined(USE_LIBSSH2) && defined(HAVE_LIBSSH2_INIT)
  if(libssh2_init(0)) {
    DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));
","    return CURLE_FAILED_INIT;
  }

  (void)Curl_ipv6works();

#if defined(USE_LIBSSH2) && defined(HAVE_LIBSSH2_INIT)
  if(libssh2_init(0)) {
    DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));
",269,271,274,278,"DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));","DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_146.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));
    return CURLE_FAILED_INIT;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_146.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_146.cpp,"name****name****name****expr****argument
literal****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,44
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_322.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_322.cpp,"    if(result)
      return result;

    if(fstated) {
      time_t filetime = (time_t)statbuf.st_mtime;
      struct tm buffer;
      const struct tm *tm = &buffer;
      result = Curl_gmtime(filetime, &buffer);
      if(result)
        return result;

      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year  1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    }
    /* if we fstat()ed the file, set the file size to make it available post-
       transfer */
    if(fstated)
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }
","    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year  1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }
",479,486,491,495,"snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year + 1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);","snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_147.cpp,"{
      time_t filetime = (time_t)statbuf.st_mtime;
      struct tm buffer;
      const struct tm *tm = &buffer;
      result = Curl_gmtime(filetime, &buffer);
      if(result)
        return result;

      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year + 1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_147.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 57, 0, 0, 3, 3, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 1, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 2, 2, 1, 0, 3, 0, 0, 3, 0, 16, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_147.cpp,"name****name****expr****argument
name****operator****literal****expr****argument
literal****expr****argument
name****name****operator****name****name****expr****condition****name****operator****name****name****operator****literal****expr****then****literal****expr****else****ternary****expr****index****name****expr****argument
name****operator****name****name****expr****argument
name****name****operator****name****name****expr****index****name****expr****argument
name****operator****name****name****operator****literal****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,45
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_161.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_161.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_326.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_326.cpp,"
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
  }

  major_status = Curl_gss_init_sec_context(data,
                                           &minor_status,
                                           &neg_ctx->context,
                                           neg_ctx->server_name,
                                           &Curl_spnego_mech_oid,
                                           GSS_C_NO_CHANNEL_BINDINGS,
                                           &input_token,
                                           &output_token,
                                           TRUE,
                                           NULL);
  Curl_safefree(input_token.value);

  neg_ctx->status = major_status;
  if(GSS_ERROR(major_status)) {
    if(output_token.value)
      gss_release_buffer(&discard_st, &output_token);
    Curl_gss_log_error(conn->data, minor_status,
                       ""gss_init_sec_context() failed: "");
    return CURLE_OUT_OF_MEMORY;
  }

  if(!output_token.value || !output_token.length) {
    if(output_token.value)
      gss_release_buffer(&discard_st, &output_token);
    return CURLE_OUT_OF_MEMORY;
  }

  neg_ctx->output_token = output_token;

  return CURLE_OK;
}

CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;
  OM_uint32 discard_st;

  result = Curl_base64_encode(conn->data,
                              neg_ctx->output_token.value,
                              neg_ctx->output_token.length,
                              &encoded, &len);
  if(result) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return result;
  }

  if(!encoded || !len) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return CURLE_REMOTE_ACCESS_DENIED;
  }

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded);
  if(proxy) {
    Curl_safefree(conn->allocptr.proxyuserpwd);
    conn->allocptr.proxyuserpwd = userp;
","
#include ""curl_setup.h""

#if !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""rawstr.h""
#include ""http_negotiate.h""
#include ""vauth/vauth.h""

/* The last 3 #include files should be in this order */
#include ""curl_printf.h""
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct Curl_easy *data = conn->data;
  size_t len;

  /* Point to the username, password, service and host */
  const char *userp;
  const char *passwdp;
  const char *service;
  const char *host;

  /* Point to the correct struct with this */
  struct negotiatedata *neg_ctx;

  if(proxy) {
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    service = data->set.str[STRING_PROXY_SERVICE_NAME] ?
              data->set.str[STRING_PROXY_SERVICE_NAME] : ""HTTP"";
    host = conn->proxy.name;
    neg_ctx = &data->state.proxyneg;
  }
  else {
    userp = conn->user;
    passwdp = conn->passwd;
    service = data->set.str[STRING_SERVICE_NAME] ?
              data->set.str[STRING_SERVICE_NAME] : ""HTTP"";
    host = conn->host.name;
    neg_ctx = &data->state.negotiate;
  }

  /* Not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

  /* Obtain the input token, if any */
  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(!len) {
    /* Is this the first call in a new negotiation? */
    if(neg_ctx->context) {
      /* The server rejected our authentication and hasn't suppled any more
      negotiation mechanisms */
      return CURLE_LOGIN_DENIED;
    }
  }

  /* Initilise the security context and decode our challenge */
  return Curl_auth_decode_spnego_message(data, userp, passwdp, service, host,
                                         header, neg_ctx);
}

CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy ? &conn->data->state.proxyneg :
    &conn->data->state.negotiate;
  char *base64 = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;

  result = Curl_auth_create_spnego_message(conn->data, neg_ctx, &base64, &len);
  if(result)
    return result;

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  base64);

  if(proxy) {
    Curl_safefree(conn->allocptr.proxyuserpwd);
    conn->allocptr.proxyuserpwd = userp;
",22,22,173,110,"userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded);","userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  base64);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_148.cpp,"struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;
  OM_uint32 discard_st;

  result = Curl_base64_encode(conn->data,
                              neg_ctx->output_token.value,
                              neg_ctx->output_token.length,
                              &encoded, &len);
  if(result) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return result;
  }

  if(!encoded || !len) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return CURLE_REMOTE_ACCESS_DENIED;
  }

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_148.cpp,"[2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 76, 0, 0, 6, 6, 0, 0, 3, 6, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 1, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 3, 3, 1, 0, 4, 0, 0, 8, 0, 12, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_148.cpp,"name****operator****name****literal****expr****argument
name****expr****condition****literal****expr****then****literal****expr****else****ternary****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,46
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/http_proxy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_162.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_162.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_327.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_327.cpp,"
      if(!result) {
        char *host=(char *)"""";
        const char *proxyconn="""";
        const char *useragent="""";
        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?
          ""1.0"" : ""1.1"";
        char *hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", conn->bits.ipv6_ip?""["":"""",
                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
","
      if(!result) {
        char *host=(char *)"""";
        const char *useragent="""";
        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?
          ""1.0"" : ""1.1"";
        bool ipv6_ip = conn->bits.ipv6_ip;
        char *hostheader;

        /* the hostname may be different */
        if(hostname != conn->host.name)
          ipv6_ip = (strchr(hostname, ':') != NULL);
        hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", ipv6_ip?""["":"""", hostname, ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
",150,160,158,172,"aprintf(""%s%s%s:%hu"", conn->bits.ipv6_ip?""["":"""",
                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);","hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", ipv6_ip?""["":"""", hostname, ipv6_ip?""]"":"""",
                  remote_port);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_149.cpp,"{
        char *host=(char *)"""";
        const char *proxyconn="""";
        const char *useragent="""";
        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?
          ""1.0"" : ""1.1"";
        char *hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", conn->bits.ipv6_ip?""["":"""",
                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
          return CURLE_OUT_OF_MEMORY;
        }

        if(!Curl_checkProxyheaders(conn, ""Host:"")) {
          host = aprintf(""Host: %s\r\n"", hostheader);
          if(!host) {
            free(hostheader);
            Curl_add_buffer_free(req_buffer);
            return CURLE_OUT_OF_MEMORY;
          }
        }
        if(!Curl_checkProxyheaders(conn, ""Proxy-Connection:""))
          proxyconn = ""Proxy-Connection: Keep-Alive\r\n"";

        if(!Curl_checkProxyheaders(conn, ""User-Agent:"") &&
           data->set.str[STRING_USERAGENT])
          useragent = conn->allocptr.uagent;

        result =
          Curl_add_bufferf(req_buffer,
                           ""CONNECT %s HTTP/%s\r\n""
                           ""%s""  /* Host: */
                           ""%s""  /* Proxy-Authorization */
                           ""%s""  /* User-Agent */
                           ""%s"", /* Proxy-Connection */
                           hostheader,
                           http,
                           host,
                           conn->allocptr.proxyuserpwd?
                           conn->allocptr.proxyuserpwd:"""",
                           useragent,
                           proxyconn);

        if(host && *host)
          free(host);
        free(hostheader);

        if(!result)
          result = Curl_add_custom_headers(conn, TRUE, req_buffer);

        if(!result)
          /* CRLF terminate the request */
          result = Curl_add_bufferf(req_buffer, ""\r\n"");

        if(!result) {
          /* Send the connect request to the proxy */
          /* BLOCKING */
          result =
            Curl_add_buffer_send(req_buffer, conn,
                                 &data->info.request_size, 0, sockindex);
        }
        req_buffer = NULL;
        if(result)
          failf(data, ""Failed sending CONNECT to proxy"");
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_149.cpp,"[10, 0, 0, 0, 0, 0, 2, 0, 0, 0, 11, 0, 0, 0, 3, 103, 0, 0, 5, 5, 0, 0, 5, 24, 0, 0, 0, 0, 5, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 4, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 14, 14, 4, 0, 15, 0, 0, 14, 0, 38, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_149.cpp,"name****literal****expr****argument
name****operator****name****operator****name****name****expr****condition****literal****expr****then****literal****expr****else****ternary****expr****argument
name****expr****argument
name****operator****name****operator****name****name****expr****condition****literal****expr****then****literal****expr****else****ternary****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T19:08:56,Brad King,47
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_163.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_163.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_328.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_328.cpp," *
 * If you ever want truly portable and good *printf() clones, the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at http://daniel.haxx.se/trio/
 */

#include ""curl_setup.h""

#if defined(DJGPP) && (DJGPP_MINOR < 4)
#undef _MPRINTF_REPLACE /* don't use x_was_used() here */
#endif

#include <curl/mprintf.h>

#include ""curl_memory.h""
"," *
 * If you ever want truly portable and good *printf() clones, the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at https://daniel.haxx.se/projects/trio/
 */

#include ""curl_setup.h""
#include <curl/mprintf.h>

#include ""curl_memory.h""
",32,32,33,33,"the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at http://daniel.haxx.se/trio/
 */;","the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at https://daniel.haxx.se/projects/trio/
 */;",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_150.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_150.cpp,[],second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_150.cpp,name****name****name****modifier****name****name****name****name****name****type****name****name****name****name****name****name****name****name****name****modifier****name****name****name****comment****operator****operator****expr****range****decl****decl_stmt****unit****,2016-08-03T19:08:56,Brad King,48
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/conncache.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_168.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_168.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_333.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_333.cpp,"/* returns an allocated key to find a bundle for this connection */
static char *hashkey(struct connectdata *conn)
{
  return aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);
}

/* Look up the bundle with all the connections to the same host this
","/* returns an allocated key to find a bundle for this connection */
static char *hashkey(struct connectdata *conn)
{
  const char *hostname;

  if(conn->bits.proxy)
    hostname = conn->proxy.name;
  else if(conn->bits.conn_to_host)
    hostname = conn->conn_to_host.name;
  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}

/* Look up the bundle with all the connections to the same host this
",132,131,135,-1,"aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_151.cpp,"{
  return aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_151.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_151.cpp,"name****literal****expr****argument
name****operator****name****operator****name****name****expr****condition****name****operator****name****operator****name****name****expr****then****name****operator****name****operator****name****name****expr****else****ternary****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,35
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,169,-1,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_152.cpp,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_152.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_152.cpp,"name****operator****name****operator****operator****operator****name****name****operator****literal****expr****index****name****expr****argument
literal****expr****argument
literal****expr****argument
name****name****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,91
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,278,-1,"aprintf(""%s/%s"", service, host);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_153.cpp,"{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_153.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_153.cpp,"name****literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,108
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,475,-1,"response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_154.cpp,"{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_154.cpp,"[4, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 2, 86, 0, 0, 5, 5, 0, 0, 2, 20, 0, 0, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 17, 0, 4, 4, 0, 0, 10, 0, 0, 7, 0, 36, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_154.cpp,"name****operator****name****literal****expr****argument
name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,36
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,637,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_155.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_155.cpp,"[10, 0, 3, 0, 0, 0, 11, 0, 0, 0, 14, 0, 0, 0, 24, 357, 0, 0, 19, 19, 0, 0, 9, 63, 0, 0, 0, 0, 3, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120, 0, 276, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 27, 0, 13, 10, 0, 0, 77, 0, 0, 49, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_155.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,89
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,670,-1,"snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_156.cpp,"snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_156.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_156.cpp,"name****operator****name****literal****operator****name****expr****index****name****expr****argument
literal****expr****argument
literal****expr****argument
name****name****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,106
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,693,-1,"snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_157.cpp,"snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_157.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_157.cpp,"name****operator****name****literal****operator****name****expr****index****name****expr****argument
literal****expr****argument
literal****expr****argument
name****name****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,106
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,723,-1,"snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_158.cpp,"snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_158.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_158.cpp,"name****operator****name****literal****operator****name****expr****index****name****expr****argument
literal****expr****argument
literal****expr****argument
name****name****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,106
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,726,-1,"response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_159.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_159.cpp,"[10, 0, 3, 0, 0, 0, 11, 0, 0, 0, 14, 0, 0, 0, 24, 357, 0, 0, 19, 19, 0, 0, 9, 63, 0, 0, 0, 0, 3, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120, 0, 276, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 27, 0, 13, 10, 0, 0, 77, 0, 0, 49, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_159.cpp,"name****operator****name****literal****literal****literal****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,37
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,922,-1,"snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_160.cpp,"{
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_160.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 23, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 8, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_160.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,92
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,946,-1,"(""%s:%s:%s"";",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_161.cpp,"{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_161.cpp,"[18, 0, 0, 0, 0, 0, 10, 0, 0, 0, 21, 0, 0, 0, 0, 287, 0, 0, 13, 13, 0, 0, 5, 32, 0, 0, 0, 0, 6, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 180, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 5, 0, 18, 18, 2, 0, 42, 0, 0, 40, 0, 102, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_161.cpp,operator****literal****expr****expr_stmt****unit****,2016-08-03T18:26:53,Brad King,107
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,957,-1,"tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_162.cpp,"{
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_162.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 5, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_162.cpp,"name****operator****name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,93
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,980,-1,"md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_163.cpp,"{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_163.cpp,"[18, 0, 0, 0, 0, 0, 10, 0, 0, 0, 21, 0, 0, 0, 0, 287, 0, 0, 13, 13, 0, 0, 5, 32, 0, 0, 0, 0, 6, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 180, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 5, 0, 18, 18, 2, 0, 42, 0, 0, 40, 0, 102, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_163.cpp,"name****operator****operator****name****name****operator****operator****name****literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,38
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,986,-1,"(""%s:%s"";",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_164.cpp,"{
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_164.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_164.cpp,operator****literal****expr****expr_stmt****unit****,2016-08-03T18:26:53,Brad King,107
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1000,-1,"md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_165.cpp,"{
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_165.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_165.cpp,"name****operator****operator****name****name****operator****operator****name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,39
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1009,-1,"md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_166.cpp,"{
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_166.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_166.cpp,"name****operator****operator****name****name****operator****operator****name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,40
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1041,-1,"response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_167.cpp,"{
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_167.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_167.cpp,"name****operator****name****literal****literal****literal****literal****literal****literal****literal****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,41
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1064,-1,"response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_168.cpp,"{
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_168.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_168.cpp,"name****operator****name****literal****literal****literal****literal****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,42
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1082,-1,"tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_169.cpp,"{
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_169.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_169.cpp,"name****operator****name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,97
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1092,-1,"tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_170.cpp,"{
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_170.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_170.cpp,"name****operator****name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,97
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1181,-1,"xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_171.cpp,"{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_171.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 23, 0, 0, 2, 2, 0, 0, 2, 1, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 0, 0, 4, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_171.cpp,"name****operator****name****literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,43
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_171.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_171.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_336.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_336.cpp,"    return CURLE_FAILED_INIT;
  }

#if defined(USE_LIBSSH2) && defined(HAVE_LIBSSH2_INIT)
  if(libssh2_init(0)) {
    DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));
","    return CURLE_FAILED_INIT;
  }

  (void)Curl_ipv6works();

#if defined(USE_LIBSSH2) && defined(HAVE_LIBSSH2_INIT)
  if(libssh2_init(0)) {
    DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));
",269,271,274,278,"DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));","DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_172.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));
    return CURLE_FAILED_INIT;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_172.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_172.cpp,"name****name****name****expr****argument
literal****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,44
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_172.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_172.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_339.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_339.cpp,"    if(result)
      return result;

    if(fstated) {
      time_t filetime = (time_t)statbuf.st_mtime;
      struct tm buffer;
      const struct tm *tm = &buffer;
      result = Curl_gmtime(filetime, &buffer);
      if(result)
        return result;

      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year  1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    }
    /* if we fstat()ed the file, set the file size to make it available post-
       transfer */
    if(fstated)
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }
","    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year  1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }
",479,486,491,495,"snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year + 1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);","snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_173.cpp,"{
      time_t filetime = (time_t)statbuf.st_mtime;
      struct tm buffer;
      const struct tm *tm = &buffer;
      result = Curl_gmtime(filetime, &buffer);
      if(result)
        return result;

      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year + 1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_173.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 57, 0, 0, 3, 3, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 1, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 2, 2, 1, 0, 3, 0, 0, 3, 0, 16, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_173.cpp,"name****name****expr****argument
name****operator****literal****expr****argument
literal****expr****argument
name****name****operator****name****name****expr****condition****name****operator****name****name****operator****literal****expr****then****literal****expr****else****ternary****expr****index****name****expr****argument
name****operator****name****name****expr****argument
name****name****operator****name****name****expr****index****name****expr****argument
name****operator****name****name****operator****literal****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,45
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_176.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_176.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_343.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_343.cpp,"
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
  }

  major_status = Curl_gss_init_sec_context(data,
                                           &minor_status,
                                           &neg_ctx->context,
                                           neg_ctx->server_name,
                                           &Curl_spnego_mech_oid,
                                           GSS_C_NO_CHANNEL_BINDINGS,
                                           &input_token,
                                           &output_token,
                                           TRUE,
                                           NULL);
  Curl_safefree(input_token.value);

  neg_ctx->status = major_status;
  if(GSS_ERROR(major_status)) {
    if(output_token.value)
      gss_release_buffer(&discard_st, &output_token);
    Curl_gss_log_error(conn->data, minor_status,
                       ""gss_init_sec_context() failed: "");
    return CURLE_OUT_OF_MEMORY;
  }

  if(!output_token.value || !output_token.length) {
    if(output_token.value)
      gss_release_buffer(&discard_st, &output_token);
    return CURLE_OUT_OF_MEMORY;
  }

  neg_ctx->output_token = output_token;

  return CURLE_OK;
}

CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;
  OM_uint32 discard_st;

  result = Curl_base64_encode(conn->data,
                              neg_ctx->output_token.value,
                              neg_ctx->output_token.length,
                              &encoded, &len);
  if(result) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return result;
  }

  if(!encoded || !len) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return CURLE_REMOTE_ACCESS_DENIED;
  }

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded);
  if(proxy) {
    Curl_safefree(conn->allocptr.proxyuserpwd);
    conn->allocptr.proxyuserpwd = userp;
","
#include ""curl_setup.h""

#if !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""rawstr.h""
#include ""http_negotiate.h""
#include ""vauth/vauth.h""

/* The last 3 #include files should be in this order */
#include ""curl_printf.h""
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct Curl_easy *data = conn->data;
  size_t len;

  /* Point to the username, password, service and host */
  const char *userp;
  const char *passwdp;
  const char *service;
  const char *host;

  /* Point to the correct struct with this */
  struct negotiatedata *neg_ctx;

  if(proxy) {
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    service = data->set.str[STRING_PROXY_SERVICE_NAME] ?
              data->set.str[STRING_PROXY_SERVICE_NAME] : ""HTTP"";
    host = conn->proxy.name;
    neg_ctx = &data->state.proxyneg;
  }
  else {
    userp = conn->user;
    passwdp = conn->passwd;
    service = data->set.str[STRING_SERVICE_NAME] ?
              data->set.str[STRING_SERVICE_NAME] : ""HTTP"";
    host = conn->host.name;
    neg_ctx = &data->state.negotiate;
  }

  /* Not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

  /* Obtain the input token, if any */
  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(!len) {
    /* Is this the first call in a new negotiation? */
    if(neg_ctx->context) {
      /* The server rejected our authentication and hasn't suppled any more
      negotiation mechanisms */
      return CURLE_LOGIN_DENIED;
    }
  }

  /* Initilise the security context and decode our challenge */
  return Curl_auth_decode_spnego_message(data, userp, passwdp, service, host,
                                         header, neg_ctx);
}

CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy ? &conn->data->state.proxyneg :
    &conn->data->state.negotiate;
  char *base64 = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;

  result = Curl_auth_create_spnego_message(conn->data, neg_ctx, &base64, &len);
  if(result)
    return result;

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  base64);

  if(proxy) {
    Curl_safefree(conn->allocptr.proxyuserpwd);
    conn->allocptr.proxyuserpwd = userp;
",22,22,173,110,"userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded);","userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  base64);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_174.cpp,"struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;
  OM_uint32 discard_st;

  result = Curl_base64_encode(conn->data,
                              neg_ctx->output_token.value,
                              neg_ctx->output_token.length,
                              &encoded, &len);
  if(result) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return result;
  }

  if(!encoded || !len) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return CURLE_REMOTE_ACCESS_DENIED;
  }

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_174.cpp,"[2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 76, 0, 0, 6, 6, 0, 0, 3, 6, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 1, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 3, 3, 1, 0, 4, 0, 0, 8, 0, 12, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_174.cpp,"name****operator****name****literal****expr****argument
name****expr****condition****literal****expr****then****literal****expr****else****ternary****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,46
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/http_proxy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_177.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_177.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_344.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_344.cpp,"
      if(!result) {
        char *host=(char *)"""";
        const char *proxyconn="""";
        const char *useragent="""";
        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?
          ""1.0"" : ""1.1"";
        char *hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", conn->bits.ipv6_ip?""["":"""",
                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
","
      if(!result) {
        char *host=(char *)"""";
        const char *useragent="""";
        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?
          ""1.0"" : ""1.1"";
        bool ipv6_ip = conn->bits.ipv6_ip;
        char *hostheader;

        /* the hostname may be different */
        if(hostname != conn->host.name)
          ipv6_ip = (strchr(hostname, ':') != NULL);
        hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", ipv6_ip?""["":"""", hostname, ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
",150,160,158,172,"aprintf(""%s%s%s:%hu"", conn->bits.ipv6_ip?""["":"""",
                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);","hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", ipv6_ip?""["":"""", hostname, ipv6_ip?""]"":"""",
                  remote_port);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_175.cpp,"{
        char *host=(char *)"""";
        const char *proxyconn="""";
        const char *useragent="""";
        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?
          ""1.0"" : ""1.1"";
        char *hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", conn->bits.ipv6_ip?""["":"""",
                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
          return CURLE_OUT_OF_MEMORY;
        }

        if(!Curl_checkProxyheaders(conn, ""Host:"")) {
          host = aprintf(""Host: %s\r\n"", hostheader);
          if(!host) {
            free(hostheader);
            Curl_add_buffer_free(req_buffer);
            return CURLE_OUT_OF_MEMORY;
          }
        }
        if(!Curl_checkProxyheaders(conn, ""Proxy-Connection:""))
          proxyconn = ""Proxy-Connection: Keep-Alive\r\n"";

        if(!Curl_checkProxyheaders(conn, ""User-Agent:"") &&
           data->set.str[STRING_USERAGENT])
          useragent = conn->allocptr.uagent;

        result =
          Curl_add_bufferf(req_buffer,
                           ""CONNECT %s HTTP/%s\r\n""
                           ""%s""  /* Host: */
                           ""%s""  /* Proxy-Authorization */
                           ""%s""  /* User-Agent */
                           ""%s"", /* Proxy-Connection */
                           hostheader,
                           http,
                           host,
                           conn->allocptr.proxyuserpwd?
                           conn->allocptr.proxyuserpwd:"""",
                           useragent,
                           proxyconn);

        if(host && *host)
          free(host);
        free(hostheader);

        if(!result)
          result = Curl_add_custom_headers(conn, TRUE, req_buffer);

        if(!result)
          /* CRLF terminate the request */
          result = Curl_add_bufferf(req_buffer, ""\r\n"");

        if(!result) {
          /* Send the connect request to the proxy */
          /* BLOCKING */
          result =
            Curl_add_buffer_send(req_buffer, conn,
                                 &data->info.request_size, 0, sockindex);
        }
        req_buffer = NULL;
        if(result)
          failf(data, ""Failed sending CONNECT to proxy"");
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_175.cpp,"[10, 0, 0, 0, 0, 0, 2, 0, 0, 0, 11, 0, 0, 0, 3, 103, 0, 0, 5, 5, 0, 0, 5, 24, 0, 0, 0, 0, 5, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 4, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 14, 14, 4, 0, 15, 0, 0, 14, 0, 38, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_175.cpp,"name****literal****expr****argument
name****operator****name****operator****name****name****expr****condition****literal****expr****then****literal****expr****else****ternary****expr****argument
name****expr****argument
name****operator****name****operator****name****name****expr****condition****literal****expr****then****literal****expr****else****ternary****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,47
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_178.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_178.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_345.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_345.cpp," *
 * If you ever want truly portable and good *printf() clones, the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at http://daniel.haxx.se/trio/
 */

#include ""curl_setup.h""

#if defined(DJGPP) && (DJGPP_MINOR < 4)
#undef _MPRINTF_REPLACE /* don't use x_was_used() here */
#endif

#include <curl/mprintf.h>

#include ""curl_memory.h""
"," *
 * If you ever want truly portable and good *printf() clones, the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at https://daniel.haxx.se/projects/trio/
 */

#include ""curl_setup.h""
#include <curl/mprintf.h>

#include ""curl_memory.h""
",32,32,33,33,"the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at http://daniel.haxx.se/trio/
 */;","the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at https://daniel.haxx.se/projects/trio/
 */;",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_176.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_176.cpp,[],second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_176.cpp,name****name****name****modifier****name****name****name****name****name****type****name****name****name****name****name****name****name****name****name****modifier****name****name****name****comment****operator****operator****expr****range****decl****decl_stmt****unit****,2016-08-03T18:26:53,Brad King,48
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/tftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_349.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_349.cpp,"             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_TSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_BLKSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_INTERVAL);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
","             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* optional addition of TFTP options */
    if(!data->set.tftp_no_options) {
      /* add tsize option */
      if(data->set.upload && (data->state.infilesize != -1))
        snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
                 data->state.infilesize);
      else
        strcpy(buf, ""0""); /* the destination is large enough */

      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_TSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
      /* add blksize option */
      snprintf(buf, sizeof(buf), ""%d"", state->requested_blksize);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_BLKSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);

      /* add timeout option */
      snprintf(buf, sizeof(buf), ""%d"", state->retry_time);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_INTERVAL);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
    }

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
",494,494,510,512,"snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );","snprintf(buf, sizeof(buf), ""%d"", state->requested_blksize);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_177.cpp,"{

  case TFTP_EVENT_INIT:    /* Send the first packet out */
  case TFTP_EVENT_TIMEOUT: /* Resend the first packet out */
    /* Increment the retry counter, quit if over the limit */
    state->retries++;
    if(state->retries>state->retry_max) {
      state->error = TFTP_ERR_NORESPONSE;
      state->state = TFTP_STATE_FIN;
      return result;
    }

    if(data->set.upload) {
      /* If we are uploading, send an WRQ */
      setpacketevent(&state->spacket, TFTP_EVENT_WRQ);
      state->conn->data->req.upload_fromhere =
        (char *)state->spacket.data+4;
      if(data->state.infilesize != -1)
        Curl_pgrsSetUploadSize(data, data->state.infilesize);
    }
    else {
      /* If we are downloading, send an RRQ */
      setpacketevent(&state->spacket, TFTP_EVENT_RRQ);
    }
    /* As RFC3617 describes the separator slash is not actually part of the
       file name so we skip the always-present first letter of the path
       string. */
    filename = curl_easy_unescape(data, &state->conn->data->state.path[1], 0,
                                  NULL);
    if(!filename)
      return CURLE_OUT_OF_MEMORY;

    snprintf((char *)state->spacket.data+2,
             state->blksize,
             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4 + strlen(filename) + strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_TSIZE);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_BLKSIZE);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_INTERVAL);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
    senddata = sendto(state->sockfd, (void *)state->spacket.data,
                      (SEND_TYPE_ARG3)sbytes, 0,
                      state->conn->ip_addr->ai_addr,
                      state->conn->ip_addr->ai_addrlen);
    if(senddata != (ssize_t)sbytes) {
      failf(data, ""%s"", Curl_strerror(state->conn, SOCKERRNO));
    }
    free(filename);
    break;

  case TFTP_EVENT_OACK:
    if(data->set.upload) {
      result = tftp_connect_for_tx(state, event);
    }
    else {
      result = tftp_connect_for_rx(state, event);
    }
    break;

  case TFTP_EVENT_ACK: /* Connected for transmit */
    result = tftp_connect_for_tx(state, event);
    break;

  case TFTP_EVENT_DATA: /* Connected for receive */
    result = tftp_connect_for_rx(state, event);
    break;

  case TFTP_EVENT_ERROR:
    state->state = TFTP_STATE_FIN;
    break;

  default:
    failf(state->conn->data, ""tftp_send_first: internal error"");
    break;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_177.cpp,"[7, 0, 0, 0, 6, 0, 2, 0, 6, 1, 11, 0, 0, 0, 0, 246, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133, 0, 127, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 7, 7, 3, 0, 29, 0, 0, 29, 0, 82, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_177.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,90
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/tftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_349.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_349.cpp,"             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_TSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_BLKSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_INTERVAL);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
","             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* optional addition of TFTP options */
    if(!data->set.tftp_no_options) {
      /* add tsize option */
      if(data->set.upload && (data->state.infilesize != -1))
        snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
                 data->state.infilesize);
      else
        strcpy(buf, ""0""); /* the destination is large enough */

      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_TSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
      /* add blksize option */
      snprintf(buf, sizeof(buf), ""%d"", state->requested_blksize);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_BLKSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);

      /* add timeout option */
      snprintf(buf, sizeof(buf), ""%d"", state->retry_time);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_INTERVAL);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
    }

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
",494,494,518,520,"snprintf( buf, sizeof(buf), ""%d"", state->retry_time);","snprintf(buf, sizeof(buf), ""%d"", state->retry_time);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_178.cpp,"{

  case TFTP_EVENT_INIT:    /* Send the first packet out */
  case TFTP_EVENT_TIMEOUT: /* Resend the first packet out */
    /* Increment the retry counter, quit if over the limit */
    state->retries++;
    if(state->retries>state->retry_max) {
      state->error = TFTP_ERR_NORESPONSE;
      state->state = TFTP_STATE_FIN;
      return result;
    }

    if(data->set.upload) {
      /* If we are uploading, send an WRQ */
      setpacketevent(&state->spacket, TFTP_EVENT_WRQ);
      state->conn->data->req.upload_fromhere =
        (char *)state->spacket.data+4;
      if(data->state.infilesize != -1)
        Curl_pgrsSetUploadSize(data, data->state.infilesize);
    }
    else {
      /* If we are downloading, send an RRQ */
      setpacketevent(&state->spacket, TFTP_EVENT_RRQ);
    }
    /* As RFC3617 describes the separator slash is not actually part of the
       file name so we skip the always-present first letter of the path
       string. */
    filename = curl_easy_unescape(data, &state->conn->data->state.path[1], 0,
                                  NULL);
    if(!filename)
      return CURLE_OUT_OF_MEMORY;

    snprintf((char *)state->spacket.data+2,
             state->blksize,
             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4 + strlen(filename) + strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_TSIZE);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_BLKSIZE);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_INTERVAL);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
    senddata = sendto(state->sockfd, (void *)state->spacket.data,
                      (SEND_TYPE_ARG3)sbytes, 0,
                      state->conn->ip_addr->ai_addr,
                      state->conn->ip_addr->ai_addrlen);
    if(senddata != (ssize_t)sbytes) {
      failf(data, ""%s"", Curl_strerror(state->conn, SOCKERRNO));
    }
    free(filename);
    break;

  case TFTP_EVENT_OACK:
    if(data->set.upload) {
      result = tftp_connect_for_tx(state, event);
    }
    else {
      result = tftp_connect_for_rx(state, event);
    }
    break;

  case TFTP_EVENT_ACK: /* Connected for transmit */
    result = tftp_connect_for_tx(state, event);
    break;

  case TFTP_EVENT_DATA: /* Connected for receive */
    result = tftp_connect_for_rx(state, event);
    break;

  case TFTP_EVENT_ERROR:
    state->state = TFTP_STATE_FIN;
    break;

  default:
    failf(state->conn->data, ""tftp_send_first: internal error"");
    break;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_178.cpp,"[7, 0, 0, 0, 6, 0, 2, 0, 6, 1, 11, 0, 0, 0, 0, 246, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133, 0, 127, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 7, 7, 3, 0, 29, 0, 0, 29, 0, 82, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_178.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:53,Brad King,90
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/conncache.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_184.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_184.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_351.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_351.cpp,"/* returns an allocated key to find a bundle for this connection */
static char *hashkey(struct connectdata *conn)
{
  return aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);
}

/* Look up the bundle with all the connections to the same host this
","/* returns an allocated key to find a bundle for this connection */
static char *hashkey(struct connectdata *conn)
{
  const char *hostname;

  if(conn->bits.proxy)
    hostname = conn->proxy.name;
  else if(conn->bits.conn_to_host)
    hostname = conn->conn_to_host.name;
  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}

/* Look up the bundle with all the connections to the same host this
",132,131,135,-1,"aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_179.cpp,"{
  return aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_179.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_179.cpp,"name****literal****expr****argument
name****operator****name****operator****name****name****expr****condition****name****operator****name****operator****name****name****expr****then****name****operator****name****operator****name****name****expr****else****ternary****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,35
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,169,-1,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_180.cpp,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_180.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_180.cpp,"name****operator****name****operator****operator****operator****name****name****operator****literal****expr****index****name****expr****argument
literal****expr****argument
literal****expr****argument
name****name****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,91
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,278,-1,"aprintf(""%s/%s"", service, host);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_181.cpp,"{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_181.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_181.cpp,"name****literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,108
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,475,-1,"response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_182.cpp,"{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_182.cpp,"[4, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 2, 86, 0, 0, 5, 5, 0, 0, 2, 20, 0, 0, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 17, 0, 4, 4, 0, 0, 10, 0, 0, 7, 0, 36, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_182.cpp,"name****operator****name****literal****expr****argument
name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,36
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,637,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_183.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_183.cpp,"[10, 0, 3, 0, 0, 0, 11, 0, 0, 0, 14, 0, 0, 0, 24, 357, 0, 0, 19, 19, 0, 0, 9, 63, 0, 0, 0, 0, 3, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120, 0, 276, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 27, 0, 13, 10, 0, 0, 77, 0, 0, 49, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_183.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,89
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,670,-1,"snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_184.cpp,"snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_184.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_184.cpp,"name****operator****name****literal****operator****name****expr****index****name****expr****argument
literal****expr****argument
literal****expr****argument
name****name****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,106
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,693,-1,"snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_185.cpp,"snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_185.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_185.cpp,"name****operator****name****literal****operator****name****expr****index****name****expr****argument
literal****expr****argument
literal****expr****argument
name****name****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,106
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,723,-1,"snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_186.cpp,"snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_186.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_186.cpp,"name****operator****name****literal****operator****name****expr****index****name****expr****argument
literal****expr****argument
literal****expr****argument
name****name****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,106
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,726,-1,"response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_187.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_187.cpp,"[10, 0, 3, 0, 0, 0, 11, 0, 0, 0, 14, 0, 0, 0, 24, 357, 0, 0, 19, 19, 0, 0, 9, 63, 0, 0, 0, 0, 3, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120, 0, 276, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 27, 0, 13, 10, 0, 0, 77, 0, 0, 49, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_187.cpp,"name****operator****name****literal****literal****literal****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,37
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,922,-1,"snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_188.cpp,"{
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_188.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 23, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 8, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_188.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,92
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,946,-1,"(""%s:%s:%s"";",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_189.cpp,"{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_189.cpp,"[18, 0, 0, 0, 0, 0, 10, 0, 0, 0, 21, 0, 0, 0, 0, 287, 0, 0, 13, 13, 0, 0, 5, 32, 0, 0, 0, 0, 6, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 180, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 5, 0, 18, 18, 2, 0, 42, 0, 0, 40, 0, 102, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_189.cpp,operator****literal****expr****expr_stmt****unit****,2016-08-03T18:26:29,Brad King,107
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,957,-1,"tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_190.cpp,"{
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_190.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 5, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_190.cpp,"name****operator****name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,93
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,980,-1,"md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_191.cpp,"{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_191.cpp,"[18, 0, 0, 0, 0, 0, 10, 0, 0, 0, 21, 0, 0, 0, 0, 287, 0, 0, 13, 13, 0, 0, 5, 32, 0, 0, 0, 0, 6, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 180, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 5, 0, 18, 18, 2, 0, 42, 0, 0, 40, 0, 102, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_191.cpp,"name****operator****operator****name****name****operator****operator****name****literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,38
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,986,-1,"(""%s:%s"";",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_192.cpp,"{
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_192.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_192.cpp,operator****literal****expr****expr_stmt****unit****,2016-08-03T18:26:29,Brad King,107
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1000,-1,"md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_193.cpp,"{
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_193.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_193.cpp,"name****operator****operator****name****name****operator****operator****name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,39
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1009,-1,"md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_194.cpp,"{
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_194.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_194.cpp,"name****operator****operator****name****name****operator****operator****name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,40
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1041,-1,"response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_195.cpp,"{
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_195.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_195.cpp,"name****operator****name****literal****literal****literal****literal****literal****literal****literal****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,41
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1064,-1,"response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_196.cpp,"{
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_196.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_196.cpp,"name****operator****name****literal****literal****literal****literal****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,42
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1082,-1,"tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_197.cpp,"{
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_197.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_197.cpp,"name****operator****name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,97
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1092,-1,"tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_198.cpp,"{
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_198.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_198.cpp,"name****operator****name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,97
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1181,-1,"xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_199.cpp,"{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_199.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 23, 0, 0, 2, 2, 0, 0, 2, 1, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 0, 0, 4, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_199.cpp,"name****operator****name****literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,43
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_187.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_187.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_354.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_354.cpp,"    return CURLE_FAILED_INIT;
  }

#if defined(USE_LIBSSH2) && defined(HAVE_LIBSSH2_INIT)
  if(libssh2_init(0)) {
    DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));
","    return CURLE_FAILED_INIT;
  }

  (void)Curl_ipv6works();

#if defined(USE_LIBSSH2) && defined(HAVE_LIBSSH2_INIT)
  if(libssh2_init(0)) {
    DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));
",269,271,274,278,"DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));","DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_200.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));
    return CURLE_FAILED_INIT;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_200.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_200.cpp,"name****name****name****expr****argument
literal****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,44
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_188.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_188.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_357.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_357.cpp,"    if(result)
      return result;

    if(fstated) {
      time_t filetime = (time_t)statbuf.st_mtime;
      struct tm buffer;
      const struct tm *tm = &buffer;
      result = Curl_gmtime(filetime, &buffer);
      if(result)
        return result;

      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year  1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    }
    /* if we fstat()ed the file, set the file size to make it available post-
       transfer */
    if(fstated)
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }
","    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year  1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }
",479,486,491,495,"snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year + 1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);","snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_201.cpp,"{
      time_t filetime = (time_t)statbuf.st_mtime;
      struct tm buffer;
      const struct tm *tm = &buffer;
      result = Curl_gmtime(filetime, &buffer);
      if(result)
        return result;

      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year + 1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_201.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 57, 0, 0, 3, 3, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 1, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 2, 2, 1, 0, 3, 0, 0, 3, 0, 16, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_201.cpp,"name****name****expr****argument
name****operator****literal****expr****argument
literal****expr****argument
name****name****operator****name****name****expr****condition****name****operator****name****name****operator****literal****expr****then****literal****expr****else****ternary****expr****index****name****expr****argument
name****operator****name****name****expr****argument
name****name****operator****name****name****expr****index****name****expr****argument
name****operator****name****name****operator****literal****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,45
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_192.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_192.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_361.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_361.cpp,"
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
  }

  major_status = Curl_gss_init_sec_context(data,
                                           &minor_status,
                                           &neg_ctx->context,
                                           neg_ctx->server_name,
                                           &Curl_spnego_mech_oid,
                                           GSS_C_NO_CHANNEL_BINDINGS,
                                           &input_token,
                                           &output_token,
                                           TRUE,
                                           NULL);
  Curl_safefree(input_token.value);

  neg_ctx->status = major_status;
  if(GSS_ERROR(major_status)) {
    if(output_token.value)
      gss_release_buffer(&discard_st, &output_token);
    Curl_gss_log_error(conn->data, minor_status,
                       ""gss_init_sec_context() failed: "");
    return CURLE_OUT_OF_MEMORY;
  }

  if(!output_token.value || !output_token.length) {
    if(output_token.value)
      gss_release_buffer(&discard_st, &output_token);
    return CURLE_OUT_OF_MEMORY;
  }

  neg_ctx->output_token = output_token;

  return CURLE_OK;
}

CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;
  OM_uint32 discard_st;

  result = Curl_base64_encode(conn->data,
                              neg_ctx->output_token.value,
                              neg_ctx->output_token.length,
                              &encoded, &len);
  if(result) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return result;
  }

  if(!encoded || !len) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return CURLE_REMOTE_ACCESS_DENIED;
  }

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded);
  if(proxy) {
    Curl_safefree(conn->allocptr.proxyuserpwd);
    conn->allocptr.proxyuserpwd = userp;
","
#include ""curl_setup.h""

#if !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""rawstr.h""
#include ""http_negotiate.h""
#include ""vauth/vauth.h""

/* The last 3 #include files should be in this order */
#include ""curl_printf.h""
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct Curl_easy *data = conn->data;
  size_t len;

  /* Point to the username, password, service and host */
  const char *userp;
  const char *passwdp;
  const char *service;
  const char *host;

  /* Point to the correct struct with this */
  struct negotiatedata *neg_ctx;

  if(proxy) {
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    service = data->set.str[STRING_PROXY_SERVICE_NAME] ?
              data->set.str[STRING_PROXY_SERVICE_NAME] : ""HTTP"";
    host = conn->proxy.name;
    neg_ctx = &data->state.proxyneg;
  }
  else {
    userp = conn->user;
    passwdp = conn->passwd;
    service = data->set.str[STRING_SERVICE_NAME] ?
              data->set.str[STRING_SERVICE_NAME] : ""HTTP"";
    host = conn->host.name;
    neg_ctx = &data->state.negotiate;
  }

  /* Not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

  /* Obtain the input token, if any */
  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(!len) {
    /* Is this the first call in a new negotiation? */
    if(neg_ctx->context) {
      /* The server rejected our authentication and hasn't suppled any more
      negotiation mechanisms */
      return CURLE_LOGIN_DENIED;
    }
  }

  /* Initilise the security context and decode our challenge */
  return Curl_auth_decode_spnego_message(data, userp, passwdp, service, host,
                                         header, neg_ctx);
}

CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy ? &conn->data->state.proxyneg :
    &conn->data->state.negotiate;
  char *base64 = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;

  result = Curl_auth_create_spnego_message(conn->data, neg_ctx, &base64, &len);
  if(result)
    return result;

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  base64);

  if(proxy) {
    Curl_safefree(conn->allocptr.proxyuserpwd);
    conn->allocptr.proxyuserpwd = userp;
",22,22,173,110,"userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded);","userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  base64);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_202.cpp,"struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;
  OM_uint32 discard_st;

  result = Curl_base64_encode(conn->data,
                              neg_ctx->output_token.value,
                              neg_ctx->output_token.length,
                              &encoded, &len);
  if(result) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return result;
  }

  if(!encoded || !len) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return CURLE_REMOTE_ACCESS_DENIED;
  }

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_202.cpp,"[2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 76, 0, 0, 6, 6, 0, 0, 3, 6, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 1, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 3, 3, 1, 0, 4, 0, 0, 8, 0, 12, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_202.cpp,"name****operator****name****literal****expr****argument
name****expr****condition****literal****expr****then****literal****expr****else****ternary****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,46
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/http_proxy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_193.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_193.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_362.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_362.cpp,"
      if(!result) {
        char *host=(char *)"""";
        const char *proxyconn="""";
        const char *useragent="""";
        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?
          ""1.0"" : ""1.1"";
        char *hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", conn->bits.ipv6_ip?""["":"""",
                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
","
      if(!result) {
        char *host=(char *)"""";
        const char *useragent="""";
        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?
          ""1.0"" : ""1.1"";
        bool ipv6_ip = conn->bits.ipv6_ip;
        char *hostheader;

        /* the hostname may be different */
        if(hostname != conn->host.name)
          ipv6_ip = (strchr(hostname, ':') != NULL);
        hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", ipv6_ip?""["":"""", hostname, ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
",150,160,158,172,"aprintf(""%s%s%s:%hu"", conn->bits.ipv6_ip?""["":"""",
                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);","hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", ipv6_ip?""["":"""", hostname, ipv6_ip?""]"":"""",
                  remote_port);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_203.cpp,"{
        char *host=(char *)"""";
        const char *proxyconn="""";
        const char *useragent="""";
        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?
          ""1.0"" : ""1.1"";
        char *hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", conn->bits.ipv6_ip?""["":"""",
                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
          return CURLE_OUT_OF_MEMORY;
        }

        if(!Curl_checkProxyheaders(conn, ""Host:"")) {
          host = aprintf(""Host: %s\r\n"", hostheader);
          if(!host) {
            free(hostheader);
            Curl_add_buffer_free(req_buffer);
            return CURLE_OUT_OF_MEMORY;
          }
        }
        if(!Curl_checkProxyheaders(conn, ""Proxy-Connection:""))
          proxyconn = ""Proxy-Connection: Keep-Alive\r\n"";

        if(!Curl_checkProxyheaders(conn, ""User-Agent:"") &&
           data->set.str[STRING_USERAGENT])
          useragent = conn->allocptr.uagent;

        result =
          Curl_add_bufferf(req_buffer,
                           ""CONNECT %s HTTP/%s\r\n""
                           ""%s""  /* Host: */
                           ""%s""  /* Proxy-Authorization */
                           ""%s""  /* User-Agent */
                           ""%s"", /* Proxy-Connection */
                           hostheader,
                           http,
                           host,
                           conn->allocptr.proxyuserpwd?
                           conn->allocptr.proxyuserpwd:"""",
                           useragent,
                           proxyconn);

        if(host && *host)
          free(host);
        free(hostheader);

        if(!result)
          result = Curl_add_custom_headers(conn, TRUE, req_buffer);

        if(!result)
          /* CRLF terminate the request */
          result = Curl_add_bufferf(req_buffer, ""\r\n"");

        if(!result) {
          /* Send the connect request to the proxy */
          /* BLOCKING */
          result =
            Curl_add_buffer_send(req_buffer, conn,
                                 &data->info.request_size, 0, sockindex);
        }
        req_buffer = NULL;
        if(result)
          failf(data, ""Failed sending CONNECT to proxy"");
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_203.cpp,"[10, 0, 0, 0, 0, 0, 2, 0, 0, 0, 11, 0, 0, 0, 3, 103, 0, 0, 5, 5, 0, 0, 5, 24, 0, 0, 0, 0, 5, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 4, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 14, 14, 4, 0, 15, 0, 0, 14, 0, 38, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_203.cpp,"name****literal****expr****argument
name****operator****name****operator****name****name****expr****condition****literal****expr****then****literal****expr****else****ternary****expr****argument
name****expr****argument
name****operator****name****operator****name****name****expr****condition****literal****expr****then****literal****expr****else****ternary****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,47
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_194.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_194.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_363.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_363.cpp," *
 * If you ever want truly portable and good *printf() clones, the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at http://daniel.haxx.se/trio/
 */

#include ""curl_setup.h""

#if defined(DJGPP) && (DJGPP_MINOR < 4)
#undef _MPRINTF_REPLACE /* don't use x_was_used() here */
#endif

#include <curl/mprintf.h>

#include ""curl_memory.h""
"," *
 * If you ever want truly portable and good *printf() clones, the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at https://daniel.haxx.se/projects/trio/
 */

#include ""curl_setup.h""
#include <curl/mprintf.h>

#include ""curl_memory.h""
",32,32,33,33,"the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at http://daniel.haxx.se/trio/
 */;","the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at https://daniel.haxx.se/projects/trio/
 */;",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_204.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_204.cpp,[],second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_204.cpp,name****name****name****modifier****name****name****name****name****name****type****name****name****name****name****name****name****name****name****name****modifier****name****name****name****comment****operator****operator****expr****range****decl****decl_stmt****unit****,2016-08-03T18:26:29,Brad King,48
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/tftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_198.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_198.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_367.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_367.cpp,"             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_TSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_BLKSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_INTERVAL);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
","             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* optional addition of TFTP options */
    if(!data->set.tftp_no_options) {
      /* add tsize option */
      if(data->set.upload && (data->state.infilesize != -1))
        snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
                 data->state.infilesize);
      else
        strcpy(buf, ""0""); /* the destination is large enough */

      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_TSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
      /* add blksize option */
      snprintf(buf, sizeof(buf), ""%d"", state->requested_blksize);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_BLKSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);

      /* add timeout option */
      snprintf(buf, sizeof(buf), ""%d"", state->retry_time);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_INTERVAL);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
    }

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
",494,494,510,512,"snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );","snprintf(buf, sizeof(buf), ""%d"", state->requested_blksize);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_205.cpp,"{

  case TFTP_EVENT_INIT:    /* Send the first packet out */
  case TFTP_EVENT_TIMEOUT: /* Resend the first packet out */
    /* Increment the retry counter, quit if over the limit */
    state->retries++;
    if(state->retries>state->retry_max) {
      state->error = TFTP_ERR_NORESPONSE;
      state->state = TFTP_STATE_FIN;
      return result;
    }

    if(data->set.upload) {
      /* If we are uploading, send an WRQ */
      setpacketevent(&state->spacket, TFTP_EVENT_WRQ);
      state->conn->data->req.upload_fromhere =
        (char *)state->spacket.data+4;
      if(data->state.infilesize != -1)
        Curl_pgrsSetUploadSize(data, data->state.infilesize);
    }
    else {
      /* If we are downloading, send an RRQ */
      setpacketevent(&state->spacket, TFTP_EVENT_RRQ);
    }
    /* As RFC3617 describes the separator slash is not actually part of the
       file name so we skip the always-present first letter of the path
       string. */
    filename = curl_easy_unescape(data, &state->conn->data->state.path[1], 0,
                                  NULL);
    if(!filename)
      return CURLE_OUT_OF_MEMORY;

    snprintf((char *)state->spacket.data+2,
             state->blksize,
             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4 + strlen(filename) + strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_TSIZE);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_BLKSIZE);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_INTERVAL);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
    senddata = sendto(state->sockfd, (void *)state->spacket.data,
                      (SEND_TYPE_ARG3)sbytes, 0,
                      state->conn->ip_addr->ai_addr,
                      state->conn->ip_addr->ai_addrlen);
    if(senddata != (ssize_t)sbytes) {
      failf(data, ""%s"", Curl_strerror(state->conn, SOCKERRNO));
    }
    free(filename);
    break;

  case TFTP_EVENT_OACK:
    if(data->set.upload) {
      result = tftp_connect_for_tx(state, event);
    }
    else {
      result = tftp_connect_for_rx(state, event);
    }
    break;

  case TFTP_EVENT_ACK: /* Connected for transmit */
    result = tftp_connect_for_tx(state, event);
    break;

  case TFTP_EVENT_DATA: /* Connected for receive */
    result = tftp_connect_for_rx(state, event);
    break;

  case TFTP_EVENT_ERROR:
    state->state = TFTP_STATE_FIN;
    break;

  default:
    failf(state->conn->data, ""tftp_send_first: internal error"");
    break;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_205.cpp,"[7, 0, 0, 0, 6, 0, 2, 0, 6, 1, 11, 0, 0, 0, 0, 246, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133, 0, 127, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 7, 7, 3, 0, 29, 0, 0, 29, 0, 82, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_205.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,90
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/tftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_198.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_198.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_367.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_367.cpp,"             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_TSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_BLKSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_INTERVAL);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
","             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* optional addition of TFTP options */
    if(!data->set.tftp_no_options) {
      /* add tsize option */
      if(data->set.upload && (data->state.infilesize != -1))
        snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
                 data->state.infilesize);
      else
        strcpy(buf, ""0""); /* the destination is large enough */

      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_TSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
      /* add blksize option */
      snprintf(buf, sizeof(buf), ""%d"", state->requested_blksize);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_BLKSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);

      /* add timeout option */
      snprintf(buf, sizeof(buf), ""%d"", state->retry_time);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_INTERVAL);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
    }

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
",494,494,518,520,"snprintf( buf, sizeof(buf), ""%d"", state->retry_time);","snprintf(buf, sizeof(buf), ""%d"", state->retry_time);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_206.cpp,"{

  case TFTP_EVENT_INIT:    /* Send the first packet out */
  case TFTP_EVENT_TIMEOUT: /* Resend the first packet out */
    /* Increment the retry counter, quit if over the limit */
    state->retries++;
    if(state->retries>state->retry_max) {
      state->error = TFTP_ERR_NORESPONSE;
      state->state = TFTP_STATE_FIN;
      return result;
    }

    if(data->set.upload) {
      /* If we are uploading, send an WRQ */
      setpacketevent(&state->spacket, TFTP_EVENT_WRQ);
      state->conn->data->req.upload_fromhere =
        (char *)state->spacket.data+4;
      if(data->state.infilesize != -1)
        Curl_pgrsSetUploadSize(data, data->state.infilesize);
    }
    else {
      /* If we are downloading, send an RRQ */
      setpacketevent(&state->spacket, TFTP_EVENT_RRQ);
    }
    /* As RFC3617 describes the separator slash is not actually part of the
       file name so we skip the always-present first letter of the path
       string. */
    filename = curl_easy_unescape(data, &state->conn->data->state.path[1], 0,
                                  NULL);
    if(!filename)
      return CURLE_OUT_OF_MEMORY;

    snprintf((char *)state->spacket.data+2,
             state->blksize,
             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4 + strlen(filename) + strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_TSIZE);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_BLKSIZE);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_INTERVAL);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
    senddata = sendto(state->sockfd, (void *)state->spacket.data,
                      (SEND_TYPE_ARG3)sbytes, 0,
                      state->conn->ip_addr->ai_addr,
                      state->conn->ip_addr->ai_addrlen);
    if(senddata != (ssize_t)sbytes) {
      failf(data, ""%s"", Curl_strerror(state->conn, SOCKERRNO));
    }
    free(filename);
    break;

  case TFTP_EVENT_OACK:
    if(data->set.upload) {
      result = tftp_connect_for_tx(state, event);
    }
    else {
      result = tftp_connect_for_rx(state, event);
    }
    break;

  case TFTP_EVENT_ACK: /* Connected for transmit */
    result = tftp_connect_for_tx(state, event);
    break;

  case TFTP_EVENT_DATA: /* Connected for receive */
    result = tftp_connect_for_rx(state, event);
    break;

  case TFTP_EVENT_ERROR:
    state->state = TFTP_STATE_FIN;
    break;

  default:
    failf(state->conn->data, ""tftp_send_first: internal error"");
    break;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_206.cpp,"[7, 0, 0, 0, 6, 0, 2, 0, 6, 1, 11, 0, 0, 0, 0, 246, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133, 0, 127, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 7, 7, 3, 0, 29, 0, 0, 29, 0, 82, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_206.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-08-03T18:26:29,Brad King,90
fb4791b37ccea1f38b8625b31df952408ab942f3,"cmCoreTryCompile: Refactor forwarding of variables to test project

De-duplicate the logic that constructs the cmake `-D` flag used to pass
variables into the test project cache.  Also subsume variables that were
propagated by generating `set()` commands in the project and pass them
as cache entries instead.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_207.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_207.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_377.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_377.cpp,"              fname.c_str());
    }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if (this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"") !=
        0) {
      std::string flag = ""-DCMAKE_OSX_ARCHITECTURES="";
      flag = this->Makefile->GetSafeDefinition(
        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
    } else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"") != 0) {
      std::string flag = ""-DCMAKE_OSX_ARCHITECTURES="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
    }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if (this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"") != 0) {
      std::string flag = ""-DCMAKE_OSX_SYSROOT="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
    }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if (this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"") != 0) {
      std::string flag = ""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
    }
    if (const char* cxxDef =
          this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET"")) {
      std::string flag = ""-DCMAKE_CXX_COMPILER_TARGET="";
      flag = cxxDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* cDef =
          this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET"")) {
      std::string flag = ""-DCMAKE_C_COMPILER_TARGET="";
      flag = cDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* tcxxDef = this->Makefile->GetDefinition(
          ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN"")) {
      std::string flag = ""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag = tcxxDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* tcDef = this->Makefile->GetDefinition(
          ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN"")) {
      std::string flag = ""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag = tcDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* rootDef = this->Makefile->GetDefinition(""CMAKE_SYSROOT"")) {
      std::string flag = ""-DCMAKE_SYSROOT="";
      flag = rootDef;
      cmakeFlags.push_back(flag);
    }
    if (this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"") !=
        0) {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
    }
    if (const char* lssDef =
          this->Makefile->GetDefinition(""CMAKE_LINK_SEARCH_START_STATIC"")) {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef);
    }
    if (const char* lssDef =
          this->Makefile->GetDefinition(""CMAKE_LINK_SEARCH_END_STATIC"")) {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef);
    }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
","              fname.c_str());
    }

    // Forward a set of variables to the inner project cache.
    {
      std::set<std::string> vars;
      vars.insert(kCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN);
      vars.insert(kCMAKE_C_COMPILER_TARGET);
      vars.insert(kCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN);
      vars.insert(kCMAKE_CXX_COMPILER_TARGET);
      vars.insert(kCMAKE_ENABLE_EXPORTS);
      vars.insert(kCMAKE_LINK_SEARCH_END_STATIC);
      vars.insert(kCMAKE_LINK_SEARCH_START_STATIC);
      vars.insert(kCMAKE_OSX_ARCHITECTURES);
      vars.insert(kCMAKE_OSX_DEPLOYMENT_TARGET);
      vars.insert(kCMAKE_OSX_SYSROOT);
      vars.insert(kCMAKE_POSITION_INDEPENDENT_CODE);
      vars.insert(kCMAKE_SYSROOT);

      /* for the TRY_COMPILEs we want to be able to specify the architecture.
         So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
         CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
         have the tests run for each specific architecture. Since
         cmLocalGenerator doesn't allow building for ""the other""
         architecture only via CMAKE_OSX_ARCHITECTURES.
         */
      if (const char* tcArchs = this->Makefile->GetDefinition(
            kCMAKE_TRY_COMPILE_OSX_ARCHITECTURES)) {
        vars.erase(kCMAKE_OSX_ARCHITECTURES);
        std::string flag = ""-DCMAKE_OSX_ARCHITECTURES=""  std::string(tcArchs);
        cmakeFlags.push_back(flag);
      }

      for (std::set<std::string>::iterator vi = vars.begin(); vi != vars.end();
           ï«¸ï¿½) {
        std::string const& var = *vi;
        if (const char* val = this->Makefile->GetDefinition(var)) {
          std::string flag = ""-D""  var  ""=""  val;
          cmakeFlags.push_back(flag);
        }
      }
    }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
",383,405,447,-1,"fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_207.cpp,"{
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_207.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_207.cpp,"name****name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-25T13:36:19,Brad King,94
fb4791b37ccea1f38b8625b31df952408ab942f3,"cmCoreTryCompile: Refactor forwarding of variables to test project

De-duplicate the logic that constructs the cmake `-D` flag used to pass
variables into the test project cache.  Also subsume variables that were
propagated by generating `set()` commands in the project and pass them
as cache entries instead.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_207.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_207.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_377.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_377.cpp,"              fname.c_str());
    }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if (this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"") !=
        0) {
      std::string flag = ""-DCMAKE_OSX_ARCHITECTURES="";
      flag = this->Makefile->GetSafeDefinition(
        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
    } else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"") != 0) {
      std::string flag = ""-DCMAKE_OSX_ARCHITECTURES="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
    }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if (this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"") != 0) {
      std::string flag = ""-DCMAKE_OSX_SYSROOT="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
    }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if (this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"") != 0) {
      std::string flag = ""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
    }
    if (const char* cxxDef =
          this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET"")) {
      std::string flag = ""-DCMAKE_CXX_COMPILER_TARGET="";
      flag = cxxDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* cDef =
          this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET"")) {
      std::string flag = ""-DCMAKE_C_COMPILER_TARGET="";
      flag = cDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* tcxxDef = this->Makefile->GetDefinition(
          ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN"")) {
      std::string flag = ""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag = tcxxDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* tcDef = this->Makefile->GetDefinition(
          ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN"")) {
      std::string flag = ""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag = tcDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* rootDef = this->Makefile->GetDefinition(""CMAKE_SYSROOT"")) {
      std::string flag = ""-DCMAKE_SYSROOT="";
      flag = rootDef;
      cmakeFlags.push_back(flag);
    }
    if (this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"") !=
        0) {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
    }
    if (const char* lssDef =
          this->Makefile->GetDefinition(""CMAKE_LINK_SEARCH_START_STATIC"")) {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef);
    }
    if (const char* lssDef =
          this->Makefile->GetDefinition(""CMAKE_LINK_SEARCH_END_STATIC"")) {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef);
    }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
","              fname.c_str());
    }

    // Forward a set of variables to the inner project cache.
    {
      std::set<std::string> vars;
      vars.insert(kCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN);
      vars.insert(kCMAKE_C_COMPILER_TARGET);
      vars.insert(kCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN);
      vars.insert(kCMAKE_CXX_COMPILER_TARGET);
      vars.insert(kCMAKE_ENABLE_EXPORTS);
      vars.insert(kCMAKE_LINK_SEARCH_END_STATIC);
      vars.insert(kCMAKE_LINK_SEARCH_START_STATIC);
      vars.insert(kCMAKE_OSX_ARCHITECTURES);
      vars.insert(kCMAKE_OSX_DEPLOYMENT_TARGET);
      vars.insert(kCMAKE_OSX_SYSROOT);
      vars.insert(kCMAKE_POSITION_INDEPENDENT_CODE);
      vars.insert(kCMAKE_SYSROOT);

      /* for the TRY_COMPILEs we want to be able to specify the architecture.
         So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
         CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
         have the tests run for each specific architecture. Since
         cmLocalGenerator doesn't allow building for ""the other""
         architecture only via CMAKE_OSX_ARCHITECTURES.
         */
      if (const char* tcArchs = this->Makefile->GetDefinition(
            kCMAKE_TRY_COMPILE_OSX_ARCHITECTURES)) {
        vars.erase(kCMAKE_OSX_ARCHITECTURES);
        std::string flag = ""-DCMAKE_OSX_ARCHITECTURES=""  std::string(tcArchs);
        cmakeFlags.push_back(flag);
      }

      for (std::set<std::string>::iterator vi = vars.begin(); vi != vars.end();
           ï«¸ï¿½) {
        std::string const& var = *vi;
        if (const char* val = this->Makefile->GetDefinition(var)) {
          std::string flag = ""-D""  var  ""=""  val;
          cmakeFlags.push_back(flag);
        }
      }
    }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
",383,405,451,-1,"fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_208.cpp,"{
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_208.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_208.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-25T13:36:19,Brad King,108
fb4791b37ccea1f38b8625b31df952408ab942f3,"cmCoreTryCompile: Refactor forwarding of variables to test project

De-duplicate the logic that constructs the cmake `-D` flag used to pass
variables into the test project cache.  Also subsume variables that were
propagated by generating `set()` commands in the project and pass them
as cache entries instead.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_207.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_207.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_377.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_377.cpp,"              fname.c_str());
    }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if (this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"") !=
        0) {
      std::string flag = ""-DCMAKE_OSX_ARCHITECTURES="";
      flag = this->Makefile->GetSafeDefinition(
        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
    } else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"") != 0) {
      std::string flag = ""-DCMAKE_OSX_ARCHITECTURES="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
    }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if (this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"") != 0) {
      std::string flag = ""-DCMAKE_OSX_SYSROOT="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
    }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if (this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"") != 0) {
      std::string flag = ""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
    }
    if (const char* cxxDef =
          this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET"")) {
      std::string flag = ""-DCMAKE_CXX_COMPILER_TARGET="";
      flag = cxxDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* cDef =
          this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET"")) {
      std::string flag = ""-DCMAKE_C_COMPILER_TARGET="";
      flag = cDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* tcxxDef = this->Makefile->GetDefinition(
          ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN"")) {
      std::string flag = ""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag = tcxxDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* tcDef = this->Makefile->GetDefinition(
          ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN"")) {
      std::string flag = ""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag = tcDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* rootDef = this->Makefile->GetDefinition(""CMAKE_SYSROOT"")) {
      std::string flag = ""-DCMAKE_SYSROOT="";
      flag = rootDef;
      cmakeFlags.push_back(flag);
    }
    if (this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"") !=
        0) {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
    }
    if (const char* lssDef =
          this->Makefile->GetDefinition(""CMAKE_LINK_SEARCH_START_STATIC"")) {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef);
    }
    if (const char* lssDef =
          this->Makefile->GetDefinition(""CMAKE_LINK_SEARCH_END_STATIC"")) {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef);
    }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
","              fname.c_str());
    }

    // Forward a set of variables to the inner project cache.
    {
      std::set<std::string> vars;
      vars.insert(kCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN);
      vars.insert(kCMAKE_C_COMPILER_TARGET);
      vars.insert(kCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN);
      vars.insert(kCMAKE_CXX_COMPILER_TARGET);
      vars.insert(kCMAKE_ENABLE_EXPORTS);
      vars.insert(kCMAKE_LINK_SEARCH_END_STATIC);
      vars.insert(kCMAKE_LINK_SEARCH_START_STATIC);
      vars.insert(kCMAKE_OSX_ARCHITECTURES);
      vars.insert(kCMAKE_OSX_DEPLOYMENT_TARGET);
      vars.insert(kCMAKE_OSX_SYSROOT);
      vars.insert(kCMAKE_POSITION_INDEPENDENT_CODE);
      vars.insert(kCMAKE_SYSROOT);

      /* for the TRY_COMPILEs we want to be able to specify the architecture.
         So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
         CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
         have the tests run for each specific architecture. Since
         cmLocalGenerator doesn't allow building for ""the other""
         architecture only via CMAKE_OSX_ARCHITECTURES.
         */
      if (const char* tcArchs = this->Makefile->GetDefinition(
            kCMAKE_TRY_COMPILE_OSX_ARCHITECTURES)) {
        vars.erase(kCMAKE_OSX_ARCHITECTURES);
        std::string flag = ""-DCMAKE_OSX_ARCHITECTURES=""  std::string(tcArchs);
        cmakeFlags.push_back(flag);
      }

      for (std::set<std::string>::iterator vi = vars.begin(); vi != vars.end();
           ï«¸ï¿½) {
        std::string const& var = *vi;
        if (const char* val = this->Makefile->GetDefinition(var)) {
          std::string flag = ""-D""  var  ""=""  val;
          cmakeFlags.push_back(flag);
        }
      }
    }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
",383,405,455,-1,"fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_209.cpp,"{
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_209.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_209.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-25T13:36:19,Brad King,108
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_385.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_385.cpp,"}

/** Set the current line number.
 * @param line_number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmListFileLexer_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param line_number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmListFileLexer_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmListFileLexer_yy_switch_to_buffer
 */
void cmListFileLexer_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmListFileLexer_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmListFileLexer_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmListFileLexer_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmListFileLexer_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmListFileLexer_yy_switch_to_buffer
 */
void cmListFileLexer_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmListFileLexer_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmListFileLexer_yyget_debug  (yyscan_t yyscanner)
",2091,2156,2103,2168,"yy_fatal_error( ""cmListFileLexer_yyset_lineno called with no buffer"" , yyscanner);","YY_FATAL_ERROR( ""cmListFileLexer_yyset_lineno called with no buffer"" );",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_210.cpp,"yy_fatal_error( ""cmListFileLexer_yyset_lineno called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_210.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_210.cpp,"name****literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-17T14:56:37,Brad King,105
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_385.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_385.cpp,"}

/** Set the current line number.
 * @param line_number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmListFileLexer_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param line_number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmListFileLexer_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmListFileLexer_yy_switch_to_buffer
 */
void cmListFileLexer_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmListFileLexer_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmListFileLexer_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmListFileLexer_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmListFileLexer_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmListFileLexer_yy_switch_to_buffer
 */
void cmListFileLexer_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmListFileLexer_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmListFileLexer_yyget_debug  (yyscan_t yyscanner)
",2091,2156,2118,2183,"yy_fatal_error( ""cmListFileLexer_yyset_column called with no buffer"" , yyscanner);","YY_FATAL_ERROR( ""cmListFileLexer_yyset_column called with no buffer"" );",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_211.cpp,"yy_fatal_error( ""cmListFileLexer_yyset_column called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_211.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_211.cpp,"name****literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-17T14:56:37,Brad King,105
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_215.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_215.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_397.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_397.cpp,"{
struct unknown_tag *tag;

#if DEBUG
fprintf(stderr, ""unknowntag_start:%s\n"", name);
#endif
tag = malloc(sizeof(*tag));
if (tag == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
","{
struct unknown_tag *tag;

tag = malloc(sizeof(*tag));
if (tag == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
",1939,1939,1943,-1,"fprintf(stderr, ""unknowntag_start:%s\n"", name);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_212.cpp,"{
	struct unknown_tag *tag;

#if DEBUG
	fprintf(stderr, ""unknowntag_start:%s\n"", name);
#endif
	tag = malloc(sizeof(*tag));
	if (tag == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}
	tag->next = xar->unknowntags;
	archive_string_init(&(tag->name));
	archive_strcpy(&(tag->name), name);
	if (xar->unknowntags == NULL) {
		xar->xmlsts_unknown = xar->xmlsts;
		xar->xmlsts = UNKNOWN;
	}
	xar->unknowntags = tag;
	return (ARCHIVE_OK);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_212.cpp,"[3, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 53, 0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 0, 25, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 0, 0, 6, 0, 0, 9, 0, 11, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_212.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-02T14:48:48,Brad King,108
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_215.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_215.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_398.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_398.cpp,"{
struct unknown_tag *tag;

#if DEBUG
fprintf(stderr, ""unknowntag_end:%s\n"", name);
#endif
tag = xar->unknowntags;
if (tag == NULL || name == NULL)
return;
if (strcmp(tag->name.s, name) == 0) {
xar->unknowntags = tag->next;
archive_string_free(&(tag->name));
free(tag);
if (xar->unknowntags == NULL)
xar->xmlsts = xar->xmlsts_unknown;
}
}

","{
struct unknown_tag *tag;

tag = xar->unknowntags;
if (tag == NULL || name == NULL)
return;
if (strcmp(tag->name.s, name) == 0) {
xar->unknowntags = tag->next;
archive_string_free(&(tag->name));
free(tag);
if (xar->unknowntags == NULL) {
#if DEBUG
fprintf(stderr, ""UNKNOWNTAG_END:%s\n"", name);
#endif
xar->xmlsts = xar->xmlsts_unknown;
}
}
}

",1963,1963,1967,1975,"fprintf(stderr, ""unknowntag_end:%s\n"", name);","fprintf(stderr, ""UNKNOWNTAG_END:%s\n"", name);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_213.cpp,"{
	struct unknown_tag *tag;

#if DEBUG
	fprintf(stderr, ""unknowntag_end:%s\n"", name);
#endif
	tag = xar->unknowntags;
	if (tag == NULL || name == NULL)
		return;
	if (strcmp(tag->name.s, name) == 0) {
		xar->unknowntags = tag->next;
		archive_string_free(&(tag->name));
		free(tag);
		if (xar->unknowntags == NULL)
			xar->xmlsts = xar->xmlsts_unknown;
	}
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_213.cpp,"[4, 0, 0, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 44, 0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 3, 0, 0, 4, 0, 0, 6, 0, 7, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_213.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-02T14:48:48,Brad King,49
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_216.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_216.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_400.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_400.cpp,"}
}

/* Read the extra data. */
if ((h = __archive_read_ahead(a, extra_length, NULL)) == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file header"");
return (ARCHIVE_FATAL);
}

process_extra(h, extra_length, zip_entry);
__archive_read_consume(a, extra_length);

if (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {
/* If this came from the central dir, it's size info
 * is definitive, so ignore the length-at-end flag. */
","}
}

/* Make sure directories end in '/' */
if ((zip_entry->mode & AE_IFMT) == AE_IFDIR) {
wp = archive_entry_pathname_w(entry);
if (wp != NULL) {
len = wcslen(wp);
if (len > 0 && wp[len - 1] != L'/') {
struct archive_wstring s;
archive_string_init(&s);
archive_wstrcat(&s, wp);
archive_wstrappend_wchar(&s, L'/');
archive_entry_copy_pathname_w(entry, s.s);
}
} else {
cp = archive_entry_pathname(entry);
len = (cp != NULL)?strlen(cp):0;
if (len > 0 && cp[len - 1] != '/') {
struct archive_string s;
archive_string_init(&s);
archive_strcat(&s, cp);
archive_strappend_char(&s, '/');
archive_entry_set_pathname(entry, s.s);
}
}
}

if (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {
/* If this came from the central dir, it's size info
 * is definitive, so ignore the length-at-end flag. */
",843,868,848,879,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");","archive_wstrcat(&s, wp);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_214.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_214.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_214.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-02T14:48:48,Brad King,50
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_403.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_403.cpp,"    &data->child_stdout);
if (child == -1) {
archive_set_error(f->archive, EINVAL,
    ""Can't initialise filter"");
return (ARCHIVE_FATAL);
}
#if defined(_WIN32) && !defined(__CYGWIN__)
","    &data->child_stdout);
if (child == -1) {
archive_set_error(f->archive, EINVAL,
    ""Can't launch external program: %s"", cmd);
return (ARCHIVE_FATAL);
}
#if defined(_WIN32) && !defined(__CYGWIN__)
",231,233,233,235,"archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");","archive_set_error(f->archive, EINVAL,
		    ""Can't launch external program: %s"", cmd);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_215.cpp,"{
		archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_215.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_215.cpp,"name****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-02T14:48:48,Brad King,102
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_404.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_404.cpp,"close(data->child_stdout);
data->child_stdout = -1;
archive_set_error(f->archive, EINVAL,
    ""Can't initialise filter"");
return (ARCHIVE_FATAL);
}
#else
","close(data->child_stdout);
data->child_stdout = -1;
archive_set_error(f->archive, EINVAL,
    ""Can't launch external program: %s"", cmd);
return (ARCHIVE_FATAL);
}
#else
",242,244,244,246,"archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");","archive_set_error(f->archive, EINVAL,
		    ""Can't launch external program: %s"", cmd);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_216.cpp,"{
		close(data->child_stdin);
		data->child_stdin = -1;
		close(data->child_stdout);
		data->child_stdout = -1;
		archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_216.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_216.cpp,"name****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-02T14:48:48,Brad King,102
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_405.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_405.cpp,"ret = child_write(f, data, buf, length);
if (ret == -1 || ret == 0) {
archive_set_error(f->archive, EIO,
    ""Can't write to filter"");
return (ARCHIVE_FATAL);
}
length -= ret;
","ret = child_write(f, data, buf, length);
if (ret == -1 || ret == 0) {
archive_set_error(f->archive, EIO,
    ""Can't write to program: %s"", data->program_name);
return (ARCHIVE_FATAL);
}
length -= ret;
",334,336,336,338,"archive_set_error(f->archive, EIO,
			    ""Can't write to filter"");","archive_set_error(f->archive, EIO,
			    ""Can't write to program: %s"", data->program_name);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_217.cpp,"{
			archive_set_error(f->archive, EIO,
			    ""Can't write to filter"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_217.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_217.cpp,"name****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-02T14:48:48,Brad King,95
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_406.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_406.cpp,"
if (bytes_read == -1) {
archive_set_error(f->archive, errno,
    ""Read from filter failed unexpectedly."");
ret = ARCHIVE_FATAL;
goto cleanup;
}
","
if (bytes_read == -1) {
archive_set_error(f->archive, errno,
    ""Error reading from program: %s"", data->program_name);
ret = ARCHIVE_FATAL;
goto cleanup;
}
",373,375,375,377,"archive_set_error(f->archive, errno,
			    ""Read from filter failed unexpectedly."");","archive_set_error(f->archive, errno,
			    ""Error reading from program: %s"", data->program_name);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_218.cpp,"{
			archive_set_error(f->archive, errno,
			    ""Read from filter failed unexpectedly."");
			ret = ARCHIVE_FATAL;
			goto cleanup;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_218.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_218.cpp,"name****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-02T14:48:48,Brad King,95
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_224.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_224.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_414.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_414.cpp,"{
struct unknown_tag *tag;

#if DEBUG
fprintf(stderr, ""unknowntag_start:%s\n"", name);
#endif
tag = malloc(sizeof(*tag));
if (tag == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
","{
struct unknown_tag *tag;

tag = malloc(sizeof(*tag));
if (tag == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
",1939,1939,1943,-1,"fprintf(stderr, ""unknowntag_start:%s\n"", name);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_219.cpp,"{
	struct unknown_tag *tag;

#if DEBUG
	fprintf(stderr, ""unknowntag_start:%s\n"", name);
#endif
	tag = malloc(sizeof(*tag));
	if (tag == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}
	tag->next = xar->unknowntags;
	archive_string_init(&(tag->name));
	archive_strcpy(&(tag->name), name);
	if (xar->unknowntags == NULL) {
		xar->xmlsts_unknown = xar->xmlsts;
		xar->xmlsts = UNKNOWN;
	}
	xar->unknowntags = tag;
	return (ARCHIVE_OK);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_219.cpp,"[3, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 53, 0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 0, 25, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 0, 0, 6, 0, 0, 9, 0, 11, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_219.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-02T14:25:52,Brad King,108
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_224.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_224.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_415.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_415.cpp,"{
struct unknown_tag *tag;

#if DEBUG
fprintf(stderr, ""unknowntag_end:%s\n"", name);
#endif
tag = xar->unknowntags;
if (tag == NULL || name == NULL)
return;
if (strcmp(tag->name.s, name) == 0) {
xar->unknowntags = tag->next;
archive_string_free(&(tag->name));
free(tag);
if (xar->unknowntags == NULL)
xar->xmlsts = xar->xmlsts_unknown;
}
}

","{
struct unknown_tag *tag;

tag = xar->unknowntags;
if (tag == NULL || name == NULL)
return;
if (strcmp(tag->name.s, name) == 0) {
xar->unknowntags = tag->next;
archive_string_free(&(tag->name));
free(tag);
if (xar->unknowntags == NULL) {
#if DEBUG
fprintf(stderr, ""UNKNOWNTAG_END:%s\n"", name);
#endif
xar->xmlsts = xar->xmlsts_unknown;
}
}
}

",1963,1963,1967,1975,"fprintf(stderr, ""unknowntag_end:%s\n"", name);","fprintf(stderr, ""UNKNOWNTAG_END:%s\n"", name);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_220.cpp,"{
	struct unknown_tag *tag;

#if DEBUG
	fprintf(stderr, ""unknowntag_end:%s\n"", name);
#endif
	tag = xar->unknowntags;
	if (tag == NULL || name == NULL)
		return;
	if (strcmp(tag->name.s, name) == 0) {
		xar->unknowntags = tag->next;
		archive_string_free(&(tag->name));
		free(tag);
		if (xar->unknowntags == NULL)
			xar->xmlsts = xar->xmlsts_unknown;
	}
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_220.cpp,"[4, 0, 0, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 44, 0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 3, 0, 0, 4, 0, 0, 6, 0, 7, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_220.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-02T14:25:52,Brad King,49
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_225.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_225.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_417.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_417.cpp,"}
}

/* Read the extra data. */
if ((h = __archive_read_ahead(a, extra_length, NULL)) == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file header"");
return (ARCHIVE_FATAL);
}

process_extra(h, extra_length, zip_entry);
__archive_read_consume(a, extra_length);

if (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {
/* If this came from the central dir, it's size info
 * is definitive, so ignore the length-at-end flag. */
","}
}

/* Make sure directories end in '/' */
if ((zip_entry->mode & AE_IFMT) == AE_IFDIR) {
wp = archive_entry_pathname_w(entry);
if (wp != NULL) {
len = wcslen(wp);
if (len > 0 && wp[len - 1] != L'/') {
struct archive_wstring s;
archive_string_init(&s);
archive_wstrcat(&s, wp);
archive_wstrappend_wchar(&s, L'/');
archive_entry_copy_pathname_w(entry, s.s);
}
} else {
cp = archive_entry_pathname(entry);
len = (cp != NULL)?strlen(cp):0;
if (len > 0 && cp[len - 1] != '/') {
struct archive_string s;
archive_string_init(&s);
archive_strcat(&s, cp);
archive_strappend_char(&s, '/');
archive_entry_set_pathname(entry, s.s);
}
}
}

if (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {
/* If this came from the central dir, it's size info
 * is definitive, so ignore the length-at-end flag. */
",843,868,848,879,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");","archive_wstrcat(&s, wp);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_221.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_221.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_221.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-02T14:25:52,Brad King,50
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_420.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_420.cpp,"    &data->child_stdout);
if (child == -1) {
archive_set_error(f->archive, EINVAL,
    ""Can't initialise filter"");
return (ARCHIVE_FATAL);
}
#if defined(_WIN32) && !defined(__CYGWIN__)
","    &data->child_stdout);
if (child == -1) {
archive_set_error(f->archive, EINVAL,
    ""Can't launch external program: %s"", cmd);
return (ARCHIVE_FATAL);
}
#if defined(_WIN32) && !defined(__CYGWIN__)
",231,233,233,235,"archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");","archive_set_error(f->archive, EINVAL,
		    ""Can't launch external program: %s"", cmd);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_222.cpp,"{
		archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_222.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_222.cpp,"name****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-02T14:25:52,Brad King,102
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_421.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_421.cpp,"close(data->child_stdout);
data->child_stdout = -1;
archive_set_error(f->archive, EINVAL,
    ""Can't initialise filter"");
return (ARCHIVE_FATAL);
}
#else
","close(data->child_stdout);
data->child_stdout = -1;
archive_set_error(f->archive, EINVAL,
    ""Can't launch external program: %s"", cmd);
return (ARCHIVE_FATAL);
}
#else
",242,244,244,246,"archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");","archive_set_error(f->archive, EINVAL,
		    ""Can't launch external program: %s"", cmd);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_223.cpp,"{
		close(data->child_stdin);
		data->child_stdin = -1;
		close(data->child_stdout);
		data->child_stdout = -1;
		archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_223.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_223.cpp,"name****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-02T14:25:52,Brad King,102
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_422.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_422.cpp,"ret = child_write(f, data, buf, length);
if (ret == -1 || ret == 0) {
archive_set_error(f->archive, EIO,
    ""Can't write to filter"");
return (ARCHIVE_FATAL);
}
length -= ret;
","ret = child_write(f, data, buf, length);
if (ret == -1 || ret == 0) {
archive_set_error(f->archive, EIO,
    ""Can't write to program: %s"", data->program_name);
return (ARCHIVE_FATAL);
}
length -= ret;
",334,336,336,338,"archive_set_error(f->archive, EIO,
			    ""Can't write to filter"");","archive_set_error(f->archive, EIO,
			    ""Can't write to program: %s"", data->program_name);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_224.cpp,"{
			archive_set_error(f->archive, EIO,
			    ""Can't write to filter"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_224.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_224.cpp,"name****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-02T14:25:52,Brad King,95
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_423.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_423.cpp,"
if (bytes_read == -1) {
archive_set_error(f->archive, errno,
    ""Read from filter failed unexpectedly."");
ret = ARCHIVE_FATAL;
goto cleanup;
}
","
if (bytes_read == -1) {
archive_set_error(f->archive, errno,
    ""Error reading from program: %s"", data->program_name);
ret = ARCHIVE_FATAL;
goto cleanup;
}
",373,375,375,377,"archive_set_error(f->archive, errno,
			    ""Read from filter failed unexpectedly."");","archive_set_error(f->archive, errno,
			    ""Error reading from program: %s"", data->program_name);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_225.cpp,"{
			archive_set_error(f->archive, errno,
			    ""Read from filter failed unexpectedly."");
			ret = ARCHIVE_FATAL;
			goto cleanup;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_225.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_225.cpp,"name****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-05-02T14:25:52,Brad King,95
7f1bd9fe6910f7633d98dec018cc01331a46b87e,"try_compile: Add option to control type of target

Create a `CMAKE_TRY_COMPILE_TARGET_TYPE` option to specify use
of `add_library(... STATIC ...)` for the generated test project.
This will be useful for cross-compiling toolchains that cannot
link a binary without custom flags or scripts.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_229.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_229.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_425.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_425.cpp,"      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName.c_str());
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ï«ï¿½)
      {
","      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }

    if (targetType == cmState::EXECUTABLE)
      {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
      }
    else // if (targetType == cmState::STATIC_LIBRARY)
      {
      /* Put the static library at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual static library.  */
      fprintf(fout, ""add_library(%s STATIC"", targetName.c_str());
      }
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ï«ï¿½)
      {
",486,515,490,-1,"f(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_226.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile);

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmGlobalGenerator* gg = this->Makefile->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      std::string lang = gg->GetLanguageFromExtension(ext.c_str());
      if(!lang.empty())
        {
        testLangs.insert(lang);
        }
      else
        {
        std::ostringstream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n  "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        err << cmJoin(langs, "" "");
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = cmsys::SystemTools::Fopen(outFileName,""w"");
    if (!fout)
      {
      std::ostringstream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""set(CMAKE_MODULE_PATH \""%s\"")\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""project(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""set(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmOutputConverter::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    switch(this->Makefile->GetPolicyStatus(cmPolicies::CMP0056))
      {
      case cmPolicies::WARN:
        if(this->Makefile->PolicyOptionalWarningEnabled(
             ""CMAKE_POLICY_WARNING_CMP0056""))
          {
          std::ostringstream w;
          w << cmPolicies::GetPolicyWarning(cmPolicies::CMP0056) << ""\n""
            ""For compatibility with older versions of CMake, try_compile ""
            ""is not honoring caller link flags (e.g. CMAKE_EXE_LINKER_FLAGS) ""
            ""in the test project.""
            ;
          this->Makefile->IssueMessage(cmake::AUTHOR_WARNING, w.str());
          }
      case cmPolicies::OLD:
        // OLD behavior is to do nothing.
        break;
      case cmPolicies::REQUIRED_IF_USED:
      case cmPolicies::REQUIRED_ALWAYS:
        this->Makefile->IssueMessage(
          cmake::FATAL_ERROR,
          cmPolicies::GetRequiredPolicyError(cmPolicies::CMP0056)
          );
      case cmPolicies::NEW:
        // NEW behavior is to pass linker flags.
        {
        const char* exeLinkFlags =
          this->Makefile->GetDefinition(""CMAKE_EXE_LINKER_FLAGS"");
        fprintf(fout, ""set(CMAKE_EXE_LINKER_FLAGS %s)\n"",
                cmOutputConverter::EscapeForCMake(
                    exeLinkFlags ? exeLinkFlags : """").c_str());
        } break;
      }
    fprintf(fout, ""set(CMAKE_EXE_LINKER_FLAGS \""${CMAKE_EXE_LINKER_FLAGS}""
            "" ${EXE_LINKER_FLAGS}\"")\n"");
    fprintf(fout, ""include_directories(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (!compileDefs.empty())
      {
      fprintf(fout, ""add_definitions(%s)\n"", cmJoin(compileDefs, "" "").c_str());
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTC_%05x"",
            cmSystemTools::RandomSeed() & 0xFFFFF);
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg(gg, targets, this->Makefile);
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetConfig(this->Makefile->GetSafeDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if (const char *cxxDef
              = this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_TARGET="";
      flag += cxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *cDef
                = this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_TARGET="";
      flag += cDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcxxDef = this->Makefile->GetDefinition(
                                  ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcDef = this->Makefile->GetDefinition(
                                    ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *rootDef
              = this->Makefile->GetDefinition(""CMAKE_SYSROOT""))
      {
      std::string flag=""-DCMAKE_SYSROOT="";
      flag += rootDef;
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }
    if (const char *lssDef = this->Makefile->GetDefinition(
        ""CMAKE_LINK_SEARCH_START_STATIC""))
      {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef);
      }
    if (const char *lssDef = this->Makefile->GetDefinition(
        ""CMAKE_LINK_SEARCH_END_STATIC""))
      {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef);
      }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
    fprintf(fout, ""cmake_policy(SET CMP0065 %s)\n"",
       this->Makefile->GetPolicyStatus(cmPolicies::CMP0065) ==
         cmPolicies::NEW ? ""NEW"" : ""OLD"");
    if(const char *ee = this->Makefile->GetDefinition(
        ""CMAKE_ENABLE_EXPORTS""))
      {
      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName.c_str());
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_226.cpp,"[25, 0, 4, 0, 2, 0, 3, 1, 5, 0, 34, 0, 0, 0, 13, 679, 0, 0, 27, 44, 1, 0, 39, 101, 0, 0, 0, 0, 15, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 260, 3, 301, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 45, 0, 1, 0, 33, 28, 5, 0, 134, 3, 0, 68, 2, 156, 0, 4, 0, 0, 4, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_226.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-02-19T19:07:38,Brad King,0
7f1bd9fe6910f7633d98dec018cc01331a46b87e,"try_compile: Add option to control type of target

Create a `CMAKE_TRY_COMPILE_TARGET_TYPE` option to specify use
of `add_library(... STATIC ...)` for the generated test project.
This will be useful for cross-compiling toolchains that cannot
link a binary without custom flags or scripts.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_229.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_229.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_425.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_425.cpp,"      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName.c_str());
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ï«ï¿½)
      {
","      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }

    if (targetType == cmState::EXECUTABLE)
      {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
      }
    else // if (targetType == cmState::STATIC_LIBRARY)
      {
      /* Put the static library at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual static library.  */
      fprintf(fout, ""add_library(%s STATIC"", targetName.c_str());
      }
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ï«ï¿½)
      {
",486,515,493,518,"fprintf(fout, ""add_executable(%s"", targetName.c_str());","(targetType == cmState::EXECUTABLE)
      {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
      };",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_227.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile);

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmGlobalGenerator* gg = this->Makefile->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      std::string lang = gg->GetLanguageFromExtension(ext.c_str());
      if(!lang.empty())
        {
        testLangs.insert(lang);
        }
      else
        {
        std::ostringstream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n  "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        err << cmJoin(langs, "" "");
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = cmsys::SystemTools::Fopen(outFileName,""w"");
    if (!fout)
      {
      std::ostringstream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""set(CMAKE_MODULE_PATH \""%s\"")\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""project(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""set(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmOutputConverter::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    switch(this->Makefile->GetPolicyStatus(cmPolicies::CMP0056))
      {
      case cmPolicies::WARN:
        if(this->Makefile->PolicyOptionalWarningEnabled(
             ""CMAKE_POLICY_WARNING_CMP0056""))
          {
          std::ostringstream w;
          w << cmPolicies::GetPolicyWarning(cmPolicies::CMP0056) << ""\n""
            ""For compatibility with older versions of CMake, try_compile ""
            ""is not honoring caller link flags (e.g. CMAKE_EXE_LINKER_FLAGS) ""
            ""in the test project.""
            ;
          this->Makefile->IssueMessage(cmake::AUTHOR_WARNING, w.str());
          }
      case cmPolicies::OLD:
        // OLD behavior is to do nothing.
        break;
      case cmPolicies::REQUIRED_IF_USED:
      case cmPolicies::REQUIRED_ALWAYS:
        this->Makefile->IssueMessage(
          cmake::FATAL_ERROR,
          cmPolicies::GetRequiredPolicyError(cmPolicies::CMP0056)
          );
      case cmPolicies::NEW:
        // NEW behavior is to pass linker flags.
        {
        const char* exeLinkFlags =
          this->Makefile->GetDefinition(""CMAKE_EXE_LINKER_FLAGS"");
        fprintf(fout, ""set(CMAKE_EXE_LINKER_FLAGS %s)\n"",
                cmOutputConverter::EscapeForCMake(
                    exeLinkFlags ? exeLinkFlags : """").c_str());
        } break;
      }
    fprintf(fout, ""set(CMAKE_EXE_LINKER_FLAGS \""${CMAKE_EXE_LINKER_FLAGS}""
            "" ${EXE_LINKER_FLAGS}\"")\n"");
    fprintf(fout, ""include_directories(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (!compileDefs.empty())
      {
      fprintf(fout, ""add_definitions(%s)\n"", cmJoin(compileDefs, "" "").c_str());
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTC_%05x"",
            cmSystemTools::RandomSeed() & 0xFFFFF);
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg(gg, targets, this->Makefile);
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetConfig(this->Makefile->GetSafeDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if (const char *cxxDef
              = this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_TARGET="";
      flag += cxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *cDef
                = this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_TARGET="";
      flag += cDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcxxDef = this->Makefile->GetDefinition(
                                  ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcDef = this->Makefile->GetDefinition(
                                    ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *rootDef
              = this->Makefile->GetDefinition(""CMAKE_SYSROOT""))
      {
      std::string flag=""-DCMAKE_SYSROOT="";
      flag += rootDef;
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }
    if (const char *lssDef = this->Makefile->GetDefinition(
        ""CMAKE_LINK_SEARCH_START_STATIC""))
      {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef);
      }
    if (const char *lssDef = this->Makefile->GetDefinition(
        ""CMAKE_LINK_SEARCH_END_STATIC""))
      {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef);
      }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
    fprintf(fout, ""cmake_policy(SET CMP0065 %s)\n"",
       this->Makefile->GetPolicyStatus(cmPolicies::CMP0065) ==
         cmPolicies::NEW ? ""NEW"" : ""OLD"");
    if(const char *ee = this->Makefile->GetDefinition(
        ""CMAKE_ENABLE_EXPORTS""))
      {
      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName.c_str());
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_227.cpp,"[25, 0, 4, 0, 2, 0, 3, 1, 5, 0, 34, 0, 0, 0, 13, 679, 0, 0, 27, 44, 1, 0, 39, 101, 0, 0, 0, 0, 15, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 260, 3, 301, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 45, 0, 1, 0, 33, 28, 5, 0, 134, 3, 0, 68, 2, 156, 0, 4, 0, 0, 4, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_227.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2016-02-19T19:07:38,Brad King,1
1c1ace2db012919f23b6de5400ab192b9277dfc6,"De-duplicate symbols listed in generated module definition files

MS tools have a limit on the number of symbols that can be listed
in a `.def` file.  If multiple `.obj` files provide a symbol then
avoid listing it more than once in the generated `.def` file to
avoid counting toward the limit.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_426.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_426.cpp,"                symbol.erase(0,1);
                }
              }
            if (this->ImportFlag) {
               this->ImportFlag = false;
               fprintf(this->FileOut,""EXPORTS \n"");
            }
            /*
            Check whether it is ""Scalar deleting destructor"" and
            ""Vector deleting destructor""
","                symbol.erase(0,1);
                }
              }
            /*
            Check whether it is ""Scalar deleting destructor"" and
            ""Vector deleting destructor""
",296,298,301,-1,"fprintf(this->FileOut,""EXPORTS \n"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_228.cpp,"{
               this->ImportFlag = false;
               fprintf(this->FileOut,""EXPORTS \n"");
            }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_228.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_228.cpp,"name****name****operator****name****name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-11-18T15:02:48,Brad King,51
1c1ace2db012919f23b6de5400ab192b9277dfc6,"De-duplicate symbols listed in generated module definition files

MS tools have a limit on the number of symbols that can be listed
in a `.def` file.  If multiple `.obj` files provide a symbol then
avoid listing it more than once in the generated `.def` file to
avoid counting toward the limit.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_427.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_427.cpp,"                 SectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str());
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     fprintf(this->FileOut, ""\t%s\n"", symbol.c_str());
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
","                 SectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  this->DataSymbols.insert(symbol);
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     this->Symbols.insert(symbol);
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
",319,317,322,320,"fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str());",this->DataSymbols.insert(symbol);,3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_229.cpp,"{
                  // Read only (i.e. constants) must be excluded
                  fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str());
               }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_229.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_229.cpp,"name****name****operator****name****name****expr****argument
literal****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-11-18T15:02:48,Brad King,52
1c1ace2db012919f23b6de5400ab192b9277dfc6,"De-duplicate symbols listed in generated module definition files

MS tools have a limit on the number of symbols that can be listed
in a `.def` file.  If multiple `.obj` files provide a symbol then
avoid listing it more than once in the generated `.def` file to
avoid counting toward the limit.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_427.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_427.cpp,"                 SectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str());
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     fprintf(this->FileOut, ""\t%s\n"", symbol.c_str());
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
","                 SectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  this->DataSymbols.insert(symbol);
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     this->Symbols.insert(symbol);
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
",319,317,326,324,"fprintf(this->FileOut, ""\t%s\n"", symbol.c_str());",this->Symbols.insert(symbol);,3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_230.cpp,"{
                     fprintf(this->FileOut, ""\t%s\n"", symbol.c_str());
                  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_230.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_230.cpp,"name****name****operator****name****name****expr****argument
literal****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-11-18T15:02:48,Brad King,52
1c1ace2db012919f23b6de5400ab192b9277dfc6,"De-duplicate symbols listed in generated module definition files

MS tools have a limit on the number of symbols that can be listed
in a `.def` file.  If multiple `.obj` files provide a symbol then
avoid listing it more than once in the generated `.def` file to
avoid counting toward the limit.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_428.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_428.cpp,"            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!this->ImportFlag) {
               this->ImportFlag = true;
               fprintf(this->FileOut,""IMPORTS \n"");
            }
            fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()ï¿½);
         }
      }

","            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            this->DataSymbols.insert(symbol);
         }
      }

",340,338,345,-1,"fprintf(this->FileOut,""IMPORTS \n"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_231.cpp,"{
               this->ImportFlag = true;
               fprintf(this->FileOut,""IMPORTS \n"");
            }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_231.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_231.cpp,"name****name****operator****name****name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-11-18T15:02:48,Brad King,51
1c1ace2db012919f23b6de5400ab192b9277dfc6,"De-duplicate symbols listed in generated module definition files

MS tools have a limit on the number of symbols that can be listed
in a `.def` file.  If multiple `.obj` files provide a symbol then
avoid listing it more than once in the generated `.def` file to
avoid counting toward the limit.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_428.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_428.cpp,"            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!this->ImportFlag) {
               this->ImportFlag = true;
               fprintf(this->FileOut,""IMPORTS \n"");
            }
            fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()ï¿½);
         }
      }

","            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            this->DataSymbols.insert(symbol);
         }
      }

",340,338,347,341,"fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()+1);",this->DataSymbols.insert(symbol);,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_232.cpp,"{
            symbol = stringTable + pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!this->ImportFlag) {
               this->ImportFlag = true;
               fprintf(this->FileOut,""IMPORTS \n"");
            }
            fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()+1);
         }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_232.cpp,"[2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 35, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 2, 0, 0, 6, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_232.cpp,"name****name****operator****name****name****expr****argument
literal****expr****argument
name****operator****name****name****argument_list****call****operator****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-11-18T15:02:48,Brad King,2
ba819f49df33b546072a5928de3253770c4716b9,"cmFortranParser: Parse #line directives

Teach the lexer to extract the #line directive prefix and line number as
a new token type.  Teach the parser to recognize this token followed by
a string as the file name (plus possibly other content).  Report the
named file as included by the source file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_429.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_429.cpp,"
        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmFortran_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmFortran_yyset_column (int  column_no , yyscan_t yyscanner)
","
        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmFortran_yyset_lineno called with no buffer"" );

    yylineno = line_number;
}

/** Set the current column.
 * @param line_number
 * @param yyscanner The scanner object.
 */
void cmFortran_yyset_column (int  column_no , yyscan_t yyscanner)
",2174,2192,2177,2195,"yy_fatal_error( ""cmFortran_yyset_lineno called with no buffer"" , yyscanner);","YY_FATAL_ERROR( ""cmFortran_yyset_lineno called with no buffer"" );",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_233.cpp,"yy_fatal_error( ""cmFortran_yyset_lineno called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_233.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_233.cpp,"name****literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-11-02T20:29:52,Brad King,105
ba819f49df33b546072a5928de3253770c4716b9,"cmFortranParser: Parse #line directives

Teach the lexer to extract the #line directive prefix and line number as
a new token type.  Teach the parser to recognize this token followed by
a string as the file name (plus possibly other content).  Report the
named file as included by the source file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_430.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_430.cpp,"
        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmFortran_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}
","
        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmFortran_yyset_column called with no buffer"" );

    yycolumn = column_no;
}
",2189,2207,2192,2210,"yy_fatal_error( ""cmFortran_yyset_column called with no buffer"" , yyscanner);","YY_FATAL_ERROR( ""cmFortran_yyset_column called with no buffer"" );",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_234.cpp,"yy_fatal_error( ""cmFortran_yyset_column called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_234.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_234.cpp,"name****literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-11-02T20:29:52,Brad King,105
7f8bb857b8ab714b80acfa6a6e2c34195fabff6f,VS6: Port to cmGeneratorTarget.,[],Source/cmLocalVisualStudio6Generator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_232.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_232.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_431.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_431.cpp,"
void
cmLocalVisualStudio6Generator
::AddUtilityCommandHack(cmTarget& target, int count,
                        std::vector<std::string>& depends,
                        const cmCustomCommand& origCommand)
{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->GetCurrentBinaryDirectory())
                            target.GetName().size()  30)];
  sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);
  const char* comment = origCommand.GetComment();
  if(!comment && origCommand.GetOutputs().empty())
    {
","
void
cmLocalVisualStudio6Generator
::AddUtilityCommandHack(cmGeneratorTarget *target, int count,
                        std::vector<std::string>& depends,
                        const cmCustomCommand& origCommand)
{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->GetCurrentBinaryDirectory())
                            target->GetName().size()  30)];
  sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target->GetName().c_str(), count);
  const char* comment = origCommand.GetComment();
  if(!comment && origCommand.GetOutputs().empty())
    {
",575,570,585,580,"sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);","sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target->GetName().c_str(), count);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_235.cpp,"{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->GetCurrentBinaryDirectory())
                           + target.GetName().size() + 30)];
  sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);
  const char* comment = origCommand.GetComment();
  if(!comment && origCommand.GetOutputs().empty())
    {
    comment = ""<hack>"";
    }

  // Add the rule with the given dependencies and commands.
  std::string no_main_dependency = """";
  if(cmSourceFile* outsf =
     this->Makefile->AddCustomCommandToOutput(
       output, depends, no_main_dependency,
       origCommand.GetCommandLines(), comment,
       origCommand.GetWorkingDirectory().c_str()))
    {
    cmGeneratorTarget* gt = this->GlobalGenerator->GetGeneratorTarget(&target);
    gt->AddSource(outsf->GetFullPath());
    }

  // Replace the dependencies with the output of this rule so that the
  // next rule added will run after this one.
  depends.clear();
  depends.push_back(output);

  // Free the fake output name.
  delete [] output;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_235.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1, 75, 0, 0, 4, 5, 0, 0, 5, 4, 0, 0, 0, 0, 4, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 2, 0, 2, 2, 0, 0, 20, 0, 0, 6, 0, 15, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_235.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****argument_list****call****operator****name****argument_list****call****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-24T07:19:55,Stephen Kelly,3
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_233.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_233.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_432.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_432.cpp,"}

if (a->read_data_offset < a->read_data_output_offset) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Encountered out-of-order sparse blocks"");
return (ARCHIVE_RETRY);
}
","}

if (a->read_data_offset < a->read_data_output_offset) {
archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Encountered out-of-order sparse blocks"");
return (ARCHIVE_RETRY);
}
",843,850,846,853,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Encountered out-of-order sparse blocks"");","archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Encountered out-of-order sparse blocks"");",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_236.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Encountered out-of-order sparse blocks"");
			return (ARCHIVE_RETRY);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_236.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_236.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T14:18:52,Brad King,53
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_233.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_233.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_433.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_433.cpp,"if (a->format->read_data == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
    ""Internal error: ""
    ""No format_read_data_block function registered"");
return (ARCHIVE_FATAL);
}

","if (a->format->read_data == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
    ""Internal error: ""
    ""No format->read_data function registered"");
return (ARCHIVE_FATAL);
}

",953,975,954,976,"archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
		    ""Internal error: ""
		    ""No format_read_data_block function registered"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
		    ""Internal error: ""
		    ""No format->read_data function registered"");",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_237.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
		    ""Internal error: ""
		    ""No format_read_data_block function registered"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_237.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_237.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T14:18:52,Brad King,54
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_436.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_436.cpp," */
if (ar->strtab == NULL || number > ar->strtab_size) {
archive_set_error(&a->archive, EINVAL,
    ""Can't find long filename for entry"");
archive_entry_copy_pathname(entry, filename);
/* Parse the time, owner, mode, size fields. */
ar_parse_common_header(ar, entry, h);
return (ARCHIVE_WARN);
}

archive_entry_copy_pathname(entry, &ar->strtab[(size_t)number]);
"," */
if (ar->strtab == NULL || number > ar->strtab_size) {
archive_set_error(&a->archive, EINVAL,
    ""Can't find long filename for GNU/SVR4 archive entry"");
archive_entry_copy_pathname(entry, filename);
/* Parse the time, owner, mode, size fields. */
ar_parse_common_header(ar, entry, h);
return (ARCHIVE_FATAL);
}

archive_entry_copy_pathname(entry, &ar->strtab[(size_t)number]);
",311,318,313,320,"archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for entry"");","archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for GNU/SVR4 archive entry"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_238.cpp,"{
			archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for entry"");
			archive_entry_copy_pathname(entry, filename);
			/* Parse the time, owner, mode, size fields. */
			ar_parse_common_header(ar, entry, h);
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_238.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_238.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T14:18:52,Brad King,111
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_236.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_236.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_438.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_438.cpp,"lha->entry_unconsumed = 0;
}
if (lha->end_of_entry) {
if (!lha->end_of_entry_cleanup) {
if ((lha->setflag & CRC_IS_SET) &&
    lha->crc != lha->entry_crc_calculated) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""LHa data CRC error"");
return (ARCHIVE_WARN);
}

/* End-of-entry cleanup done. */
lha->end_of_entry_cleanup = 1;
}
*offset = lha->entry_offset;
*size = 0;
*buff = NULL;
return (ARCHIVE_EOF);
}

if (lha->entry_is_compressed)
","lha->entry_unconsumed = 0;
}
if (lha->end_of_entry) {
*offset = lha->entry_offset;
*size = 0;
*buff = NULL;
return (lha_end_of_entry(a));
}

if (lha->entry_is_compressed)
",1390,1374,1396,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""LHa data CRC error"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_239.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""LHa data CRC error"");
				return (ARCHIVE_WARN);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_239.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_239.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T14:18:52,Brad King,109
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_236.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_236.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_439.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_439.cpp,"ssize_t bytes_avail;
int r;

/* If the buffer hasn't been allocated, allocate it now. */
if (lha->uncompressed_buffer == NULL) {
lha->uncompressed_buffer_size = 64 * 1024;
lha->uncompressed_buffer
    = (unsigned char *)malloc(lha->uncompressed_buffer_size);
if (lha->uncompressed_buffer == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""No memory for lzh decompression"");
return (ARCHIVE_FATAL);
}
}

/* If we haven't yet read any data, initialize the decompressor. */
if (!lha->decompress_init) {
r = lzh_decode_init(&(lha->strm), lha->method);
","ssize_t bytes_avail;
int r;

/* If we haven't yet read any data, initialize the decompressor. */
if (!lha->decompress_init) {
r = lzh_decode_init(&(lha->strm), lha->method);
",1477,1449,1486,-1,"archive_set_error(&a->archive, ENOMEM,
			    ""No memory for lzh decompression"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_240.cpp,"{
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for lzh decompression"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_240.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_240.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T14:18:52,Brad King,109
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_441.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_441.cpp,"}

/*
 * Check for a mismatch between the type in the specification and
 * the type of the contents object on disk.
 */
if (st != NULL) {
if (
((st->st_mode & S_IFMT) == S_IFREG &&
 archive_entry_filetype(entry) == AE_IFREG)
#ifdef S_IFLNK
|| ((st->st_mode & S_IFMT) == S_IFLNK &&
archive_entry_filetype(entry) == AE_IFLNK)
#endif
#ifdef S_IFSOCK
|| ((st->st_mode & S_IFSOCK) == S_IFSOCK &&
archive_entry_filetype(entry) == AE_IFSOCK)
#endif
#ifdef S_IFCHR
|| ((st->st_mode & S_IFMT) == S_IFCHR &&
archive_entry_filetype(entry) == AE_IFCHR)
#endif
#ifdef S_IFBLK
|| ((st->st_mode & S_IFMT) == S_IFBLK &&
archive_entry_filetype(entry) == AE_IFBLK)
#endif
|| ((st->st_mode & S_IFMT) == S_IFDIR &&
archive_entry_filetype(entry) == AE_IFDIR)
#ifdef S_IFIFO
|| ((st->st_mode & S_IFMT) == S_IFIFO &&
archive_entry_filetype(entry) == AE_IFIFO)
#endif
) {
/* Types match. */
} else {
/* Types don't match; bail out gracefully. */
if (mtree->fd >= 0)
close(mtree->fd);
mtree->fd = -1;
if (parsed_kws & MTREE_HAS_OPTIONAL) {
/* It's not an error for an optional entry
   to not match disk. */
*use_next = 1;
} else if (r == ARCHIVE_OK) {
archive_set_error(&a->archive,
ARCHIVE_ERRNO_MISC,
""mtree specification has different type for %s"",
archive_entry_pathname(entry));
r = ARCHIVE_WARN;
}
return r;
}
}

/*
 * If there is a contents file on disk, pick some of the metadata
 * from that file.  For most of these, we only set it from the contents
 * if it wasn't already parsed from the specification.
 */
if (st != NULL) {
if (((parsed_kws & MTREE_HAS_DEVICE) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0) &&
(archive_entry_filetype(entry) == AE_IFCHR ||
 archive_entry_filetype(entry) == AE_IFBLK))
archive_entry_set_rdev(entry, st->st_rdev);
if ((parsed_kws & (MTREE_HAS_GID | MTREE_HAS_GNAME)) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_gid(entry, st->st_gid);
if ((parsed_kws & (MTREE_HAS_UID | MTREE_HAS_UNAME)) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_uid(entry, st->st_uid);
if ((parsed_kws & MTREE_HAS_MTIME) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0) {
#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC
archive_entry_set_mtime(entry, st->st_mtime,
st->st_mtimespec.tv_nsec);
","}

/*
 * Check for a mismatch between the type in the specification
 * and the type of the contents object on disk.
 */
if (st != NULL) {
if (((st->st_mode & S_IFMT) == S_IFREG &&
      archive_entry_filetype(entry) == AE_IFREG)
#ifdef S_IFLNK
  ||((st->st_mode & S_IFMT) == S_IFLNK &&
      archive_entry_filetype(entry) == AE_IFLNK)
#endif
#ifdef S_IFSOCK
  ||((st->st_mode & S_IFSOCK) == S_IFSOCK &&
      archive_entry_filetype(entry) == AE_IFSOCK)
#endif
#ifdef S_IFCHR
  ||((st->st_mode & S_IFMT) == S_IFCHR &&
      archive_entry_filetype(entry) == AE_IFCHR)
#endif
#ifdef S_IFBLK
  ||((st->st_mode & S_IFMT) == S_IFBLK &&
      archive_entry_filetype(entry) == AE_IFBLK)
#endif
  ||((st->st_mode & S_IFMT) == S_IFDIR &&
      archive_entry_filetype(entry) == AE_IFDIR)
#ifdef S_IFIFO
  ||((st->st_mode & S_IFMT) == S_IFIFO &&
      archive_entry_filetype(entry) == AE_IFIFO)
#endif
) {
/* Types match. */
} else {
/* Types don't match; bail out gracefully. */
if (mtree->fd >= 0)
close(mtree->fd);
mtree->fd = -1;
if (parsed_kws & MTREE_HAS_OPTIONAL) {
/* It's not an error for an optional
 * entry to not match disk. */
*use_next = 1;
} else if (r == ARCHIVE_OK) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""mtree specification has different""
    "" type for %s"",
    archive_entry_pathname(entry));
r = ARCHIVE_WARN;
}
return (r);
}
}

/*
 * If there is a contents file on disk, pick some of the
 * metadata from that file.  For most of these, we only
 * set it from the contents if it wasn't already parsed
 * from the specification.
 */
if (st != NULL) {
if (((parsed_kws & MTREE_HAS_DEVICE) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0) &&
(archive_entry_filetype(entry) == AE_IFCHR ||
 archive_entry_filetype(entry) == AE_IFBLK))
archive_entry_set_rdev(entry, st->st_rdev);
if ((parsed_kws & (MTREE_HAS_GID | MTREE_HAS_GNAME))
== 0 ||
    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_gid(entry, st->st_gid);
if ((parsed_kws & (MTREE_HAS_UID | MTREE_HAS_UNAME))
== 0 ||
    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_uid(entry, st->st_uid);
if ((parsed_kws & MTREE_HAS_MTIME) == 0 ||
    (parsed_kws & MTREE_HAS_NOCHANGE) != 0) {
#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC
archive_entry_set_mtime(entry, st->st_mtime,
st->st_mtimespec.tv_nsec);
",1175,1177,1219,1220,"archive_set_error(&a->archive,
									ARCHIVE_ERRNO_MISC,
									""mtree specification has different type for %s"",
									archive_entry_pathname(entry));","archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""mtree specification has different""
					    "" type for %s"",
					    archive_entry_pathname(entry));",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_241.cpp,"{
							archive_set_error(&a->archive,
									ARCHIVE_ERRNO_MISC,
									""mtree specification has different type for %s"",
									archive_entry_pathname(entry));
							r = ARCHIVE_WARN;
						}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_241.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_241.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T14:18:52,Brad King,55
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_443.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_443.cpp,"}
case 'c':
if (strcmp(val, ""char"") == 0) {
archive_entry_set_filetype(entry, AE_IFCHR);
break;
}
case 'd':
if (strcmp(val, ""dir"") == 0) {
archive_entry_set_filetype(entry, AE_IFDIR);
break;
}
case 'f':
if (strcmp(val, ""fifo"") == 0) {
archive_entry_set_filetype(entry, AE_IFIFO);
break;
}
if (strcmp(val, ""file"") == 0) {
archive_entry_set_filetype(entry, AE_IFREG);
break;
}
case 'l':
if (strcmp(val, ""link"") == 0) {
archive_entry_set_filetype(entry, AE_IFLNK);
break;
}
default:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Unrecognized file type \""%s\""; assuming \""file\"""", val);
archive_entry_set_filetype(entry, AE_IFREG);
return (ARCHIVE_WARN);
}
","}
case 'c':
if (strcmp(val, ""char"") == 0) {
archive_entry_set_filetype(entry,
AE_IFCHR);
break;
}
case 'd':
if (strcmp(val, ""dir"") == 0) {
archive_entry_set_filetype(entry,
AE_IFDIR);
break;
}
case 'f':
if (strcmp(val, ""fifo"") == 0) {
archive_entry_set_filetype(entry,
AE_IFIFO);
break;
}
if (strcmp(val, ""file"") == 0) {
archive_entry_set_filetype(entry,
AE_IFREG);
break;
}
case 'l':
if (strcmp(val, ""link"") == 0) {
archive_entry_set_filetype(entry,
AE_IFLNK);
break;
}
default:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Unrecognized file type \""%s\""; ""
    ""assuming \""file\"""", val);
archive_entry_set_filetype(entry, AE_IFREG);
return (ARCHIVE_WARN);
}
",1583,1589,1609,1620,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Unrecognized file type \""%s\""; assuming \""file\"""", val);","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Unrecognized file type \""%s\""; ""
				    ""assuming \""file\"""", val);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_242.cpp,"{
			case 'b':
				if (strcmp(val, ""block"") == 0) {
					archive_entry_set_filetype(entry, AE_IFBLK);
					break;
				}
			case 'c':
				if (strcmp(val, ""char"") == 0) {
					archive_entry_set_filetype(entry, AE_IFCHR);
					break;
				}
			case 'd':
				if (strcmp(val, ""dir"") == 0) {
					archive_entry_set_filetype(entry, AE_IFDIR);
					break;
				}
			case 'f':
				if (strcmp(val, ""fifo"") == 0) {
					archive_entry_set_filetype(entry, AE_IFIFO);
					break;
				}
				if (strcmp(val, ""file"") == 0) {
					archive_entry_set_filetype(entry, AE_IFREG);
					break;
				}
			case 'l':
				if (strcmp(val, ""link"") == 0) {
					archive_entry_set_filetype(entry, AE_IFLNK);
					break;
				}
			default:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Unrecognized file type \""%s\""; assuming \""file\"""", val);
				archive_entry_set_filetype(entry, AE_IFREG);
				return (ARCHIVE_WARN);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_242.cpp,"[6, 0, 0, 0, 6, 0, 1, 0, 5, 1, 7, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 14, 0, 0, 8, 0, 30, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_242.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T14:18:52,Brad King,56
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_446.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_446.cpp,"{
unsigned offset = 0;

while (offset < extra_length - 4)
{
unsigned short headerid = archive_le16dec(p  offset);
unsigned short datasize = archive_le16dec(p  offset  2);
offset = 4;
if (offset  datasize > extra_length)
break;
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%x, length %d\n"",
    headerid, datasize);
#endif
switch (headerid) {
","{
unsigned offset = 0;

while (offset < extra_length - 4) {
unsigned short headerid = archive_le16dec(p  offset);
unsigned short datasize = archive_le16dec(p  offset  2);

offset = 4;
if (offset  datasize > extra_length)
break;
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%04x, length %d\n"",
    headerid, datasize);
#endif
switch (headerid) {
",248,418,259,429,"fprintf(stderr, ""Header id 0x%x, length %d\n"",
		    headerid, datasize);","fprintf(stderr, ""Header id 0x%04x, length %d\n"",
		    headerid, datasize);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_243.cpp,"{
		unsigned short headerid = archive_le16dec(p + offset);
		unsigned short datasize = archive_le16dec(p + offset + 2);
		offset += 4;
		if (offset + datasize > extra_length)
			break;
#ifdef DEBUG
		fprintf(stderr, ""Header id 0x%x, length %d\n"",
		    headerid, datasize);
#endif
		switch (headerid) {
		case 0x0001:
			/* Zip64 extended information extra field. */
			zip_entry->flags |= LA_USED_ZIP64;
			if (zip_entry->uncompressed_size == 0xffffffff) {
				if (datasize < 8)
					break;
				zip_entry->uncompressed_size =
				    archive_le64dec(p + offset);
				offset += 8;
				datasize -= 8;
			}
			if (zip_entry->compressed_size == 0xffffffff) {
				if (datasize < 8)
					break;
				zip_entry->compressed_size =
				    archive_le64dec(p + offset);
				offset += 8;
				datasize -= 8;
			}
			if (zip_entry->local_header_offset == 0xffffffff) {
				if (datasize < 8)
					break;
				zip_entry->local_header_offset =
				    archive_le64dec(p + offset);
				offset += 8;
				datasize -= 8;
			}
			/* archive_le32dec(p + offset) gives disk
			 * on which file starts, but we don't handle
			 * multi-volume Zip files. */
			break;
		case 0x5455:
		{
			/* Extended time field ""UT"". */
			int flags = p[offset];
			offset++;
			datasize--;
			/* Flag bits indicate which dates are present. */
			if (flags & 0x01)
			{
#ifdef DEBUG
				fprintf(stderr, ""mtime: %lld -> %d\n"",
				    (long long)zip_entry->mtime,
				    archive_le32dec(p + offset));
#endif
				if (datasize < 4)
					break;
				zip_entry->mtime = archive_le32dec(p + offset);
				offset += 4;
				datasize -= 4;
			}
			if (flags & 0x02)
			{
				if (datasize < 4)
					break;
				zip_entry->atime = archive_le32dec(p + offset);
				offset += 4;
				datasize -= 4;
			}
			if (flags & 0x04)
			{
				if (datasize < 4)
					break;
				zip_entry->ctime = archive_le32dec(p + offset);
				offset += 4;
				datasize -= 4;
			}
			break;
		}
		case 0x5855:
		{
			/* Info-ZIP Unix Extra Field (old version) ""UX"". */
			if (datasize >= 8) {
				zip_entry->atime = archive_le32dec(p + offset);
				zip_entry->mtime =
				    archive_le32dec(p + offset + 4);
			}
			if (datasize >= 12) {
				zip_entry->uid =
				    archive_le16dec(p + offset + 8);
				zip_entry->gid =
				    archive_le16dec(p + offset + 10);
			}
			break;
		}
		case 0x6c65:
		{
			/* Experimental 'el' field */
			/*
			 * Introduced Dec 2013 to provide a way to
			 * include external file attributes in local file
			 * header.  This provides file type and permission
			 * information necessary to support full streaming
			 * extraction.  Currently being discussed with
			 * other Zip developers... subject to change.
			 */
			int bitmap, bitmap_last;

			if (datasize < 1)
				break;
			bitmap_last = bitmap = 0xff & p[offset];
			offset += 1;
			datasize -= 1;

			/* We only support first 7 bits of bitmap; skip rest. */
			while ((bitmap_last & 0x80) != 0
			    && datasize >= 1) {
				bitmap_last = p[offset];
				offset += 1;
				datasize -= 1;
			}

			if (bitmap & 1) {
				// 2 byte ""version made by""
				if (datasize < 2)
					break;
				zip_entry->system
				    = archive_le16dec(p + offset) >> 8;
				offset += 2;
				datasize -= 2;
			}
			if (bitmap & 2) {
				// 2 byte ""internal file attributes""
				uint32_t internal_attributes;
				if (datasize < 2)
					break;
				internal_attributes
				    = archive_le16dec(p + offset);
				// Not used by libarchive at present.
				(void)internal_attributes; /* UNUSED */
				offset += 2;
				datasize -= 2;
			}
			if (bitmap & 4) {
				// 4 byte ""external file attributes""
				uint32_t external_attributes;
				if (datasize < 4)
					break;
				external_attributes
				    = archive_le32dec(p + offset);
				if (zip_entry->system == 3) {
					zip_entry->mode
					    = external_attributes >> 16;
				}
				offset += 4;
				datasize -= 4;
			}
			if (bitmap & 8) {
				// 2 byte comment length + comment
				uint32_t comment_length;
				if (datasize < 2)
					break;
				comment_length
				    = archive_le16dec(p + offset);
				offset += 2;
				datasize -= 2;

				if (datasize < comment_length)
					break;
				// Comment is not supported by libarchive
				offset += comment_length;
				datasize -= comment_length;
			}
			break;
		}
		case 0x7855:
			/* Info-ZIP Unix Extra Field (type 2) ""Ux"". */
#ifdef DEBUG
			fprintf(stderr, ""uid %d gid %d\n"",
			    archive_le16dec(p + offset),
			    archive_le16dec(p + offset + 2));
#endif
			if (datasize >= 2)
				zip_entry->uid = archive_le16dec(p + offset);
			if (datasize >= 4)
				zip_entry->gid =
				    archive_le16dec(p + offset + 2);
			break;
		case 0x7875:
		{
			/* Info-Zip Unix Extra Field (type 3) ""ux"". */
			int uidsize = 0, gidsize = 0;

			/* TODO: support arbitrary uidsize/gidsize. */
			if (datasize >= 1 && p[offset] == 1) {/* version=1 */
				if (datasize >= 4) {
					/* get a uid size. */
					uidsize = p[offset+1];
					if (uidsize == 2)
						zip_entry->uid =
						    archive_le16dec(
						        p + offset + 2);
					else if (uidsize == 4 && datasize >= 6)
						zip_entry->uid =
						    archive_le32dec(
						        p + offset + 2);
				}
				if (datasize >= (2 + uidsize + 3)) {
					/* get a gid size. */
					gidsize = p[offset+2+uidsize];
					if (gidsize == 2)
						zip_entry->gid =
						    archive_le16dec(
						        p+offset+2+uidsize+1);
					else if (gidsize == 4 &&
					    datasize >= (2 + uidsize + 5))
						zip_entry->gid =
						    archive_le32dec(
						        p+offset+2+uidsize+1);
				}
			}
			break;
		}
		default:
			break;
		}
		offset += datasize;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_243.cpp,"[35, 1, 0, 0, 20, 0, 0, 1, 6, 1, 42, 0, 0, 0, 0, 287, 0, 0, 8, 10, 0, 0, 5, 94, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 186, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 6, 0, 37, 35, 0, 0, 28, 0, 0, 60, 2, 37, 6, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_243.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T14:18:52,Brad King,57
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_447.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_447.cpp,"    ""Truncated Zip file"");
return ARCHIVE_FATAL;
}
if (__archive_read_consume(a, linkname_length) < 0) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Read error skipping symlink target name"");
return ARCHIVE_FATAL;
}

sconv = zip->sconv;
if (sconv == NULL && (zip->entry->zip_flags & ZIP_UTF8_NAME))
","    ""Truncated Zip file"");
return ARCHIVE_FATAL;
}

sconv = zip->sconv;
if (sconv == NULL && (zip->entry->zip_flags & ZIP_UTF8_NAME))
",696,927,700,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Read error skipping symlink target name"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_244.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Read error skipping symlink target name"");
			return ARCHIVE_FATAL;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_244.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_244.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T14:18:52,Brad King,109
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_448.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_448.cpp,"zip->end_of_entry = 1;

/* Set up a more descriptive format name. */
snprintf(zip->format_name, sizeof(zip->format_name), ""ZIP %d.%d (%s)"",
    version / 10, version % 10,
    compression_name(zip->entry->compression));
a->archive.archive_format_name = zip->format_name;

return (ret);
}

/*
 * Read ""uncompressed"" data.  There are three cases:
 *  1) We know the size of the data.  This is always true for the
","zip->end_of_entry = 1;

/* Set up a more descriptive format name. */
archive_string_sprintf(&zip->format_name, ""ZIP %d.%d (%s)"",
    version / 10, version % 10,
    compression_name(zip->entry->compression));
a->archive.archive_format_name = zip->format_name.s;

return (ret);
}

static int
check_authentication_code(struct archive_read *a, const void *_p)
{
struct zip *zip = (struct zip *)(a->format->data);

/* Check authentication code. */
if (zip->hctx_valid) {
const void *p;
uint8_t hmac[20];
size_t hmac_len = 20;
int cmp;

archive_hmac_sha1_final(&zip->hctx, hmac, &hmac_len);
if (_p == NULL) {
/* Read authentication code. */
p = __archive_read_ahead(a, AUTH_CODE_SIZE, NULL);
if (p == NULL) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file data"");
return (ARCHIVE_FATAL);
}
} else {
p = _p;
}
cmp = memcmp(hmac, p, AUTH_CODE_SIZE);
__archive_read_consume(a, AUTH_CODE_SIZE);
if (cmp != 0) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""ZIP bad Authentication code"");
return (ARCHIVE_WARN);
}
}
return (ARCHIVE_OK);
}

/*
 * Read ""uncompressed"" data.  There are three cases:
 *  1) We know the size of the data.  This is always true for the
",748,980,751,983,"snprintf(zip->format_name, sizeof(zip->format_name), ""ZIP %d.%d (%s)"",
	    version / 10, version % 10,
	    compression_name(zip->entry->compression));","archive_string_sprintf(&zip->format_name, ""ZIP %d.%d (%s)"",
	    version / 10, version % 10,
	    compression_name(zip->entry->compression));",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_245.cpp,"{
	const char *p;
	const void *h;
	const wchar_t *wp;
	const char *cp;
	size_t len, filename_length, extra_length;
	struct archive_string_conv *sconv;
	struct zip_entry *zip_entry = zip->entry;
	struct zip_entry zip_entry_central_dir;
	int ret = ARCHIVE_OK;
	char version;

	/* Save a copy of the original for consistency checks. */
	zip_entry_central_dir = *zip_entry;

	zip->decompress_init = 0;
	zip->end_of_entry = 0;
	zip->entry_uncompressed_bytes_read = 0;
	zip->entry_compressed_bytes_read = 0;
	zip->entry_crc32 = zip->crc32func(0, NULL, 0);

	/* Setup default conversion. */
	if (zip->sconv == NULL && !zip->init_default_conversion) {
		zip->sconv_default =
		    archive_string_default_conversion_for_read(&(a->archive));
		zip->init_default_conversion = 1;
	}

	if ((p = __archive_read_ahead(a, 30, NULL)) == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");
		return (ARCHIVE_FATAL);
	}

	if (memcmp(p, ""PK\003\004"", 4) != 0) {
		archive_set_error(&a->archive, -1, ""Damaged Zip archive"");
		return ARCHIVE_FATAL;
	}
	version = p[4];
	zip_entry->system = p[5];
	zip_entry->zip_flags = archive_le16dec(p + 6);
	if (zip_entry->zip_flags & (ZIP_ENCRYPTED | ZIP_STRONG_ENCRYPTED)) {
		zip->has_encrypted_entries = 1;
		archive_entry_set_is_data_encrypted(entry, 1);
		if (zip_entry->zip_flags & ZIP_CENTRAL_DIRECTORY_ENCRYPTED &&
			zip_entry->zip_flags & ZIP_ENCRYPTED &&
			zip_entry->zip_flags & ZIP_STRONG_ENCRYPTED) {
			archive_entry_set_is_metadata_encrypted(entry, 1);
			return ARCHIVE_FATAL;
		}
	}
	zip_entry->compression = (char)archive_le16dec(p + 8);
	zip_entry->mtime = zip_time(p + 10);
	zip_entry->crc32 = archive_le32dec(p + 14);
	zip_entry->compressed_size = archive_le32dec(p + 18);
	zip_entry->uncompressed_size = archive_le32dec(p + 22);
	filename_length = archive_le16dec(p + 26);
	extra_length = archive_le16dec(p + 28);

	__archive_read_consume(a, 30);

	/* Read the filename. */
	if ((h = __archive_read_ahead(a, filename_length, NULL)) == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");
		return (ARCHIVE_FATAL);
	}
	if (zip_entry->zip_flags & ZIP_UTF8_NAME) {
		/* The filename is stored to be UTF-8. */
		if (zip->sconv_utf8 == NULL) {
			zip->sconv_utf8 =
			    archive_string_conversion_from_charset(
				&a->archive, ""UTF-8"", 1);
			if (zip->sconv_utf8 == NULL)
				return (ARCHIVE_FATAL);
		}
		sconv = zip->sconv_utf8;
	} else if (zip->sconv != NULL)
		sconv = zip->sconv;
	else
		sconv = zip->sconv_default;

	if (archive_entry_copy_pathname_l(entry,
	    h, filename_length, sconv) != 0) {
		if (errno == ENOMEM) {
			archive_set_error(&a->archive, ENOMEM,
			    ""Can't allocate memory for Pathname"");
			return (ARCHIVE_FATAL);
		}
		archive_set_error(&a->archive,
		    ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Pathname cannot be converted ""
		    ""from %s to current locale."",
		    archive_string_conversion_charset_name(sconv));
		ret = ARCHIVE_WARN;
	}
	__archive_read_consume(a, filename_length);

	/* Work around a bug in Info-Zip: When reading from a pipe, it
	 * stats the pipe instead of synthesizing a file entry. */
	if ((zip_entry->mode & AE_IFMT) == AE_IFIFO) {
		zip_entry->mode &= ~ AE_IFMT;
		zip_entry->mode |= AE_IFREG;
	}

	if ((zip_entry->mode & AE_IFMT) == 0) {
		/* Especially in streaming mode, we can end up
		   here without having seen proper mode information.
		   Guess from the filename. */
		wp = archive_entry_pathname_w(entry);
		if (wp != NULL) {
			len = wcslen(wp);
			if (len > 0 && wp[len - 1] == L'/')
				zip_entry->mode |= AE_IFDIR;
			else
				zip_entry->mode |= AE_IFREG;
		} else {
			cp = archive_entry_pathname(entry);
			len = (cp != NULL)?strlen(cp):0;
			if (len > 0 && cp[len - 1] == '/')
				zip_entry->mode |= AE_IFDIR;
			else
				zip_entry->mode |= AE_IFREG;
		}
		if (zip_entry->mode == AE_IFDIR) {
			zip_entry->mode |= 0775;
		} else if (zip_entry->mode == AE_IFREG) {
			zip_entry->mode |= 0664;
		}
	}

	/* Read the extra data. */
	if ((h = __archive_read_ahead(a, extra_length, NULL)) == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");
		return (ARCHIVE_FATAL);
	}

	process_extra(h, extra_length, zip_entry);
	__archive_read_consume(a, extra_length);

	if (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {
		/* If this came from the central dir, it's size info
		 * is definitive, so ignore the length-at-end flag. */
		zip_entry->zip_flags &= ~ZIP_LENGTH_AT_END;
		/* If local header is missing a value, use the one from
		   the central directory.  If both have it, warn about
		   mismatches. */
		if (zip_entry->crc32 == 0) {
			zip_entry->crc32 = zip_entry_central_dir.crc32;
		} else if (!zip->ignore_crc32
		    && zip_entry->crc32 != zip_entry_central_dir.crc32) {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Inconsistent CRC32 values"");
			ret = ARCHIVE_WARN;
		}
		if (zip_entry->compressed_size == 0) {
			zip_entry->compressed_size
			    = zip_entry_central_dir.compressed_size;
		} else if (zip_entry->compressed_size
		    != zip_entry_central_dir.compressed_size) {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Inconsistent compressed size: ""
			    ""%jd in central directory, %jd in local header"",
			    (intmax_t)zip_entry_central_dir.compressed_size,
			    (intmax_t)zip_entry->compressed_size);
			ret = ARCHIVE_WARN;
		}
		if (zip_entry->uncompressed_size == 0) {
			zip_entry->uncompressed_size
			    = zip_entry_central_dir.uncompressed_size;
		} else if (zip_entry->uncompressed_size
		    != zip_entry_central_dir.uncompressed_size) {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Inconsistent uncompressed size: ""
			    ""%jd in central directory, %jd in local header"",
			    (intmax_t)zip_entry_central_dir.uncompressed_size,
			    (intmax_t)zip_entry->uncompressed_size);
			ret = ARCHIVE_WARN;
		}
	}

	/* Populate some additional entry fields: */
	archive_entry_set_mode(entry, zip_entry->mode);
	archive_entry_set_uid(entry, zip_entry->uid);
	archive_entry_set_gid(entry, zip_entry->gid);
	archive_entry_set_mtime(entry, zip_entry->mtime, 0);
	archive_entry_set_ctime(entry, zip_entry->ctime, 0);
	archive_entry_set_atime(entry, zip_entry->atime, 0);

	if ((zip->entry->mode & AE_IFMT) == AE_IFLNK) {
		size_t linkname_length = zip_entry->compressed_size;

		archive_entry_set_size(entry, 0);
		p = __archive_read_ahead(a, linkname_length, NULL);
		if (p == NULL) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Truncated Zip file"");
			return ARCHIVE_FATAL;
		}
		if (__archive_read_consume(a, linkname_length) < 0) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Read error skipping symlink target name"");
			return ARCHIVE_FATAL;
		}

		sconv = zip->sconv;
		if (sconv == NULL && (zip->entry->zip_flags & ZIP_UTF8_NAME))
			sconv = zip->sconv_utf8;
		if (sconv == NULL)
			sconv = zip->sconv_default;
		if (archive_entry_copy_symlink_l(entry, p, linkname_length,
		    sconv) != 0) {
			if (errno != ENOMEM && sconv == zip->sconv_utf8 &&
			    (zip->entry->zip_flags & ZIP_UTF8_NAME))
			    archive_entry_copy_symlink_l(entry, p,
				linkname_length, NULL);
			if (errno == ENOMEM) {
				archive_set_error(&a->archive, ENOMEM,
				    ""Can't allocate memory for Symlink"");
				return (ARCHIVE_FATAL);
			}
			/*
			 * Since there is no character-set regulation for
			 * symlink name, do not report the conversion error
			 * in an automatic conversion.
			 */
			if (sconv != zip->sconv_utf8 ||
			    (zip->entry->zip_flags & ZIP_UTF8_NAME) == 0) {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Symlink cannot be converted ""
				    ""from %s to current locale."",
				    archive_string_conversion_charset_name(
					sconv));
				ret = ARCHIVE_WARN;
			}
		}
		zip_entry->uncompressed_size = zip_entry->compressed_size = 0;
	} else if (0 == (zip_entry->zip_flags & ZIP_LENGTH_AT_END)
	    || zip_entry->uncompressed_size > 0) {
		/* Set the size only if it's meaningful. */
		archive_entry_set_size(entry, zip_entry->uncompressed_size);
	}
	zip->entry_bytes_remaining = zip_entry->compressed_size;

	/* If there's no body, force read_data() to return EOF immediately. */
	if (0 == (zip_entry->zip_flags & ZIP_LENGTH_AT_END)
	    && zip->entry_bytes_remaining < 1)
		zip->end_of_entry = 1;

	/* Set up a more descriptive format name. */
	snprintf(zip->format_name, sizeof(zip->format_name), ""ZIP %d.%d (%s)"",
	    version / 10, version % 10,
	    compression_name(zip->entry->compression));
	a->archive.archive_format_name = zip->format_name;

	return (ret);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_245.cpp,"[38, 0, 0, 0, 0, 0, 11, 0, 0, 0, 43, 0, 0, 0, 4, 605, 0, 0, 11, 13, 0, 0, 3, 75, 0, 0, 0, 0, 6, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 326, 1, 275, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 4, 0, 39, 39, 5, 0, 56, 0, 0, 81, 6, 135, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_245.cpp,"name****name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****operator****literal****expr****argument
name****operator****literal****expr****argument
name****name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T14:18:52,Brad King,58
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_449.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_449.cpp,"if (AE_IFREG != (zip->entry->mode & AE_IFMT))
return (ARCHIVE_EOF);

if (zip->entry->zip_flags & (ZIP_ENCRYPTED | ZIP_STRONG_ENCRYPTED)) {
zip->has_encrypted_entries = 1;
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Encrypted file is unsupported"");
return (ARCHIVE_FAILED);
}

__archive_read_consume(a, zip->unconsumed);
zip->unconsumed = 0;

switch(zip->entry->compression) {
case 0:  /* No compression. */
r =  zip_read_data_none(a, buff, size, offset);
","if (AE_IFREG != (zip->entry->mode & AE_IFMT))
return (ARCHIVE_EOF);

__archive_read_consume(a, zip->unconsumed);
zip->unconsumed = 0;

if (zip->init_decryption) {
zip->has_encrypted_entries = 1;
if (zip->entry->zip_flags & ZIP_STRONG_ENCRYPTED)
r = read_decryption_header(a);
else if (zip->entry->compression == WINZIP_AES_ENCRYPTION)
r = init_WinZip_AES_decryption(a);
else
r = init_traditional_PKWARE_decryption(a);
if (r != ARCHIVE_OK)
return (r);
zip->init_decryption = 0;
}

switch(zip->entry->compression) {
case 0:  /* No compression. */
r =  zip_read_data_none(a, buff, size, offset);
",1037,1790,1042,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Encrypted file is unsupported"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_246.cpp,"{
		zip->has_encrypted_entries = 1;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Encrypted file is unsupported"");
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_246.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_246.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T14:18:52,Brad King,109
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_240.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_240.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_453.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_453.cpp,"{
static const lzma_stream lzma_stream_init_data = LZMA_STREAM_INIT;
int ret;

data->stream = lzma_stream_init_data;
data->stream.next_out = data->compressed;
data->stream.avail_out = data->compressed_buffer_size;
if (f->code == ARCHIVE_FILTER_XZ)
ret = lzma_stream_encoder(&(data->stream),
    data->lzmafilters, LZMA_CHECK_CRC64);
else if (f->code == ARCHIVE_FILTER_LZMA)
ret = lzma_alone_encoder(&(data->stream), &data->lzma_opt);
else {/* ARCHIVE_FILTER_LZIP */
int dict_size = data->lzma_opt.dict_size;
int ds, log2dic, wedges;

/* Calculate a coded dictionary size */
if (dict_size < (1 << 12) || dict_size > (1 << 27)) {
archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
    ""Unacceptable dictionary dize for lzip: %d"",
    dict_size);
return (ARCHIVE_FATAL);
}
","{
static const lzma_stream lzma_stream_init_data = LZMA_STREAM_INIT;
int ret;
#ifdef HAVE_LZMA_STREAM_ENCODER_MT
lzma_mt mt_options;
#endif

data->stream = lzma_stream_init_data;
data->stream.next_out = data->compressed;
data->stream.avail_out = data->compressed_buffer_size;
if (f->code == ARCHIVE_FILTER_XZ) {
#ifdef HAVE_LZMA_STREAM_ENCODER_MT
if (data->threads != 1) {
bzero(&mt_options, sizeof(mt_options));
mt_options.threads = data->threads;
mt_options.timeout = 300;
mt_options.filters = data->lzmafilters;
mt_options.check = LZMA_CHECK_CRC64;
ret = lzma_stream_encoder_mt(&(data->stream),
    &mt_options);
} else
#endif
ret = lzma_stream_encoder(&(data->stream),
    data->lzmafilters, LZMA_CHECK_CRC64);
} else if (f->code == ARCHIVE_FILTER_LZMA) {
ret = lzma_alone_encoder(&(data->stream), &data->lzma_opt);
} else {/* ARCHIVE_FILTER_LZIP */
int dict_size = data->lzma_opt.dict_size;
int ds, log2dic, wedges;

/* Calculate a coded dictionary size */
if (dict_size < (1 << 12) || dict_size > (1 << 27)) {
archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
    ""Unacceptable dictionary size for lzip: %d"",
    dict_size);
return (ARCHIVE_FATAL);
}
",221,223,239,255,"archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
			    ""Unacceptable dictionary dize for lzip: %d"",
			    dict_size);","archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
			    ""Unacceptable dictionary size for lzip: %d"",
			    dict_size);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_247.cpp,"{
			archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
			    ""Unacceptable dictionary dize for lzip: %d"",
			    dict_size);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_247.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_247.cpp,"name****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T14:18:52,Brad King,59
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_454.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_454.cpp,"return (r);
if ((size_t)r < size) {
archive_set_error(&a->archive, 0,
    ""Write request too large"");
return (ARCHIVE_WARN);
}
return (ARCHIVE_OK);
}

static ssize_t
","return (r);
if ((size_t)r < size) {
archive_set_error(&a->archive, 0,
    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);
return (ARCHIVE_WARN);
}
#if ARCHIVE_VERSION_NUMBER < 3999000
return (ARCHIVE_OK);
#else
return (size);
#endif
}

static ssize_t
",1467,1468,1469,1470,"archive_set_error(&a->archive, 0,
		    ""Write request too large"");","archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_248.cpp,"{
		archive_set_error(&a->archive, 0,
		    ""Write request too large"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_248.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_248.cpp,"name****operator****name****operator****name****name****expr****argument
literal****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T14:18:52,Brad King,60
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_244.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_244.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_462.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_462.cpp,"}

if (a->read_data_offset < a->read_data_output_offset) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Encountered out-of-order sparse blocks"");
return (ARCHIVE_RETRY);
}
","}

if (a->read_data_offset < a->read_data_output_offset) {
archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Encountered out-of-order sparse blocks"");
return (ARCHIVE_RETRY);
}
",843,850,846,853,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Encountered out-of-order sparse blocks"");","archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Encountered out-of-order sparse blocks"");",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_249.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Encountered out-of-order sparse blocks"");
			return (ARCHIVE_RETRY);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_249.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_249.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T13:37:00,Brad King,53
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_244.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_244.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_463.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_463.cpp,"if (a->format->read_data == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
    ""Internal error: ""
    ""No format_read_data_block function registered"");
return (ARCHIVE_FATAL);
}

","if (a->format->read_data == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
    ""Internal error: ""
    ""No format->read_data function registered"");
return (ARCHIVE_FATAL);
}

",953,975,954,976,"archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
		    ""Internal error: ""
		    ""No format_read_data_block function registered"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
		    ""Internal error: ""
		    ""No format->read_data function registered"");",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_250.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
		    ""Internal error: ""
		    ""No format_read_data_block function registered"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_250.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_250.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T13:37:00,Brad King,54
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_466.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_466.cpp," */
if (ar->strtab == NULL || number > ar->strtab_size) {
archive_set_error(&a->archive, EINVAL,
    ""Can't find long filename for entry"");
archive_entry_copy_pathname(entry, filename);
/* Parse the time, owner, mode, size fields. */
ar_parse_common_header(ar, entry, h);
return (ARCHIVE_WARN);
}

archive_entry_copy_pathname(entry, &ar->strtab[(size_t)number]);
"," */
if (ar->strtab == NULL || number > ar->strtab_size) {
archive_set_error(&a->archive, EINVAL,
    ""Can't find long filename for GNU/SVR4 archive entry"");
archive_entry_copy_pathname(entry, filename);
/* Parse the time, owner, mode, size fields. */
ar_parse_common_header(ar, entry, h);
return (ARCHIVE_FATAL);
}

archive_entry_copy_pathname(entry, &ar->strtab[(size_t)number]);
",311,318,313,320,"archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for entry"");","archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for GNU/SVR4 archive entry"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_251.cpp,"{
			archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for entry"");
			archive_entry_copy_pathname(entry, filename);
			/* Parse the time, owner, mode, size fields. */
			ar_parse_common_header(ar, entry, h);
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_251.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_251.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T13:37:00,Brad King,111
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_247.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_247.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_468.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_468.cpp,"lha->entry_unconsumed = 0;
}
if (lha->end_of_entry) {
if (!lha->end_of_entry_cleanup) {
if ((lha->setflag & CRC_IS_SET) &&
    lha->crc != lha->entry_crc_calculated) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""LHa data CRC error"");
return (ARCHIVE_WARN);
}

/* End-of-entry cleanup done. */
lha->end_of_entry_cleanup = 1;
}
*offset = lha->entry_offset;
*size = 0;
*buff = NULL;
return (ARCHIVE_EOF);
}

if (lha->entry_is_compressed)
","lha->entry_unconsumed = 0;
}
if (lha->end_of_entry) {
*offset = lha->entry_offset;
*size = 0;
*buff = NULL;
return (lha_end_of_entry(a));
}

if (lha->entry_is_compressed)
",1390,1374,1396,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""LHa data CRC error"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_252.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""LHa data CRC error"");
				return (ARCHIVE_WARN);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_252.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_252.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T13:37:00,Brad King,109
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_247.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_247.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_469.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_469.cpp,"ssize_t bytes_avail;
int r;

/* If the buffer hasn't been allocated, allocate it now. */
if (lha->uncompressed_buffer == NULL) {
lha->uncompressed_buffer_size = 64 * 1024;
lha->uncompressed_buffer
    = (unsigned char *)malloc(lha->uncompressed_buffer_size);
if (lha->uncompressed_buffer == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""No memory for lzh decompression"");
return (ARCHIVE_FATAL);
}
}

/* If we haven't yet read any data, initialize the decompressor. */
if (!lha->decompress_init) {
r = lzh_decode_init(&(lha->strm), lha->method);
","ssize_t bytes_avail;
int r;

/* If we haven't yet read any data, initialize the decompressor. */
if (!lha->decompress_init) {
r = lzh_decode_init(&(lha->strm), lha->method);
",1477,1449,1486,-1,"archive_set_error(&a->archive, ENOMEM,
			    ""No memory for lzh decompression"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_253.cpp,"{
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for lzh decompression"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_253.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_253.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T13:37:00,Brad King,109
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_471.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_471.cpp,"}

/*
 * Check for a mismatch between the type in the specification and
 * the type of the contents object on disk.
 */
if (st != NULL) {
if (
((st->st_mode & S_IFMT) == S_IFREG &&
 archive_entry_filetype(entry) == AE_IFREG)
#ifdef S_IFLNK
|| ((st->st_mode & S_IFMT) == S_IFLNK &&
archive_entry_filetype(entry) == AE_IFLNK)
#endif
#ifdef S_IFSOCK
|| ((st->st_mode & S_IFSOCK) == S_IFSOCK &&
archive_entry_filetype(entry) == AE_IFSOCK)
#endif
#ifdef S_IFCHR
|| ((st->st_mode & S_IFMT) == S_IFCHR &&
archive_entry_filetype(entry) == AE_IFCHR)
#endif
#ifdef S_IFBLK
|| ((st->st_mode & S_IFMT) == S_IFBLK &&
archive_entry_filetype(entry) == AE_IFBLK)
#endif
|| ((st->st_mode & S_IFMT) == S_IFDIR &&
archive_entry_filetype(entry) == AE_IFDIR)
#ifdef S_IFIFO
|| ((st->st_mode & S_IFMT) == S_IFIFO &&
archive_entry_filetype(entry) == AE_IFIFO)
#endif
) {
/* Types match. */
} else {
/* Types don't match; bail out gracefully. */
if (mtree->fd >= 0)
close(mtree->fd);
mtree->fd = -1;
if (parsed_kws & MTREE_HAS_OPTIONAL) {
/* It's not an error for an optional entry
   to not match disk. */
*use_next = 1;
} else if (r == ARCHIVE_OK) {
archive_set_error(&a->archive,
ARCHIVE_ERRNO_MISC,
""mtree specification has different type for %s"",
archive_entry_pathname(entry));
r = ARCHIVE_WARN;
}
return r;
}
}

/*
 * If there is a contents file on disk, pick some of the metadata
 * from that file.  For most of these, we only set it from the contents
 * if it wasn't already parsed from the specification.
 */
if (st != NULL) {
if (((parsed_kws & MTREE_HAS_DEVICE) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0) &&
(archive_entry_filetype(entry) == AE_IFCHR ||
 archive_entry_filetype(entry) == AE_IFBLK))
archive_entry_set_rdev(entry, st->st_rdev);
if ((parsed_kws & (MTREE_HAS_GID | MTREE_HAS_GNAME)) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_gid(entry, st->st_gid);
if ((parsed_kws & (MTREE_HAS_UID | MTREE_HAS_UNAME)) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_uid(entry, st->st_uid);
if ((parsed_kws & MTREE_HAS_MTIME) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0) {
#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC
archive_entry_set_mtime(entry, st->st_mtime,
st->st_mtimespec.tv_nsec);
","}

/*
 * Check for a mismatch between the type in the specification
 * and the type of the contents object on disk.
 */
if (st != NULL) {
if (((st->st_mode & S_IFMT) == S_IFREG &&
      archive_entry_filetype(entry) == AE_IFREG)
#ifdef S_IFLNK
  ||((st->st_mode & S_IFMT) == S_IFLNK &&
      archive_entry_filetype(entry) == AE_IFLNK)
#endif
#ifdef S_IFSOCK
  ||((st->st_mode & S_IFSOCK) == S_IFSOCK &&
      archive_entry_filetype(entry) == AE_IFSOCK)
#endif
#ifdef S_IFCHR
  ||((st->st_mode & S_IFMT) == S_IFCHR &&
      archive_entry_filetype(entry) == AE_IFCHR)
#endif
#ifdef S_IFBLK
  ||((st->st_mode & S_IFMT) == S_IFBLK &&
      archive_entry_filetype(entry) == AE_IFBLK)
#endif
  ||((st->st_mode & S_IFMT) == S_IFDIR &&
      archive_entry_filetype(entry) == AE_IFDIR)
#ifdef S_IFIFO
  ||((st->st_mode & S_IFMT) == S_IFIFO &&
      archive_entry_filetype(entry) == AE_IFIFO)
#endif
) {
/* Types match. */
} else {
/* Types don't match; bail out gracefully. */
if (mtree->fd >= 0)
close(mtree->fd);
mtree->fd = -1;
if (parsed_kws & MTREE_HAS_OPTIONAL) {
/* It's not an error for an optional
 * entry to not match disk. */
*use_next = 1;
} else if (r == ARCHIVE_OK) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""mtree specification has different""
    "" type for %s"",
    archive_entry_pathname(entry));
r = ARCHIVE_WARN;
}
return (r);
}
}

/*
 * If there is a contents file on disk, pick some of the
 * metadata from that file.  For most of these, we only
 * set it from the contents if it wasn't already parsed
 * from the specification.
 */
if (st != NULL) {
if (((parsed_kws & MTREE_HAS_DEVICE) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0) &&
(archive_entry_filetype(entry) == AE_IFCHR ||
 archive_entry_filetype(entry) == AE_IFBLK))
archive_entry_set_rdev(entry, st->st_rdev);
if ((parsed_kws & (MTREE_HAS_GID | MTREE_HAS_GNAME))
== 0 ||
    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_gid(entry, st->st_gid);
if ((parsed_kws & (MTREE_HAS_UID | MTREE_HAS_UNAME))
== 0 ||
    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_uid(entry, st->st_uid);
if ((parsed_kws & MTREE_HAS_MTIME) == 0 ||
    (parsed_kws & MTREE_HAS_NOCHANGE) != 0) {
#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC
archive_entry_set_mtime(entry, st->st_mtime,
st->st_mtimespec.tv_nsec);
",1175,1177,1219,1220,"archive_set_error(&a->archive,
									ARCHIVE_ERRNO_MISC,
									""mtree specification has different type for %s"",
									archive_entry_pathname(entry));","archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""mtree specification has different""
					    "" type for %s"",
					    archive_entry_pathname(entry));",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_254.cpp,"{
							archive_set_error(&a->archive,
									ARCHIVE_ERRNO_MISC,
									""mtree specification has different type for %s"",
									archive_entry_pathname(entry));
							r = ARCHIVE_WARN;
						}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_254.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_254.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T13:37:00,Brad King,55
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_473.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_473.cpp,"}
case 'c':
if (strcmp(val, ""char"") == 0) {
archive_entry_set_filetype(entry, AE_IFCHR);
break;
}
case 'd':
if (strcmp(val, ""dir"") == 0) {
archive_entry_set_filetype(entry, AE_IFDIR);
break;
}
case 'f':
if (strcmp(val, ""fifo"") == 0) {
archive_entry_set_filetype(entry, AE_IFIFO);
break;
}
if (strcmp(val, ""file"") == 0) {
archive_entry_set_filetype(entry, AE_IFREG);
break;
}
case 'l':
if (strcmp(val, ""link"") == 0) {
archive_entry_set_filetype(entry, AE_IFLNK);
break;
}
default:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Unrecognized file type \""%s\""; assuming \""file\"""", val);
archive_entry_set_filetype(entry, AE_IFREG);
return (ARCHIVE_WARN);
}
","}
case 'c':
if (strcmp(val, ""char"") == 0) {
archive_entry_set_filetype(entry,
AE_IFCHR);
break;
}
case 'd':
if (strcmp(val, ""dir"") == 0) {
archive_entry_set_filetype(entry,
AE_IFDIR);
break;
}
case 'f':
if (strcmp(val, ""fifo"") == 0) {
archive_entry_set_filetype(entry,
AE_IFIFO);
break;
}
if (strcmp(val, ""file"") == 0) {
archive_entry_set_filetype(entry,
AE_IFREG);
break;
}
case 'l':
if (strcmp(val, ""link"") == 0) {
archive_entry_set_filetype(entry,
AE_IFLNK);
break;
}
default:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Unrecognized file type \""%s\""; ""
    ""assuming \""file\"""", val);
archive_entry_set_filetype(entry, AE_IFREG);
return (ARCHIVE_WARN);
}
",1583,1589,1609,1620,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Unrecognized file type \""%s\""; assuming \""file\"""", val);","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Unrecognized file type \""%s\""; ""
				    ""assuming \""file\"""", val);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_255.cpp,"{
			case 'b':
				if (strcmp(val, ""block"") == 0) {
					archive_entry_set_filetype(entry, AE_IFBLK);
					break;
				}
			case 'c':
				if (strcmp(val, ""char"") == 0) {
					archive_entry_set_filetype(entry, AE_IFCHR);
					break;
				}
			case 'd':
				if (strcmp(val, ""dir"") == 0) {
					archive_entry_set_filetype(entry, AE_IFDIR);
					break;
				}
			case 'f':
				if (strcmp(val, ""fifo"") == 0) {
					archive_entry_set_filetype(entry, AE_IFIFO);
					break;
				}
				if (strcmp(val, ""file"") == 0) {
					archive_entry_set_filetype(entry, AE_IFREG);
					break;
				}
			case 'l':
				if (strcmp(val, ""link"") == 0) {
					archive_entry_set_filetype(entry, AE_IFLNK);
					break;
				}
			default:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Unrecognized file type \""%s\""; assuming \""file\"""", val);
				archive_entry_set_filetype(entry, AE_IFREG);
				return (ARCHIVE_WARN);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_255.cpp,"[6, 0, 0, 0, 6, 0, 1, 0, 5, 1, 7, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 14, 0, 0, 8, 0, 30, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_255.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T13:37:00,Brad King,56
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_476.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_476.cpp,"{
unsigned offset = 0;

while (offset < extra_length - 4)
{
unsigned short headerid = archive_le16dec(p  offset);
unsigned short datasize = archive_le16dec(p  offset  2);
offset = 4;
if (offset  datasize > extra_length)
break;
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%x, length %d\n"",
    headerid, datasize);
#endif
switch (headerid) {
","{
unsigned offset = 0;

while (offset < extra_length - 4) {
unsigned short headerid = archive_le16dec(p  offset);
unsigned short datasize = archive_le16dec(p  offset  2);

offset = 4;
if (offset  datasize > extra_length)
break;
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%04x, length %d\n"",
    headerid, datasize);
#endif
switch (headerid) {
",244,414,255,425,"fprintf(stderr, ""Header id 0x%x, length %d\n"",
		    headerid, datasize);","fprintf(stderr, ""Header id 0x%04x, length %d\n"",
		    headerid, datasize);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_256.cpp,"{
		unsigned short headerid = archive_le16dec(p + offset);
		unsigned short datasize = archive_le16dec(p + offset + 2);
		offset += 4;
		if (offset + datasize > extra_length)
			break;
#ifdef DEBUG
		fprintf(stderr, ""Header id 0x%x, length %d\n"",
		    headerid, datasize);
#endif
		switch (headerid) {
		case 0x0001:
			/* Zip64 extended information extra field. */
			zip_entry->flags |= LA_USED_ZIP64;
			if (zip_entry->uncompressed_size == 0xffffffff) {
				if (datasize < 8)
					break;
				zip_entry->uncompressed_size =
				    archive_le64dec(p + offset);
				offset += 8;
				datasize -= 8;
			}
			if (zip_entry->compressed_size == 0xffffffff) {
				if (datasize < 8)
					break;
				zip_entry->compressed_size =
				    archive_le64dec(p + offset);
				offset += 8;
				datasize -= 8;
			}
			if (zip_entry->local_header_offset == 0xffffffff) {
				if (datasize < 8)
					break;
				zip_entry->local_header_offset =
				    archive_le64dec(p + offset);
				offset += 8;
				datasize -= 8;
			}
			/* archive_le32dec(p + offset) gives disk
			 * on which file starts, but we don't handle
			 * multi-volume Zip files. */
			break;
		case 0x5455:
		{
			/* Extended time field ""UT"". */
			int flags = p[offset];
			offset++;
			datasize--;
			/* Flag bits indicate which dates are present. */
			if (flags & 0x01)
			{
#ifdef DEBUG
				fprintf(stderr, ""mtime: %lld -> %d\n"",
				    (long long)zip_entry->mtime,
				    archive_le32dec(p + offset));
#endif
				if (datasize < 4)
					break;
				zip_entry->mtime = archive_le32dec(p + offset);
				offset += 4;
				datasize -= 4;
			}
			if (flags & 0x02)
			{
				if (datasize < 4)
					break;
				zip_entry->atime = archive_le32dec(p + offset);
				offset += 4;
				datasize -= 4;
			}
			if (flags & 0x04)
			{
				if (datasize < 4)
					break;
				zip_entry->ctime = archive_le32dec(p + offset);
				offset += 4;
				datasize -= 4;
			}
			break;
		}
		case 0x5855:
		{
			/* Info-ZIP Unix Extra Field (old version) ""UX"". */
			if (datasize >= 8) {
				zip_entry->atime = archive_le32dec(p + offset);
				zip_entry->mtime =
				    archive_le32dec(p + offset + 4);
			}
			if (datasize >= 12) {
				zip_entry->uid =
				    archive_le16dec(p + offset + 8);
				zip_entry->gid =
				    archive_le16dec(p + offset + 10);
			}
			break;
		}
		case 0x6c65:
		{
			/* Experimental 'el' field */
			/*
			 * Introduced Dec 2013 to provide a way to
			 * include external file attributes in local file
			 * header.  This provides file type and permission
			 * information necessary to support full streaming
			 * extraction.  Currently being discussed with
			 * other Zip developers... subject to change.
			 */
			int bitmap, bitmap_last;

			if (datasize < 1)
				break;
			bitmap_last = bitmap = 0xff & p[offset];
			offset += 1;
			datasize -= 1;

			/* We only support first 7 bits of bitmap; skip rest. */
			while ((bitmap_last & 0x80) != 0
			    && datasize >= 1) {
				bitmap_last = p[offset];
				offset += 1;
				datasize -= 1;
			}

			if (bitmap & 1) {
				// 2 byte ""version made by""
				if (datasize < 2)
					break;
				zip_entry->system
				    = archive_le16dec(p + offset) >> 8;
				offset += 2;
				datasize -= 2;
			}
			if (bitmap & 2) {
				// 2 byte ""internal file attributes""
				uint32_t internal_attributes;
				if (datasize < 2)
					break;
				internal_attributes
				    = archive_le16dec(p + offset);
				// Not used by libarchive at present.
				(void)internal_attributes; /* UNUSED */
				offset += 2;
				datasize -= 2;
			}
			if (bitmap & 4) {
				// 4 byte ""external file attributes""
				uint32_t external_attributes;
				if (datasize < 4)
					break;
				external_attributes
				    = archive_le32dec(p + offset);
				if (zip_entry->system == 3) {
					zip_entry->mode
					    = external_attributes >> 16;
				}
				offset += 4;
				datasize -= 4;
			}
			if (bitmap & 8) {
				// 2 byte comment length + comment
				uint32_t comment_length;
				if (datasize < 2)
					break;
				comment_length
				    = archive_le16dec(p + offset);
				offset += 2;
				datasize -= 2;

				if (datasize < comment_length)
					break;
				// Comment is not supported by libarchive
				offset += comment_length;
				datasize -= comment_length;
			}
			break;
		}
		case 0x7855:
			/* Info-ZIP Unix Extra Field (type 2) ""Ux"". */
#ifdef DEBUG
			fprintf(stderr, ""uid %d gid %d\n"",
			    archive_le16dec(p + offset),
			    archive_le16dec(p + offset + 2));
#endif
			if (datasize >= 2)
				zip_entry->uid = archive_le16dec(p + offset);
			if (datasize >= 4)
				zip_entry->gid =
				    archive_le16dec(p + offset + 2);
			break;
		case 0x7875:
		{
			/* Info-Zip Unix Extra Field (type 3) ""ux"". */
			int uidsize = 0, gidsize = 0;

			/* TODO: support arbitrary uidsize/gidsize. */
			if (datasize >= 1 && p[offset] == 1) {/* version=1 */
				if (datasize >= 4) {
					/* get a uid size. */
					uidsize = p[offset+1];
					if (uidsize == 2)
						zip_entry->uid =
						    archive_le16dec(
						        p + offset + 2);
					else if (uidsize == 4 && datasize >= 6)
						zip_entry->uid =
						    archive_le32dec(
						        p + offset + 2);
				}
				if (datasize >= (2 + uidsize + 3)) {
					/* get a gid size. */
					gidsize = p[offset+2+uidsize];
					if (gidsize == 2)
						zip_entry->gid =
						    archive_le16dec(
						        p+offset+2+uidsize+1);
					else if (gidsize == 4 &&
					    datasize >= (2 + uidsize + 5))
						zip_entry->gid =
						    archive_le32dec(
						        p+offset+2+uidsize+1);
				}
			}
			break;
		}
		default:
			break;
		}
		offset += datasize;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_256.cpp,"[35, 1, 0, 0, 20, 0, 0, 1, 6, 1, 42, 0, 0, 0, 0, 287, 0, 0, 8, 10, 0, 0, 5, 94, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 186, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 6, 0, 37, 35, 0, 0, 28, 0, 0, 60, 2, 37, 6, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_256.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T13:37:00,Brad King,57
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_477.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_477.cpp,"    ""Truncated Zip file"");
return ARCHIVE_FATAL;
}
if (__archive_read_consume(a, linkname_length) < 0) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Read error skipping symlink target name"");
return ARCHIVE_FATAL;
}

sconv = zip->sconv;
if (sconv == NULL && (zip->entry->zip_flags & ZIP_UTF8_NAME))
","    ""Truncated Zip file"");
return ARCHIVE_FATAL;
}

sconv = zip->sconv;
if (sconv == NULL && (zip->entry->zip_flags & ZIP_UTF8_NAME))
",692,923,696,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Read error skipping symlink target name"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_257.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Read error skipping symlink target name"");
			return ARCHIVE_FATAL;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_257.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_257.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T13:37:00,Brad King,109
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_478.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_478.cpp,"zip->end_of_entry = 1;

/* Set up a more descriptive format name. */
snprintf(zip->format_name, sizeof(zip->format_name), ""ZIP %d.%d (%s)"",
    version / 10, version % 10,
    compression_name(zip->entry->compression));
a->archive.archive_format_name = zip->format_name;

return (ret);
}

/*
 * Read ""uncompressed"" data.  There are three cases:
 *  1) We know the size of the data.  This is always true for the
","zip->end_of_entry = 1;

/* Set up a more descriptive format name. */
archive_string_sprintf(&zip->format_name, ""ZIP %d.%d (%s)"",
    version / 10, version % 10,
    compression_name(zip->entry->compression));
a->archive.archive_format_name = zip->format_name.s;

return (ret);
}

static int
check_authentication_code(struct archive_read *a, const void *_p)
{
struct zip *zip = (struct zip *)(a->format->data);

/* Check authentication code. */
if (zip->hctx_valid) {
const void *p;
uint8_t hmac[20];
size_t hmac_len = 20;
int cmp;

archive_hmac_sha1_final(&zip->hctx, hmac, &hmac_len);
if (_p == NULL) {
/* Read authentication code. */
p = __archive_read_ahead(a, AUTH_CODE_SIZE, NULL);
if (p == NULL) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file data"");
return (ARCHIVE_FATAL);
}
} else {
p = _p;
}
cmp = memcmp(hmac, p, AUTH_CODE_SIZE);
__archive_read_consume(a, AUTH_CODE_SIZE);
if (cmp != 0) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""ZIP bad Authentication code"");
return (ARCHIVE_WARN);
}
}
return (ARCHIVE_OK);
}

/*
 * Read ""uncompressed"" data.  There are three cases:
 *  1) We know the size of the data.  This is always true for the
",744,976,747,979,"snprintf(zip->format_name, sizeof(zip->format_name), ""ZIP %d.%d (%s)"",
	    version / 10, version % 10,
	    compression_name(zip->entry->compression));","archive_string_sprintf(&zip->format_name, ""ZIP %d.%d (%s)"",
	    version / 10, version % 10,
	    compression_name(zip->entry->compression));",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_258.cpp,"{
	const char *p;
	const void *h;
	const wchar_t *wp;
	const char *cp;
	size_t len, filename_length, extra_length;
	struct archive_string_conv *sconv;
	struct zip_entry *zip_entry = zip->entry;
	struct zip_entry zip_entry_central_dir;
	int ret = ARCHIVE_OK;
	char version;

	/* Save a copy of the original for consistency checks. */
	zip_entry_central_dir = *zip_entry;

	zip->decompress_init = 0;
	zip->end_of_entry = 0;
	zip->entry_uncompressed_bytes_read = 0;
	zip->entry_compressed_bytes_read = 0;
	zip->entry_crc32 = zip->crc32func(0, NULL, 0);

	/* Setup default conversion. */
	if (zip->sconv == NULL && !zip->init_default_conversion) {
		zip->sconv_default =
		    archive_string_default_conversion_for_read(&(a->archive));
		zip->init_default_conversion = 1;
	}

	if ((p = __archive_read_ahead(a, 30, NULL)) == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");
		return (ARCHIVE_FATAL);
	}

	if (memcmp(p, ""PK\003\004"", 4) != 0) {
		archive_set_error(&a->archive, -1, ""Damaged Zip archive"");
		return ARCHIVE_FATAL;
	}
	version = p[4];
	zip_entry->system = p[5];
	zip_entry->zip_flags = archive_le16dec(p + 6);
	if (zip_entry->zip_flags & (ZIP_ENCRYPTED | ZIP_STRONG_ENCRYPTED)) {
		zip->has_encrypted_entries = 1;
		archive_entry_set_is_data_encrypted(entry, 1);
		if (zip_entry->zip_flags & ZIP_CENTRAL_DIRECTORY_ENCRYPTED &&
			zip_entry->zip_flags & ZIP_ENCRYPTED &&
			zip_entry->zip_flags & ZIP_STRONG_ENCRYPTED) {
			archive_entry_set_is_metadata_encrypted(entry, 1);
			return ARCHIVE_FATAL;
		}
	}
	zip_entry->compression = (char)archive_le16dec(p + 8);
	zip_entry->mtime = zip_time(p + 10);
	zip_entry->crc32 = archive_le32dec(p + 14);
	zip_entry->compressed_size = archive_le32dec(p + 18);
	zip_entry->uncompressed_size = archive_le32dec(p + 22);
	filename_length = archive_le16dec(p + 26);
	extra_length = archive_le16dec(p + 28);

	__archive_read_consume(a, 30);

	/* Read the filename. */
	if ((h = __archive_read_ahead(a, filename_length, NULL)) == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");
		return (ARCHIVE_FATAL);
	}
	if (zip_entry->zip_flags & ZIP_UTF8_NAME) {
		/* The filename is stored to be UTF-8. */
		if (zip->sconv_utf8 == NULL) {
			zip->sconv_utf8 =
			    archive_string_conversion_from_charset(
				&a->archive, ""UTF-8"", 1);
			if (zip->sconv_utf8 == NULL)
				return (ARCHIVE_FATAL);
		}
		sconv = zip->sconv_utf8;
	} else if (zip->sconv != NULL)
		sconv = zip->sconv;
	else
		sconv = zip->sconv_default;

	if (archive_entry_copy_pathname_l(entry,
	    h, filename_length, sconv) != 0) {
		if (errno == ENOMEM) {
			archive_set_error(&a->archive, ENOMEM,
			    ""Can't allocate memory for Pathname"");
			return (ARCHIVE_FATAL);
		}
		archive_set_error(&a->archive,
		    ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Pathname cannot be converted ""
		    ""from %s to current locale."",
		    archive_string_conversion_charset_name(sconv));
		ret = ARCHIVE_WARN;
	}
	__archive_read_consume(a, filename_length);

	/* Work around a bug in Info-Zip: When reading from a pipe, it
	 * stats the pipe instead of synthesizing a file entry. */
	if ((zip_entry->mode & AE_IFMT) == AE_IFIFO) {
		zip_entry->mode &= ~ AE_IFMT;
		zip_entry->mode |= AE_IFREG;
	}

	if ((zip_entry->mode & AE_IFMT) == 0) {
		/* Especially in streaming mode, we can end up
		   here without having seen proper mode information.
		   Guess from the filename. */
		wp = archive_entry_pathname_w(entry);
		if (wp != NULL) {
			len = wcslen(wp);
			if (len > 0 && wp[len - 1] == L'/')
				zip_entry->mode |= AE_IFDIR;
			else
				zip_entry->mode |= AE_IFREG;
		} else {
			cp = archive_entry_pathname(entry);
			len = (cp != NULL)?strlen(cp):0;
			if (len > 0 && cp[len - 1] == '/')
				zip_entry->mode |= AE_IFDIR;
			else
				zip_entry->mode |= AE_IFREG;
		}
		if (zip_entry->mode == AE_IFDIR) {
			zip_entry->mode |= 0775;
		} else if (zip_entry->mode == AE_IFREG) {
			zip_entry->mode |= 0664;
		}
	}

	/* Read the extra data. */
	if ((h = __archive_read_ahead(a, extra_length, NULL)) == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");
		return (ARCHIVE_FATAL);
	}

	process_extra(h, extra_length, zip_entry);
	__archive_read_consume(a, extra_length);

	if (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {
		/* If this came from the central dir, it's size info
		 * is definitive, so ignore the length-at-end flag. */
		zip_entry->zip_flags &= ~ZIP_LENGTH_AT_END;
		/* If local header is missing a value, use the one from
		   the central directory.  If both have it, warn about
		   mismatches. */
		if (zip_entry->crc32 == 0) {
			zip_entry->crc32 = zip_entry_central_dir.crc32;
		} else if (!zip->ignore_crc32
		    && zip_entry->crc32 != zip_entry_central_dir.crc32) {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Inconsistent CRC32 values"");
			ret = ARCHIVE_WARN;
		}
		if (zip_entry->compressed_size == 0) {
			zip_entry->compressed_size
			    = zip_entry_central_dir.compressed_size;
		} else if (zip_entry->compressed_size
		    != zip_entry_central_dir.compressed_size) {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Inconsistent compressed size: ""
			    ""%jd in central directory, %jd in local header"",
			    (intmax_t)zip_entry_central_dir.compressed_size,
			    (intmax_t)zip_entry->compressed_size);
			ret = ARCHIVE_WARN;
		}
		if (zip_entry->uncompressed_size == 0) {
			zip_entry->uncompressed_size
			    = zip_entry_central_dir.uncompressed_size;
		} else if (zip_entry->uncompressed_size
		    != zip_entry_central_dir.uncompressed_size) {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Inconsistent uncompressed size: ""
			    ""%jd in central directory, %jd in local header"",
			    (intmax_t)zip_entry_central_dir.uncompressed_size,
			    (intmax_t)zip_entry->uncompressed_size);
			ret = ARCHIVE_WARN;
		}
	}

	/* Populate some additional entry fields: */
	archive_entry_set_mode(entry, zip_entry->mode);
	archive_entry_set_uid(entry, zip_entry->uid);
	archive_entry_set_gid(entry, zip_entry->gid);
	archive_entry_set_mtime(entry, zip_entry->mtime, 0);
	archive_entry_set_ctime(entry, zip_entry->ctime, 0);
	archive_entry_set_atime(entry, zip_entry->atime, 0);

	if ((zip->entry->mode & AE_IFMT) == AE_IFLNK) {
		size_t linkname_length = zip_entry->compressed_size;

		archive_entry_set_size(entry, 0);
		p = __archive_read_ahead(a, linkname_length, NULL);
		if (p == NULL) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Truncated Zip file"");
			return ARCHIVE_FATAL;
		}
		if (__archive_read_consume(a, linkname_length) < 0) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Read error skipping symlink target name"");
			return ARCHIVE_FATAL;
		}

		sconv = zip->sconv;
		if (sconv == NULL && (zip->entry->zip_flags & ZIP_UTF8_NAME))
			sconv = zip->sconv_utf8;
		if (sconv == NULL)
			sconv = zip->sconv_default;
		if (archive_entry_copy_symlink_l(entry, p, linkname_length,
		    sconv) != 0) {
			if (errno != ENOMEM && sconv == zip->sconv_utf8 &&
			    (zip->entry->zip_flags & ZIP_UTF8_NAME))
			    archive_entry_copy_symlink_l(entry, p,
				linkname_length, NULL);
			if (errno == ENOMEM) {
				archive_set_error(&a->archive, ENOMEM,
				    ""Can't allocate memory for Symlink"");
				return (ARCHIVE_FATAL);
			}
			/*
			 * Since there is no character-set regulation for
			 * symlink name, do not report the conversion error
			 * in an automatic conversion.
			 */
			if (sconv != zip->sconv_utf8 ||
			    (zip->entry->zip_flags & ZIP_UTF8_NAME) == 0) {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Symlink cannot be converted ""
				    ""from %s to current locale."",
				    archive_string_conversion_charset_name(
					sconv));
				ret = ARCHIVE_WARN;
			}
		}
		zip_entry->uncompressed_size = zip_entry->compressed_size = 0;
	} else if (0 == (zip_entry->zip_flags & ZIP_LENGTH_AT_END)
	    || zip_entry->uncompressed_size > 0) {
		/* Set the size only if it's meaningful. */
		archive_entry_set_size(entry, zip_entry->uncompressed_size);
	}
	zip->entry_bytes_remaining = zip_entry->compressed_size;

	/* If there's no body, force read_data() to return EOF immediately. */
	if (0 == (zip_entry->zip_flags & ZIP_LENGTH_AT_END)
	    && zip->entry_bytes_remaining < 1)
		zip->end_of_entry = 1;

	/* Set up a more descriptive format name. */
	snprintf(zip->format_name, sizeof(zip->format_name), ""ZIP %d.%d (%s)"",
	    version / 10, version % 10,
	    compression_name(zip->entry->compression));
	a->archive.archive_format_name = zip->format_name;

	return (ret);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_258.cpp,"[38, 0, 0, 0, 0, 0, 11, 0, 0, 0, 43, 0, 0, 0, 4, 605, 0, 0, 11, 13, 0, 0, 3, 75, 0, 0, 0, 0, 6, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 326, 1, 275, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 4, 0, 39, 39, 5, 0, 56, 0, 0, 81, 6, 135, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_258.cpp,"name****name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****operator****literal****expr****argument
name****operator****literal****expr****argument
name****name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T13:37:00,Brad King,58
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_479.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_479.cpp,"if (AE_IFREG != (zip->entry->mode & AE_IFMT))
return (ARCHIVE_EOF);

if (zip->entry->zip_flags & (ZIP_ENCRYPTED | ZIP_STRONG_ENCRYPTED)) {
zip->has_encrypted_entries = 1;
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Encrypted file is unsupported"");
return (ARCHIVE_FAILED);
}

__archive_read_consume(a, zip->unconsumed);
zip->unconsumed = 0;

switch(zip->entry->compression) {
case 0:  /* No compression. */
r =  zip_read_data_none(a, buff, size, offset);
","if (AE_IFREG != (zip->entry->mode & AE_IFMT))
return (ARCHIVE_EOF);

__archive_read_consume(a, zip->unconsumed);
zip->unconsumed = 0;

if (zip->init_decryption) {
zip->has_encrypted_entries = 1;
if (zip->entry->zip_flags & ZIP_STRONG_ENCRYPTED)
r = read_decryption_header(a);
else if (zip->entry->compression == WINZIP_AES_ENCRYPTION)
r = init_WinZip_AES_decryption(a);
else
r = init_traditional_PKWARE_decryption(a);
if (r != ARCHIVE_OK)
return (r);
zip->init_decryption = 0;
}

switch(zip->entry->compression) {
case 0:  /* No compression. */
r =  zip_read_data_none(a, buff, size, offset);
",1033,1786,1038,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Encrypted file is unsupported"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_259.cpp,"{
		zip->has_encrypted_entries = 1;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Encrypted file is unsupported"");
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_259.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_259.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T13:37:00,Brad King,109
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_add_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_251.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_251.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_483.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_483.cpp,"{
static const lzma_stream lzma_stream_init_data = LZMA_STREAM_INIT;
int ret;

data->stream = lzma_stream_init_data;
data->stream.next_out = data->compressed;
data->stream.avail_out = data->compressed_buffer_size;
if (f->code == ARCHIVE_FILTER_XZ)
ret = lzma_stream_encoder(&(data->stream),
    data->lzmafilters, LZMA_CHECK_CRC64);
else if (f->code == ARCHIVE_FILTER_LZMA)
ret = lzma_alone_encoder(&(data->stream), &data->lzma_opt);
else {/* ARCHIVE_FILTER_LZIP */
int dict_size = data->lzma_opt.dict_size;
int ds, log2dic, wedges;

/* Calculate a coded dictionary size */
if (dict_size < (1 << 12) || dict_size > (1 << 27)) {
archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
    ""Unacceptable dictionary dize for lzip: %d"",
    dict_size);
return (ARCHIVE_FATAL);
}
","{
static const lzma_stream lzma_stream_init_data = LZMA_STREAM_INIT;
int ret;
#ifdef HAVE_LZMA_STREAM_ENCODER_MT
lzma_mt mt_options;
#endif

data->stream = lzma_stream_init_data;
data->stream.next_out = data->compressed;
data->stream.avail_out = data->compressed_buffer_size;
if (f->code == ARCHIVE_FILTER_XZ) {
#ifdef HAVE_LZMA_STREAM_ENCODER_MT
if (data->threads != 1) {
bzero(&mt_options, sizeof(mt_options));
mt_options.threads = data->threads;
mt_options.timeout = 300;
mt_options.filters = data->lzmafilters;
mt_options.check = LZMA_CHECK_CRC64;
ret = lzma_stream_encoder_mt(&(data->stream),
    &mt_options);
} else
#endif
ret = lzma_stream_encoder(&(data->stream),
    data->lzmafilters, LZMA_CHECK_CRC64);
} else if (f->code == ARCHIVE_FILTER_LZMA) {
ret = lzma_alone_encoder(&(data->stream), &data->lzma_opt);
} else {/* ARCHIVE_FILTER_LZIP */
int dict_size = data->lzma_opt.dict_size;
int ds, log2dic, wedges;

/* Calculate a coded dictionary size */
if (dict_size < (1 << 12) || dict_size > (1 << 27)) {
archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
    ""Unacceptable dictionary size for lzip: %d"",
    dict_size);
return (ARCHIVE_FATAL);
}
",221,223,239,255,"archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
			    ""Unacceptable dictionary dize for lzip: %d"",
			    dict_size);","archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
			    ""Unacceptable dictionary size for lzip: %d"",
			    dict_size);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_260.cpp,"{
			archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
			    ""Unacceptable dictionary dize for lzip: %d"",
			    dict_size);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_260.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_260.cpp,"name****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T13:37:00,Brad King,59
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_484.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_484.cpp,"return (r);
if ((size_t)r < size) {
archive_set_error(&a->archive, 0,
    ""Write request too large"");
return (ARCHIVE_WARN);
}
return (ARCHIVE_OK);
}

static ssize_t
","return (r);
if ((size_t)r < size) {
archive_set_error(&a->archive, 0,
    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);
return (ARCHIVE_WARN);
}
#if ARCHIVE_VERSION_NUMBER < 3999000
return (ARCHIVE_OK);
#else
return (size);
#endif
}

static ssize_t
",1467,1468,1469,1470,"archive_set_error(&a->archive, 0,
		    ""Write request too large"");","archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_261.cpp,"{
		archive_set_error(&a->archive, 0,
		    ""Write request too large"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_261.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_261.cpp,"name****operator****name****operator****name****name****expr****argument
literal****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-21T13:37:00,Brad King,60
bbef3c2da83b7a69d1f99b21dc92d5506d98fb35,cmLocalGenerator: Add current binary directory accessor.,[],Source/cmLocalVisualStudio6Generator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_255.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_255.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_491.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_491.cpp,"                        const cmCustomCommand& origCommand)
{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->Makefile->GetCurrentBinaryDirectory())
                            target.GetName().size()  30)];
  sprintf(output,""%s/%s_force_%i"", this->Makefile->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);
  const char* comment = origCommand.GetComment();
  if(!comment && origCommand.GetOutputs().empty())
","                        const cmCustomCommand& origCommand)
{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->GetCurrentBinaryDirectory())
                            target.GetName().size()  30)];
  sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);
  const char* comment = origCommand.GetComment();
  if(!comment && origCommand.GetOutputs().empty())
",578,578,583,583,"sprintf(output,""%s/%s_force_%i"", this->Makefile->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);","sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_262.cpp,"{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->Makefile->GetCurrentBinaryDirectory())
                           + target.GetName().size() + 30)];
  sprintf(output,""%s/%s_force_%i"", this->Makefile->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);
  const char* comment = origCommand.GetComment();
  if(!comment && origCommand.GetOutputs().empty())
    {
    comment = ""<hack>"";
    }

  // Add the rule with the given dependencies and commands.
  std::string no_main_dependency = """";
  if(cmSourceFile* outsf =
     this->Makefile->AddCustomCommandToOutput(
       output, depends, no_main_dependency,
       origCommand.GetCommandLines(), comment,
       origCommand.GetWorkingDirectory().c_str()))
    {
    cmGeneratorTarget* gt = this->GlobalGenerator->GetGeneratorTarget(&target);
    gt->AddSource(outsf->GetFullPath());
    }

  // Replace the dependencies with the output of this rule so that the
  // next rule added will run after this one.
  depends.clear();
  depends.push_back(output);

  // Free the fake output name.
  delete [] output;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_262.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1, 77, 0, 0, 4, 5, 0, 0, 5, 4, 0, 0, 0, 0, 4, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 2, 0, 2, 2, 0, 0, 20, 0, 0, 6, 0, 15, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_262.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****argument_list****call****operator****name****argument_list****call****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-10-10T09:04:39,Stephen Kelly,4
2e6063068c94d4045e699fed51e6d1e9af344bbf,"Merge branch 'improve-variable-help-formatting' into revert-cmake-W-options

Resolve conflicts in

 Help/variable/CMAKE_ERROR_DEPRECATED.rst
 Help/variable/CMAKE_WARN_DEPRECATED.rst

by integrating changes from both sides.",[],Source/cmGlobalGenerator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_257.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_257.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_493.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_493.cpp,"  // update the cache entry for the number of local generators, this is used
  // for progress
  char num[100];
  sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_LOCAL_GENERATORS"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
","  // update the cache entry for the number of local generators, this is used
  // for progress
  char num[100];
  sprintf(num,""%d"",static_cast<int>(this->Makefiles.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_MAKEFILES"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
",1111,1148,1114,1151,"sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));","sprintf(num,""%d"",static_cast<int>(this->Makefiles.size()));",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_263.cpp,"{
  this->FirstTimeProgress = 0.0f;
  this->ClearGeneratorMembers();

  // start with this directory
  cmLocalGenerator *lg = this->MakeLocalGenerator();
  this->LocalGenerators.push_back(lg);

  // set the Start directories
  lg->GetMakefile()->SetCurrentSourceDirectory
    (this->CMakeInstance->GetHomeDirectory());
  lg->GetMakefile()->SetCurrentBinaryDirectory
    (this->CMakeInstance->GetHomeOutputDirectory());

  this->BinaryDirectories.insert(
      this->CMakeInstance->GetHomeOutputDirectory());

  // now do it
  lg->GetMakefile()->Configure();
  lg->GetMakefile()->EnforceDirectoryLevelRules();

  // update the cache entry for the number of local generators, this is used
  // for progress
  char num[100];
  sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_LOCAL_GENERATORS"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
  // and for infinite loops
  this->CheckLocalGenerators();

  // at this point this->LocalGenerators has been filled,
  // so create the map from project name to vector of local generators
  this->FillProjectMap();

  if ( this->CMakeInstance->GetWorkingMode() == cmake::NORMAL_MODE)
    {
    std::ostringstream msg;
    if(cmSystemTools::GetErrorOccuredFlag())
      {
      msg << ""Configuring incomplete, errors occurred!"";
      const char* logs[] = {""CMakeOutput.log"", ""CMakeError.log"", 0};
      for(const char** log = logs; *log; ++log)
        {
        std::string f = this->CMakeInstance->GetHomeOutputDirectory();
        f += this->CMakeInstance->GetCMakeFilesDirectory();
        f += ""/"";
        f += *log;
        if(cmSystemTools::FileExists(f.c_str()))
          {
          msg << ""\nSee also \"""" << f << ""\""."";
          }
        }
      }
    else
      {
      msg << ""Configuring done"";
      }
    this->CMakeInstance->UpdateProgress(msg.str().c_str(), -1);
    }

  unsigned int i;

  // Put a copy of each global target in every directory.
  cmTargets globalTargets;
  this->CreateDefaultGlobalTargets(&globalTargets);

  for (i = 0; i < this->LocalGenerators.size(); ++i)
    {
    cmMakefile* mf = this->LocalGenerators[i]->GetMakefile();
    cmTargets* targets = &(mf->GetTargets());
    cmTargets::iterator tit;
    for ( tit = globalTargets.begin(); tit != globalTargets.end(); ++ tit )
      {
      (*targets)[tit->first] = tit->second;
      (*targets)[tit->first].SetMakefile(mf);
      }
    }

}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_263.cpp,"[3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 2, 182, 0, 0, 10, 11, 0, 0, 9, 15, 0, 0, 0, 0, 6, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 88, 0, 64, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 5, 0, 6, 3, 1, 0, 39, 0, 0, 22, 0, 18, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_263.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****name****operator****name****operator****name****name****argument_list****call****expr****argument
argument_list****cast****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-09-22T17:57:08,Brad King,61
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_512.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_512.cpp,"        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);

          if(conn->bits.tunnel_proxy ||
             conn->proxytype == CURLPROXY_SOCKS5 ||
             conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
             conn->proxytype == CURLPROXY_SOCKS4 ||
             conn->proxytype == CURLPROXY_SOCKS4A)
            /* proxy tunnel -> use other host info because ip_addr_str is the
               proxy address not the ftp host */
            snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name);
          else
            /* use the same IP we are already connected to */
            snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str);
        }
      }
      else
","        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);
          ftpc->newhost = strdup(control_address(conn));
          if(!ftpc->newhost)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else
",1933,1967,1944,-1,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_264.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_264.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_264.cpp,"name****name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T19:43:52,Brad King,96
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_512.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_512.cpp,"        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);

          if(conn->bits.tunnel_proxy ||
             conn->proxytype == CURLPROXY_SOCKS5 ||
             conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
             conn->proxytype == CURLPROXY_SOCKS4 ||
             conn->proxytype == CURLPROXY_SOCKS4A)
            /* proxy tunnel -> use other host info because ip_addr_str is the
               proxy address not the ftp host */
            snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name);
          else
            /* use the same IP we are already connected to */
            snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str);
        }
      }
      else
","        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);
          ftpc->newhost = strdup(control_address(conn));
          if(!ftpc->newhost)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else
",1933,1967,1948,-1,"snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_265.cpp,"snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_265.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_265.cpp,"name****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T19:43:52,Brad King,62
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_513.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_513.cpp,"
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the one we used
         for the control connection */
      infof(data, ""Skips %d.%d.%d.%d for data connection, uses %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->ip_addr_str);
      if(conn->bits.tunnel_proxy ||
         conn->proxytype == CURLPROXY_SOCKS5 ||
         conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
         conn->proxytype == CURLPROXY_SOCKS4 ||
         conn->proxytype == CURLPROXY_SOCKS4A)
        /* proxy tunnel -> use other host info because ip_addr_str is the
           proxy address not the ftp host */
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name);
      else
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str);
    }
    else
      snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);
    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
","
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the host we used
         for the control connection */
      infof(data, ""Skip %d.%d.%d.%d for data connection, re-use %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->host.name);
      ftpc->newhost = strdup(control_address(conn));
    }
    else
      ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);

    if(!ftpc->newhost)
      return CURLE_OUT_OF_MEMORY;

    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
",1986,2010,2001,-1,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_266.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_266.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_266.cpp,"name****name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T19:43:52,Brad King,96
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_513.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_513.cpp,"
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the one we used
         for the control connection */
      infof(data, ""Skips %d.%d.%d.%d for data connection, uses %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->ip_addr_str);
      if(conn->bits.tunnel_proxy ||
         conn->proxytype == CURLPROXY_SOCKS5 ||
         conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
         conn->proxytype == CURLPROXY_SOCKS4 ||
         conn->proxytype == CURLPROXY_SOCKS4A)
        /* proxy tunnel -> use other host info because ip_addr_str is the
           proxy address not the ftp host */
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name);
      else
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str);
    }
    else
      snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);
    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
","
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the host we used
         for the control connection */
      infof(data, ""Skip %d.%d.%d.%d for data connection, re-use %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->host.name);
      ftpc->newhost = strdup(control_address(conn));
    }
    else
      ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);

    if(!ftpc->newhost)
      return CURLE_OUT_OF_MEMORY;

    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
",1986,2010,2003,-1,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_267.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_267.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_267.cpp,"name****name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T19:43:52,Brad King,63
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_513.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_513.cpp,"
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the one we used
         for the control connection */
      infof(data, ""Skips %d.%d.%d.%d for data connection, uses %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->ip_addr_str);
      if(conn->bits.tunnel_proxy ||
         conn->proxytype == CURLPROXY_SOCKS5 ||
         conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
         conn->proxytype == CURLPROXY_SOCKS4 ||
         conn->proxytype == CURLPROXY_SOCKS4A)
        /* proxy tunnel -> use other host info because ip_addr_str is the
           proxy address not the ftp host */
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name);
      else
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str);
    }
    else
      snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);
    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
","
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the host we used
         for the control connection */
      infof(data, ""Skip %d.%d.%d.%d for data connection, re-use %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->host.name);
      ftpc->newhost = strdup(control_address(conn));
    }
    else
      ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);

    if(!ftpc->newhost)
      return CURLE_OUT_OF_MEMORY;

    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
",1986,2010,2007,2021,"snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);","ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_268.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_268.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_268.cpp,"name****name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T19:43:52,Brad King,64
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_272.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_272.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_515.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_515.cpp,"    if(((httpreq == HTTPREQ_GET) || (httpreq == HTTPREQ_HEAD)) &&
       !Curl_checkheaders(conn, ""Range:"")) {
      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);
    }
    else if((httpreq != HTTPREQ_GET) &&
            !Curl_checkheaders(conn, ""Content-Range:"")) {

      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);

      if(data->set.set_resume_from < 0) {
        /* Upload resume was asked for, but we don't know the size of the
","    if(((httpreq == HTTPREQ_GET) || (httpreq == HTTPREQ_HEAD)) &&
       !Curl_checkheaders(conn, ""Range:"")) {
      /* if a line like this was already allocated, free the previous one */
      free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);
    }
    else if((httpreq != HTTPREQ_GET) &&
            !Curl_checkheaders(conn, ""Content-Range:"")) {

      /* if a line like this was already allocated, free the previous one */
      free(conn->allocptr.rangeline);

      if(data->set.set_resume_from < 0) {
        /* Upload resume was asked for, but we don't know the size of the
",2153,2198,2158,2202,"conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);","conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_269.cpp,"{
      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_269.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_269.cpp,"name****operator****name****operator****name****name****operator****name****literal****expr****argument
name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T19:43:52,Brad King,65
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_516.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_516.cpp,"
#include ""urldata.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""curl_md5.h""
#include ""http_digest.h""
#include ""strtok.h""
#include ""curl_memory.h""
#include ""vtls/vtls.h"" /* for Curl_rand() */
#include ""non-ascii.h"" /* included for Curl_convert_... prototypes */
#include ""warnless.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

#define MAX_VALUE_LENGTH 256
#define MAX_CONTENT_LENGTH 1024

static void digest_cleanup_one(struct digestdata *dig);

/*
 * Return 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
static int get_pair(const char *str, char *value, char *content,
                    const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c=MAX_VALUE_LENGTH-1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value=0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c=MAX_CONTENT_LENGTH-1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c=0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c=0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c=0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content=0;

  *endptr = str;

  return 0; /* all is fine! */
}

/* Test example headers:

WWW-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""
Proxy-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""

*/

CURLdigest Curl_input_digest(struct connectdata *conn,
                             bool proxy,
                             const char *header) /* rest of the *-authenticate:
                                                    header */
{
  char *token = NULL;
  char *tmp = NULL;
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  struct SessionHandle *data=conn->data;
  bool before = FALSE; /* got a nonce before */
  struct digestdata *d;

  if(proxy) {
    d = &data->state.proxydigest;
  }
  else {
    d = &data->state.digest;
  }

  if(checkprefix(""Digest"", header)) {
    header = strlen(""Digest"");

    /* If we already have received a nonce, keep that in mind */
    if(d->nonce)
      before = TRUE;

    /* clear off any former leftovers and init to defaults */
    digest_cleanup_one(d);

    for(;;) {
      char value[MAX_VALUE_LENGTH];
      char content[MAX_CONTENT_LENGTH];

      while(*header && ISSPACE(*header))
        headerï¿½;

      /* extract a value=content pair */
      if(!get_pair(header, value, content, &header)) {
        if(Curl_raw_equal(value, ""nonce"")) {
          d->nonce = strdup(content);
          if(!d->nonce)
            return CURLDIGEST_NOMEM;
        }
        else if(Curl_raw_equal(value, ""stale"")) {
          if(Curl_raw_equal(content, ""true"")) {
            d->stale = TRUE;
            d->nc = 1; /* we make a new nonce now */
          }
        }
        else if(Curl_raw_equal(value, ""realm"")) {
          d->realm = strdup(content);
          if(!d->realm)
            return CURLDIGEST_NOMEM;
        }
        else if(Curl_raw_equal(value, ""opaque"")) {
          d->opaque = strdup(content);
          if(!d->opaque)
            return CURLDIGEST_NOMEM;
        }
        else if(Curl_raw_equal(value, ""qop"")) {
          char *tok_buf;
          /* tokenize the list and choose auth if possible, use a temporary
             clone of the buffer since strtok_r() ruins it */
          tmp = strdup(content);
          if(!tmp)
            return CURLDIGEST_NOMEM;
          token = strtok_r(tmp, "","", &tok_buf);
          while(token != NULL) {
            if(Curl_raw_equal(token, ""auth"")) {
              foundAuth = TRUE;
            }
            else if(Curl_raw_equal(token, ""auth-int"")) {
              foundAuthInt = TRUE;
            }
            token = strtok_r(NULL, "","", &tok_buf);
          }
          free(tmp);
          /*select only auth o auth-int. Otherwise, ignore*/
          if(foundAuth) {
            d->qop = strdup(""auth"");
            if(!d->qop)
              return CURLDIGEST_NOMEM;
          }
          else if(foundAuthInt) {
            d->qop = strdup(""auth-int"");
            if(!d->qop)
              return CURLDIGEST_NOMEM;
          }
        }
        else if(Curl_raw_equal(value, ""algorithm"")) {
          d->algorithm = strdup(content);
          if(!d->algorithm)
            return CURLDIGEST_NOMEM;
          if(Curl_raw_equal(content, ""MD5-sess""))
            d->algo = CURLDIGESTALGO_MD5SESS;
          else if(Curl_raw_equal(content, ""MD5""))
            d->algo = CURLDIGESTALGO_MD5;
          else
            return CURLDIGEST_BADALGO;
        }
        else {
          /* unknown specifier, ignore it! */
        }
      }
      else
        break; /* we're done here */

      /* pass all additional spaces here */
      while(*header && ISSPACE(*header))
        headerï¿½;
      if(',' == *header)
        /* allow the list to be comma-separated */
        headerï¿½;
    }
    /* We had a nonce since before, and we got another one now without
       'stale=true'. This means we provided bad credentials in the previous
       request */
    if(before && !d->stale)
      return CURLDIGEST_BAD;

    /* We got this header without a nonce, that's a bad Digest line! */
    if(!d->nonce)
      return CURLDIGEST_BAD;
  }
  else
    /* else not a digest, get out */
    return CURLDIGEST_NONE;

  return CURLDIGEST_FINE;
}

/* convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void md5_to_ascii(unsigned char *source, /* 16 bytes */
                         unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i=0; i<16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

CURLcode Curl_output_digest(struct connectdata *conn,
                            bool proxy,
                            const unsigned char *request,
                            const unsigned char *uripath)
{
  /* We have a Digest setup for this, use it!  Now, to get all the details for
     this sorted out, I must urge you dear friend to read up on the RFC2617
     section 3.2.2, */
  size_t urilen;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *tmp = NULL;
  char **allocuserpwd;
  size_t userlen;
  const char *userp;
  char *userp_quoted;
  const char *passwdp;
  struct auth *authp;

  struct SessionHandle *data = conn->data;
  struct digestdata *d;
  CURLcode rc;
/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  rc = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(rc != CURLE_OK) { \
    free(b); \
    return rc; \
  }

  if(proxy) {
    d = &data->state.proxydigest;
    allocuserpwd = &conn->allocptr.proxyuserpwd;
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    authp = &data->state.authproxy;
  }
  else {
    d = &data->state.digest;
    allocuserpwd = &conn->allocptr.userpwd;
    userp = conn->user;
    passwdp = conn->passwd;
","
#include ""urldata.h""
#include ""rawstr.h""
#include ""curl_sasl.h""
#include ""http_digest.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

/* Test example headers:

WWW-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""
Proxy-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""

*/

CURLcode Curl_input_digest(struct connectdata *conn,
                           bool proxy,
                           const char *header) /* rest of the *-authenticate:
                                                  header */
{
  struct SessionHandle *data = conn->data;

  /* Point to the correct struct with this */
  struct digestdata *digest;

  if(proxy) {
    digest = &data->state.proxydigest;
  }
  else {
    digest = &data->state.digest;
  }

  if(!checkprefix(""Digest"", header))
    return CURLE_BAD_CONTENT_ENCODING;

  header = strlen(""Digest"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  return Curl_sasl_decode_digest_http_message(header, digest);
}

CURLcode Curl_output_digest(struct connectdata *conn,
                            bool proxy,
                            const unsigned char *request,
                            const unsigned char *uripath)
{
  CURLcode result;
  struct SessionHandle *data = conn->data;
  unsigned char *path;
  char *tmp;
  char *response;
  size_t len;
  bool have_chlg;

  /* Point to the address of the pointer that holds the string to send to the
     server, which is for a plain host or for a HTTP proxy */
  char **allocuserpwd;

  /* Point to the name and password for this */
  const char *userp;
  const char *passwdp;

  /* Point to the correct struct with this */
  struct digestdata *digest;
  struct auth *authp;

  if(proxy) {
    digest = &data->state.proxydigest;
    allocuserpwd = &conn->allocptr.proxyuserpwd;
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    authp = &data->state.authproxy;
  }
  else {
    digest = &data->state.digest;
    allocuserpwd = &conn->allocptr.userpwd;
    userp = conn->user;
    passwdp = conn->passwd;
",26,26,262,-1,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_270.cpp,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_270.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_270.cpp,"name****operator****name****operator****operator****operator****name****name****operator****literal****expr****index****name****expr****argument
literal****expr****argument
literal****expr****argument
name****name****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T19:43:52,Brad King,91
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_517.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_517.cpp,"
  /* not set means empty */
  if(!userp)
    userp="""";

  if(!passwdp)
    passwdp="""";

  if(!d->nonce) {
    authp->done = FALSE;
    return CURLE_OK;
  }
  authp->done = TRUE;

  if(!d->nc)
    d->nc = 1;

  if(!d->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, d->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha1);

  if(d->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
","
  /* not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

#if defined(USE_WINDOWS_SSPI)
  have_chlg = digest->input_token ? TRUE : FALSE;
#else
  have_chlg = digest->nonce ? TRUE : FALSE;
#endif

  if(!have_chlg) {
    authp->done = FALSE;
    return CURLE_OK;
  }

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
",352,112,370,-1,"snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_271.cpp,"{
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_271.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 23, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 8, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_271.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T19:43:52,Brad King,92
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_517.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_517.cpp,"
  /* not set means empty */
  if(!userp)
    userp="""";

  if(!passwdp)
    passwdp="""";

  if(!d->nonce) {
    authp->done = FALSE;
    return CURLE_OK;
  }
  authp->done = TRUE;

  if(!d->nc)
    d->nc = 1;

  if(!d->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, d->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha1);

  if(d->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
","
  /* not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

#if defined(USE_WINDOWS_SSPI)
  have_chlg = digest->input_token ? TRUE : FALSE;
#else
  have_chlg = digest->nonce ? TRUE : FALSE;
#endif

  if(!have_chlg) {
    authp->done = FALSE;
    return CURLE_OK;
  }

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
",352,112,392,-1,"(""%s:%s:%s"";",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_272.cpp,"{
  /* We have a Digest setup for this, use it!  Now, to get all the details for
     this sorted out, I must urge you dear friend to read up on the RFC2617
     section 3.2.2, */
  size_t urilen;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *tmp = NULL;
  char **allocuserpwd;
  size_t userlen;
  const char *userp;
  char *userp_quoted;
  const char *passwdp;
  struct auth *authp;

  struct SessionHandle *data = conn->data;
  struct digestdata *d;
  CURLcode rc;
/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  rc = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(rc != CURLE_OK) { \
    free(b); \
    return rc; \
  }

  if(proxy) {
    d = &data->state.proxydigest;
    allocuserpwd = &conn->allocptr.proxyuserpwd;
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    authp = &data->state.authproxy;
  }
  else {
    d = &data->state.digest;
    allocuserpwd = &conn->allocptr.userpwd;
    userp = conn->user;
    passwdp = conn->passwd;
    authp = &data->state.authhost;
  }

  Curl_safefree(*allocuserpwd);

  /* not set means empty */
  if(!userp)
    userp="""";

  if(!passwdp)
    passwdp="""";

  if(!d->nonce) {
    authp->done = FALSE;
    return CURLE_OK;
  }
  authp->done = TRUE;

  if(!d->nc)
    d->nc = 1;

  if(!d->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, d->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha1);

  if(d->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
     do the Digest IE-style. Note that the different ways cause different MD5
     sums to get sent.

     Apache servers can be set to do the Digest IE-style automatically using
     the BrowserMatch feature:
     http://httpd.apache.org/docs/2.2/mod/mod_auth_digest.html#msie

     Further details on Digest implementation differences:
     http://www.fngtps.com/2006/09/http-authentication
  */

  if(authp->iestyle && ((tmp = strchr((char *)uripath, '?')) != NULL))
    urilen = tmp - (char *)uripath;
  else
    urilen = strlen((char *)uripath);

  md5this = (unsigned char *)aprintf(""%s:%.*s"", request, urilen, uripath);

  if(d->qop && Curl_raw_equal(d->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    Curl_safefree(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha2);

  if(d->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       d->nonce,
                                       d->nc,
                                       d->cnonce,
                                       d->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       d->nonce,
                                       ha2);
  }
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(d->qop) {
    *allocuserpwd =
      aprintf( ""%sAuthorization: Digest ""
               ""username=\""%s\"", ""
               ""realm=\""%s\"", ""
               ""nonce=\""%s\"", ""
               ""uri=\""%.*s\"", ""
               ""cnonce=\""%s\"", ""
               ""nc=%08x, ""
               ""qop=%s, ""
               ""response=\""%s\"""",
               proxy?""Proxy-"":"""",
               userp_quoted,
               d->realm,
               d->nonce,
               urilen, uripath, /* this is the PATH part of the URL */
               d->cnonce,
               d->nc,
               d->qop,
               request_digest);

    if(Curl_raw_equal(d->qop, ""auth""))
      d->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0 padded
                  which tells to the server how many times you are using the
                  same nonce in the qop=auth mode. */
  }
  else {
    *allocuserpwd =
      aprintf( ""%sAuthorization: Digest ""
               ""username=\""%s\"", ""
               ""realm=\""%s\"", ""
               ""nonce=\""%s\"", ""
               ""uri=\""%.*s\"", ""
               ""response=\""%s\"""",
               proxy?""Proxy-"":"""",
               userp_quoted,
               d->realm,
               d->nonce,
               urilen, uripath, /* this is the PATH part of the URL */
               request_digest);
  }
  Curl_safefree(userp_quoted);
  if(!*allocuserpwd)
    return CURLE_OUT_OF_MEMORY;

  /* Add optional fields */
  if(d->opaque) {
    /* append opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", *allocuserpwd, d->opaque);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    free(*allocuserpwd);
    *allocuserpwd = tmp;
  }

  if(d->algorithm) {
    /* append algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", *allocuserpwd, d->algorithm);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    free(*allocuserpwd);
    *allocuserpwd = tmp;
  }

  /* append CRLF + zero (3 bytes) to the userpwd header */
  userlen = strlen(*allocuserpwd);
  tmp = realloc(*allocuserpwd, userlen + 3);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;
  strcpy(&tmp[userlen], ""\r\n""); /* append the data */
  *allocuserpwd = tmp;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_272.cpp,"[24, 0, 0, 0, 0, 0, 12, 0, 0, 0, 29, 0, 0, 0, 2, 408, 0, 0, 20, 20, 0, 0, 5, 43, 0, 0, 0, 0, 12, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 161, 2, 227, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 22, 0, 6, 0, 26, 26, 6, 0, 47, 2, 0, 59, 0, 115, 1, 0, 1, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_272.cpp,operator****literal****expr****expr_stmt****unit****,2015-08-12T19:43:52,Brad King,107
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_517.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_517.cpp,"
  /* not set means empty */
  if(!userp)
    userp="""";

  if(!passwdp)
    passwdp="""";

  if(!d->nonce) {
    authp->done = FALSE;
    return CURLE_OK;
  }
  authp->done = TRUE;

  if(!d->nc)
    d->nc = 1;

  if(!d->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, d->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha1);

  if(d->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
","
  /* not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

#if defined(USE_WINDOWS_SSPI)
  have_chlg = digest->input_token ? TRUE : FALSE;
#else
  have_chlg = digest->nonce ? TRUE : FALSE;
#endif

  if(!have_chlg) {
    authp->done = FALSE;
    return CURLE_OK;
  }

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
",352,112,403,-1,"tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_273.cpp,"{
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_273.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 5, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_273.cpp,"name****operator****name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T19:43:52,Brad King,93
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_518.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_518.cpp,"
#include ""curl_setup.h""

#ifdef HAVE_GSSAPI
#ifdef HAVE_OLD_GSSMIT
#define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
#define NCOMPAT 1
#endif

#ifndef CURL_DISABLE_HTTP

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_memory.h""
#include ""url.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

static int
get_gss_name(struct connectdata *conn, bool proxy, gss_name_t *server)
{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service)  1  strlen(proxy ? conn->proxy.name :
                                              conn->host.name)  1;
  if(token.length  1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}

static void
log_gss_error(struct connectdata *conn, OM_uint32 error_status,
              const char *prefix)
{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len  status_string.length  1) {
        snprintf(buf  len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len = status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}

/* returning zero (0) means success, everything else is treated as ""failure""
   with no care exactly what the failure was */
int Curl_input_negotiate(struct connectdata *conn, bool proxy,
                         const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  int ret;
  size_t len;
  size_t rawlen = 0;
  CURLcode error;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return -1;
  }

  if(neg_ctx->server_name == NULL &&
      (ret = get_gss_name(conn, proxy, &neg_ctx->server_name)))
    return ret;

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    error = Curl_base64_decode(header,
                               (unsigned char **)&input_token.value, &rawlen);
    if(error || rawlen == 0)
      return -1;
    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
","
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
",22,22,61,-1,"snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_274.cpp,"{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service) + 1 + strlen(proxy ? conn->proxy.name :
                                              conn->host.name) + 1;
  if(token.length + 1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_274.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 1, 57, 0, 0, 4, 5, 0, 0, 2, 8, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 3, 33, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 4, 4, 3, 0, 7, 0, 0, 4, 0, 14, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_274.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****expr****argument
name****expr****condition****name****operator****name****operator****name****name****expr****then****name****operator****name****operator****name****name****expr****else****ternary****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T19:43:52,Brad King,66
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_518.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_518.cpp,"
#include ""curl_setup.h""

#ifdef HAVE_GSSAPI
#ifdef HAVE_OLD_GSSMIT
#define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
#define NCOMPAT 1
#endif

#ifndef CURL_DISABLE_HTTP

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_memory.h""
#include ""url.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

static int
get_gss_name(struct connectdata *conn, bool proxy, gss_name_t *server)
{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service)  1  strlen(proxy ? conn->proxy.name :
                                              conn->host.name)  1;
  if(token.length  1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}

static void
log_gss_error(struct connectdata *conn, OM_uint32 error_status,
              const char *prefix)
{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len  status_string.length  1) {
        snprintf(buf  len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len = status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}

/* returning zero (0) means success, everything else is treated as ""failure""
   with no care exactly what the failure was */
int Curl_input_negotiate(struct connectdata *conn, bool proxy,
                         const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  int ret;
  size_t len;
  size_t rawlen = 0;
  CURLcode error;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return -1;
  }

  if(neg_ctx->server_name == NULL &&
      (ret = get_gss_name(conn, proxy, &neg_ctx->server_name)))
    return ret;

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    error = Curl_base64_decode(header,
                               (unsigned char **)&input_token.value, &rawlen);
    if(error || rawlen == 0)
      return -1;
    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
","
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
",22,22,83,-1,"snprintf(buf, sizeof(buf), ""%s"", prefix);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_275.cpp,"{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len + status_string.length + 1) {
        snprintf(buf + len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len += status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_275.cpp,"[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 56, 0, 0, 5, 6, 0, 0, 1, 7, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 35, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 1, 0, 2, 1, 0, 0, 10, 0, 0, 7, 0, 24, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_275.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T19:43:52,Brad King,88
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_518.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_518.cpp,"
#include ""curl_setup.h""

#ifdef HAVE_GSSAPI
#ifdef HAVE_OLD_GSSMIT
#define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
#define NCOMPAT 1
#endif

#ifndef CURL_DISABLE_HTTP

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_memory.h""
#include ""url.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

static int
get_gss_name(struct connectdata *conn, bool proxy, gss_name_t *server)
{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service)  1  strlen(proxy ? conn->proxy.name :
                                              conn->host.name)  1;
  if(token.length  1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}

static void
log_gss_error(struct connectdata *conn, OM_uint32 error_status,
              const char *prefix)
{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len  status_string.length  1) {
        snprintf(buf  len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len = status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}

/* returning zero (0) means success, everything else is treated as ""failure""
   with no care exactly what the failure was */
int Curl_input_negotiate(struct connectdata *conn, bool proxy,
                         const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  int ret;
  size_t len;
  size_t rawlen = 0;
  CURLcode error;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return -1;
  }

  if(neg_ctx->server_name == NULL &&
      (ret = get_gss_name(conn, proxy, &neg_ctx->server_name)))
    return ret;

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    error = Curl_base64_decode(header,
                               (unsigned char **)&input_token.value, &rawlen);
    if(error || rawlen == 0)
      return -1;
    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
","
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
",22,22,93,-1,"snprintf(buf + len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_276.cpp,"{
        snprintf(buf + len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len += status_string.length;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_276.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_276.cpp,"name****name****operator****name****expr****argument
name****expr****argument
argument_list****sizeof****operator****name****expr****argument
literal****expr****argument
operator****name****operator****operator****name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T19:43:52,Brad King,67
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_534.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_534.cpp,"        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);

          if(conn->bits.tunnel_proxy ||
             conn->proxytype == CURLPROXY_SOCKS5 ||
             conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
             conn->proxytype == CURLPROXY_SOCKS4 ||
             conn->proxytype == CURLPROXY_SOCKS4A)
            /* proxy tunnel -> use other host info because ip_addr_str is the
               proxy address not the ftp host */
            snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name);
          else
            /* use the same IP we are already connected to */
            snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str);
        }
      }
      else
","        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);
          ftpc->newhost = strdup(control_address(conn));
          if(!ftpc->newhost)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else
",1933,1967,1944,-1,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_277.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_277.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_277.cpp,"name****name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T18:18:06,Brad King,96
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_534.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_534.cpp,"        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);

          if(conn->bits.tunnel_proxy ||
             conn->proxytype == CURLPROXY_SOCKS5 ||
             conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
             conn->proxytype == CURLPROXY_SOCKS4 ||
             conn->proxytype == CURLPROXY_SOCKS4A)
            /* proxy tunnel -> use other host info because ip_addr_str is the
               proxy address not the ftp host */
            snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name);
          else
            /* use the same IP we are already connected to */
            snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str);
        }
      }
      else
","        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);
          ftpc->newhost = strdup(control_address(conn));
          if(!ftpc->newhost)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else
",1933,1967,1948,-1,"snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_278.cpp,"snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_278.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_278.cpp,"name****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T18:18:06,Brad King,62
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_535.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_535.cpp,"
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the one we used
         for the control connection */
      infof(data, ""Skips %d.%d.%d.%d for data connection, uses %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->ip_addr_str);
      if(conn->bits.tunnel_proxy ||
         conn->proxytype == CURLPROXY_SOCKS5 ||
         conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
         conn->proxytype == CURLPROXY_SOCKS4 ||
         conn->proxytype == CURLPROXY_SOCKS4A)
        /* proxy tunnel -> use other host info because ip_addr_str is the
           proxy address not the ftp host */
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name);
      else
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str);
    }
    else
      snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);
    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
","
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the host we used
         for the control connection */
      infof(data, ""Skip %d.%d.%d.%d for data connection, re-use %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->host.name);
      ftpc->newhost = strdup(control_address(conn));
    }
    else
      ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);

    if(!ftpc->newhost)
      return CURLE_OUT_OF_MEMORY;

    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
",1986,2010,2001,-1,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_279.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_279.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_279.cpp,"name****name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T18:18:06,Brad King,96
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_535.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_535.cpp,"
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the one we used
         for the control connection */
      infof(data, ""Skips %d.%d.%d.%d for data connection, uses %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->ip_addr_str);
      if(conn->bits.tunnel_proxy ||
         conn->proxytype == CURLPROXY_SOCKS5 ||
         conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
         conn->proxytype == CURLPROXY_SOCKS4 ||
         conn->proxytype == CURLPROXY_SOCKS4A)
        /* proxy tunnel -> use other host info because ip_addr_str is the
           proxy address not the ftp host */
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name);
      else
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str);
    }
    else
      snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);
    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
","
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the host we used
         for the control connection */
      infof(data, ""Skip %d.%d.%d.%d for data connection, re-use %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->host.name);
      ftpc->newhost = strdup(control_address(conn));
    }
    else
      ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);

    if(!ftpc->newhost)
      return CURLE_OUT_OF_MEMORY;

    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
",1986,2010,2003,-1,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_280.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_280.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_280.cpp,"name****name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T18:18:06,Brad King,63
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_535.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_535.cpp,"
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the one we used
         for the control connection */
      infof(data, ""Skips %d.%d.%d.%d for data connection, uses %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->ip_addr_str);
      if(conn->bits.tunnel_proxy ||
         conn->proxytype == CURLPROXY_SOCKS5 ||
         conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
         conn->proxytype == CURLPROXY_SOCKS4 ||
         conn->proxytype == CURLPROXY_SOCKS4A)
        /* proxy tunnel -> use other host info because ip_addr_str is the
           proxy address not the ftp host */
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name);
      else
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str);
    }
    else
      snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);
    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
","
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the host we used
         for the control connection */
      infof(data, ""Skip %d.%d.%d.%d for data connection, re-use %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->host.name);
      ftpc->newhost = strdup(control_address(conn));
    }
    else
      ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);

    if(!ftpc->newhost)
      return CURLE_OUT_OF_MEMORY;

    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
",1986,2010,2007,2021,"snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);","ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_281.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_281.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_281.cpp,"name****name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
name****literal****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T18:18:06,Brad King,64
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_285.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_285.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_537.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_537.cpp,"    if(((httpreq == HTTPREQ_GET) || (httpreq == HTTPREQ_HEAD)) &&
       !Curl_checkheaders(conn, ""Range:"")) {
      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);
    }
    else if((httpreq != HTTPREQ_GET) &&
            !Curl_checkheaders(conn, ""Content-Range:"")) {

      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);

      if(data->set.set_resume_from < 0) {
        /* Upload resume was asked for, but we don't know the size of the
","    if(((httpreq == HTTPREQ_GET) || (httpreq == HTTPREQ_HEAD)) &&
       !Curl_checkheaders(conn, ""Range:"")) {
      /* if a line like this was already allocated, free the previous one */
      free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);
    }
    else if((httpreq != HTTPREQ_GET) &&
            !Curl_checkheaders(conn, ""Content-Range:"")) {

      /* if a line like this was already allocated, free the previous one */
      free(conn->allocptr.rangeline);

      if(data->set.set_resume_from < 0) {
        /* Upload resume was asked for, but we don't know the size of the
",2153,2198,2158,2202,"conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);","conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_282.cpp,"{
      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_282.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_282.cpp,"name****operator****name****operator****name****name****operator****name****literal****expr****argument
name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T18:18:06,Brad King,65
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_538.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_538.cpp,"
#include ""urldata.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""curl_md5.h""
#include ""http_digest.h""
#include ""strtok.h""
#include ""curl_memory.h""
#include ""vtls/vtls.h"" /* for Curl_rand() */
#include ""non-ascii.h"" /* included for Curl_convert_... prototypes */
#include ""warnless.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

#define MAX_VALUE_LENGTH 256
#define MAX_CONTENT_LENGTH 1024

static void digest_cleanup_one(struct digestdata *dig);

/*
 * Return 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
static int get_pair(const char *str, char *value, char *content,
                    const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c=MAX_VALUE_LENGTH-1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value=0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c=MAX_CONTENT_LENGTH-1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c=0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c=0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c=0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content=0;

  *endptr = str;

  return 0; /* all is fine! */
}

/* Test example headers:

WWW-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""
Proxy-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""

*/

CURLdigest Curl_input_digest(struct connectdata *conn,
                             bool proxy,
                             const char *header) /* rest of the *-authenticate:
                                                    header */
{
  char *token = NULL;
  char *tmp = NULL;
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  struct SessionHandle *data=conn->data;
  bool before = FALSE; /* got a nonce before */
  struct digestdata *d;

  if(proxy) {
    d = &data->state.proxydigest;
  }
  else {
    d = &data->state.digest;
  }

  if(checkprefix(""Digest"", header)) {
    header = strlen(""Digest"");

    /* If we already have received a nonce, keep that in mind */
    if(d->nonce)
      before = TRUE;

    /* clear off any former leftovers and init to defaults */
    digest_cleanup_one(d);

    for(;;) {
      char value[MAX_VALUE_LENGTH];
      char content[MAX_CONTENT_LENGTH];

      while(*header && ISSPACE(*header))
        headerï¿½;

      /* extract a value=content pair */
      if(!get_pair(header, value, content, &header)) {
        if(Curl_raw_equal(value, ""nonce"")) {
          d->nonce = strdup(content);
          if(!d->nonce)
            return CURLDIGEST_NOMEM;
        }
        else if(Curl_raw_equal(value, ""stale"")) {
          if(Curl_raw_equal(content, ""true"")) {
            d->stale = TRUE;
            d->nc = 1; /* we make a new nonce now */
          }
        }
        else if(Curl_raw_equal(value, ""realm"")) {
          d->realm = strdup(content);
          if(!d->realm)
            return CURLDIGEST_NOMEM;
        }
        else if(Curl_raw_equal(value, ""opaque"")) {
          d->opaque = strdup(content);
          if(!d->opaque)
            return CURLDIGEST_NOMEM;
        }
        else if(Curl_raw_equal(value, ""qop"")) {
          char *tok_buf;
          /* tokenize the list and choose auth if possible, use a temporary
             clone of the buffer since strtok_r() ruins it */
          tmp = strdup(content);
          if(!tmp)
            return CURLDIGEST_NOMEM;
          token = strtok_r(tmp, "","", &tok_buf);
          while(token != NULL) {
            if(Curl_raw_equal(token, ""auth"")) {
              foundAuth = TRUE;
            }
            else if(Curl_raw_equal(token, ""auth-int"")) {
              foundAuthInt = TRUE;
            }
            token = strtok_r(NULL, "","", &tok_buf);
          }
          free(tmp);
          /*select only auth o auth-int. Otherwise, ignore*/
          if(foundAuth) {
            d->qop = strdup(""auth"");
            if(!d->qop)
              return CURLDIGEST_NOMEM;
          }
          else if(foundAuthInt) {
            d->qop = strdup(""auth-int"");
            if(!d->qop)
              return CURLDIGEST_NOMEM;
          }
        }
        else if(Curl_raw_equal(value, ""algorithm"")) {
          d->algorithm = strdup(content);
          if(!d->algorithm)
            return CURLDIGEST_NOMEM;
          if(Curl_raw_equal(content, ""MD5-sess""))
            d->algo = CURLDIGESTALGO_MD5SESS;
          else if(Curl_raw_equal(content, ""MD5""))
            d->algo = CURLDIGESTALGO_MD5;
          else
            return CURLDIGEST_BADALGO;
        }
        else {
          /* unknown specifier, ignore it! */
        }
      }
      else
        break; /* we're done here */

      /* pass all additional spaces here */
      while(*header && ISSPACE(*header))
        headerï¿½;
      if(',' == *header)
        /* allow the list to be comma-separated */
        headerï¿½;
    }
    /* We had a nonce since before, and we got another one now without
       'stale=true'. This means we provided bad credentials in the previous
       request */
    if(before && !d->stale)
      return CURLDIGEST_BAD;

    /* We got this header without a nonce, that's a bad Digest line! */
    if(!d->nonce)
      return CURLDIGEST_BAD;
  }
  else
    /* else not a digest, get out */
    return CURLDIGEST_NONE;

  return CURLDIGEST_FINE;
}

/* convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void md5_to_ascii(unsigned char *source, /* 16 bytes */
                         unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i=0; i<16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

CURLcode Curl_output_digest(struct connectdata *conn,
                            bool proxy,
                            const unsigned char *request,
                            const unsigned char *uripath)
{
  /* We have a Digest setup for this, use it!  Now, to get all the details for
     this sorted out, I must urge you dear friend to read up on the RFC2617
     section 3.2.2, */
  size_t urilen;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *tmp = NULL;
  char **allocuserpwd;
  size_t userlen;
  const char *userp;
  char *userp_quoted;
  const char *passwdp;
  struct auth *authp;

  struct SessionHandle *data = conn->data;
  struct digestdata *d;
  CURLcode rc;
/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  rc = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(rc != CURLE_OK) { \
    free(b); \
    return rc; \
  }

  if(proxy) {
    d = &data->state.proxydigest;
    allocuserpwd = &conn->allocptr.proxyuserpwd;
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    authp = &data->state.authproxy;
  }
  else {
    d = &data->state.digest;
    allocuserpwd = &conn->allocptr.userpwd;
    userp = conn->user;
    passwdp = conn->passwd;
","
#include ""urldata.h""
#include ""rawstr.h""
#include ""curl_sasl.h""
#include ""http_digest.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

/* Test example headers:

WWW-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""
Proxy-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""

*/

CURLcode Curl_input_digest(struct connectdata *conn,
                           bool proxy,
                           const char *header) /* rest of the *-authenticate:
                                                  header */
{
  struct SessionHandle *data = conn->data;

  /* Point to the correct struct with this */
  struct digestdata *digest;

  if(proxy) {
    digest = &data->state.proxydigest;
  }
  else {
    digest = &data->state.digest;
  }

  if(!checkprefix(""Digest"", header))
    return CURLE_BAD_CONTENT_ENCODING;

  header = strlen(""Digest"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  return Curl_sasl_decode_digest_http_message(header, digest);
}

CURLcode Curl_output_digest(struct connectdata *conn,
                            bool proxy,
                            const unsigned char *request,
                            const unsigned char *uripath)
{
  CURLcode result;
  struct SessionHandle *data = conn->data;
  unsigned char *path;
  char *tmp;
  char *response;
  size_t len;
  bool have_chlg;

  /* Point to the address of the pointer that holds the string to send to the
     server, which is for a plain host or for a HTTP proxy */
  char **allocuserpwd;

  /* Point to the name and password for this */
  const char *userp;
  const char *passwdp;

  /* Point to the correct struct with this */
  struct digestdata *digest;
  struct auth *authp;

  if(proxy) {
    digest = &data->state.proxydigest;
    allocuserpwd = &conn->allocptr.proxyuserpwd;
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    authp = &data->state.authproxy;
  }
  else {
    digest = &data->state.digest;
    allocuserpwd = &conn->allocptr.userpwd;
    userp = conn->user;
    passwdp = conn->passwd;
",26,26,262,-1,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_283.cpp,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_283.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_283.cpp,"name****operator****name****operator****operator****operator****name****name****operator****literal****expr****index****name****expr****argument
literal****expr****argument
literal****expr****argument
name****name****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T18:18:06,Brad King,91
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_539.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_539.cpp,"
  /* not set means empty */
  if(!userp)
    userp="""";

  if(!passwdp)
    passwdp="""";

  if(!d->nonce) {
    authp->done = FALSE;
    return CURLE_OK;
  }
  authp->done = TRUE;

  if(!d->nc)
    d->nc = 1;

  if(!d->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, d->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha1);

  if(d->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
","
  /* not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

#if defined(USE_WINDOWS_SSPI)
  have_chlg = digest->input_token ? TRUE : FALSE;
#else
  have_chlg = digest->nonce ? TRUE : FALSE;
#endif

  if(!have_chlg) {
    authp->done = FALSE;
    return CURLE_OK;
  }

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
",352,112,370,-1,"snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_284.cpp,"{
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_284.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 23, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 8, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_284.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T18:18:06,Brad King,92
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_539.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_539.cpp,"
  /* not set means empty */
  if(!userp)
    userp="""";

  if(!passwdp)
    passwdp="""";

  if(!d->nonce) {
    authp->done = FALSE;
    return CURLE_OK;
  }
  authp->done = TRUE;

  if(!d->nc)
    d->nc = 1;

  if(!d->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, d->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha1);

  if(d->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
","
  /* not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

#if defined(USE_WINDOWS_SSPI)
  have_chlg = digest->input_token ? TRUE : FALSE;
#else
  have_chlg = digest->nonce ? TRUE : FALSE;
#endif

  if(!have_chlg) {
    authp->done = FALSE;
    return CURLE_OK;
  }

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
",352,112,392,-1,"(""%s:%s:%s"";",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_285.cpp,"{
  /* We have a Digest setup for this, use it!  Now, to get all the details for
     this sorted out, I must urge you dear friend to read up on the RFC2617
     section 3.2.2, */
  size_t urilen;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *tmp = NULL;
  char **allocuserpwd;
  size_t userlen;
  const char *userp;
  char *userp_quoted;
  const char *passwdp;
  struct auth *authp;

  struct SessionHandle *data = conn->data;
  struct digestdata *d;
  CURLcode rc;
/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  rc = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(rc != CURLE_OK) { \
    free(b); \
    return rc; \
  }

  if(proxy) {
    d = &data->state.proxydigest;
    allocuserpwd = &conn->allocptr.proxyuserpwd;
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    authp = &data->state.authproxy;
  }
  else {
    d = &data->state.digest;
    allocuserpwd = &conn->allocptr.userpwd;
    userp = conn->user;
    passwdp = conn->passwd;
    authp = &data->state.authhost;
  }

  Curl_safefree(*allocuserpwd);

  /* not set means empty */
  if(!userp)
    userp="""";

  if(!passwdp)
    passwdp="""";

  if(!d->nonce) {
    authp->done = FALSE;
    return CURLE_OK;
  }
  authp->done = TRUE;

  if(!d->nc)
    d->nc = 1;

  if(!d->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, d->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha1);

  if(d->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
     do the Digest IE-style. Note that the different ways cause different MD5
     sums to get sent.

     Apache servers can be set to do the Digest IE-style automatically using
     the BrowserMatch feature:
     http://httpd.apache.org/docs/2.2/mod/mod_auth_digest.html#msie

     Further details on Digest implementation differences:
     http://www.fngtps.com/2006/09/http-authentication
  */

  if(authp->iestyle && ((tmp = strchr((char *)uripath, '?')) != NULL))
    urilen = tmp - (char *)uripath;
  else
    urilen = strlen((char *)uripath);

  md5this = (unsigned char *)aprintf(""%s:%.*s"", request, urilen, uripath);

  if(d->qop && Curl_raw_equal(d->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    Curl_safefree(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha2);

  if(d->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       d->nonce,
                                       d->nc,
                                       d->cnonce,
                                       d->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       d->nonce,
                                       ha2);
  }
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(d->qop) {
    *allocuserpwd =
      aprintf( ""%sAuthorization: Digest ""
               ""username=\""%s\"", ""
               ""realm=\""%s\"", ""
               ""nonce=\""%s\"", ""
               ""uri=\""%.*s\"", ""
               ""cnonce=\""%s\"", ""
               ""nc=%08x, ""
               ""qop=%s, ""
               ""response=\""%s\"""",
               proxy?""Proxy-"":"""",
               userp_quoted,
               d->realm,
               d->nonce,
               urilen, uripath, /* this is the PATH part of the URL */
               d->cnonce,
               d->nc,
               d->qop,
               request_digest);

    if(Curl_raw_equal(d->qop, ""auth""))
      d->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0 padded
                  which tells to the server how many times you are using the
                  same nonce in the qop=auth mode. */
  }
  else {
    *allocuserpwd =
      aprintf( ""%sAuthorization: Digest ""
               ""username=\""%s\"", ""
               ""realm=\""%s\"", ""
               ""nonce=\""%s\"", ""
               ""uri=\""%.*s\"", ""
               ""response=\""%s\"""",
               proxy?""Proxy-"":"""",
               userp_quoted,
               d->realm,
               d->nonce,
               urilen, uripath, /* this is the PATH part of the URL */
               request_digest);
  }
  Curl_safefree(userp_quoted);
  if(!*allocuserpwd)
    return CURLE_OUT_OF_MEMORY;

  /* Add optional fields */
  if(d->opaque) {
    /* append opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", *allocuserpwd, d->opaque);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    free(*allocuserpwd);
    *allocuserpwd = tmp;
  }

  if(d->algorithm) {
    /* append algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", *allocuserpwd, d->algorithm);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    free(*allocuserpwd);
    *allocuserpwd = tmp;
  }

  /* append CRLF + zero (3 bytes) to the userpwd header */
  userlen = strlen(*allocuserpwd);
  tmp = realloc(*allocuserpwd, userlen + 3);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;
  strcpy(&tmp[userlen], ""\r\n""); /* append the data */
  *allocuserpwd = tmp;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_285.cpp,"[24, 0, 0, 0, 0, 0, 12, 0, 0, 0, 29, 0, 0, 0, 2, 408, 0, 0, 20, 20, 0, 0, 5, 43, 0, 0, 0, 0, 12, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 161, 2, 227, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 22, 0, 6, 0, 26, 26, 6, 0, 47, 2, 0, 59, 0, 115, 1, 0, 1, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_285.cpp,operator****literal****expr****expr_stmt****unit****,2015-08-12T18:18:06,Brad King,107
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_539.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_539.cpp,"
  /* not set means empty */
  if(!userp)
    userp="""";

  if(!passwdp)
    passwdp="""";

  if(!d->nonce) {
    authp->done = FALSE;
    return CURLE_OK;
  }
  authp->done = TRUE;

  if(!d->nc)
    d->nc = 1;

  if(!d->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, d->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha1);

  if(d->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
","
  /* not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

#if defined(USE_WINDOWS_SSPI)
  have_chlg = digest->input_token ? TRUE : FALSE;
#else
  have_chlg = digest->nonce ? TRUE : FALSE;
#endif

  if(!have_chlg) {
    authp->done = FALSE;
    return CURLE_OK;
  }

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
",352,112,403,-1,"tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_286.cpp,"{
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_286.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 5, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_286.cpp,"name****operator****name****literal****expr****argument
name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T18:18:06,Brad King,93
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_540.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_540.cpp,"
#include ""curl_setup.h""

#ifdef HAVE_GSSAPI
#ifdef HAVE_OLD_GSSMIT
#define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
#define NCOMPAT 1
#endif

#ifndef CURL_DISABLE_HTTP

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_memory.h""
#include ""url.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

static int
get_gss_name(struct connectdata *conn, bool proxy, gss_name_t *server)
{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service)  1  strlen(proxy ? conn->proxy.name :
                                              conn->host.name)  1;
  if(token.length  1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}

static void
log_gss_error(struct connectdata *conn, OM_uint32 error_status,
              const char *prefix)
{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len  status_string.length  1) {
        snprintf(buf  len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len = status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}

/* returning zero (0) means success, everything else is treated as ""failure""
   with no care exactly what the failure was */
int Curl_input_negotiate(struct connectdata *conn, bool proxy,
                         const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  int ret;
  size_t len;
  size_t rawlen = 0;
  CURLcode error;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return -1;
  }

  if(neg_ctx->server_name == NULL &&
      (ret = get_gss_name(conn, proxy, &neg_ctx->server_name)))
    return ret;

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    error = Curl_base64_decode(header,
                               (unsigned char **)&input_token.value, &rawlen);
    if(error || rawlen == 0)
      return -1;
    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
","
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
",22,22,61,-1,"snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_287.cpp,"{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service) + 1 + strlen(proxy ? conn->proxy.name :
                                              conn->host.name) + 1;
  if(token.length + 1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_287.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 1, 57, 0, 0, 4, 5, 0, 0, 2, 8, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 3, 33, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 4, 4, 3, 0, 7, 0, 0, 4, 0, 14, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_287.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****expr****argument
name****expr****condition****name****operator****name****operator****name****name****expr****then****name****operator****name****operator****name****name****expr****else****ternary****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T18:18:06,Brad King,66
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_540.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_540.cpp,"
#include ""curl_setup.h""

#ifdef HAVE_GSSAPI
#ifdef HAVE_OLD_GSSMIT
#define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
#define NCOMPAT 1
#endif

#ifndef CURL_DISABLE_HTTP

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_memory.h""
#include ""url.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

static int
get_gss_name(struct connectdata *conn, bool proxy, gss_name_t *server)
{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service)  1  strlen(proxy ? conn->proxy.name :
                                              conn->host.name)  1;
  if(token.length  1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}

static void
log_gss_error(struct connectdata *conn, OM_uint32 error_status,
              const char *prefix)
{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len  status_string.length  1) {
        snprintf(buf  len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len = status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}

/* returning zero (0) means success, everything else is treated as ""failure""
   with no care exactly what the failure was */
int Curl_input_negotiate(struct connectdata *conn, bool proxy,
                         const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  int ret;
  size_t len;
  size_t rawlen = 0;
  CURLcode error;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return -1;
  }

  if(neg_ctx->server_name == NULL &&
      (ret = get_gss_name(conn, proxy, &neg_ctx->server_name)))
    return ret;

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    error = Curl_base64_decode(header,
                               (unsigned char **)&input_token.value, &rawlen);
    if(error || rawlen == 0)
      return -1;
    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
","
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
",22,22,83,-1,"snprintf(buf, sizeof(buf), ""%s"", prefix);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_288.cpp,"{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len + status_string.length + 1) {
        snprintf(buf + len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len += status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_288.cpp,"[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 56, 0, 0, 5, 6, 0, 0, 1, 7, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 35, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 1, 0, 2, 1, 0, 0, 10, 0, 0, 7, 0, 24, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_288.cpp,"name****name****expr****argument
name****expr****argument
argument_list****sizeof****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T18:18:06,Brad King,88
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_540.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_540.cpp,"
#include ""curl_setup.h""

#ifdef HAVE_GSSAPI
#ifdef HAVE_OLD_GSSMIT
#define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
#define NCOMPAT 1
#endif

#ifndef CURL_DISABLE_HTTP

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_memory.h""
#include ""url.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

static int
get_gss_name(struct connectdata *conn, bool proxy, gss_name_t *server)
{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service)  1  strlen(proxy ? conn->proxy.name :
                                              conn->host.name)  1;
  if(token.length  1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}

static void
log_gss_error(struct connectdata *conn, OM_uint32 error_status,
              const char *prefix)
{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len  status_string.length  1) {
        snprintf(buf  len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len = status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}

/* returning zero (0) means success, everything else is treated as ""failure""
   with no care exactly what the failure was */
int Curl_input_negotiate(struct connectdata *conn, bool proxy,
                         const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  int ret;
  size_t len;
  size_t rawlen = 0;
  CURLcode error;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return -1;
  }

  if(neg_ctx->server_name == NULL &&
      (ret = get_gss_name(conn, proxy, &neg_ctx->server_name)))
    return ret;

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    error = Curl_base64_decode(header,
                               (unsigned char **)&input_token.value, &rawlen);
    if(error || rawlen == 0)
      return -1;
    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
","
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
",22,22,93,-1,"snprintf(buf + len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_289.cpp,"{
        snprintf(buf + len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len += status_string.length;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_289.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_289.cpp,"name****name****operator****name****expr****argument
name****expr****argument
argument_list****sizeof****operator****name****expr****argument
literal****expr****argument
operator****name****operator****operator****name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-12T18:18:06,Brad King,67
f8be9ba9c258698ed88a7510cf2ba3335491f3da,"cmGlobalGenerator: Base progress on Makefiles, not LocalGenerators.",[],Source/cmGlobalGenerator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_291.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_291.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_545.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_545.cpp,"  // update the cache entry for the number of local generators, this is used
  // for progress
  char num[100];
  sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_LOCAL_GENERATORS"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
","  // update the cache entry for the number of local generators, this is used
  // for progress
  char num[100];
  sprintf(num,""%d"",static_cast<int>(this->Makefiles.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_MAKEFILES"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
",1148,1148,1151,1151,"sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));","sprintf(num,""%d"",static_cast<int>(this->Makefiles.size()));",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_290.cpp,"{
  this->FirstTimeProgress = 0.0f;
  this->ClearGeneratorMembers();

  // start with this directory
  cmLocalGenerator *lg = this->MakeLocalGenerator();
  this->Makefiles.push_back(lg->GetMakefile());
  this->LocalGenerators.push_back(lg);

  // set the Start directories
  lg->GetMakefile()->SetCurrentSourceDirectory
    (this->CMakeInstance->GetHomeDirectory());
  lg->GetMakefile()->SetCurrentBinaryDirectory
    (this->CMakeInstance->GetHomeOutputDirectory());

  this->BinaryDirectories.insert(
      this->CMakeInstance->GetHomeOutputDirectory());

  // now do it
  lg->GetMakefile()->Configure();
  lg->GetMakefile()->EnforceDirectoryLevelRules();

  // update the cache entry for the number of local generators, this is used
  // for progress
  char num[100];
  sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_LOCAL_GENERATORS"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
  // and for infinite loops
  this->CheckLocalGenerators();

  // at this point this->LocalGenerators has been filled,
  // so create the map from project name to vector of local generators
  this->FillProjectMap();

  if ( this->CMakeInstance->GetWorkingMode() == cmake::NORMAL_MODE)
    {
    std::ostringstream msg;
    if(cmSystemTools::GetErrorOccuredFlag())
      {
      msg << ""Configuring incomplete, errors occurred!"";
      const char* logs[] = {""CMakeOutput.log"", ""CMakeError.log"", 0};
      for(const char** log = logs; *log; ++log)
        {
        std::string f = this->CMakeInstance->GetHomeOutputDirectory();
        f += this->CMakeInstance->GetCMakeFilesDirectory();
        f += ""/"";
        f += *log;
        if(cmSystemTools::FileExists(f.c_str()))
          {
          msg << ""\nSee also \"""" << f << ""\""."";
          }
        }
      }
    else
      {
      msg << ""Configuring done"";
      }
    this->CMakeInstance->UpdateProgress(msg.str().c_str(), -1);
    }

  unsigned int i;

  // Put a copy of each global target in every directory.
  cmTargets globalTargets;
  this->CreateDefaultGlobalTargets(&globalTargets);

  for (i = 0; i < this->LocalGenerators.size(); ++i)
    {
    cmMakefile* mf = this->LocalGenerators[i]->GetMakefile();
    cmTargets* targets = &(mf->GetTargets());
    cmTargets::iterator tit;
    for ( tit = globalTargets.begin(); tit != globalTargets.end(); ++ tit )
      {
      (*targets)[tit->first] = tit->second;
      (*targets)[tit->first].SetMakefile(mf);
      }
    }

}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_290.cpp,"[3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 2, 189, 0, 0, 10, 11, 0, 0, 9, 15, 0, 0, 0, 0, 6, 0, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 91, 0, 66, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 5, 0, 6, 3, 1, 0, 41, 0, 0, 23, 0, 19, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_290.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****name****operator****name****operator****name****name****argument_list****call****expr****argument
argument_list****cast****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-08-07T02:10:28,Stephen Kelly,61
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_292.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_292.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_546.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_546.cpp,"    if(cp->ErrorMessage[0] == 0)
      {
      /* Format the error message.  */
      DWORD original = GetLastError();
      wchar_t err_msg[KWSYSPE_PIPE_BUFFER_SIZE];
      DWORD length = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                                   FORMAT_MESSAGE_IGNORE_INSERTS, 0, original,
                                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                   err_msg, KWSYSPE_PIPE_BUFFER_SIZE, 0);
      WideCharToMultiByte(CP_UTF8, 0, err_msg, -1, cp->ErrorMessage,
                          KWSYSPE_PIPE_BUFFER_SIZE, NULL, NULL);
      if(length < 1)
        {
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError());
        }
      }

","    if(cp->ErrorMessage[0] == 0)
      {
      /* Format the error message.  */
      wchar_t err_msg[KWSYSPE_PIPE_BUFFER_SIZE];
      DWORD length = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                                   FORMAT_MESSAGE_IGNORE_INSERTS, 0, error,
                                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                   err_msg, KWSYSPE_PIPE_BUFFER_SIZE, 0);
      if(length < 1)
        {
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  error, GetLastError());
        }
      if(!WideCharToMultiByte(CP_UTF8, 0, err_msg, -1, cp->ErrorMessage,
                              KWSYSPE_PIPE_BUFFER_SIZE, NULL, NULL))
        {
        /* WideCharToMultiByte failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""WideCharToMultiByte failed with error 0x%X"",
                  error, GetLastError());
        }
      }

",1886,2007,1900,2018,"_snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError());","_snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  error, GetLastError());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_291.cpp,"{
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError());
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_291.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_291.cpp,"name****name****operator****name****name****expr****argument
name****expr****argument
literal****literal****expr****argument
name****expr****argument
name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-07-31T13:26:35,Brad King,68
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrlï¿½.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrlï¿½ and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_294.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_294.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_556.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_556.cpp,"    if(cp->ErrorMessage[0] == 0)
      {
      /* Format the error message.  */
      DWORD original = GetLastError();
      wchar_t err_msg[KWSYSPE_PIPE_BUFFER_SIZE];
      DWORD length = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                                   FORMAT_MESSAGE_IGNORE_INSERTS, 0, original,
                                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                   err_msg, KWSYSPE_PIPE_BUFFER_SIZE, 0);
      WideCharToMultiByte(CP_UTF8, 0, err_msg, -1, cp->ErrorMessage,
                          KWSYSPE_PIPE_BUFFER_SIZE, NULL, NULL);
      if(length < 1)
        {
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError());
        }
      }

","    if(cp->ErrorMessage[0] == 0)
      {
      /* Format the error message.  */
      wchar_t err_msg[KWSYSPE_PIPE_BUFFER_SIZE];
      DWORD length = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                                   FORMAT_MESSAGE_IGNORE_INSERTS, 0, error,
                                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                   err_msg, KWSYSPE_PIPE_BUFFER_SIZE, 0);
      if(length < 1)
        {
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  error, GetLastError());
        }
      if(!WideCharToMultiByte(CP_UTF8, 0, err_msg, -1, cp->ErrorMessage,
                              KWSYSPE_PIPE_BUFFER_SIZE, NULL, NULL))
        {
        /* WideCharToMultiByte failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""WideCharToMultiByte failed with error 0x%X"",
                  error, GetLastError());
        }
      }

",1886,2007,1900,2018,"_snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError());","_snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  error, GetLastError());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_292.cpp,"{
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError());
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_292.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_292.cpp,"name****name****operator****name****name****expr****argument
name****expr****argument
literal****literal****expr****argument
name****expr****argument
name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-07-31T13:26:30,Brad King,68
069aa93b555293679f4b8c07623133ba62a74ee4,"bindexplib: Add support for ""/bigobj"" format objects",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_566.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_566.cpp,"               }
            }
            if (symbol[0] == '_') symbol.erase(0,1);
            if (fImportFlag) {
               fImportFlag = 0;
               fprintf(fout,""EXPORTS \n"");
            }
            /*
            Check whether it is ""Scalar deleting destructor"" and
","               }
            }
            if (symbol[0] == '_') symbol.erase(0,1);
            if (this->ImportFlag) {
               this->ImportFlag = false;
               fprintf(this->FileOut,""EXPORTS \n"");
            }
            /*
            Check whether it is ""Scalar deleting destructor"" and
",209,288,214,293,"fprintf(fout,""EXPORTS \n"");","fprintf(this->FileOut,""EXPORTS \n"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_293.cpp,"{
               fImportFlag = 0;
               fprintf(fout,""EXPORTS \n"");
            }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_293.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_293.cpp,"name****name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-07-06T15:11:01,Brad King,69
069aa93b555293679f4b8c07623133ba62a74ee4,"bindexplib: Add support for ""/bigobj"" format objects",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_567.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_567.cpp,"                symbol.compare(0, 4, vectorPrefix) )
            {
               SectChar =
                pSectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  fprintf(fout, ""\t%s \t DATA\n"", symbol.c_str());
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     fprintf(fout, ""\t%s\n"", symbol.c_str());
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
","                symbol.compare(0, 4, vectorPrefix) )
            {
               SectChar =
                 this->
                 SectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str());
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     fprintf(this->FileOut, ""\t%s\n"", symbol.c_str());
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
",228,307,234,314,"fprintf(fout, ""\t%s \t DATA\n"", symbol.c_str());","fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_294.cpp,"{
                  // Read only (i.e. constants) must be excluded
                  fprintf(fout, ""\t%s \t DATA\n"", symbol.c_str());
               }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_294.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_294.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-07-06T15:11:01,Brad King,70
069aa93b555293679f4b8c07623133ba62a74ee4,"bindexplib: Add support for ""/bigobj"" format objects",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_567.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_567.cpp,"                symbol.compare(0, 4, vectorPrefix) )
            {
               SectChar =
                pSectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  fprintf(fout, ""\t%s \t DATA\n"", symbol.c_str());
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     fprintf(fout, ""\t%s\n"", symbol.c_str());
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
","                symbol.compare(0, 4, vectorPrefix) )
            {
               SectChar =
                 this->
                 SectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str());
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     fprintf(this->FileOut, ""\t%s\n"", symbol.c_str());
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
",228,307,238,318,"fprintf(fout, ""\t%s\n"", symbol.c_str());","fprintf(this->FileOut, ""\t%s\n"", symbol.c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_295.cpp,"{
                     fprintf(fout, ""\t%s\n"", symbol.c_str());
                  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_295.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_295.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-07-06T15:11:01,Brad King,70
069aa93b555293679f4b8c07623133ba62a74ee4,"bindexplib: Add support for ""/bigobj"" format objects",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_568.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_568.cpp,"            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!fImportFlag) {
               fImportFlag = 1;
               fprintf(fout,""IMPORTS \n"");
            }
            fprintf(fout, ""\t%s DATA \n"", symbol.c_str()ï¿½);
         }
      }

","            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!this->ImportFlag) {
               this->ImportFlag = true;
               fprintf(this->FileOut,""IMPORTS \n"");
            }
            fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()ï¿½);
         }
      }

",252,332,257,337,"fprintf(fout,""IMPORTS \n"");","fprintf(this->FileOut,""IMPORTS \n"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_296.cpp,"{
               fImportFlag = 1;
               fprintf(fout,""IMPORTS \n"");
            }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_296.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_296.cpp,"name****name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-07-06T15:11:01,Brad King,69
069aa93b555293679f4b8c07623133ba62a74ee4,"bindexplib: Add support for ""/bigobj"" format objects",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_568.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_568.cpp,"            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!fImportFlag) {
               fImportFlag = 1;
               fprintf(fout,""IMPORTS \n"");
            }
            fprintf(fout, ""\t%s DATA \n"", symbol.c_str()ï¿½);
         }
      }

","            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!this->ImportFlag) {
               this->ImportFlag = true;
               fprintf(this->FileOut,""IMPORTS \n"");
            }
            fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()ï¿½);
         }
      }

",252,332,259,339,"fprintf(fout, ""\t%s DATA \n"", symbol.c_str()+1);","fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()+1);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_297.cpp,"{
            symbol = stringTable + pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!fImportFlag) {
               fImportFlag = 1;
               fprintf(fout,""IMPORTS \n"");
            }
            fprintf(fout, ""\t%s DATA \n"", symbol.c_str()+1);
         }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_297.cpp,"[2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 2, 0, 0, 6, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_297.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****name****argument_list****call****operator****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-07-06T15:11:01,Brad King,5
de70c922d9c846cf3a6fabfbedd054c02f4b8934,"bindexplib: Teach DumpFile to return errors

This will allow callers to know if it worked.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_297.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_297.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_569.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_569.cpp,"      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file with CreateFile()\n"");
      return;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
","      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
      return false;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return false;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return false;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return false;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
",309,310,312,313,"fprintf(stderr, ""Couldn't open file with CreateFile()\n"");","fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_298.cpp,"{
      fprintf(stderr, ""Couldn't open file with CreateFile()\n"");
      return;
   }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_298.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_298.cpp,"name****name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-07-06T15:11:01,Brad King,6
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,264,-1,"fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_299.cpp,"{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; i++ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable + pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable++;
   }
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_299.cpp,"[2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 95, 0, 0, 5, 5, 0, 0, 1, 12, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 2, 1, 1, 0, 13, 0, 0, 15, 0, 32, 2, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_299.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-07-06T15:11:00,Brad King,108
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,267,-1,"fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_300.cpp,"{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; i++ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable + pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable++;
   }
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_300.cpp,"[2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 95, 0, 0, 5, 5, 0, 0, 1, 12, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 2, 1, 1, 0, 13, 0, 0, 15, 0, 32, 2, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_300.cpp,"name****name****expr****argument
literal****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-07-06T15:11:00,Brad King,7
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,277,-1,"fprintf(fout, ""%04X "", i);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_301.cpp,"{
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable + pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable++;
   }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_301.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 11, 0, 0, 12, 0, 27, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_301.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-07-06T15:11:00,Brad King,108
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,279,-1,"fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_302.cpp,"fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_302.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_302.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-07-06T15:11:00,Brad King,97
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,281,-1,"fprintf(fout, ""%-20s"", stringTable + pSymbolTable->N.Name.Long);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_303.cpp,"fprintf(fout, ""%-20s"", stringTable + pSymbolTable->N.Name.Long)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_303.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_303.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****operator****name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-07-06T15:11:00,Brad King,8
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,283,-1,"fprintf(fout, "" %08X"", pSymbolTable->Value);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_304.cpp,"{
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable + pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable++;
   }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_304.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 11, 0, 0, 12, 0, 27, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_304.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-07-06T15:11:00,Brad King,9
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,287,-1,"fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_305.cpp,"{
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable + pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable++;
   }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_305.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 11, 0, 0, 12, 0, 27, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_305.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****name****operator****name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-07-06T15:11:00,Brad King,10
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,294,-1,"fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_306.cpp,"{
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable + pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable++;
   }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_306.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 11, 0, 0, 12, 0, 27, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_306.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-07-06T15:11:00,Brad King,71
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,341,-1,"fprintf(fout, ""\t%s\n"", symbol.c_str());",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_307.cpp,"{
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable + pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()+1);
#endif
         }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_307.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 1, 49, 0, 0, 1, 1, 0, 0, 1, 8, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 2, 0, 7, 0, 0, 6, 0, 11, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_307.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-07-06T15:11:00,Brad King,71
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,343,-1,"fprintf(fout, ""\t%s\n"", symbol.c_str()+1);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_308.cpp,"{
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable + pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()+1);
#endif
         }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_308.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 1, 49, 0, 0, 1, 1, 0, 0, 1, 8, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 2, 0, 7, 0, 0, 6, 0, 11, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_308.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****name****argument_list****call****operator****literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-07-06T15:11:00,Brad King,11
59e21ffa134faf0b089d9a704b3763e7f6f237d5,Port static calls from cmLocalGenerator to cmOutputConverter.,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_302.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_302.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_576.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_576.cpp,"      std::string langFlags = ""CMAKE_""  *li  ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmLocalGenerator::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
","      std::string langFlags = ""CMAKE_""  *li  ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmOutputConverter::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
",322,322,324,324,"fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmLocalGenerator::EscapeForCMake(flags?flags:"""").c_str());","fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmOutputConverter::EscapeForCMake(flags?flags:"""").c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_309.cpp,"{
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmLocalGenerator::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_309.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 31, 0, 0, 2, 2, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 8, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_309.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****name****expr****condition****name****expr****then****literal****expr****else****ternary****expr****argument
argument_list****call****operator****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-06-06T07:15:58,Stephen Kelly,72
9486769866661e3aa76dd588ca5a7466e2969dc3,Don't use a cmLocalGenerator instance to call static methods.,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_304.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_304.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_578.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_578.cpp,"      std::string langFlags = ""CMAKE_""  *li  ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
","      std::string langFlags = ""CMAKE_""  *li  ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmLocalGenerator::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
",323,322,325,324,"fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());","fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmLocalGenerator::EscapeForCMake(flags?flags:"""").c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_310.cpp,"{
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_310.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 31, 0, 0, 2, 2, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 8, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_310.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****name****expr****condition****name****expr****then****literal****expr****else****ternary****expr****argument
argument_list****call****operator****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-05-14T18:30:09,Stephen Kelly,72
8521fdf56e4908676c28c6bbdda3f1fb2284d3d7,"Makefile: Fix output during parallel builds (#12991)

Replace use of separate ""cmake -E cmake_progress_report"" and ""cmake -E
cmake_echo_color"" commands to report the progress and message portions
of build output lines with --progress-* options to the latter to print
everything with a single command.  The line buffering of the stdout FILE
stream should cause the whole line to be printed with one atomic write.
This will avoid inter-mixing of line-wise messages from different
processes during a parallel build.",[u'https://gitlab.kitware.com/cmake/cmake/issues/12991'],Source/cmcmd.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_311.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_311.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_588.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_588.cpp,"    // Command to report progress for a build
    else if (args[1] == ""cmake_progress_report"" && args.size() >= 3)
      {
      std::string dirName = args[2];
      dirName += ""/Progress"";
      std::string fName;
      FILE *progFile;

      // read the count
      fName = dirName;
      fName += ""/count.txt"";
      progFile = cmsys::SystemTools::Fopen(fName,""r"");
      int count = 0;
      if (!progFile)
        {
        return 0;
        }
      else
        {
        if (1!=fscanf(progFile,""%i"",&count))
          {
          cmSystemTools::Message(""Could not read from progress file."");
          }
        fclose(progFile);
        }
      unsigned int i;
      for (i = 3; i < args.size(); ++i)
        {
        fName = dirName;
        fName += ""/"";
        fName += args[i];
        progFile = cmsys::SystemTools::Fopen(fName,""w"");
        if (progFile)
          {
          fprintf(progFile,""empty"");
          fclose(progFile);
          }
        }
      int fileNum = static_cast<int>
        (cmsys::Directory::GetNumberOfFilesInDirectory(dirName));
      if (count > 0)
        {
        // print the progress
        fprintf(stdout,""[%3i%%] "",((fileNum-3)*100)/count);
        }
      return 0;
      }

","    // Command to report progress for a build
    else if (args[1] == ""cmake_progress_report"" && args.size() >= 3)
      {
      // This has been superseded by cmake_echo_color --progress-*
      // options.  We leave it here to avoid errors if somehow this
      // is invoked by an existing makefile without regenerating.
      return 0;
      }

",534,534,568,-1,"fprintf(progFile,""empty"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_311.cpp,"{
          fprintf(progFile,""empty"");
          fclose(progFile);
          }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_311.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_311.cpp,"name****name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-02-06T13:36:51,Brad King,94
8521fdf56e4908676c28c6bbdda3f1fb2284d3d7,"Makefile: Fix output during parallel builds (#12991)

Replace use of separate ""cmake -E cmake_progress_report"" and ""cmake -E
cmake_echo_color"" commands to report the progress and message portions
of build output lines with --progress-* options to the latter to print
everything with a single command.  The line buffering of the stdout FILE
stream should cause the whole line to be printed with one atomic write.
This will avoid inter-mixing of line-wise messages from different
processes during a parallel build.",[u'https://gitlab.kitware.com/cmake/cmake/issues/12991'],Source/cmcmd.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_311.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_311.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_588.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_588.cpp,"    // Command to report progress for a build
    else if (args[1] == ""cmake_progress_report"" && args.size() >= 3)
      {
      std::string dirName = args[2];
      dirName += ""/Progress"";
      std::string fName;
      FILE *progFile;

      // read the count
      fName = dirName;
      fName += ""/count.txt"";
      progFile = cmsys::SystemTools::Fopen(fName,""r"");
      int count = 0;
      if (!progFile)
        {
        return 0;
        }
      else
        {
        if (1!=fscanf(progFile,""%i"",&count))
          {
          cmSystemTools::Message(""Could not read from progress file."");
          }
        fclose(progFile);
        }
      unsigned int i;
      for (i = 3; i < args.size(); ++i)
        {
        fName = dirName;
        fName += ""/"";
        fName += args[i];
        progFile = cmsys::SystemTools::Fopen(fName,""w"");
        if (progFile)
          {
          fprintf(progFile,""empty"");
          fclose(progFile);
          }
        }
      int fileNum = static_cast<int>
        (cmsys::Directory::GetNumberOfFilesInDirectory(dirName));
      if (count > 0)
        {
        // print the progress
        fprintf(stdout,""[%3i%%] "",((fileNum-3)*100)/count);
        }
      return 0;
      }

","    // Command to report progress for a build
    else if (args[1] == ""cmake_progress_report"" && args.size() >= 3)
      {
      // This has been superseded by cmake_echo_color --progress-*
      // options.  We leave it here to avoid errors if somehow this
      // is invoked by an existing makefile without regenerating.
      return 0;
      }

",534,534,577,-1,"fprintf(stdout,""[%3i%%] "",((fileNum-3)*100)/count);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_312.cpp,"{
        // print the progress
        fprintf(stdout,""[%3i%%] "",((fileNum-3)*100)/count);
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_312.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_312.cpp,"name****name****expr****argument
literal****expr****argument
operator****operator****name****operator****literal****operator****operator****literal****operator****operator****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2015-02-06T13:36:51,Brad King,12
60c783676c91ff1ded2ed5e6fd50d0f9664032e5,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_320.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_320.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_600.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_600.cpp,"  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = strlen(name);
  if ( name[n - 1] == '/' || name[n - 1] == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( strchr(name, '\\') )
      {
      sprintf(buf, ""%s\\*"", name);
      }
    else
      {
      sprintf(buf, ""%s/*"", name);
      }
    }
  struct _wfinddata_t data;      // data of current file
","  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' || *name.rbegin() == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( name.find('\\') != name.npos )
      {
      sprintf(buf, ""%s\\*"", name.c_str());
      }
    else
      {
      sprintf(buf, ""%s/*"", name.c_str());
      }
    }
  struct _wfinddata_t data;      // data of current file
",112,112,119,119,"sprintf(buf, ""%s*"", name);","sprintf(buf, ""%s*"", name.c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_313.cpp,"{
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_313.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_313.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-08-04T14:16:34,Brad King,112
60c783676c91ff1ded2ed5e6fd50d0f9664032e5,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_320.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_320.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_600.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_600.cpp,"  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = strlen(name);
  if ( name[n - 1] == '/' || name[n - 1] == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( strchr(name, '\\') )
      {
      sprintf(buf, ""%s\\*"", name);
      }
    else
      {
      sprintf(buf, ""%s/*"", name);
      }
    }
  struct _wfinddata_t data;      // data of current file
","  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' || *name.rbegin() == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( name.find('\\') != name.npos )
      {
      sprintf(buf, ""%s\\*"", name.c_str());
      }
    else
      {
      sprintf(buf, ""%s/*"", name.c_str());
      }
    }
  struct _wfinddata_t data;      // data of current file
",112,112,128,128,"sprintf(buf, ""%s\\*"", name);","sprintf(buf, ""%s\\*"", name.c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_314.cpp,"{
      sprintf(buf, ""%s\\*"", name);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_314.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_314.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-08-04T14:16:34,Brad King,112
60c783676c91ff1ded2ed5e6fd50d0f9664032e5,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_320.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_320.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_600.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_600.cpp,"  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = strlen(name);
  if ( name[n - 1] == '/' || name[n - 1] == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( strchr(name, '\\') )
      {
      sprintf(buf, ""%s\\*"", name);
      }
    else
      {
      sprintf(buf, ""%s/*"", name);
      }
    }
  struct _wfinddata_t data;      // data of current file
","  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' || *name.rbegin() == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( name.find('\\') != name.npos )
      {
      sprintf(buf, ""%s\\*"", name.c_str());
      }
    else
      {
      sprintf(buf, ""%s/*"", name.c_str());
      }
    }
  struct _wfinddata_t data;      // data of current file
",112,112,132,132,"sprintf(buf, ""%s/*"", name);","sprintf(buf, ""%s/*"", name.c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_315.cpp,"{
      sprintf(buf, ""%s/*"", name);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_315.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_315.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-08-04T14:16:34,Brad King,112
60c783676c91ff1ded2ed5e6fd50d0f9664032e5,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_320.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_320.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_601.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_601.cpp,"  return _findclose(srchHandle) != -1;
}

unsigned long Directory::GetNumberOfFilesInDirectory(const char* name)
{
#if _MSC_VER < 1300
  long srchHandle;
#else
  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = strlen(name);
  if ( name[n - 1] == '/' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }
  else
    {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name);
    }
  struct _wfinddata_t data;      // data of current file

","  return _findclose(srchHandle) != -1;
}

unsigned long Directory::GetNumberOfFilesInDirectory(const kwsys_stl::string& name)
{
#if _MSC_VER < 1300
  long srchHandle;
#else
  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
    }
  struct _wfinddata_t data;      // data of current file

",153,153,168,168,"sprintf(buf, ""%s*"", name);","sprintf(buf, ""%s*"", name.c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_316.cpp,"{
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_316.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_316.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-08-04T14:16:34,Brad King,112
60c783676c91ff1ded2ed5e6fd50d0f9664032e5,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_320.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_320.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_601.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_601.cpp,"  return _findclose(srchHandle) != -1;
}

unsigned long Directory::GetNumberOfFilesInDirectory(const char* name)
{
#if _MSC_VER < 1300
  long srchHandle;
#else
  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = strlen(name);
  if ( name[n - 1] == '/' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }
  else
    {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name);
    }
  struct _wfinddata_t data;      // data of current file

","  return _findclose(srchHandle) != -1;
}

unsigned long Directory::GetNumberOfFilesInDirectory(const kwsys_stl::string& name)
{
#if _MSC_VER < 1300
  long srchHandle;
#else
  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
    }
  struct _wfinddata_t data;      // data of current file

",153,153,173,173,"sprintf(buf, ""%s/*"", name);","sprintf(buf, ""%s/*"", name.c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_317.cpp,"{
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_317.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_317.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-08-04T14:16:34,Brad King,112
158c6d1cffe863fde284d4e5eeeb8129d40ce0e9,"KWSys 2014-08-04 (e787837a)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ e787837a | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 65b36ede..e787837a
Ben Boeckel (4):
      9927862c SystemTools: more string replacements
      b3d598b0 strings: remove unnecessary c_str calls
      ffe94132 SystemTools: use char instead of const char*
      f29fec7c Directory: accept strings in methods

Rashad M (1):
      e787837a SharedForward: Cast away const to call execvp on MinGW 64-bit

Change-Id: I96437b332971670cfcd953717c5563e9ba0f2b99",[],Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_321.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_321.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_602.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_602.cpp,"  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = strlen(name);
  if ( name[n - 1] == '/' || name[n - 1] == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( strchr(name, '\\') )
      {
      sprintf(buf, ""%s\\*"", name);
      }
    else
      {
      sprintf(buf, ""%s/*"", name);
      }
    }
  struct _wfinddata_t data;      // data of current file
","  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' || *name.rbegin() == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( name.find('\\') != name.npos )
      {
      sprintf(buf, ""%s\\*"", name.c_str());
      }
    else
      {
      sprintf(buf, ""%s/*"", name.c_str());
      }
    }
  struct _wfinddata_t data;      // data of current file
",112,112,119,119,"sprintf(buf, ""%s*"", name);","sprintf(buf, ""%s*"", name.c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_318.cpp,"{
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_318.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_318.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-08-04T14:16:30,Brad King,112
158c6d1cffe863fde284d4e5eeeb8129d40ce0e9,"KWSys 2014-08-04 (e787837a)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ e787837a | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 65b36ede..e787837a
Ben Boeckel (4):
      9927862c SystemTools: more string replacements
      b3d598b0 strings: remove unnecessary c_str calls
      ffe94132 SystemTools: use char instead of const char*
      f29fec7c Directory: accept strings in methods

Rashad M (1):
      e787837a SharedForward: Cast away const to call execvp on MinGW 64-bit

Change-Id: I96437b332971670cfcd953717c5563e9ba0f2b99",[],Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_321.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_321.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_602.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_602.cpp,"  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = strlen(name);
  if ( name[n - 1] == '/' || name[n - 1] == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( strchr(name, '\\') )
      {
      sprintf(buf, ""%s\\*"", name);
      }
    else
      {
      sprintf(buf, ""%s/*"", name);
      }
    }
  struct _wfinddata_t data;      // data of current file
","  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' || *name.rbegin() == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( name.find('\\') != name.npos )
      {
      sprintf(buf, ""%s\\*"", name.c_str());
      }
    else
      {
      sprintf(buf, ""%s/*"", name.c_str());
      }
    }
  struct _wfinddata_t data;      // data of current file
",112,112,128,128,"sprintf(buf, ""%s\\*"", name);","sprintf(buf, ""%s\\*"", name.c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_319.cpp,"{
      sprintf(buf, ""%s\\*"", name);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_319.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_319.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-08-04T14:16:30,Brad King,112
158c6d1cffe863fde284d4e5eeeb8129d40ce0e9,"KWSys 2014-08-04 (e787837a)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ e787837a | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 65b36ede..e787837a
Ben Boeckel (4):
      9927862c SystemTools: more string replacements
      b3d598b0 strings: remove unnecessary c_str calls
      ffe94132 SystemTools: use char instead of const char*
      f29fec7c Directory: accept strings in methods

Rashad M (1):
      e787837a SharedForward: Cast away const to call execvp on MinGW 64-bit

Change-Id: I96437b332971670cfcd953717c5563e9ba0f2b99",[],Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_321.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_321.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_602.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_602.cpp,"  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = strlen(name);
  if ( name[n - 1] == '/' || name[n - 1] == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( strchr(name, '\\') )
      {
      sprintf(buf, ""%s\\*"", name);
      }
    else
      {
      sprintf(buf, ""%s/*"", name);
      }
    }
  struct _wfinddata_t data;      // data of current file
","  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' || *name.rbegin() == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( name.find('\\') != name.npos )
      {
      sprintf(buf, ""%s\\*"", name.c_str());
      }
    else
      {
      sprintf(buf, ""%s/*"", name.c_str());
      }
    }
  struct _wfinddata_t data;      // data of current file
",112,112,132,132,"sprintf(buf, ""%s/*"", name);","sprintf(buf, ""%s/*"", name.c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_320.cpp,"{
      sprintf(buf, ""%s/*"", name);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_320.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_320.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-08-04T14:16:30,Brad King,112
158c6d1cffe863fde284d4e5eeeb8129d40ce0e9,"KWSys 2014-08-04 (e787837a)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ e787837a | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 65b36ede..e787837a
Ben Boeckel (4):
      9927862c SystemTools: more string replacements
      b3d598b0 strings: remove unnecessary c_str calls
      ffe94132 SystemTools: use char instead of const char*
      f29fec7c Directory: accept strings in methods

Rashad M (1):
      e787837a SharedForward: Cast away const to call execvp on MinGW 64-bit

Change-Id: I96437b332971670cfcd953717c5563e9ba0f2b99",[],Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_321.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_321.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_603.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_603.cpp,"  return _findclose(srchHandle) != -1;
}

unsigned long Directory::GetNumberOfFilesInDirectory(const char* name)
{
#if _MSC_VER < 1300
  long srchHandle;
#else
  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = strlen(name);
  if ( name[n - 1] == '/' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }
  else
    {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name);
    }
  struct _wfinddata_t data;      // data of current file

","  return _findclose(srchHandle) != -1;
}

unsigned long Directory::GetNumberOfFilesInDirectory(const kwsys_stl::string& name)
{
#if _MSC_VER < 1300
  long srchHandle;
#else
  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
    }
  struct _wfinddata_t data;      // data of current file

",153,153,168,168,"sprintf(buf, ""%s*"", name);","sprintf(buf, ""%s*"", name.c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_321.cpp,"{
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_321.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_321.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-08-04T14:16:30,Brad King,112
158c6d1cffe863fde284d4e5eeeb8129d40ce0e9,"KWSys 2014-08-04 (e787837a)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ e787837a | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 65b36ede..e787837a
Ben Boeckel (4):
      9927862c SystemTools: more string replacements
      b3d598b0 strings: remove unnecessary c_str calls
      ffe94132 SystemTools: use char instead of const char*
      f29fec7c Directory: accept strings in methods

Rashad M (1):
      e787837a SharedForward: Cast away const to call execvp on MinGW 64-bit

Change-Id: I96437b332971670cfcd953717c5563e9ba0f2b99",[],Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_321.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_321.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_603.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_603.cpp,"  return _findclose(srchHandle) != -1;
}

unsigned long Directory::GetNumberOfFilesInDirectory(const char* name)
{
#if _MSC_VER < 1300
  long srchHandle;
#else
  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = strlen(name);
  if ( name[n - 1] == '/' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }
  else
    {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name);
    }
  struct _wfinddata_t data;      // data of current file

","  return _findclose(srchHandle) != -1;
}

unsigned long Directory::GetNumberOfFilesInDirectory(const kwsys_stl::string& name)
{
#if _MSC_VER < 1300
  long srchHandle;
#else
  intptr_t srchHandle;
#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
    }
  struct _wfinddata_t data;      // data of current file

",153,153,173,173,"sprintf(buf, ""%s/*"", name);","sprintf(buf, ""%s/*"", name.c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_322.cpp,"{
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_322.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_322.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-08-04T14:16:30,Brad King,112
71c981a213a463d05b4bdc73dfb445c80ce2a476,"Encoding: Fix potential encoding issues with libarchive on Windows.

Because the 8bit string encoding in libarchive can be different than
the 8bit string encoding in CMake, change to call the wide version
of libarchive functions.  They are different if CMake is configured
to use UTF-8 as the internal encoding.

Create helper functions for some libarchive calls to use wstring
internally on platforms supporting it.",[],Source/cmSystemTools.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_322.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_322.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_604.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_604.cpp,"    }
  strftime(tmp, sizeof(tmp), fmt, localtime(&tim));
  fprintf(out, "" %s "", tmp);
  fprintf(out, ""%s"", archive_entry_pathname(entry));

  /* Extra information for links. */
  if (archive_entry_hardlink(entry)) /* Hard link */
","    }
  strftime(tmp, sizeof(tmp), fmt, localtime(&tim));
  fprintf(out, "" %s "", tmp);
  fprintf(out, ""%s"", cm_archive_entry_pathname(entry).c_str());

  /* Extra information for links. */
  if (archive_entry_hardlink(entry)) /* Hard link */
",1581,1606,1584,1609,"fprintf(out, ""%s"", archive_entry_pathname(entry));","fprintf(out, ""%s"", cm_archive_entry_pathname(entry).c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_323.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_323.cpp,[],second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_323.cpp,"name****name****expr****argument
literal****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-07-02T13:49:45,Brad King,73
71c981a213a463d05b4bdc73dfb445c80ce2a476,"Encoding: Fix potential encoding issues with libarchive on Windows.

Because the 8bit string encoding in libarchive can be different than
the 8bit string encoding in CMake, change to call the wide version
of libarchive functions.  They are different if CMake is configured
to use UTF-8 as the internal encoding.

Create helper functions for some libarchive calls to use wstring
internally on platforms supporting it.",[],Source/cmSystemTools.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_323.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_323.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_606.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_606.cpp,"    }
  strftime(tmp, sizeof(tmp), fmt, localtime(&tim));
  fprintf(out, "" %s "", tmp);
  fprintf(out, ""%s"", archive_entry_pathname(entry));

  /* Extra information for links. */
  if (archive_entry_hardlink(entry)) /* Hard link */
","    }
  strftime(tmp, sizeof(tmp), fmt, localtime(&tim));
  fprintf(out, "" %s "", tmp);
  fprintf(out, ""%s"", cm_archive_entry_pathname(entry).c_str());

  /* Extra information for links. */
  if (archive_entry_hardlink(entry)) /* Hard link */
",1581,1606,1584,1609,"fprintf(out, ""%s"", archive_entry_pathname(entry));","fprintf(out, ""%s"", cm_archive_entry_pathname(entry).c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_324.cpp,"{
  char                   tmp[100];
  size_t                         w;
  const char            *p;
  const char            *fmt;
  time_t                         tim;
  static time_t          now;
  size_t u_width = 6;
  size_t gs_width = 13;

  /*
   * We avoid collecting the entire list in memory at once by
   * listing things as we see them.  However, that also means we can't
   * just pre-compute the field widths.  Instead, we start with guesses
   * and just widen them as necessary.  These numbers are completely
   * arbitrary.
   */
  if (!now)
    {
    time(&now);
    }
  fprintf(out, ""%s %d "",
          archive_entry_strmode(entry),
          archive_entry_nlink(entry));

  /* Use uname if it's present, else uid. */
  p = archive_entry_uname(entry);
  if ((p == NULL) || (*p == '\0'))
    {
    sprintf(tmp, ""%lu "",
            (unsigned long)archive_entry_uid(entry));
    p = tmp;
    }
  w = strlen(p);
  if (w > u_width)
    {
    u_width = w;
    }
  fprintf(out, ""%-*s "", (int)u_width, p);
  /* Use gname if it's present, else gid. */
  p = archive_entry_gname(entry);
  if (p != NULL && p[0] != '\0')
    {
    fprintf(out, ""%s"", p);
    w = strlen(p);
    }
  else
    {
    sprintf(tmp, ""%lu"",
            (unsigned long)archive_entry_gid(entry));
    w = strlen(tmp);
    fprintf(out, ""%s"", tmp);
    }

  /*
   * Print device number or file size, right-aligned so as to make
   * total width of group and devnum/filesize fields be gs_width.
   * If gs_width is too small, grow it.
   */
  if (archive_entry_filetype(entry) == AE_IFCHR
      || archive_entry_filetype(entry) == AE_IFBLK)
    {
    sprintf(tmp, ""%lu,%lu"",
            (unsigned long)archive_entry_rdevmajor(entry),
            (unsigned long)archive_entry_rdevminor(entry));
    }
  else
    {
    /*
     * Note the use of platform-dependent macros to format
     * the filesize here.  We need the format string and the
     * corresponding type for the cast.
     */
    sprintf(tmp, BSDTAR_FILESIZE_PRINTF,
            (BSDTAR_FILESIZE_TYPE)archive_entry_size(entry));
    }
  if (w + strlen(tmp) >= gs_width)
    {
    gs_width = w+strlen(tmp)+1;
    }
  fprintf(out, ""%*s"", (int)(gs_width - w), tmp);

  /* Format the time using 'ls -l' conventions. */
  tim = archive_entry_mtime(entry);
#define HALF_YEAR (time_t)365 * 86400 / 2
#if defined(_WIN32) && !defined(__CYGWIN__)
  /* Windows' strftime function does not support %e format. */
#define DAY_FMT  ""%d""
#else
#define DAY_FMT  ""%e""  /* Day number without leading zeros */
#endif
  if (tim < now - HALF_YEAR || tim > now + HALF_YEAR)
    {
    fmt = DAY_FMT "" %b  %Y"";
    }
  else
    {
    fmt = DAY_FMT "" %b %H:%M"";
    }
  strftime(tmp, sizeof(tmp), fmt, localtime(&tim));
  fprintf(out, "" %s "", tmp);
  fprintf(out, ""%s"", archive_entry_pathname(entry));

  /* Extra information for links. */
  if (archive_entry_hardlink(entry)) /* Hard link */
    {
    fprintf(out, "" link to %s"",
            archive_entry_hardlink(entry));
    }
  else if (archive_entry_symlink(entry)) /* Symbolic link */
    {
    fprintf(out, "" -> %s"", archive_entry_symlink(entry));
    }
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_324.cpp,"[10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 3, 159, 0, 0, 8, 8, 0, 0, 2, 21, 0, 0, 0, 0, 2, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51, 0, 116, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 2, 0, 9, 9, 4, 0, 43, 0, 0, 26, 1, 76, 6, 0, 3, 3, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_324.cpp,"name****name****expr****argument
literal****expr****argument
name****name****expr****argument
argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-07-02T13:49:45,Brad King,73
e4e76f286c2eb5cfa822f89145611d02dc9d39b3,"Merge branch 'master' into osx-CFBundle-info-plist

Resolve conflict in Source/cmOSXBundleGenerator.cxx by taking
the side from 'master'.",[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_325.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_325.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_608.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_608.cpp,"            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");
    this->DisplayConstraintGraph();
    }

","            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName().c_str(),
            this->HasConfig?this->Config.c_str():""noconfig"");
    this->DisplayConstraintGraph();
    }

",254,255,256,257,"fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");","fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName().c_str(),
            this->HasConfig?this->Config.c_str():""noconfig"");",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_325.cpp,"{
    fprintf(stderr,
            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");
    this->DisplayConstraintGraph();
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_325.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 4, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_325.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****expr****condition****name****operator****name****name****expr****then****literal****expr****else****ternary****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-22T16:51:55,Brad King,98
e4e76f286c2eb5cfa822f89145611d02dc9d39b3,"Merge branch 'master' into osx-CFBundle-info-plist

Resolve conflict in Source/cmOSXBundleGenerator.cxx by taking
the side from 'master'.",[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_325.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_325.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_609.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_609.cpp,"//----------------------------------------------------------------------------
void cmComputeLinkDepends::DisplayFinalEntries()
{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }
    else
      {
","//----------------------------------------------------------------------------
void cmComputeLinkDepends::DisplayFinalEntries()
{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName().c_str());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName().c_str());
      }
    else
      {
",968,970,971,973,"fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());","fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName().c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_326.cpp,"{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }
    else
      {
      fprintf(stderr, ""  item [%s]\n"", lei->Item.c_str());
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_326.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 40, 0, 0, 0, 1, 0, 0, 2, 4, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 1, 1, 0, 10, 0, 0, 4, 0, 12, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_326.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-22T16:51:55,Brad King,110
e4e76f286c2eb5cfa822f89145611d02dc9d39b3,"Merge branch 'master' into osx-CFBundle-info-plist

Resolve conflict in Source/cmOSXBundleGenerator.cxx by taking
the side from 'master'.",[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_325.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_325.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_609.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_609.cpp,"//----------------------------------------------------------------------------
void cmComputeLinkDepends::DisplayFinalEntries()
{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }
    else
      {
","//----------------------------------------------------------------------------
void cmComputeLinkDepends::DisplayFinalEntries()
{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName().c_str());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName().c_str());
      }
    else
      {
",968,970,978,980,"fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());","fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName().c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_327.cpp,"{
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_327.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_327.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-22T16:51:55,Brad King,110
e4e76f286c2eb5cfa822f89145611d02dc9d39b3,"Merge branch 'master' into osx-CFBundle-info-plist

Resolve conflict in Source/cmOSXBundleGenerator.cxx by taking
the side from 'master'.",[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_326.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_326.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_610.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_610.cpp,"
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph, const char* name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
","
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph,
                                     const std::string& name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
",435,435,440,441,"fprintf(stderr, ""The %s target dependency graph is:\n"", name);","fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_328.cpp,"{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_328.cpp,"[0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 63, 0, 0, 5, 7, 0, 0, 9, 7, 0, 0, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 1, 37, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 3, 0, 3, 1, 1, 0, 12, 0, 0, 4, 0, 16, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_328.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-22T16:51:55,Brad King,112
e4e76f286c2eb5cfa822f89145611d02dc9d39b3,"Merge branch 'master' into osx-CFBundle-info-plist

Resolve conflict in Source/cmOSXBundleGenerator.cxx by taking
the side from 'master'.",[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_326.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_326.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_610.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_610.cpp,"
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph, const char* name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
","
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph,
                                     const std::string& name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
",435,435,446,447,"fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());","fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_329.cpp,"{
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_329.cpp,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 47, 0, 0, 4, 5, 0, 0, 6, 4, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 3, 0, 2, 1, 1, 0, 7, 0, 0, 2, 0, 9, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_329.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-22T16:51:55,Brad King,99
e4e76f286c2eb5cfa822f89145611d02dc9d39b3,"Merge branch 'master' into osx-CFBundle-info-plist

Resolve conflict in Source/cmOSXBundleGenerator.cxx by taking
the side from 'master'.",[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_326.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_326.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_610.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_610.cpp,"
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph, const char* name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
","
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph,
                                     const std::string& name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
",435,435,452,453,"fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");","fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_330.cpp,"{
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_330.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 18, 0, 0, 2, 2, 0, 0, 2, 3, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 1, 1, 0, 3, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_330.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****argument_list****call****expr****condition****literal****expr****then****literal****expr****else****ternary****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-22T16:51:55,Brad King,100
e4e76f286c2eb5cfa822f89145611d02dc9d39b3,"Merge branch 'master' into osx-CFBundle-info-plist

Resolve conflict in Source/cmOSXBundleGenerator.cxx by taking
the side from 'master'.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_327.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_327.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_613.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_613.cpp,"    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
","    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName.c_str());
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
",449,450,452,453,"fprintf(fout, ""add_executable(%s"", targetName);","fprintf(fout, ""add_executable(%s"", targetName.c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_331.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmLocalGenerator* lg = this->Makefile->GetLocalGenerator();
    cmGlobalGenerator* gg = lg->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      if(const char* lang = gg->GetLanguageFromExtension(ext.c_str()))
        {
        testLangs.insert(lang);
        }
      else
        {
        cmOStringStream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        for(std::vector<std::string>::iterator l = langs.begin();
            l != langs.end(); ++l)
          {
          err << "" "" << *l;
          }
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = cmsys::SystemTools::Fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""set(CMAKE_MODULE_PATH %s)\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""project(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""set(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    fprintf(fout, ""include_directories(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""add_definitions( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if (const char *cxxDef
              = this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_TARGET="";
      flag += cxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *cDef
                = this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_TARGET="";
      flag += cDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcxxDef = this->Makefile->GetDefinition(
                                  ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcDef = this->Makefile->GetDefinition(
                                    ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *rootDef
              = this->Makefile->GetDefinition(""CMAKE_SYSROOT""))
      {
      std::string flag=""-DCMAKE_SYSROOT="";
      flag += rootDef;
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_331.cpp,"[21, 0, 6, 0, 0, 0, 3, 0, 0, 0, 30, 0, 0, 0, 10, 593, 0, 0, 26, 40, 0, 0, 40, 83, 0, 0, 0, 0, 13, 0, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 1, 256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 2, 0, 28, 22, 3, 0, 122, 0, 0, 62, 2, 127, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_331.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-22T16:51:55,Brad King,112
e4e76f286c2eb5cfa822f89145611d02dc9d39b3,"Merge branch 'master' into osx-CFBundle-info-plist

Resolve conflict in Source/cmOSXBundleGenerator.cxx by taking
the side from 'master'.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_327.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_327.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_614.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_614.cpp,"    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
","    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());
      }
    fclose(fout);
",465,466,467,468,"fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);","fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_332.cpp,"{
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_332.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_332.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-22T16:51:55,Brad King,112
e4e76f286c2eb5cfa822f89145611d02dc9d39b3,"Merge branch 'master' into osx-CFBundle-info-plist

Resolve conflict in Source/cmOSXBundleGenerator.cxx by taking
the side from 'master'.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_327.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_327.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_614.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_614.cpp,"    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
","    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());
      }
    fclose(fout);
",465,466,472,474,"fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());","fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_333.cpp,"{
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_333.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_333.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-22T16:51:55,Brad King,101
2f1978632b709a9370b3cb1137375c05351d149c,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts in favor of the upstream side where possible.
Resolve a logical conflict in archive_windows.h where the upstream
port to Watcom was done slightly differently from ours.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_330.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_330.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_618.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_618.cpp,"
/*
 * Device entries have one of the following forms:
 * raw dev_t
 * format,major,minor[,subdevice]
 *
 * Just use major and minor, no translation etc is done
 * between formats.
 */
static int
parse_device(struct archive *a, struct archive_entry *entry, char *val)
{
	char *comma1, *comma2;

	comma1 = strchr(val, ',');
	if (comma1 == NULL) {
		archive_entry_set_dev(entry, (dev_t)mtree_atol10(&val));
		return (ARCHIVE_OK);
	}
	++comma1;
	comma2 = strchr(comma1, ',');
	if (comma2 == NULL) {
		archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Malformed device attribute"");
		return (ARCHIVE_WARN);
	}
	++comma2;
	archive_entry_set_rdevmajor(entry, (dev_t)mtree_atol(&comma1));
	archive_entry_set_rdevminor(entry, (dev_t)mtree_atol(&comma2));
	return (ARCHIVE_OK);
}

/*
","
/*
 * Device entries have one of the following forms:
 *  - raw dev_t
 *  - format,major,minor[,subdevice]
 * When parsing succeeded, `pdev' will contain the appropriate dev_t value.
 */

/* strsep() is not in C90, but strcspn() is. */
/* Taken from http://unixpapa.com/incnote/string.html */
static char *
la_strsep(char **sp, char *sep)
{
	char *p, *s;
	if (sp == NULL || *sp == NULL || **sp == '\0')
		return(NULL);
	s = *sp;
	p = s + strcspn(s, sep);
	if (*p != '\0')
		*p++ = '\0';
	*sp = p;
	return(s);
}

static int
parse_device(dev_t *pdev, struct archive *a, char *val)
{
#define MAX_PACK_ARGS 3
	unsigned long numbers[MAX_PACK_ARGS];
	char *p, *dev;
	int argc;
	pack_t *pack;
	dev_t result;
	const char *error = NULL;

	memset(pdev, 0, sizeof(*pdev));
	if ((dev = strchr(val, ',')) != NULL) {
		/*
		 * Device's major/minor are given in a specified format.
		 * Decode and pack it accordingly.
		 */
		*dev++ = '\0';
		if ((pack = pack_find(val)) == NULL) {
			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Unknown format `%s'"", val);
			return ARCHIVE_WARN;
		}
		argc = 0;
		while ((p = la_strsep(&dev, "","")) != NULL) {
			if (*p == '\0') {
				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Missing number"");
				return ARCHIVE_WARN;
			}
			numbers[argc++] = mtree_atol(&p);
			if (argc > MAX_PACK_ARGS) {
				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"");
				return ARCHIVE_WARN;
			}
		}
		if (argc < 2) {
			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Not enough arguments"");
			return ARCHIVE_WARN;
		}
		result = (*pack)(argc, numbers, &error);
		if (error != NULL) {
			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""%s"", error);
			return ARCHIVE_WARN;
		}
	} else {
		/* file system raw value. */
		result = (dev_t)mtree_atol(&val);
	}
	*pdev = result;
	return ARCHIVE_OK;
#undef MAX_PACK_ARGS
}

/*
",1292,1319,1314,1362,"archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Malformed device attribute"");","archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Unknown format `%s'"", val);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_334.cpp,"{
		archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Malformed device attribute"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_334.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_334.cpp,"name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-03T19:02:49,Brad King,74
2f1978632b709a9370b3cb1137375c05351d149c,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts in favor of the upstream side where possible.
Resolve a logical conflict in archive_windows.h where the upstream
port to Watcom was done slightly differently from ours.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_334.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_334.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_629.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_629.cpp,"static int
archive_write_zip_header(struct archive_write *a, struct archive_entry *entry)
{
	struct zip *zip;
	uint8_t h[SIZE_LOCAL_FILE_HEADER];
	uint8_t e[SIZE_EXTRA_DATA_LOCAL];
	uint8_t *d;
	struct zip_file_header_link *l;
	struct archive_string_conv *sconv;
	int ret, ret2 = ARCHIVE_OK;
	int64_t size;
	mode_t type;

	/* Entries other than a regular file or a folder are skipped. */
	type = archive_entry_filetype(entry);
	if (type != AE_IFREG && type != AE_IFDIR && type != AE_IFLNK) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Filetype not supported"");
		return ARCHIVE_FAILED;
	};

	/* Directory entries should have a size of 0. */
	if (type == AE_IFDIR)
		archive_entry_set_size(entry, 0);

	zip = a->format_data;
	/* Setup default conversion. */
	if (zip->opt_sconv == NULL && !zip->init_default_conversion) {
		zip->sconv_default =
		    archive_string_default_conversion_for_write(&(a->archive));
		zip->init_default_conversion = 1;
	}

	if (zip->flags == 0) {
		/* Initialize the general purpose flags. */
		zip->flags = ZIP_FLAGS;
		if (zip->opt_sconv != NULL) {
			if (strcmp(archive_string_conversion_charset_name(
			    zip->opt_sconv), ""UTF-8"") == 0)
				zip->flags |= ZIP_FLAGS_UTF8_NAME;
#if HAVE_NL_LANGINFO
		} else if (strcmp(nl_langinfo(CODESET), ""UTF-8"") == 0) {
			zip->flags |= ZIP_FLAGS_UTF8_NAME;
#endif
		}
	}
	d = zip->data_descriptor;
	size = archive_entry_size(entry);
	zip->remaining_data_bytes = size;

	/* Append archive entry to the central directory data. */
	l = (struct zip_file_header_link *) malloc(sizeof(*l));
	if (l == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip header data"");
		return (ARCHIVE_FATAL);
	}
#if defined(_WIN32) && !defined(__CYGWIN__)
	/* Make sure the path separators in pahtname, hardlink and symlink
	 * are all slash '/', not the Windows path separator '\'. */
	l->entry = __la_win_entry_in_posix_pathseparator(entry);
	if (l->entry == entry)
		l->entry = archive_entry_clone(entry);
#else
	l->entry = archive_entry_clone(entry);
#endif
	if (l->entry == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip header data"");
		free(l);
		return (ARCHIVE_FATAL);
	}
	l->flags = zip->flags;
	if (zip->opt_sconv != NULL)
		sconv = zip->opt_sconv;
	else
		sconv = zip->sconv_default;
	if (sconv != NULL) {
		const char *p;
		size_t len;

		if (archive_entry_pathname_l(entry, &p, &len, sconv) != 0) {
			if (errno == ENOMEM) {
				archive_entry_free(l->entry);
				free(l);
				archive_set_error(&a->archive, ENOMEM,
				    ""Can't allocate memory for Pathname"");
				return (ARCHIVE_FATAL);
","static int
archive_write_zip_header(struct archive_write *a, struct archive_entry *entry)
{
	unsigned char local_header[32];
	unsigned char local_extra[128];
	struct zip *zip = a->format_data;
	unsigned char *e;
	unsigned char *cd_extra;
	size_t filename_length;
	const char *symlink = NULL;
	size_t symlink_size = 0;
	struct archive_string_conv *sconv = get_sconv(a, zip);
	int ret, ret2 = ARCHIVE_OK;
	int64_t size;
	mode_t type;
	int version_needed = 10;

	/* Ignore types of entries that we don't support. */
	type = archive_entry_filetype(entry);
	if (type != AE_IFREG && type != AE_IFDIR && type != AE_IFLNK) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Filetype not supported"");
		return ARCHIVE_FAILED;
	};

	/* If we're not using Zip64, reject large files. */
	if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
		/* Reject entries over 4GB. */
		if (archive_entry_size_is_set(entry)
		    && (archive_entry_size(entry) > 0xffffffff)) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Files > 4GB require Zip64 extensions"");
			return ARCHIVE_FAILED;
		}
		/* Reject entries if archive is > 4GB. */
		if (zip->written_bytes > 0xffffffff) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Archives > 4GB require Zip64 extensions"");
			return ARCHIVE_FAILED;
		}
	}

	/* Only regular files can have size > 0. */
	if (type != AE_IFREG)
		archive_entry_set_size(entry, 0);


	/* Reset information from last entry. */
	zip->entry_offset = zip->written_bytes;
	zip->entry_uncompressed_limit = INT64_MAX;
	zip->entry_compressed_size = 0;
	zip->entry_uncompressed_size = 0;
	zip->entry_compressed_written = 0;
	zip->entry_uncompressed_written = 0;
	zip->entry_flags = 0;
	zip->entry_uses_zip64 = 0;
	zip->entry_crc32 = zip->crc32func(0, NULL, 0);
	if (zip->entry != NULL) {
		archive_entry_free(zip->entry);
		zip->entry = NULL;
	}

#if defined(_WIN32) && !defined(__CYGWIN__)
	/* Make sure the path separators in pahtname, hardlink and symlink
	 * are all slash '/', not the Windows path separator '\'. */
	zip->entry = __la_win_entry_in_posix_pathseparator(entry);
	if (zip->entry == entry)
		zip->entry = archive_entry_clone(entry);
#else
	zip->entry = archive_entry_clone(entry);
#endif
	if (zip->entry == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip header data"");
		return (ARCHIVE_FATAL);
	}

	if (sconv != NULL) {
		const char *p;
		size_t len;

		if (archive_entry_pathname_l(entry, &p, &len, sconv) != 0) {
			if (errno == ENOMEM) {
				archive_set_error(&a->archive, ENOMEM,
				    ""Can't allocate memory for Pathname"");
				return (ARCHIVE_FATAL);
",376,399,443,435,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip header data"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Archives > 4GB require Zip64 extensions"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_335.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip header data"");
		free(l);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_335.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_335.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-03T19:02:49,Brad King,111
2f1978632b709a9370b3cb1137375c05351d149c,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts in favor of the upstream side where possible.
Resolve a logical conflict in archive_windows.h where the upstream
port to Watcom was done slightly differently from ours.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_334.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_334.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_631.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_631.cpp,"					zip->len_buf);
				if (ret != ARCHIVE_OK)
					return (ret);
				l->compressed_size += zip->len_buf;
				zip->written_bytes += zip->len_buf;
				zip->stream.next_out = zip->buf;
				zip->stream.avail_out = (uInt)zip->len_buf;
			}
		} while (zip->stream.avail_in != 0);
		zip->remaining_data_bytes -= s;
		/* If we have it, use zlib's fast crc32() */
		l->crc32 = crc32(l->crc32, buff, (uInt)s);
		return (s);
#endif

	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid ZIP compression type"");
		return ARCHIVE_FATAL;
	}
}

static int
archive_write_zip_finish_entry(struct archive_write *a)
{
	/* Write the data descripter after file data has been written. */
	int ret;
	struct zip *zip = a->format_data;
	uint8_t *d = zip->data_descriptor;
	struct zip_file_header_link *l = zip->central_directory_end;
#if HAVE_ZLIB_H
	size_t reminder;
#endif

	switch(l->compression) {
	case COMPRESSION_STORE:
		break;
#if HAVE_ZLIB_H
	case COMPRESSION_DEFLATE:
		for (;;) {
			ret = deflate(&zip->stream, Z_FINISH);
			if (ret == Z_STREAM_ERROR)
				return (ARCHIVE_FATAL);
			reminder = zip->len_buf - zip->stream.avail_out;
			ret = __archive_write_output(a, zip->buf, reminder);
			if (ret != ARCHIVE_OK)
				return (ret);
			l->compressed_size += reminder;
			zip->written_bytes += reminder;
			zip->stream.next_out = zip->buf;
			if (zip->stream.avail_out != 0)
				break;
			zip->stream.avail_out = (uInt)zip->len_buf;
		}
		deflateEnd(&zip->stream);
		break;
#endif
	}

	archive_le32enc(&d[DATA_DESCRIPTOR_CRC32], l->crc32);
	archive_le32enc(&d[DATA_DESCRIPTOR_COMPRESSED_SIZE],
		(uint32_t)l->compressed_size);
	ret = __archive_write_output(a, d, SIZE_DATA_DESCRIPTOR);
	if (ret != ARCHIVE_OK)
		return (ARCHIVE_FATAL);
	zip->written_bytes += SIZE_DATA_DESCRIPTOR;
	return (ARCHIVE_OK);
}

static int
archive_write_zip_close(struct archive_write *a)
{
	struct zip *zip;
	struct zip_file_header_link *l;
	uint8_t h[SIZE_FILE_HEADER];
	uint8_t end[SIZE_CENTRAL_DIRECTORY_END];
	uint8_t e[SIZE_EXTRA_DATA_CENTRAL];
	int64_t offset_start, offset_end;
	int entries;
	int ret;

	zip = a->format_data;
	l = zip->central_directory;

	/*
	 * Formatting central directory file header fields that are
	 * fixed for all entries.
	 * Fields not used (and therefor 0) are:
	 *
	 *   - comment_length
	 *   - disk_number
	 *   - attributes_internal
	 */
	memset(h, 0, sizeof(h));
	archive_le32enc(&h[FILE_HEADER_SIGNATURE], ZIP_SIGNATURE_FILE_HEADER);
	archive_le16enc(&h[FILE_HEADER_VERSION_BY], ZIP_VERSION_BY);
	archive_le16enc(&h[FILE_HEADER_VERSION_EXTRACT], ZIP_VERSION_EXTRACT);

	entries = 0;
	offset_start = zip->written_bytes;

	/* Formatting individual header fields per entry and
	 * writing each entry. */
	while (l != NULL) {
		archive_le16enc(&h[FILE_HEADER_FLAGS], l->flags);
		archive_le16enc(&h[FILE_HEADER_COMPRESSION], l->compression);
		archive_le32enc(&h[FILE_HEADER_TIMEDATE],
			dos_time(archive_entry_mtime(l->entry)));
		archive_le32enc(&h[FILE_HEADER_CRC32], l->crc32);
		archive_le32enc(&h[FILE_HEADER_COMPRESSED_SIZE],
			(uint32_t)l->compressed_size);
		archive_le32enc(&h[FILE_HEADER_UNCOMPRESSED_SIZE],
			(uint32_t)archive_entry_size(l->entry));
		archive_le16enc(&h[FILE_HEADER_FILENAME_LENGTH],
			(uint16_t)path_length(l->entry));
		archive_le16enc(&h[FILE_HEADER_EXTRA_LENGTH], sizeof(e));
		archive_le16enc(&h[FILE_HEADER_ATTRIBUTES_EXTERNAL+2],
			archive_entry_mode(l->entry));
		archive_le32enc(&h[FILE_HEADER_OFFSET], (uint32_t)l->offset);

		/* Formatting extra data. */
		archive_le16enc(&e[EXTRA_DATA_CENTRAL_TIME_ID],
			ZIP_SIGNATURE_EXTRA_TIMESTAMP);
		archive_le16enc(&e[EXTRA_DATA_CENTRAL_TIME_SIZE], 1 + 4);
		e[EXTRA_DATA_CENTRAL_TIME_FLAG] = 0x07;
		archive_le32enc(&e[EXTRA_DATA_CENTRAL_MTIME],
			(uint32_t)archive_entry_mtime(l->entry));
		archive_le16enc(&e[EXTRA_DATA_CENTRAL_UNIX_ID],
			ZIP_SIGNATURE_EXTRA_NEW_UNIX);
		archive_le16enc(&e[EXTRA_DATA_CENTRAL_UNIX_SIZE], 0x0000);

		ret = __archive_write_output(a, h, sizeof(h));
		if (ret != ARCHIVE_OK)
			return (ARCHIVE_FATAL);
		zip->written_bytes += sizeof(h);

		ret = write_path(l->entry, a);
		if (ret <= ARCHIVE_OK)
			return (ARCHIVE_FATAL);
		zip->written_bytes += ret;

		ret = __archive_write_output(a, e, sizeof(e));
		if (ret != ARCHIVE_OK)
			return (ARCHIVE_FATAL);
		zip->written_bytes += sizeof(e);

		l = l->next;
		entries++;
	}
	offset_end = zip->written_bytes;

	/* Formatting end of central directory. */
	memset(end, 0, sizeof(end));
	archive_le32enc(&end[CENTRAL_DIRECTORY_END_SIGNATURE],
		ZIP_SIGNATURE_CENTRAL_DIRECTORY_END);
	archive_le16enc(&end[CENTRAL_DIRECTORY_END_ENTRIES_DISK], entries);
	archive_le16enc(&end[CENTRAL_DIRECTORY_END_ENTRIES], entries);
	archive_le32enc(&end[CENTRAL_DIRECTORY_END_SIZE],
		(uint32_t)(offset_end - offset_start));
	archive_le32enc(&end[CENTRAL_DIRECTORY_END_OFFSET],
		(uint32_t)offset_start);

	/* Writing end of central directory. */
	ret = __archive_write_output(a, end, sizeof(end));
	if (ret != ARCHIVE_OK)
		return (ARCHIVE_FATAL);
	zip->written_bytes += sizeof(end);
	return (ARCHIVE_OK);
}

static int
archive_write_zip_free(struct archive_write *a)
{
	struct zip *zip;
	struct zip_file_header_link *l;

	zip = a->format_data;
	while (zip->central_directory != NULL) {
	   l = zip->central_directory;
	   zip->central_directory = l->next;
	   archive_entry_free(l->entry);
	   free(l);
	}
#ifdef HAVE_ZLIB_H
	free(zip->buf);
#endif
	free(zip);
	a->format_data = NULL;
	return (ARCHIVE_OK);
","					zip->len_buf);
				if (ret != ARCHIVE_OK)
					return (ret);
				zip->entry_compressed_written += zip->len_buf;
				zip->written_bytes += zip->len_buf;
				zip->stream.next_out = zip->buf;
				zip->stream.avail_out = (uInt)zip->len_buf;
			}
		} while (zip->stream.avail_in != 0);
		break;
#endif

	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid ZIP compression type"");
		return ARCHIVE_FATAL;
	}

	zip->entry_uncompressed_limit -= s;
	zip->entry_crc32 = zip->crc32func(zip->entry_crc32, buff, (unsigned)s);
	return (s);

}

static int
archive_write_zip_finish_entry(struct archive_write *a)
{
	struct zip *zip = a->format_data;
	int ret;

#if HAVE_ZLIB_H
	if (zip->entry_compression == COMPRESSION_DEFLATE) {
		for (;;) {
			size_t remainder;
			ret = deflate(&zip->stream, Z_FINISH);
			if (ret == Z_STREAM_ERROR)
				return (ARCHIVE_FATAL);
			remainder = zip->len_buf - zip->stream.avail_out;
			ret = __archive_write_output(a, zip->buf, remainder);
			if (ret != ARCHIVE_OK)
				return (ret);
			zip->entry_compressed_written += remainder;
			zip->written_bytes += remainder;
			zip->stream.next_out = zip->buf;
			if (zip->stream.avail_out != 0)
				break;
			zip->stream.avail_out = (uInt)zip->len_buf;
		}
		deflateEnd(&zip->stream);
	}
#endif

	/* Write trailing data descriptor. */
	if ((zip->entry_flags & ZIP_ENTRY_FLAG_LENGTH_AT_END) != 0) {
		char d[24];
		memcpy(d, ""PK\007\010"", 4);
		archive_le32enc(d + 4, zip->entry_crc32);
		if (zip->entry_uses_zip64) {
			archive_le64enc(d + 8, (uint64_t)zip->entry_compressed_written);
			archive_le64enc(d + 16, (uint64_t)zip->entry_uncompressed_written);
			ret = __archive_write_output(a, d, 24);
			zip->written_bytes += 24;
		} else {
			archive_le32enc(d + 8, (uint32_t)zip->entry_compressed_written);
			archive_le32enc(d + 12, (uint32_t)zip->entry_uncompressed_written);
			ret = __archive_write_output(a, d, 16);
			zip->written_bytes += 16;
		}
		if (ret != ARCHIVE_OK)
			return (ARCHIVE_FATAL);
	}

	/* Append Zip64 extra data to central directory information. */
	if (zip->entry_compressed_written > 0xffffffffLL
	    || zip->entry_uncompressed_written > 0xffffffffLL
	    || zip->entry_offset > 0xffffffffLL) {
		unsigned char zip64[32];
		unsigned char *z = zip64, *zd;
		memcpy(z, ""\001\000\000\000"", 4);
		z += 4;
		if (zip->entry_uncompressed_written >= 0xffffffffLL) {
			archive_le64enc(z, zip->entry_uncompressed_written);
			z += 8;
		}
		if (zip->entry_compressed_written >= 0xffffffffLL) {
			archive_le64enc(z, zip->entry_compressed_written);
			z += 8;
		}
		if (zip->entry_offset >= 0xffffffffLL) {
			archive_le64enc(z, zip->entry_offset);
			z += 8;
		}
		archive_le16enc(zip64 + 2, z - (zip64 + 4));
		zd = cd_alloc(zip, z - zip64);
		if (zd == NULL) {
			archive_set_error(&a->archive, ENOMEM,
				""Can't allocate zip data"");
			return (ARCHIVE_FATAL);
		}
		memcpy(zd, zip64, z - zip64);
		/* Zip64 means version needs to be set to at least 4.5 */
		if (archive_le16dec(zip->file_header + 6) < 45)
			archive_le16enc(zip->file_header + 6, 45);
	}

	/* Fix up central directory file header. */
	archive_le32enc(zip->file_header + 16, zip->entry_crc32);
	archive_le32enc(zip->file_header + 20,
	    zipmin(zip->entry_compressed_written, 0xffffffffLL));
	archive_le32enc(zip->file_header + 24,
	    zipmin(zip->entry_uncompressed_written, 0xffffffffLL));
	archive_le16enc(zip->file_header + 30,
	    zip->central_directory_bytes - zip->file_header_extra_offset);
	archive_le32enc(zip->file_header + 42,
	    zipmin(zip->entry_offset, 0xffffffffLL));

	return (ARCHIVE_OK);
}

static int
archive_write_zip_close(struct archive_write *a)
{
	uint8_t buff[64];
	int64_t offset_start, offset_end;
	struct zip *zip = a->format_data;
	struct cd_segment *segment;
	int ret;

	offset_start = zip->written_bytes;
	segment = zip->central_directory;
	while (segment != NULL) {
		ret = __archive_write_output(a,
		    segment->buff, segment->p - segment->buff);
		if (ret != ARCHIVE_OK)
			return (ARCHIVE_FATAL);
		zip->written_bytes += segment->p - segment->buff;
		segment = segment->next;
	}
	offset_end = zip->written_bytes;

	/* If central dir info is too large, write Zip64 end-of-cd */
	if (offset_end - offset_start > 0xffffffffLL
	    || offset_start > 0xffffffffLL
	    || zip->central_directory_entries > 0xffffUL
	    || (zip->flags & ZIP_FLAG_FORCE_ZIP64)) {
	  /* Zip64 end-of-cd record */
	  memset(buff, 0, 56);
	  memcpy(buff, ""PK\006\006"", 4);
	  archive_le64enc(buff + 4, 44);
	  archive_le16enc(buff + 12, 45);
	  archive_le16enc(buff + 14, 45);
	  /* This is disk 0 of 0. */
	  archive_le64enc(buff + 24, zip->central_directory_entries);
	  archive_le64enc(buff + 32, zip->central_directory_entries);
	  archive_le64enc(buff + 40, offset_end - offset_start);
	  archive_le64enc(buff + 48, offset_start);
	  ret = __archive_write_output(a, buff, 56);
	  if (ret != ARCHIVE_OK)
		  return (ARCHIVE_FATAL);
	  zip->written_bytes += 56;

	  /* Zip64 end-of-cd locator record. */
	  memset(buff, 0, 20);
	  memcpy(buff, ""PK\006\007"", 4);
	  archive_le32enc(buff + 4, 0);
	  archive_le64enc(buff + 8, offset_end);
	  archive_le32enc(buff + 16, 1);
	  ret = __archive_write_output(a, buff, 20);
	  if (ret != ARCHIVE_OK)
		  return (ARCHIVE_FATAL);
	  zip->written_bytes += 20;

	}

	/* Format and write end of central directory. */
	memset(buff, 0, sizeof(buff));
	memcpy(buff, ""PK\005\006"", 4);
	archive_le16enc(buff + 8, zipmin(0xffffU, zip->central_directory_entries));
	archive_le16enc(buff + 10, zipmin(0xffffU, zip->central_directory_entries));
	archive_le32enc(buff + 12, (uint32_t)zipmin(0xffffffffLL, (offset_end - offset_start)));
	archive_le32enc(buff + 16, (uint32_t)zipmin(0xffffffffLL, offset_start));
	ret = __archive_write_output(a, buff, 22);
	if (ret != ARCHIVE_OK)
		return (ARCHIVE_FATAL);
	zip->written_bytes += 22;
	return (ARCHIVE_OK);
}

static int
archive_write_zip_free(struct archive_write *a)
{
	struct zip *zip;
	struct cd_segment *segment;

	zip = a->format_data;
	while (zip->central_directory != NULL) {
		segment = zip->central_directory;
		zip->central_directory = segment->next;
		free(segment->buff);
		free(segment);
	}
#ifdef HAVE_ZLIB_H
	free(zip->buf);
#endif
	archive_entry_free(zip->entry);
	/* TODO: Free opt_sconv, sconv_default */

	free(zip);
	a->format_data = NULL;
	return (ARCHIVE_OK);
",663,803,679,816,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid ZIP compression type"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid ZIP compression type"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_336.cpp,"{
	case COMPRESSION_STORE:
		ret = __archive_write_output(a, buff, s);
		if (ret != ARCHIVE_OK) return (ret);
		zip->written_bytes += s;
		zip->remaining_data_bytes -= s;
		l->compressed_size += s;
		l->crc32 = crc32(l->crc32, buff, (unsigned)s);
		return (s);
#if HAVE_ZLIB_H
	case COMPRESSION_DEFLATE:
		zip->stream.next_in = (unsigned char*)(uintptr_t)buff;
		zip->stream.avail_in = (uInt)s;
		do {
			ret = deflate(&zip->stream, Z_NO_FLUSH);
			if (ret == Z_STREAM_ERROR)
				return (ARCHIVE_FATAL);
			if (zip->stream.avail_out == 0) {
				ret = __archive_write_output(a, zip->buf,
					zip->len_buf);
				if (ret != ARCHIVE_OK)
					return (ret);
				l->compressed_size += zip->len_buf;
				zip->written_bytes += zip->len_buf;
				zip->stream.next_out = zip->buf;
				zip->stream.avail_out = (uInt)zip->len_buf;
			}
		} while (zip->stream.avail_in != 0);
		zip->remaining_data_bytes -= s;
		/* If we have it, use zlib's fast crc32() */
		l->crc32 = crc32(l->crc32, buff, (uInt)s);
		return (s);
#endif

	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid ZIP compression type"");
		return ARCHIVE_FATAL;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_336.cpp,"[5, 0, 0, 1, 0, 0, 6, 0, 2, 1, 6, 0, 0, 0, 0, 125, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 0, 0, 6, 0, 0, 16, 0, 17, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_336.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-03T19:02:49,Brad King,111
64713ae3ffddf6fbbfa7ea762c3d756cb245a066,"libarchive 3.1.2-218-g00f4bd83 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-218-g00f4bd83 &&
r=00f4bd83 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_337.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_337.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_635.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_635.cpp,"
/*
 * Device entries have one of the following forms:
 * raw dev_t
 * format,major,minor[,subdevice]
 *
 * Just use major and minor, no translation etc is done
 * between formats.
 */
static int
parse_device(struct archive *a, struct archive_entry *entry, char *val)
{
	char *comma1, *comma2;

	comma1 = strchr(val, ',');
	if (comma1 == NULL) {
		archive_entry_set_dev(entry, (dev_t)mtree_atol10(&val));
		return (ARCHIVE_OK);
	}
	++comma1;
	comma2 = strchr(comma1, ',');
	if (comma2 == NULL) {
		archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Malformed device attribute"");
		return (ARCHIVE_WARN);
	}
	++comma2;
	archive_entry_set_rdevmajor(entry, (dev_t)mtree_atol(&comma1));
	archive_entry_set_rdevminor(entry, (dev_t)mtree_atol(&comma2));
	return (ARCHIVE_OK);
}

/*
","
/*
 * Device entries have one of the following forms:
 *  - raw dev_t
 *  - format,major,minor[,subdevice]
 * When parsing succeeded, `pdev' will contain the appropriate dev_t value.
 */

/* strsep() is not in C90, but strcspn() is. */
/* Taken from http://unixpapa.com/incnote/string.html */
static char *
la_strsep(char **sp, char *sep)
{
	char *p, *s;
	if (sp == NULL || *sp == NULL || **sp == '\0')
		return(NULL);
	s = *sp;
	p = s + strcspn(s, sep);
	if (*p != '\0')
		*p++ = '\0';
	*sp = p;
	return(s);
}

static int
parse_device(dev_t *pdev, struct archive *a, char *val)
{
#define MAX_PACK_ARGS 3
	unsigned long numbers[MAX_PACK_ARGS];
	char *p, *dev;
	int argc;
	pack_t *pack;
	dev_t result;
	const char *error = NULL;

	memset(pdev, 0, sizeof(*pdev));
	if ((dev = strchr(val, ',')) != NULL) {
		/*
		 * Device's major/minor are given in a specified format.
		 * Decode and pack it accordingly.
		 */
		*dev++ = '\0';
		if ((pack = pack_find(val)) == NULL) {
			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Unknown format `%s'"", val);
			return ARCHIVE_WARN;
		}
		argc = 0;
		while ((p = la_strsep(&dev, "","")) != NULL) {
			if (*p == '\0') {
				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Missing number"");
				return ARCHIVE_WARN;
			}
			numbers[argc++] = mtree_atol(&p);
			if (argc > MAX_PACK_ARGS) {
				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"");
				return ARCHIVE_WARN;
			}
		}
		if (argc < 2) {
			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Not enough arguments"");
			return ARCHIVE_WARN;
		}
		result = (*pack)(argc, numbers, &error);
		if (error != NULL) {
			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""%s"", error);
			return ARCHIVE_WARN;
		}
	} else {
		/* file system raw value. */
		result = (dev_t)mtree_atol(&val);
	}
	*pdev = result;
	return ARCHIVE_OK;
#undef MAX_PACK_ARGS
}

/*
",1292,1319,1314,1362,"archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Malformed device attribute"");","archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Unknown format `%s'"", val);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_337.cpp,"{
		archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Malformed device attribute"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_337.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_337.cpp,"name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-03T18:19:12,Brad King,74
64713ae3ffddf6fbbfa7ea762c3d756cb245a066,"libarchive 3.1.2-218-g00f4bd83 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-218-g00f4bd83 &&
r=00f4bd83 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_341.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_341.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_646.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_646.cpp,"static int
archive_write_zip_header(struct archive_write *a, struct archive_entry *entry)
{
	struct zip *zip;
	uint8_t h[SIZE_LOCAL_FILE_HEADER];
	uint8_t e[SIZE_EXTRA_DATA_LOCAL];
	uint8_t *d;
	struct zip_file_header_link *l;
	struct archive_string_conv *sconv;
	int ret, ret2 = ARCHIVE_OK;
	int64_t size;
	mode_t type;

	/* Entries other than a regular file or a folder are skipped. */
	type = archive_entry_filetype(entry);
	if (type != AE_IFREG && type != AE_IFDIR && type != AE_IFLNK) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Filetype not supported"");
		return ARCHIVE_FAILED;
	};

	/* Directory entries should have a size of 0. */
	if (type == AE_IFDIR)
		archive_entry_set_size(entry, 0);

	zip = a->format_data;
	/* Setup default conversion. */
	if (zip->opt_sconv == NULL && !zip->init_default_conversion) {
		zip->sconv_default =
		    archive_string_default_conversion_for_write(&(a->archive));
		zip->init_default_conversion = 1;
	}

	if (zip->flags == 0) {
		/* Initialize the general purpose flags. */
		zip->flags = ZIP_FLAGS;
		if (zip->opt_sconv != NULL) {
			if (strcmp(archive_string_conversion_charset_name(
			    zip->opt_sconv), ""UTF-8"") == 0)
				zip->flags |= ZIP_FLAGS_UTF8_NAME;
#if HAVE_NL_LANGINFO
		} else if (strcmp(nl_langinfo(CODESET), ""UTF-8"") == 0) {
			zip->flags |= ZIP_FLAGS_UTF8_NAME;
#endif
		}
	}
	d = zip->data_descriptor;
	size = archive_entry_size(entry);
	zip->remaining_data_bytes = size;

	/* Append archive entry to the central directory data. */
	l = (struct zip_file_header_link *) malloc(sizeof(*l));
	if (l == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip header data"");
		return (ARCHIVE_FATAL);
	}
#if defined(_WIN32) && !defined(__CYGWIN__)
	/* Make sure the path separators in pahtname, hardlink and symlink
	 * are all slash '/', not the Windows path separator '\'. */
	l->entry = __la_win_entry_in_posix_pathseparator(entry);
	if (l->entry == entry)
		l->entry = archive_entry_clone(entry);
#else
	l->entry = archive_entry_clone(entry);
#endif
	if (l->entry == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip header data"");
		free(l);
		return (ARCHIVE_FATAL);
	}
	l->flags = zip->flags;
	if (zip->opt_sconv != NULL)
		sconv = zip->opt_sconv;
	else
		sconv = zip->sconv_default;
	if (sconv != NULL) {
		const char *p;
		size_t len;

		if (archive_entry_pathname_l(entry, &p, &len, sconv) != 0) {
			if (errno == ENOMEM) {
				archive_entry_free(l->entry);
				free(l);
				archive_set_error(&a->archive, ENOMEM,
				    ""Can't allocate memory for Pathname"");
				return (ARCHIVE_FATAL);
","static int
archive_write_zip_header(struct archive_write *a, struct archive_entry *entry)
{
	unsigned char local_header[32];
	unsigned char local_extra[128];
	struct zip *zip = a->format_data;
	unsigned char *e;
	unsigned char *cd_extra;
	size_t filename_length;
	const char *symlink = NULL;
	size_t symlink_size = 0;
	struct archive_string_conv *sconv = get_sconv(a, zip);
	int ret, ret2 = ARCHIVE_OK;
	int64_t size;
	mode_t type;
	int version_needed = 10;

	/* Ignore types of entries that we don't support. */
	type = archive_entry_filetype(entry);
	if (type != AE_IFREG && type != AE_IFDIR && type != AE_IFLNK) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Filetype not supported"");
		return ARCHIVE_FAILED;
	};

	/* If we're not using Zip64, reject large files. */
	if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
		/* Reject entries over 4GB. */
		if (archive_entry_size_is_set(entry)
		    && (archive_entry_size(entry) > 0xffffffff)) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Files > 4GB require Zip64 extensions"");
			return ARCHIVE_FAILED;
		}
		/* Reject entries if archive is > 4GB. */
		if (zip->written_bytes > 0xffffffff) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Archives > 4GB require Zip64 extensions"");
			return ARCHIVE_FAILED;
		}
	}

	/* Only regular files can have size > 0. */
	if (type != AE_IFREG)
		archive_entry_set_size(entry, 0);


	/* Reset information from last entry. */
	zip->entry_offset = zip->written_bytes;
	zip->entry_uncompressed_limit = INT64_MAX;
	zip->entry_compressed_size = 0;
	zip->entry_uncompressed_size = 0;
	zip->entry_compressed_written = 0;
	zip->entry_uncompressed_written = 0;
	zip->entry_flags = 0;
	zip->entry_uses_zip64 = 0;
	zip->entry_crc32 = zip->crc32func(0, NULL, 0);
	if (zip->entry != NULL) {
		archive_entry_free(zip->entry);
		zip->entry = NULL;
	}

#if defined(_WIN32) && !defined(__CYGWIN__)
	/* Make sure the path separators in pahtname, hardlink and symlink
	 * are all slash '/', not the Windows path separator '\'. */
	zip->entry = __la_win_entry_in_posix_pathseparator(entry);
	if (zip->entry == entry)
		zip->entry = archive_entry_clone(entry);
#else
	zip->entry = archive_entry_clone(entry);
#endif
	if (zip->entry == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip header data"");
		return (ARCHIVE_FATAL);
	}

	if (sconv != NULL) {
		const char *p;
		size_t len;

		if (archive_entry_pathname_l(entry, &p, &len, sconv) != 0) {
			if (errno == ENOMEM) {
				archive_set_error(&a->archive, ENOMEM,
				    ""Can't allocate memory for Pathname"");
				return (ARCHIVE_FATAL);
",376,399,443,435,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip header data"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Archives > 4GB require Zip64 extensions"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_338.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip header data"");
		free(l);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_338.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_338.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-03T18:19:12,Brad King,111
64713ae3ffddf6fbbfa7ea762c3d756cb245a066,"libarchive 3.1.2-218-g00f4bd83 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-218-g00f4bd83 &&
r=00f4bd83 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_341.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_341.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_648.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_648.cpp,"					zip->len_buf);
				if (ret != ARCHIVE_OK)
					return (ret);
				l->compressed_size += zip->len_buf;
				zip->written_bytes += zip->len_buf;
				zip->stream.next_out = zip->buf;
				zip->stream.avail_out = (uInt)zip->len_buf;
			}
		} while (zip->stream.avail_in != 0);
		zip->remaining_data_bytes -= s;
		/* If we have it, use zlib's fast crc32() */
		l->crc32 = crc32(l->crc32, buff, (uInt)s);
		return (s);
#endif

	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid ZIP compression type"");
		return ARCHIVE_FATAL;
	}
}

static int
archive_write_zip_finish_entry(struct archive_write *a)
{
	/* Write the data descripter after file data has been written. */
	int ret;
	struct zip *zip = a->format_data;
	uint8_t *d = zip->data_descriptor;
	struct zip_file_header_link *l = zip->central_directory_end;
#if HAVE_ZLIB_H
	size_t reminder;
#endif

	switch(l->compression) {
	case COMPRESSION_STORE:
		break;
#if HAVE_ZLIB_H
	case COMPRESSION_DEFLATE:
		for (;;) {
			ret = deflate(&zip->stream, Z_FINISH);
			if (ret == Z_STREAM_ERROR)
				return (ARCHIVE_FATAL);
			reminder = zip->len_buf - zip->stream.avail_out;
			ret = __archive_write_output(a, zip->buf, reminder);
			if (ret != ARCHIVE_OK)
				return (ret);
			l->compressed_size += reminder;
			zip->written_bytes += reminder;
			zip->stream.next_out = zip->buf;
			if (zip->stream.avail_out != 0)
				break;
			zip->stream.avail_out = (uInt)zip->len_buf;
		}
		deflateEnd(&zip->stream);
		break;
#endif
	}

	archive_le32enc(&d[DATA_DESCRIPTOR_CRC32], l->crc32);
	archive_le32enc(&d[DATA_DESCRIPTOR_COMPRESSED_SIZE],
		(uint32_t)l->compressed_size);
	ret = __archive_write_output(a, d, SIZE_DATA_DESCRIPTOR);
	if (ret != ARCHIVE_OK)
		return (ARCHIVE_FATAL);
	zip->written_bytes += SIZE_DATA_DESCRIPTOR;
	return (ARCHIVE_OK);
}

static int
archive_write_zip_close(struct archive_write *a)
{
	struct zip *zip;
	struct zip_file_header_link *l;
	uint8_t h[SIZE_FILE_HEADER];
	uint8_t end[SIZE_CENTRAL_DIRECTORY_END];
	uint8_t e[SIZE_EXTRA_DATA_CENTRAL];
	int64_t offset_start, offset_end;
	int entries;
	int ret;

	zip = a->format_data;
	l = zip->central_directory;

	/*
	 * Formatting central directory file header fields that are
	 * fixed for all entries.
	 * Fields not used (and therefor 0) are:
	 *
	 *   - comment_length
	 *   - disk_number
	 *   - attributes_internal
	 */
	memset(h, 0, sizeof(h));
	archive_le32enc(&h[FILE_HEADER_SIGNATURE], ZIP_SIGNATURE_FILE_HEADER);
	archive_le16enc(&h[FILE_HEADER_VERSION_BY], ZIP_VERSION_BY);
	archive_le16enc(&h[FILE_HEADER_VERSION_EXTRACT], ZIP_VERSION_EXTRACT);

	entries = 0;
	offset_start = zip->written_bytes;

	/* Formatting individual header fields per entry and
	 * writing each entry. */
	while (l != NULL) {
		archive_le16enc(&h[FILE_HEADER_FLAGS], l->flags);
		archive_le16enc(&h[FILE_HEADER_COMPRESSION], l->compression);
		archive_le32enc(&h[FILE_HEADER_TIMEDATE],
			dos_time(archive_entry_mtime(l->entry)));
		archive_le32enc(&h[FILE_HEADER_CRC32], l->crc32);
		archive_le32enc(&h[FILE_HEADER_COMPRESSED_SIZE],
			(uint32_t)l->compressed_size);
		archive_le32enc(&h[FILE_HEADER_UNCOMPRESSED_SIZE],
			(uint32_t)archive_entry_size(l->entry));
		archive_le16enc(&h[FILE_HEADER_FILENAME_LENGTH],
			(uint16_t)path_length(l->entry));
		archive_le16enc(&h[FILE_HEADER_EXTRA_LENGTH], sizeof(e));
		archive_le16enc(&h[FILE_HEADER_ATTRIBUTES_EXTERNAL+2],
			archive_entry_mode(l->entry));
		archive_le32enc(&h[FILE_HEADER_OFFSET], (uint32_t)l->offset);

		/* Formatting extra data. */
		archive_le16enc(&e[EXTRA_DATA_CENTRAL_TIME_ID],
			ZIP_SIGNATURE_EXTRA_TIMESTAMP);
		archive_le16enc(&e[EXTRA_DATA_CENTRAL_TIME_SIZE], 1 + 4);
		e[EXTRA_DATA_CENTRAL_TIME_FLAG] = 0x07;
		archive_le32enc(&e[EXTRA_DATA_CENTRAL_MTIME],
			(uint32_t)archive_entry_mtime(l->entry));
		archive_le16enc(&e[EXTRA_DATA_CENTRAL_UNIX_ID],
			ZIP_SIGNATURE_EXTRA_NEW_UNIX);
		archive_le16enc(&e[EXTRA_DATA_CENTRAL_UNIX_SIZE], 0x0000);

		ret = __archive_write_output(a, h, sizeof(h));
		if (ret != ARCHIVE_OK)
			return (ARCHIVE_FATAL);
		zip->written_bytes += sizeof(h);

		ret = write_path(l->entry, a);
		if (ret <= ARCHIVE_OK)
			return (ARCHIVE_FATAL);
		zip->written_bytes += ret;

		ret = __archive_write_output(a, e, sizeof(e));
		if (ret != ARCHIVE_OK)
			return (ARCHIVE_FATAL);
		zip->written_bytes += sizeof(e);

		l = l->next;
		entries++;
	}
	offset_end = zip->written_bytes;

	/* Formatting end of central directory. */
	memset(end, 0, sizeof(end));
	archive_le32enc(&end[CENTRAL_DIRECTORY_END_SIGNATURE],
		ZIP_SIGNATURE_CENTRAL_DIRECTORY_END);
	archive_le16enc(&end[CENTRAL_DIRECTORY_END_ENTRIES_DISK], entries);
	archive_le16enc(&end[CENTRAL_DIRECTORY_END_ENTRIES], entries);
	archive_le32enc(&end[CENTRAL_DIRECTORY_END_SIZE],
		(uint32_t)(offset_end - offset_start));
	archive_le32enc(&end[CENTRAL_DIRECTORY_END_OFFSET],
		(uint32_t)offset_start);

	/* Writing end of central directory. */
	ret = __archive_write_output(a, end, sizeof(end));
	if (ret != ARCHIVE_OK)
		return (ARCHIVE_FATAL);
	zip->written_bytes += sizeof(end);
	return (ARCHIVE_OK);
}

static int
archive_write_zip_free(struct archive_write *a)
{
	struct zip *zip;
	struct zip_file_header_link *l;

	zip = a->format_data;
	while (zip->central_directory != NULL) {
	   l = zip->central_directory;
	   zip->central_directory = l->next;
	   archive_entry_free(l->entry);
	   free(l);
	}
#ifdef HAVE_ZLIB_H
	free(zip->buf);
#endif
	free(zip);
	a->format_data = NULL;
	return (ARCHIVE_OK);
","					zip->len_buf);
				if (ret != ARCHIVE_OK)
					return (ret);
				zip->entry_compressed_written += zip->len_buf;
				zip->written_bytes += zip->len_buf;
				zip->stream.next_out = zip->buf;
				zip->stream.avail_out = (uInt)zip->len_buf;
			}
		} while (zip->stream.avail_in != 0);
		break;
#endif

	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid ZIP compression type"");
		return ARCHIVE_FATAL;
	}

	zip->entry_uncompressed_limit -= s;
	zip->entry_crc32 = zip->crc32func(zip->entry_crc32, buff, (unsigned)s);
	return (s);

}

static int
archive_write_zip_finish_entry(struct archive_write *a)
{
	struct zip *zip = a->format_data;
	int ret;

#if HAVE_ZLIB_H
	if (zip->entry_compression == COMPRESSION_DEFLATE) {
		for (;;) {
			size_t remainder;
			ret = deflate(&zip->stream, Z_FINISH);
			if (ret == Z_STREAM_ERROR)
				return (ARCHIVE_FATAL);
			remainder = zip->len_buf - zip->stream.avail_out;
			ret = __archive_write_output(a, zip->buf, remainder);
			if (ret != ARCHIVE_OK)
				return (ret);
			zip->entry_compressed_written += remainder;
			zip->written_bytes += remainder;
			zip->stream.next_out = zip->buf;
			if (zip->stream.avail_out != 0)
				break;
			zip->stream.avail_out = (uInt)zip->len_buf;
		}
		deflateEnd(&zip->stream);
	}
#endif

	/* Write trailing data descriptor. */
	if ((zip->entry_flags & ZIP_ENTRY_FLAG_LENGTH_AT_END) != 0) {
		char d[24];
		memcpy(d, ""PK\007\010"", 4);
		archive_le32enc(d + 4, zip->entry_crc32);
		if (zip->entry_uses_zip64) {
			archive_le64enc(d + 8, (uint64_t)zip->entry_compressed_written);
			archive_le64enc(d + 16, (uint64_t)zip->entry_uncompressed_written);
			ret = __archive_write_output(a, d, 24);
			zip->written_bytes += 24;
		} else {
			archive_le32enc(d + 8, (uint32_t)zip->entry_compressed_written);
			archive_le32enc(d + 12, (uint32_t)zip->entry_uncompressed_written);
			ret = __archive_write_output(a, d, 16);
			zip->written_bytes += 16;
		}
		if (ret != ARCHIVE_OK)
			return (ARCHIVE_FATAL);
	}

	/* Append Zip64 extra data to central directory information. */
	if (zip->entry_compressed_written > 0xffffffffLL
	    || zip->entry_uncompressed_written > 0xffffffffLL
	    || zip->entry_offset > 0xffffffffLL) {
		unsigned char zip64[32];
		unsigned char *z = zip64, *zd;
		memcpy(z, ""\001\000\000\000"", 4);
		z += 4;
		if (zip->entry_uncompressed_written >= 0xffffffffLL) {
			archive_le64enc(z, zip->entry_uncompressed_written);
			z += 8;
		}
		if (zip->entry_compressed_written >= 0xffffffffLL) {
			archive_le64enc(z, zip->entry_compressed_written);
			z += 8;
		}
		if (zip->entry_offset >= 0xffffffffLL) {
			archive_le64enc(z, zip->entry_offset);
			z += 8;
		}
		archive_le16enc(zip64 + 2, z - (zip64 + 4));
		zd = cd_alloc(zip, z - zip64);
		if (zd == NULL) {
			archive_set_error(&a->archive, ENOMEM,
				""Can't allocate zip data"");
			return (ARCHIVE_FATAL);
		}
		memcpy(zd, zip64, z - zip64);
		/* Zip64 means version needs to be set to at least 4.5 */
		if (archive_le16dec(zip->file_header + 6) < 45)
			archive_le16enc(zip->file_header + 6, 45);
	}

	/* Fix up central directory file header. */
	archive_le32enc(zip->file_header + 16, zip->entry_crc32);
	archive_le32enc(zip->file_header + 20,
	    zipmin(zip->entry_compressed_written, 0xffffffffLL));
	archive_le32enc(zip->file_header + 24,
	    zipmin(zip->entry_uncompressed_written, 0xffffffffLL));
	archive_le16enc(zip->file_header + 30,
	    zip->central_directory_bytes - zip->file_header_extra_offset);
	archive_le32enc(zip->file_header + 42,
	    zipmin(zip->entry_offset, 0xffffffffLL));

	return (ARCHIVE_OK);
}

static int
archive_write_zip_close(struct archive_write *a)
{
	uint8_t buff[64];
	int64_t offset_start, offset_end;
	struct zip *zip = a->format_data;
	struct cd_segment *segment;
	int ret;

	offset_start = zip->written_bytes;
	segment = zip->central_directory;
	while (segment != NULL) {
		ret = __archive_write_output(a,
		    segment->buff, segment->p - segment->buff);
		if (ret != ARCHIVE_OK)
			return (ARCHIVE_FATAL);
		zip->written_bytes += segment->p - segment->buff;
		segment = segment->next;
	}
	offset_end = zip->written_bytes;

	/* If central dir info is too large, write Zip64 end-of-cd */
	if (offset_end - offset_start > 0xffffffffLL
	    || offset_start > 0xffffffffLL
	    || zip->central_directory_entries > 0xffffUL
	    || (zip->flags & ZIP_FLAG_FORCE_ZIP64)) {
	  /* Zip64 end-of-cd record */
	  memset(buff, 0, 56);
	  memcpy(buff, ""PK\006\006"", 4);
	  archive_le64enc(buff + 4, 44);
	  archive_le16enc(buff + 12, 45);
	  archive_le16enc(buff + 14, 45);
	  /* This is disk 0 of 0. */
	  archive_le64enc(buff + 24, zip->central_directory_entries);
	  archive_le64enc(buff + 32, zip->central_directory_entries);
	  archive_le64enc(buff + 40, offset_end - offset_start);
	  archive_le64enc(buff + 48, offset_start);
	  ret = __archive_write_output(a, buff, 56);
	  if (ret != ARCHIVE_OK)
		  return (ARCHIVE_FATAL);
	  zip->written_bytes += 56;

	  /* Zip64 end-of-cd locator record. */
	  memset(buff, 0, 20);
	  memcpy(buff, ""PK\006\007"", 4);
	  archive_le32enc(buff + 4, 0);
	  archive_le64enc(buff + 8, offset_end);
	  archive_le32enc(buff + 16, 1);
	  ret = __archive_write_output(a, buff, 20);
	  if (ret != ARCHIVE_OK)
		  return (ARCHIVE_FATAL);
	  zip->written_bytes += 20;

	}

	/* Format and write end of central directory. */
	memset(buff, 0, sizeof(buff));
	memcpy(buff, ""PK\005\006"", 4);
	archive_le16enc(buff + 8, zipmin(0xffffU, zip->central_directory_entries));
	archive_le16enc(buff + 10, zipmin(0xffffU, zip->central_directory_entries));
	archive_le32enc(buff + 12, (uint32_t)zipmin(0xffffffffLL, (offset_end - offset_start)));
	archive_le32enc(buff + 16, (uint32_t)zipmin(0xffffffffLL, offset_start));
	ret = __archive_write_output(a, buff, 22);
	if (ret != ARCHIVE_OK)
		return (ARCHIVE_FATAL);
	zip->written_bytes += 22;
	return (ARCHIVE_OK);
}

static int
archive_write_zip_free(struct archive_write *a)
{
	struct zip *zip;
	struct cd_segment *segment;

	zip = a->format_data;
	while (zip->central_directory != NULL) {
		segment = zip->central_directory;
		zip->central_directory = segment->next;
		free(segment->buff);
		free(segment);
	}
#ifdef HAVE_ZLIB_H
	free(zip->buf);
#endif
	archive_entry_free(zip->entry);
	/* TODO: Free opt_sconv, sconv_default */

	free(zip);
	a->format_data = NULL;
	return (ARCHIVE_OK);
",663,803,679,816,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid ZIP compression type"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid ZIP compression type"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_339.cpp,"{
	case COMPRESSION_STORE:
		ret = __archive_write_output(a, buff, s);
		if (ret != ARCHIVE_OK) return (ret);
		zip->written_bytes += s;
		zip->remaining_data_bytes -= s;
		l->compressed_size += s;
		l->crc32 = crc32(l->crc32, buff, (unsigned)s);
		return (s);
#if HAVE_ZLIB_H
	case COMPRESSION_DEFLATE:
		zip->stream.next_in = (unsigned char*)(uintptr_t)buff;
		zip->stream.avail_in = (uInt)s;
		do {
			ret = deflate(&zip->stream, Z_NO_FLUSH);
			if (ret == Z_STREAM_ERROR)
				return (ARCHIVE_FATAL);
			if (zip->stream.avail_out == 0) {
				ret = __archive_write_output(a, zip->buf,
					zip->len_buf);
				if (ret != ARCHIVE_OK)
					return (ret);
				l->compressed_size += zip->len_buf;
				zip->written_bytes += zip->len_buf;
				zip->stream.next_out = zip->buf;
				zip->stream.avail_out = (uInt)zip->len_buf;
			}
		} while (zip->stream.avail_in != 0);
		zip->remaining_data_bytes -= s;
		/* If we have it, use zlib's fast crc32() */
		l->crc32 = crc32(l->crc32, buff, (uInt)s);
		return (s);
#endif

	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid ZIP compression type"");
		return ARCHIVE_FATAL;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_339.cpp,"[5, 0, 0, 1, 0, 0, 6, 0, 2, 1, 6, 0, 0, 0, 0, 125, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 0, 0, 6, 0, 0, 16, 0, 17, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_339.cpp,"name****operator****name****operator****name****name****expr****argument
name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-03T18:19:12,Brad King,111
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_342.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_342.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_649.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_649.cpp,"            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");
    this->DisplayConstraintGraph();
    }

","            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName().c_str(),
            this->HasConfig?this->Config.c_str():""noconfig"");
    this->DisplayConstraintGraph();
    }

",254,255,256,257,"fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");","fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName().c_str(),
            this->HasConfig?this->Config.c_str():""noconfig"");",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_340.cpp,"{
    fprintf(stderr,
            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");
    this->DisplayConstraintGraph();
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_340.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 4, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_340.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****expr****condition****name****operator****name****name****expr****then****literal****expr****else****ternary****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-02T18:44:35,Brad King,98
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_342.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_342.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_650.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_650.cpp,"//----------------------------------------------------------------------------
void cmComputeLinkDepends::DisplayFinalEntries()
{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }
    else
      {
","//----------------------------------------------------------------------------
void cmComputeLinkDepends::DisplayFinalEntries()
{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName().c_str());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName().c_str());
      }
    else
      {
",968,970,971,973,"fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());","fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName().c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_341.cpp,"{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }
    else
      {
      fprintf(stderr, ""  item [%s]\n"", lei->Item.c_str());
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_341.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 40, 0, 0, 0, 1, 0, 0, 2, 4, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 1, 1, 0, 10, 0, 0, 4, 0, 12, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_341.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-02T18:44:35,Brad King,110
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_342.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_342.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_650.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_650.cpp,"//----------------------------------------------------------------------------
void cmComputeLinkDepends::DisplayFinalEntries()
{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }
    else
      {
","//----------------------------------------------------------------------------
void cmComputeLinkDepends::DisplayFinalEntries()
{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName().c_str());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName().c_str());
      }
    else
      {
",968,970,978,980,"fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());","fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName().c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_342.cpp,"{
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_342.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_342.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-02T18:44:35,Brad King,110
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_343.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_343.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_651.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_651.cpp,"
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph, const char* name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
","
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph,
                                     const std::string& name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
",434,435,439,441,"fprintf(stderr, ""The %s target dependency graph is:\n"", name);","fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_343.cpp,"{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_343.cpp,"[0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 63, 0, 0, 5, 7, 0, 0, 9, 7, 0, 0, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 1, 37, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 3, 0, 3, 1, 1, 0, 12, 0, 0, 4, 0, 16, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_343.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-02T18:44:35,Brad King,112
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_343.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_343.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_651.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_651.cpp,"
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph, const char* name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
","
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph,
                                     const std::string& name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
",434,435,445,447,"fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());","fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_344.cpp,"{
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_344.cpp,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 47, 0, 0, 4, 5, 0, 0, 6, 4, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 3, 0, 2, 1, 1, 0, 7, 0, 0, 2, 0, 9, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_344.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-02T18:44:35,Brad King,99
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_343.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_343.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_651.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_651.cpp,"
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph, const char* name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
","
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph,
                                     const std::string& name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
",434,435,451,453,"fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");","fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_345.cpp,"{
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_345.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 18, 0, 0, 2, 2, 0, 0, 2, 3, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 1, 1, 0, 3, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_345.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****argument_list****call****expr****condition****literal****expr****then****literal****expr****else****ternary****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-02T18:44:35,Brad King,100
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_344.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_344.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_654.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_654.cpp,"    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
","    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName.c_str());
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
",449,450,452,453,"fprintf(fout, ""add_executable(%s"", targetName);","fprintf(fout, ""add_executable(%s"", targetName.c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_346.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmLocalGenerator* lg = this->Makefile->GetLocalGenerator();
    cmGlobalGenerator* gg = lg->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      if(const char* lang = gg->GetLanguageFromExtension(ext.c_str()))
        {
        testLangs.insert(lang);
        }
      else
        {
        cmOStringStream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        for(std::vector<std::string>::iterator l = langs.begin();
            l != langs.end(); ++l)
          {
          err << "" "" << *l;
          }
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = cmsys::SystemTools::Fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""set(CMAKE_MODULE_PATH %s)\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""project(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""set(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    fprintf(fout, ""include_directories(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""add_definitions( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if (const char *cxxDef
              = this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_TARGET="";
      flag += cxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *cDef
                = this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_TARGET="";
      flag += cDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcxxDef = this->Makefile->GetDefinition(
                                  ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcDef = this->Makefile->GetDefinition(
                                    ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *rootDef
              = this->Makefile->GetDefinition(""CMAKE_SYSROOT""))
      {
      std::string flag=""-DCMAKE_SYSROOT="";
      flag += rootDef;
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_346.cpp,"[21, 0, 6, 0, 0, 0, 3, 0, 0, 0, 30, 0, 0, 0, 10, 593, 0, 0, 26, 40, 0, 0, 40, 83, 0, 0, 0, 0, 13, 0, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 1, 256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 2, 0, 28, 22, 3, 0, 122, 0, 0, 62, 2, 127, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_346.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-02T18:44:35,Brad King,112
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_344.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_344.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_655.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_655.cpp,"    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
","    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());
      }
    fclose(fout);
",465,466,467,468,"fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);","fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_347.cpp,"{
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_347.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_347.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-02T18:44:35,Brad King,112
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_344.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_344.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_655.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_655.cpp,"    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
","    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());
      }
    fclose(fout);
",465,466,472,474,"fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());","fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_348.cpp,"{
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_348.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_348.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-02T18:44:35,Brad King,101
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_345.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_345.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_657.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_657.cpp,"            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");
    this->DisplayConstraintGraph();
    }

","            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName().c_str(),
            this->HasConfig?this->Config.c_str():""noconfig"");
    this->DisplayConstraintGraph();
    }

",254,255,256,257,"fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");","fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName().c_str(),
            this->HasConfig?this->Config.c_str():""noconfig"");",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_349.cpp,"{
    fprintf(stderr,
            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");
    this->DisplayConstraintGraph();
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_349.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 4, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_349.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****expr****condition****name****operator****name****name****expr****then****literal****expr****else****ternary****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-02T18:44:35,Brad King,98
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_345.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_345.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_658.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_658.cpp,"//----------------------------------------------------------------------------
void cmComputeLinkDepends::DisplayFinalEntries()
{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }
    else
      {
","//----------------------------------------------------------------------------
void cmComputeLinkDepends::DisplayFinalEntries()
{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName().c_str());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName().c_str());
      }
    else
      {
",968,970,971,973,"fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());","fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName().c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_350.cpp,"{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }
    else
      {
      fprintf(stderr, ""  item [%s]\n"", lei->Item.c_str());
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_350.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 40, 0, 0, 0, 1, 0, 0, 2, 4, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 1, 1, 0, 10, 0, 0, 4, 0, 12, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_350.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-02T18:44:35,Brad King,110
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_345.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_345.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_658.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_658.cpp,"//----------------------------------------------------------------------------
void cmComputeLinkDepends::DisplayFinalEntries()
{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }
    else
      {
","//----------------------------------------------------------------------------
void cmComputeLinkDepends::DisplayFinalEntries()
{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName().c_str());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName().c_str());
      }
    else
      {
",968,970,978,980,"fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());","fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName().c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_351.cpp,"{
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_351.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_351.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-02T18:44:35,Brad King,110
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_346.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_346.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_659.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_659.cpp,"
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph, const char* name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
","
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph,
                                     const std::string& name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
",434,435,439,441,"fprintf(stderr, ""The %s target dependency graph is:\n"", name);","fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_352.cpp,"{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_352.cpp,"[0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 63, 0, 0, 5, 7, 0, 0, 9, 7, 0, 0, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 1, 37, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 3, 0, 3, 1, 1, 0, 12, 0, 0, 4, 0, 16, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_352.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-02T18:44:35,Brad King,112
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_346.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_346.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_659.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_659.cpp,"
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph, const char* name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
","
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph,
                                     const std::string& name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
",434,435,445,447,"fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());","fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_353.cpp,"{
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_353.cpp,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 47, 0, 0, 4, 5, 0, 0, 6, 4, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 3, 0, 2, 1, 1, 0, 7, 0, 0, 2, 0, 9, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_353.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-02T18:44:35,Brad King,99
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_346.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_346.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_659.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_659.cpp,"
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph, const char* name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
","
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph,
                                     const std::string& name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
",434,435,451,453,"fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");","fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_354.cpp,"{
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_354.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 18, 0, 0, 2, 2, 0, 0, 2, 3, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 1, 1, 0, 3, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_354.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****argument_list****call****expr****condition****literal****expr****then****literal****expr****else****ternary****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-02T18:44:35,Brad King,100
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_347.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_347.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_662.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_662.cpp,"    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
","    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName.c_str());
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
",449,450,452,453,"fprintf(fout, ""add_executable(%s"", targetName);","fprintf(fout, ""add_executable(%s"", targetName.c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_355.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmLocalGenerator* lg = this->Makefile->GetLocalGenerator();
    cmGlobalGenerator* gg = lg->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      if(const char* lang = gg->GetLanguageFromExtension(ext.c_str()))
        {
        testLangs.insert(lang);
        }
      else
        {
        cmOStringStream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        for(std::vector<std::string>::iterator l = langs.begin();
            l != langs.end(); ++l)
          {
          err << "" "" << *l;
          }
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = cmsys::SystemTools::Fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""set(CMAKE_MODULE_PATH %s)\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""project(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""set(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    fprintf(fout, ""include_directories(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""add_definitions( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if (const char *cxxDef
              = this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_TARGET="";
      flag += cxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *cDef
                = this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_TARGET="";
      flag += cDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcxxDef = this->Makefile->GetDefinition(
                                  ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcDef = this->Makefile->GetDefinition(
                                    ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *rootDef
              = this->Makefile->GetDefinition(""CMAKE_SYSROOT""))
      {
      std::string flag=""-DCMAKE_SYSROOT="";
      flag += rootDef;
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_355.cpp,"[21, 0, 6, 0, 0, 0, 3, 0, 0, 0, 30, 0, 0, 0, 10, 593, 0, 0, 26, 40, 0, 0, 40, 83, 0, 0, 0, 0, 13, 0, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 1, 256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 2, 0, 28, 22, 3, 0, 122, 0, 0, 62, 2, 127, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_355.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-02T18:44:35,Brad King,112
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_347.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_347.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_663.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_663.cpp,"    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
","    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());
      }
    fclose(fout);
",465,466,467,468,"fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);","fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_356.cpp,"{
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_356.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_356.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-02T18:44:35,Brad King,112
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_347.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_347.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_663.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_663.cpp,"    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
","    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());
      }
    fclose(fout);
",465,466,472,474,"fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());","fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_357.cpp,"{
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_357.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_357.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-04-02T18:44:35,Brad King,101
6e466c6f2ee5160202aaa76a9d643d34bd7d908a,Merge branch 'master' into CONFIG-LOCATION-CMP0026,[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_348.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_348.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_664.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_664.cpp,"            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");
    this->DisplayConstraintGraph();
    }

","            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName().c_str(),
            this->HasConfig?this->Config.c_str():""noconfig"");
    this->DisplayConstraintGraph();
    }

",254,255,256,257,"fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");","fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName().c_str(),
            this->HasConfig?this->Config.c_str():""noconfig"");",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_358.cpp,"{
    fprintf(stderr,
            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");
    this->DisplayConstraintGraph();
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_358.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 4, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_358.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****expr****condition****name****operator****name****name****expr****then****literal****expr****else****ternary****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-17T13:31:21,Brad King,98
6e466c6f2ee5160202aaa76a9d643d34bd7d908a,Merge branch 'master' into CONFIG-LOCATION-CMP0026,[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_348.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_348.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_665.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_665.cpp,"//----------------------------------------------------------------------------
void cmComputeLinkDepends::DisplayFinalEntries()
{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }
    else
      {
","//----------------------------------------------------------------------------
void cmComputeLinkDepends::DisplayFinalEntries()
{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName().c_str());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName().c_str());
      }
    else
      {
",968,970,971,973,"fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());","fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName().c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_359.cpp,"{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }
    else
      {
      fprintf(stderr, ""  item [%s]\n"", lei->Item.c_str());
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_359.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 40, 0, 0, 0, 1, 0, 0, 2, 4, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 1, 1, 0, 10, 0, 0, 4, 0, 12, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_359.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-17T13:31:21,Brad King,110
6e466c6f2ee5160202aaa76a9d643d34bd7d908a,Merge branch 'master' into CONFIG-LOCATION-CMP0026,[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_348.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_348.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_665.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_665.cpp,"//----------------------------------------------------------------------------
void cmComputeLinkDepends::DisplayFinalEntries()
{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }
    else
      {
","//----------------------------------------------------------------------------
void cmComputeLinkDepends::DisplayFinalEntries()
{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName().c_str());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName().c_str());
      }
    else
      {
",968,970,978,980,"fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());","fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName().c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_360.cpp,"{
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_360.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_360.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-17T13:31:21,Brad King,110
6e466c6f2ee5160202aaa76a9d643d34bd7d908a,Merge branch 'master' into CONFIG-LOCATION-CMP0026,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_349.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_349.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_666.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_666.cpp,"
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph, const char* name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
","
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph,
                                     const std::string& name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
",434,434,439,440,"fprintf(stderr, ""The %s target dependency graph is:\n"", name);","fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_361.cpp,"{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_361.cpp,"[0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 63, 0, 0, 5, 7, 0, 0, 9, 7, 0, 0, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 1, 37, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 3, 0, 3, 1, 1, 0, 12, 0, 0, 4, 0, 16, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_361.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-17T13:31:21,Brad King,112
6e466c6f2ee5160202aaa76a9d643d34bd7d908a,Merge branch 'master' into CONFIG-LOCATION-CMP0026,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_349.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_349.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_666.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_666.cpp,"
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph, const char* name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
","
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph,
                                     const std::string& name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
",434,434,445,446,"fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());","fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_362.cpp,"{
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_362.cpp,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 47, 0, 0, 4, 5, 0, 0, 6, 4, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 3, 0, 2, 1, 1, 0, 7, 0, 0, 2, 0, 9, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_362.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-17T13:31:21,Brad King,99
6e466c6f2ee5160202aaa76a9d643d34bd7d908a,Merge branch 'master' into CONFIG-LOCATION-CMP0026,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_349.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_349.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_666.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_666.cpp,"
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph, const char* name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
","
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph,
                                     const std::string& name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
",434,434,451,452,"fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");","fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_363.cpp,"{
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_363.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 18, 0, 0, 2, 2, 0, 0, 2, 3, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 1, 1, 0, 3, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_363.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****argument_list****call****expr****condition****literal****expr****then****literal****expr****else****ternary****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-17T13:31:21,Brad King,100
6e466c6f2ee5160202aaa76a9d643d34bd7d908a,Merge branch 'master' into CONFIG-LOCATION-CMP0026,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_350.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_350.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_669.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_669.cpp,"    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
","    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName.c_str());
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
",449,450,452,453,"fprintf(fout, ""add_executable(%s"", targetName);","fprintf(fout, ""add_executable(%s"", targetName.c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_364.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmLocalGenerator* lg = this->Makefile->GetLocalGenerator();
    cmGlobalGenerator* gg = lg->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      if(const char* lang = gg->GetLanguageFromExtension(ext.c_str()))
        {
        testLangs.insert(lang);
        }
      else
        {
        cmOStringStream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        for(std::vector<std::string>::iterator l = langs.begin();
            l != langs.end(); ++l)
          {
          err << "" "" << *l;
          }
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = cmsys::SystemTools::Fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""set(CMAKE_MODULE_PATH %s)\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""project(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""set(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    fprintf(fout, ""include_directories(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""add_definitions( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if (const char *cxxDef
              = this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_TARGET="";
      flag += cxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *cDef
                = this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_TARGET="";
      flag += cDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcxxDef = this->Makefile->GetDefinition(
                                  ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcDef = this->Makefile->GetDefinition(
                                    ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *rootDef
              = this->Makefile->GetDefinition(""CMAKE_SYSROOT""))
      {
      std::string flag=""-DCMAKE_SYSROOT="";
      flag += rootDef;
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_364.cpp,"[21, 0, 6, 0, 0, 0, 3, 0, 0, 0, 30, 0, 0, 0, 10, 593, 0, 0, 26, 40, 0, 0, 40, 83, 0, 0, 0, 0, 13, 0, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 1, 256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 2, 0, 28, 22, 3, 0, 122, 0, 0, 62, 2, 127, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_364.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-17T13:31:21,Brad King,112
6e466c6f2ee5160202aaa76a9d643d34bd7d908a,Merge branch 'master' into CONFIG-LOCATION-CMP0026,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_350.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_350.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_670.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_670.cpp,"    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
","    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());
      }
    fclose(fout);
",465,466,467,468,"fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);","fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_365.cpp,"{
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_365.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_365.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-17T13:31:21,Brad King,112
6e466c6f2ee5160202aaa76a9d643d34bd7d908a,Merge branch 'master' into CONFIG-LOCATION-CMP0026,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_350.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_350.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_670.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_670.cpp,"    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
","    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());
      }
    fclose(fout);
",465,466,472,474,"fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());","fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_366.cpp,"{
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_366.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_366.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-17T13:31:21,Brad King,101
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_357.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_357.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_679.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_679.cpp,"            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");
    this->DisplayConstraintGraph();
    }

","            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName().c_str(),
            this->Config?this->Config:""noconfig"");
    this->DisplayConstraintGraph();
    }

",254,254,256,256,"fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");","fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName().c_str(),
            this->Config?this->Config:""noconfig"");",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_367.cpp,"{
    fprintf(stderr,
            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");
    this->DisplayConstraintGraph();
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_367.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 4, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_367.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****expr****condition****name****operator****name****name****expr****then****literal****expr****else****ternary****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-08T18:05:31,Brad King,75
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_358.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_358.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_680.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_680.cpp,"
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph, const char* name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
","
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph,
                                     const std::string& name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
",434,434,439,440,"fprintf(stderr, ""The %s target dependency graph is:\n"", name);","fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_368.cpp,"{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_368.cpp,"[0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 63, 0, 0, 5, 7, 0, 0, 9, 7, 0, 0, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 1, 37, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 3, 0, 3, 1, 1, 0, 12, 0, 0, 4, 0, 16, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_368.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-08T18:05:31,Brad King,112
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_358.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_358.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_680.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_680.cpp,"
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph, const char* name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
","
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph,
                                     const std::string& name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
",434,434,445,446,"fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());","fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_369.cpp,"{
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_369.cpp,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 47, 0, 0, 4, 5, 0, 0, 6, 4, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 3, 0, 2, 1, 1, 0, 7, 0, 0, 2, 0, 9, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_369.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-08T18:05:31,Brad King,99
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_358.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_358.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_680.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_680.cpp,"
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph, const char* name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
","
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph,
                                     const std::string& name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
",434,434,451,452,"fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");","fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_370.cpp,"{
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_370.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 18, 0, 0, 2, 2, 0, 0, 2, 3, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 1, 1, 0, 3, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_370.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****argument_list****call****expr****condition****literal****expr****then****literal****expr****else****ternary****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-08T18:05:31,Brad King,100
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_359.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_359.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_681.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_681.cpp,"    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
","    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName.c_str());
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
",450,450,453,453,"fprintf(fout, ""add_executable(%s"", targetName);","fprintf(fout, ""add_executable(%s"", targetName.c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_371.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmLocalGenerator* lg = this->Makefile->GetLocalGenerator();
    cmGlobalGenerator* gg = lg->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      std::string lang = gg->GetLanguageFromExtension(ext.c_str());
      if(!lang.empty())
        {
        testLangs.insert(lang);
        }
      else
        {
        cmOStringStream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        for(std::vector<std::string>::iterator l = langs.begin();
            l != langs.end(); ++l)
          {
          err << "" "" << *l;
          }
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = cmsys::SystemTools::Fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""set(CMAKE_MODULE_PATH %s)\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""project(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""set(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    fprintf(fout, ""include_directories(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""add_definitions( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if (const char *cxxDef
              = this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_TARGET="";
      flag += cxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *cDef
                = this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_TARGET="";
      flag += cDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcxxDef = this->Makefile->GetDefinition(
                                  ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcDef = this->Makefile->GetDefinition(
                                    ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *rootDef
              = this->Makefile->GetDefinition(""CMAKE_SYSROOT""))
      {
      std::string flag=""-DCMAKE_SYSROOT="";
      flag += rootDef;
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_371.cpp,"[21, 0, 6, 0, 0, 0, 3, 0, 0, 0, 30, 0, 0, 0, 9, 598, 0, 0, 27, 40, 0, 0, 40, 83, 0, 0, 0, 0, 12, 0, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 233, 1, 257, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 2, 0, 28, 22, 3, 0, 123, 0, 0, 62, 2, 127, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_371.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-08T18:05:31,Brad King,112
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_359.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_359.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_682.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_682.cpp,"    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
","    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());
      }
    fclose(fout);
",466,466,468,468,"fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);","fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_372.cpp,"{
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_372.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_372.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-08T18:05:31,Brad King,112
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_359.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_359.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_682.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_682.cpp,"    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
","    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());
      }
    fclose(fout);
",466,466,473,474,"fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());","fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_373.cpp,"{
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_373.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_373.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-08T18:05:31,Brad King,101
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmLocalVisualStudio6Generator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_360.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_360.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_683.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_683.cpp,"{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->Makefile->GetStartOutputDirectory()) +
                           strlen(target.GetName()) + 30)];
  sprintf(output,""%s/%s_force_%i"", this->Makefile->GetStartOutputDirectory(),
          target.GetName(), count);
  std::string comment = this->ConstructComment(origCommand, ""<hack>"");

  // Add the rule with the given dependencies and commands.
","{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->Makefile->GetStartOutputDirectory()) +
                           target.GetName().size() + 30)];
  sprintf(output,""%s/%s_force_%i"", this->Makefile->GetStartOutputDirectory(),
          target.GetName().c_str(), count);
  std::string comment = this->ConstructComment(origCommand, ""<hack>"");

  // Add the rule with the given dependencies and commands.
",572,572,576,576,"sprintf(output,""%s/%s_force_%i"", this->Makefile->GetStartOutputDirectory(),
          target.GetName(), count);","sprintf(output,""%s/%s_force_%i"", this->Makefile->GetStartOutputDirectory(),
          target.GetName().c_str(), count);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_374.cpp,"{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->Makefile->GetStartOutputDirectory()) +
                           strlen(target.GetName()) + 30)];
  sprintf(output,""%s/%s_force_%i"", this->Makefile->GetStartOutputDirectory(),
          target.GetName(), count);
  std::string comment = this->ConstructComment(origCommand, ""<hack>"");

  // Add the rule with the given dependencies and commands.
  const char* no_main_dependency = 0;
  if(cmSourceFile* outsf =
     this->Makefile->AddCustomCommandToOutput(
       output, depends, no_main_dependency,
       origCommand.GetCommandLines(), comment.c_str(),
       origCommand.GetWorkingDirectory()))
    {
    target.AddSourceFile(outsf);
    }

  // Replace the dependencies with the output of this rule so that the
  // next rule added will run after this one.
  depends.clear();
  depends.push_back(output);

  // Free the fake output name.
  delete [] output;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_374.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 63, 0, 0, 3, 4, 0, 0, 4, 4, 0, 0, 0, 0, 3, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 1, 1, 0, 0, 15, 0, 0, 5, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_374.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****argument_list****call****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-08T18:05:31,Brad King,76
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_361.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_361.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_685.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_685.cpp,"            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");
    this->DisplayConstraintGraph();
    }

","            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName().c_str(),
            this->Config?this->Config:""noconfig"");
    this->DisplayConstraintGraph();
    }

",254,254,256,256,"fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");","fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName().c_str(),
            this->Config?this->Config:""noconfig"");",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_375.cpp,"{
    fprintf(stderr,
            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");
    this->DisplayConstraintGraph();
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_375.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 4, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_375.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****expr****condition****name****operator****name****name****expr****then****literal****expr****else****ternary****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-08T18:05:31,Brad King,75
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_362.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_362.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_686.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_686.cpp,"
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph, const char* name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
","
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph,
                                     const std::string& name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
",434,434,439,440,"fprintf(stderr, ""The %s target dependency graph is:\n"", name);","fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_376.cpp,"{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_376.cpp,"[0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 63, 0, 0, 5, 7, 0, 0, 9, 7, 0, 0, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 1, 37, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 3, 0, 3, 1, 1, 0, 12, 0, 0, 4, 0, 16, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_376.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-08T18:05:31,Brad King,112
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_362.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_362.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_686.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_686.cpp,"
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph, const char* name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
","
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph,
                                     const std::string& name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
",434,434,445,446,"fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());","fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_377.cpp,"{
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_377.cpp,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 47, 0, 0, 4, 5, 0, 0, 6, 4, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 3, 0, 2, 1, 1, 0, 7, 0, 0, 2, 0, 9, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_377.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-08T18:05:31,Brad King,99
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_362.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_362.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_686.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_686.cpp,"
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph, const char* name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
","
//----------------------------------------------------------------------------
void
cmComputeTargetDepends::DisplayGraph(Graph const& graph,
                                     const std::string& name)
{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
",434,434,451,452,"fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");","fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_378.cpp,"{
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_378.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 18, 0, 0, 2, 2, 0, 0, 2, 3, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 1, 1, 0, 3, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_378.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****argument_list****call****expr****condition****literal****expr****then****literal****expr****else****ternary****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-08T18:05:31,Brad King,100
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_363.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_363.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_687.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_687.cpp,"    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
","    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName.c_str());
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
",450,450,453,453,"fprintf(fout, ""add_executable(%s"", targetName);","fprintf(fout, ""add_executable(%s"", targetName.c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_379.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmLocalGenerator* lg = this->Makefile->GetLocalGenerator();
    cmGlobalGenerator* gg = lg->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      std::string lang = gg->GetLanguageFromExtension(ext.c_str());
      if(!lang.empty())
        {
        testLangs.insert(lang);
        }
      else
        {
        cmOStringStream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        for(std::vector<std::string>::iterator l = langs.begin();
            l != langs.end(); ++l)
          {
          err << "" "" << *l;
          }
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = cmsys::SystemTools::Fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""set(CMAKE_MODULE_PATH %s)\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""project(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""set(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    fprintf(fout, ""include_directories(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""add_definitions( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if (const char *cxxDef
              = this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_TARGET="";
      flag += cxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *cDef
                = this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_TARGET="";
      flag += cDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcxxDef = this->Makefile->GetDefinition(
                                  ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcDef = this->Makefile->GetDefinition(
                                    ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *rootDef
              = this->Makefile->GetDefinition(""CMAKE_SYSROOT""))
      {
      std::string flag=""-DCMAKE_SYSROOT="";
      flag += rootDef;
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_379.cpp,"[21, 0, 6, 0, 0, 0, 3, 0, 0, 0, 30, 0, 0, 0, 9, 598, 0, 0, 27, 40, 0, 0, 40, 83, 0, 0, 0, 0, 12, 0, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 233, 1, 257, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 2, 0, 28, 22, 3, 0, 123, 0, 0, 62, 2, 127, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_379.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-08T18:05:31,Brad King,112
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_363.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_363.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_688.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_688.cpp,"    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
","    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());
      }
    fclose(fout);
",466,466,468,468,"fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);","fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_380.cpp,"{
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_380.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_380.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-08T18:05:31,Brad King,112
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_363.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_363.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_688.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_688.cpp,"    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
","    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());
      }
    fclose(fout);
",466,466,473,474,"fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());","fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_381.cpp,"{
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_381.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_381.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****operator****name****name****argument_list****call****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-08T18:05:31,Brad King,101
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmLocalVisualStudio6Generator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_364.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_364.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_689.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_689.cpp,"{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->Makefile->GetStartOutputDirectory()) +
                           strlen(target.GetName()) + 30)];
  sprintf(output,""%s/%s_force_%i"", this->Makefile->GetStartOutputDirectory(),
          target.GetName(), count);
  std::string comment = this->ConstructComment(origCommand, ""<hack>"");

  // Add the rule with the given dependencies and commands.
","{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->Makefile->GetStartOutputDirectory()) +
                           target.GetName().size() + 30)];
  sprintf(output,""%s/%s_force_%i"", this->Makefile->GetStartOutputDirectory(),
          target.GetName().c_str(), count);
  std::string comment = this->ConstructComment(origCommand, ""<hack>"");

  // Add the rule with the given dependencies and commands.
",572,572,576,576,"sprintf(output,""%s/%s_force_%i"", this->Makefile->GetStartOutputDirectory(),
          target.GetName(), count);","sprintf(output,""%s/%s_force_%i"", this->Makefile->GetStartOutputDirectory(),
          target.GetName().c_str(), count);",7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_382.cpp,"{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->Makefile->GetStartOutputDirectory()) +
                           strlen(target.GetName()) + 30)];
  sprintf(output,""%s/%s_force_%i"", this->Makefile->GetStartOutputDirectory(),
          target.GetName(), count);
  std::string comment = this->ConstructComment(origCommand, ""<hack>"");

  // Add the rule with the given dependencies and commands.
  const char* no_main_dependency = 0;
  if(cmSourceFile* outsf =
     this->Makefile->AddCustomCommandToOutput(
       output, depends, no_main_dependency,
       origCommand.GetCommandLines(), comment.c_str(),
       origCommand.GetWorkingDirectory()))
    {
    target.AddSourceFile(outsf);
    }

  // Replace the dependencies with the output of this rule so that the
  // next rule added will run after this one.
  depends.clear();
  depends.push_back(output);

  // Free the fake output name.
  delete [] output;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_382.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 63, 0, 0, 3, 4, 0, 0, 4, 4, 0, 0, 0, 0, 3, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 1, 1, 0, 0, 15, 0, 0, 5, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_382.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****operator****name****name****argument_list****call****expr****argument
name****operator****name****name****argument_list****call****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2014-03-08T18:05:31,Brad King,76
f668112039798f5ebc955e127f9c3e4e7cdb5cc4,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_368.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_368.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_695.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_695.cpp,"    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Exit code 0x%x\n"", code);
      break;
    }
}
","    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);
      break;
    }
}
",2222,2242,2225,2245,"sprintf(cp->ExitExceptionString, ""Exit code 0x%x\n"", code);","_snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_383.cpp,"{
    case STATUS_CONTROL_C_EXIT:
      KWSYSPE_CASE(Interrupt, ""User interrupt""); break;

    case STATUS_FLOAT_DENORMAL_OPERAND:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (denormal operand)""); break;
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Divide-by-zero""); break;
    case STATUS_FLOAT_INEXACT_RESULT:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (inexact result)""); break;
    case STATUS_FLOAT_INVALID_OPERATION:
      KWSYSPE_CASE(Numerical, ""Invalid floating-point operation""); break;
    case STATUS_FLOAT_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point overflow""); break;
    case STATUS_FLOAT_STACK_CHECK:
      KWSYSPE_CASE(Numerical, ""Floating-point stack check failed""); break;
    case STATUS_FLOAT_UNDERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point underflow""); break;
#ifdef STATUS_FLOAT_MULTIPLE_FAULTS
    case STATUS_FLOAT_MULTIPLE_FAULTS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple faults)""); break;
#endif
#ifdef STATUS_FLOAT_MULTIPLE_TRAPS
    case STATUS_FLOAT_MULTIPLE_TRAPS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple traps)""); break;
#endif
    case STATUS_INTEGER_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Integer divide-by-zero""); break;
    case STATUS_INTEGER_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Integer overflow""); break;

    case STATUS_DATATYPE_MISALIGNMENT:
      KWSYSPE_CASE(Fault, ""Datatype misalignment""); break;
    case STATUS_ACCESS_VIOLATION:
      KWSYSPE_CASE(Fault, ""Access violation""); break;
    case STATUS_IN_PAGE_ERROR:
      KWSYSPE_CASE(Fault, ""In-page error""); break;
    case STATUS_INVALID_HANDLE:
      KWSYSPE_CASE(Fault, ""Invalid hanlde""); break;
    case STATUS_NONCONTINUABLE_EXCEPTION:
      KWSYSPE_CASE(Fault, ""Noncontinuable exception""); break;
    case STATUS_INVALID_DISPOSITION:
      KWSYSPE_CASE(Fault, ""Invalid disposition""); break;
    case STATUS_ARRAY_BOUNDS_EXCEEDED:
      KWSYSPE_CASE(Fault, ""Array bounds exceeded""); break;
    case STATUS_STACK_OVERFLOW:
      KWSYSPE_CASE(Fault, ""Stack overflow""); break;

    case STATUS_ILLEGAL_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Illegal instruction""); break;
    case STATUS_PRIVILEGED_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Privileged instruction""); break;

    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Exit code 0x%x\n"", code);
      break;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_383.cpp,"[0, 0, 0, 0, 23, 0, 0, 0, 23, 1, 1, 0, 0, 0, 0, 78, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 94, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 24, 0, 47, 4, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_383.cpp,"name****name****operator****name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2013-11-25T16:19:42,Brad King,102
704ab3d24827cfe5754a00028086f21503c2e08b,"KWSys 2013-11-21 (1010d0e3)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ 1010d0e3 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 6eab64c3..1010d0e3
Brad King (2):
      ace1364c Encoding: Remove unused include
      1010d0e3 SystemTools: Avoid unused function warnings

Clinton Stimpson (4):
      0c2ff1f7 Encoding: Add Encoding module.
      8abbad82 FStream: Add FStream module.
      0a98de97 KWSys: Port to use wide character Windows APIs throughout.
      2b0c683d Encoding: Default to ANSI code page on Windows

David Cole (1):
      f67bb2ba SystemTools: Move typedef mode_t inside the SystemTools class

Sean McBride (1):
      a40b9263 SystemInformation: Work around gcc -Wliteral-suffix warning

Change-Id: Ie52df972331cc7377c236d410ead86024e9d15ab",[],ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_370.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_370.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_698.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_698.cpp,"    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Exit code 0x%x\n"", code);
      break;
    }
}
","    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);
      break;
    }
}
",2222,2242,2225,2245,"sprintf(cp->ExitExceptionString, ""Exit code 0x%x\n"", code);","_snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_384.cpp,"{
    case STATUS_CONTROL_C_EXIT:
      KWSYSPE_CASE(Interrupt, ""User interrupt""); break;

    case STATUS_FLOAT_DENORMAL_OPERAND:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (denormal operand)""); break;
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Divide-by-zero""); break;
    case STATUS_FLOAT_INEXACT_RESULT:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (inexact result)""); break;
    case STATUS_FLOAT_INVALID_OPERATION:
      KWSYSPE_CASE(Numerical, ""Invalid floating-point operation""); break;
    case STATUS_FLOAT_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point overflow""); break;
    case STATUS_FLOAT_STACK_CHECK:
      KWSYSPE_CASE(Numerical, ""Floating-point stack check failed""); break;
    case STATUS_FLOAT_UNDERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point underflow""); break;
#ifdef STATUS_FLOAT_MULTIPLE_FAULTS
    case STATUS_FLOAT_MULTIPLE_FAULTS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple faults)""); break;
#endif
#ifdef STATUS_FLOAT_MULTIPLE_TRAPS
    case STATUS_FLOAT_MULTIPLE_TRAPS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple traps)""); break;
#endif
    case STATUS_INTEGER_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Integer divide-by-zero""); break;
    case STATUS_INTEGER_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Integer overflow""); break;

    case STATUS_DATATYPE_MISALIGNMENT:
      KWSYSPE_CASE(Fault, ""Datatype misalignment""); break;
    case STATUS_ACCESS_VIOLATION:
      KWSYSPE_CASE(Fault, ""Access violation""); break;
    case STATUS_IN_PAGE_ERROR:
      KWSYSPE_CASE(Fault, ""In-page error""); break;
    case STATUS_INVALID_HANDLE:
      KWSYSPE_CASE(Fault, ""Invalid hanlde""); break;
    case STATUS_NONCONTINUABLE_EXCEPTION:
      KWSYSPE_CASE(Fault, ""Noncontinuable exception""); break;
    case STATUS_INVALID_DISPOSITION:
      KWSYSPE_CASE(Fault, ""Invalid disposition""); break;
    case STATUS_ARRAY_BOUNDS_EXCEEDED:
      KWSYSPE_CASE(Fault, ""Array bounds exceeded""); break;
    case STATUS_STACK_OVERFLOW:
      KWSYSPE_CASE(Fault, ""Stack overflow""); break;

    case STATUS_ILLEGAL_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Illegal instruction""); break;
    case STATUS_PRIVILEGED_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Privileged instruction""); break;

    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Exit code 0x%x\n"", code);
      break;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_384.cpp,"[0, 0, 0, 0, 23, 0, 0, 0, 23, 1, 1, 0, 0, 0, 0, 78, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 94, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 24, 0, 47, 4, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_384.cpp,"name****name****operator****name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2013-11-25T16:19:37,Brad King,102
704ab3d24827cfe5754a00028086f21503c2e08b,"KWSys 2013-11-21 (1010d0e3)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ 1010d0e3 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 6eab64c3..1010d0e3
Brad King (2):
      ace1364c Encoding: Remove unused include
      1010d0e3 SystemTools: Avoid unused function warnings

Clinton Stimpson (4):
      0c2ff1f7 Encoding: Add Encoding module.
      8abbad82 FStream: Add FStream module.
      0a98de97 KWSys: Port to use wide character Windows APIs throughout.
      2b0c683d Encoding: Default to ANSI code page on Windows

David Cole (1):
      f67bb2ba SystemTools: Move typedef mode_t inside the SystemTools class

Sean McBride (1):
      a40b9263 SystemInformation: Work around gcc -Wliteral-suffix warning

Change-Id: Ie52df972331cc7377c236d410ead86024e9d15ab",[],ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_702.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_702.cpp,"    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Exit code 0x%x\n"", code);
      break;
    }
}
","    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);
      break;
    }
}
",2222,2242,2225,2245,"sprintf(cp->ExitExceptionString, ""Exit code 0x%x\n"", code);","_snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);",3,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_385.cpp,"{
    case STATUS_CONTROL_C_EXIT:
      KWSYSPE_CASE(Interrupt, ""User interrupt""); break;

    case STATUS_FLOAT_DENORMAL_OPERAND:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (denormal operand)""); break;
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Divide-by-zero""); break;
    case STATUS_FLOAT_INEXACT_RESULT:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (inexact result)""); break;
    case STATUS_FLOAT_INVALID_OPERATION:
      KWSYSPE_CASE(Numerical, ""Invalid floating-point operation""); break;
    case STATUS_FLOAT_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point overflow""); break;
    case STATUS_FLOAT_STACK_CHECK:
      KWSYSPE_CASE(Numerical, ""Floating-point stack check failed""); break;
    case STATUS_FLOAT_UNDERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point underflow""); break;
#ifdef STATUS_FLOAT_MULTIPLE_FAULTS
    case STATUS_FLOAT_MULTIPLE_FAULTS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple faults)""); break;
#endif
#ifdef STATUS_FLOAT_MULTIPLE_TRAPS
    case STATUS_FLOAT_MULTIPLE_TRAPS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple traps)""); break;
#endif
    case STATUS_INTEGER_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Integer divide-by-zero""); break;
    case STATUS_INTEGER_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Integer overflow""); break;

    case STATUS_DATATYPE_MISALIGNMENT:
      KWSYSPE_CASE(Fault, ""Datatype misalignment""); break;
    case STATUS_ACCESS_VIOLATION:
      KWSYSPE_CASE(Fault, ""Access violation""); break;
    case STATUS_IN_PAGE_ERROR:
      KWSYSPE_CASE(Fault, ""In-page error""); break;
    case STATUS_INVALID_HANDLE:
      KWSYSPE_CASE(Fault, ""Invalid hanlde""); break;
    case STATUS_NONCONTINUABLE_EXCEPTION:
      KWSYSPE_CASE(Fault, ""Noncontinuable exception""); break;
    case STATUS_INVALID_DISPOSITION:
      KWSYSPE_CASE(Fault, ""Invalid disposition""); break;
    case STATUS_ARRAY_BOUNDS_EXCEEDED:
      KWSYSPE_CASE(Fault, ""Array bounds exceeded""); break;
    case STATUS_STACK_OVERFLOW:
      KWSYSPE_CASE(Fault, ""Stack overflow""); break;

    case STATUS_ILLEGAL_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Illegal instruction""); break;
    case STATUS_PRIVILEGED_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Privileged instruction""); break;

    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Exit code 0x%x\n"", code);
      break;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_385.cpp,"[0, 0, 0, 0, 23, 0, 0, 0, 23, 1, 1, 0, 0, 0, 0, 78, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 94, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 24, 0, 47, 4, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_385.cpp,"name****name****operator****name****name****expr****argument
literal****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2013-11-25T16:19:37,Brad King,102
9d66f74335a09019644c7b82af0860da439fce87,"KWSys 2013-02-05 (5c34ed2e)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ 5c34ed2e | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 5b0d1bd9..5c34ed2e
Brad King (1):
      5c34ed2e SystemTools: Do not abort with no current directory

Change-Id: Id054017eac2bf10c71ca721df48298cdff2bea82",[],SystemTools.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_373.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_373.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_703.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_703.cpp,"}
inline const char* Getcwd(char* buf, unsigned int len)
{
  const char* ret = _getcwd(buf, len);
  if(!ret)
    {
    fprintf(stderr, ""No current working directory.\n"");
    abort();
    }
  // make sure the drive letter is capital
  if(strlen(buf) > 1 && buf[1] == ':')
    {
    buf[0] = toupper(buf[0]);
    }
  return ret;
}
inline int Chdir(const char* dir)
{
","}
inline const char* Getcwd(char* buf, unsigned int len)
{
  if(const char* ret = _getcwd(buf, len))
    {
    // make sure the drive letter is capital
    if(strlen(buf) > 1 && buf[1] == ':')
      {
      buf[0] = toupper(buf[0]);
      }
    return ret;
    }
  return 0;
}
inline int Chdir(const char* dir)
{
",196,196,202,-1,"fprintf(stderr, ""No current working directory.\n"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_386.cpp,"{
    fprintf(stderr, ""No current working directory.\n"");
    abort();
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_386.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_386.cpp,"name****name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2013-02-07T13:34:52,Brad King,94
9d66f74335a09019644c7b82af0860da439fce87,"KWSys 2013-02-05 (5c34ed2e)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ 5c34ed2e | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 5b0d1bd9..5c34ed2e
Brad King (1):
      5c34ed2e SystemTools: Do not abort with no current directory

Change-Id: Id054017eac2bf10c71ca721df48298cdff2bea82",[],SystemTools.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_373.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_373.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_704.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_704.cpp,"}
inline const char* Getcwd(char* buf, unsigned int len)
{
  const char* ret = getcwd(buf, len);
  if(!ret)
    {
    fprintf(stderr, ""No current working directory\n"");
    abort();
    }
  return ret;
}

inline int Chdir(const char* dir)
","}
inline const char* Getcwd(char* buf, unsigned int len)
{
  return getcwd(buf, len);
}

inline int Chdir(const char* dir)
",245,243,251,-1,"fprintf(stderr, ""No current working directory\n"");",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_387.cpp,"{
    fprintf(stderr, ""No current working directory\n"");
    abort();
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_387.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_387.cpp,"name****name****expr****argument
literal****expr****argument
argument_list****call****expr****expr_stmt****unit****",2013-02-07T13:34:52,Brad King,94
a0f91f1daa7765066a784e4479da7e231374a065,"KWSys 2012-12-19 (933eb822)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ 933eb822 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 3b17de34..933eb822
Brad King (2):
      fea37696 Process: Remove support for Windows 98
      01e15c22 Remove KWSys Registry

Rolf Eike Beer (7):
      f376ec32 SystemInformation: fix typos
      bfee5174 SystemInformation: sum up all caches found in /proc/cpuinfo
      5690d711 SystemInformation: fix value extraction from /proc/cpuinfo
      36295981 SystemInformation: PA-RISC chips are from HP
      72e9d02e SystemInformation: try harder to find a useful processor name
      b39de34c SystemInformation: try harder to find the CPU family
      933eb822 SystemInformation: extract CPU stepping information from /proc/cpuinfo, too

Sean McBride (2):
      5e17bfde Process: Dereference NULL++ instead of NULL to force crash
      86a78cb7 SystemTools: Add check for empty strings to prevent integer underflow

Change-Id: Id7194f434fe67be81e6ee9e96d705010a1171a06",[],ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_375.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_375.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_708.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_708.cpp,"  GetVersionEx(&osv);
  if(osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
    /* This is Win9x.  We need the console forwarding executable to
       work-around a Windows 9x bug.  */
    char fwdName[_MAX_FNAME+1] = """";
    char tempDir[_MAX_PATH+1] = """";

    /* We will try putting the executable in the system temp
       directory.  Note that the returned path already has a trailing
       slash.  */
    DWORD length = GetTempPath(_MAX_PATH+1, tempDir);

    /* Construct the executable name from the process id and kwsysProcess
       instance.  This should be unique.  */
    sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%ld_%p.exe"",
            GetCurrentProcessId(), cp);

    /* If we have a temp directory, use it.  */
    if(length > 0 && length <= _MAX_PATH)
      {
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }

    /* If we found a place to put the forwarding executable, try to
       write it. */
    if(win9x)
      {
      if(!kwsysEncodedWriteArrayProcessFwd9x(win9x))
        {
        /* Failed to create forwarding executable.  Give up.  */
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Get a handle to the file that will delete it when closed.  */
      cp->Win9xHandle = CreateFile(win9x, GENERIC_READ, FILE_SHARE_READ, 0,
                                   OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
      if(cp->Win9xHandle == INVALID_HANDLE_VALUE)
        {
        /* We were not able to get a read handle for the forwarding
           executable.  It will not be deleted properly.  Give up.  */
        _unlink(win9x);
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }
      }
    else
      {
      /* Failed to find a place to put forwarding executable.  */
      kwsysProcess_Delete(cp);
      return 0;
      }
    }

  /* Save the path to the forwarding executable.  */
  cp->Win9x = win9x;

  /* Initially no thread owns the mutex.  Initialize semaphore to 1.  */
  if(!(cp->SharedIndexMutex = CreateSemaphore(0, 1, 1, 0)))
    {
","  GetVersionEx(&osv);
  if(osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
    /* Win9x no longer supported.  */
    kwsysProcess_Delete(cp);
    return 0;
    }

  /* Initially no thread owns the mutex.  Initialize semaphore to 1.  */
  if(!(cp->SharedIndexMutex = CreateSemaphore(0, 1, 1, 0)))
    {
",365,335,380,-1,"sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%ld_%p.exe"",
            GetCurrentProcessId(), cp);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_388.cpp,"{
    /* This is Win9x.  We need the console forwarding executable to
       work-around a Windows 9x bug.  */
    char fwdName[_MAX_FNAME+1] = """";
    char tempDir[_MAX_PATH+1] = """";

    /* We will try putting the executable in the system temp
       directory.  Note that the returned path already has a trailing
       slash.  */
    DWORD length = GetTempPath(_MAX_PATH+1, tempDir);

    /* Construct the executable name from the process id and kwsysProcess
       instance.  This should be unique.  */
    sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%ld_%p.exe"",
            GetCurrentProcessId(), cp);

    /* If we have a temp directory, use it.  */
    if(length > 0 && length <= _MAX_PATH)
      {
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }

    /* If we found a place to put the forwarding executable, try to
       write it. */
    if(win9x)
      {
      if(!kwsysEncodedWriteArrayProcessFwd9x(win9x))
        {
        /* Failed to create forwarding executable.  Give up.  */
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Get a handle to the file that will delete it when closed.  */
      cp->Win9xHandle = CreateFile(win9x, GENERIC_READ, FILE_SHARE_READ, 0,
                                   OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
      if(cp->Win9xHandle == INVALID_HANDLE_VALUE)
        {
        /* We were not able to get a read handle for the forwarding
           executable.  It will not be deleted properly.  Give up.  */
        _unlink(win9x);
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }
      }
    else
      {
      /* Failed to find a place to put forwarding executable.  */
      kwsysProcess_Delete(cp);
      return 0;
      }
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_388.cpp,"[5, 0, 0, 0, 0, 0, 4, 0, 0, 0, 7, 0, 0, 0, 0, 66, 0, 0, 4, 4, 0, 0, 4, 15, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 5, 5, 1, 0, 16, 0, 0, 11, 0, 28, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_388.cpp,"name****name****expr****argument
name****literal****expr****argument
name****argument_list****call****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2012-12-19T13:08:36,Brad King,77
a0f91f1daa7765066a784e4479da7e231374a065,"KWSys 2012-12-19 (933eb822)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ 933eb822 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 3b17de34..933eb822
Brad King (2):
      fea37696 Process: Remove support for Windows 98
      01e15c22 Remove KWSys Registry

Rolf Eike Beer (7):
      f376ec32 SystemInformation: fix typos
      bfee5174 SystemInformation: sum up all caches found in /proc/cpuinfo
      5690d711 SystemInformation: fix value extraction from /proc/cpuinfo
      36295981 SystemInformation: PA-RISC chips are from HP
      72e9d02e SystemInformation: try harder to find a useful processor name
      b39de34c SystemInformation: try harder to find the CPU family
      933eb822 SystemInformation: extract CPU stepping information from /proc/cpuinfo, too

Sean McBride (2):
      5e17bfde Process: Dereference NULL++ instead of NULL to force crash
      86a78cb7 SystemTools: Add check for empty strings to prevent integer underflow

Change-Id: Id7194f434fe67be81e6ee9e96d705010a1171a06",[],ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_375.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_375.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_708.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_708.cpp,"  GetVersionEx(&osv);
  if(osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
    /* This is Win9x.  We need the console forwarding executable to
       work-around a Windows 9x bug.  */
    char fwdName[_MAX_FNAME+1] = """";
    char tempDir[_MAX_PATH+1] = """";

    /* We will try putting the executable in the system temp
       directory.  Note that the returned path already has a trailing
       slash.  */
    DWORD length = GetTempPath(_MAX_PATH+1, tempDir);

    /* Construct the executable name from the process id and kwsysProcess
       instance.  This should be unique.  */
    sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%ld_%p.exe"",
            GetCurrentProcessId(), cp);

    /* If we have a temp directory, use it.  */
    if(length > 0 && length <= _MAX_PATH)
      {
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }

    /* If we found a place to put the forwarding executable, try to
       write it. */
    if(win9x)
      {
      if(!kwsysEncodedWriteArrayProcessFwd9x(win9x))
        {
        /* Failed to create forwarding executable.  Give up.  */
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Get a handle to the file that will delete it when closed.  */
      cp->Win9xHandle = CreateFile(win9x, GENERIC_READ, FILE_SHARE_READ, 0,
                                   OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
      if(cp->Win9xHandle == INVALID_HANDLE_VALUE)
        {
        /* We were not able to get a read handle for the forwarding
           executable.  It will not be deleted properly.  Give up.  */
        _unlink(win9x);
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }
      }
    else
      {
      /* Failed to find a place to put forwarding executable.  */
      kwsysProcess_Delete(cp);
      return 0;
      }
    }

  /* Save the path to the forwarding executable.  */
  cp->Win9x = win9x;

  /* Initially no thread owns the mutex.  Initialize semaphore to 1.  */
  if(!(cp->SharedIndexMutex = CreateSemaphore(0, 1, 1, 0)))
    {
","  GetVersionEx(&osv);
  if(osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
    /* Win9x no longer supported.  */
    kwsysProcess_Delete(cp);
    return 0;
    }

  /* Initially no thread owns the mutex.  Initialize semaphore to 1.  */
  if(!(cp->SharedIndexMutex = CreateSemaphore(0, 1, 1, 0)))
    {
",365,335,396,-1,"sprintf(win9x, ""%s%s"", tempDir, fwdName);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_389.cpp,"{
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_389.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 17, 0, 0, 1, 1, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_389.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2012-12-19T13:08:36,Brad King,78
a0f91f1daa7765066a784e4479da7e231374a065,"KWSys 2012-12-19 (933eb822)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ 933eb822 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 3b17de34..933eb822
Brad King (2):
      fea37696 Process: Remove support for Windows 98
      01e15c22 Remove KWSys Registry

Rolf Eike Beer (7):
      f376ec32 SystemInformation: fix typos
      bfee5174 SystemInformation: sum up all caches found in /proc/cpuinfo
      5690d711 SystemInformation: fix value extraction from /proc/cpuinfo
      36295981 SystemInformation: PA-RISC chips are from HP
      72e9d02e SystemInformation: try harder to find a useful processor name
      b39de34c SystemInformation: try harder to find the CPU family
      933eb822 SystemInformation: extract CPU stepping information from /proc/cpuinfo, too

Sean McBride (2):
      5e17bfde Process: Dereference NULL++ instead of NULL to force crash
      86a78cb7 SystemTools: Add check for empty strings to prevent integer underflow

Change-Id: Id7194f434fe67be81e6ee9e96d705010a1171a06",[],ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_375.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_375.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_709.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_709.cpp,"      }
    }

  /* Create the child process.  */
  {
  BOOL r;
  char* realCommand;
  if(cp->Win9x)
    {
    /* Create an error reporting pipe for the forwarding executable.
       Neither end is directly inherited.  */
    if(!CreatePipe(&si->ErrorPipeRead, &si->ErrorPipeWrite, 0, 0))
      {
      return 0;
      }

    /* Create an inherited duplicate of the write end.  This also closes
       the non-inherited version. */
    if(!DuplicateHandle(GetCurrentProcess(), si->ErrorPipeWrite,
                        GetCurrentProcess(), &si->ErrorPipeWrite,
                        0, TRUE, (DUPLICATE_CLOSE_SOURCE |
                                  DUPLICATE_SAME_ACCESS)))
      {
      return 0;
      }

    /* The forwarding executable is given a handle to the error pipe
       and resume and kill events.  */
    realCommand = (char*)malloc(strlen(cp->Win9x)+strlen(cp->Commands[index])+100);
    if(!realCommand)
      {
      return 0;
      }
    sprintf(realCommand, ""%s %p %p %p %d %s"", cp->Win9x,
            si->ErrorPipeWrite, cp->Win9xResumeEvent, cp->Win9xKillEvent,
            cp->HideWindow, cp->Commands[index]);
    }
  else
    {
    realCommand = cp->Commands[index];
    }

  /* Create the child in a suspended state so we can wait until all
     children have been created before running any one.  */
  r = CreateProcess(0, realCommand, 0, 0, TRUE,
                    cp->Win9x? 0 : CREATE_SUSPENDED, 0, 0,
                    &si->StartupInfo, &cp->ProcessInformation[index]);
  if(cp->Win9x)
    {
    /* Free memory.  */
    free(realCommand);

    /* Close the error pipe write end so we can detect when the
       forwarding executable closes it.  */
    kwsysProcessCleanupHandle(&si->ErrorPipeWrite);
    if(r)
      {
      /* Wait for the forwarding executable to report an error or
         close the error pipe to report success.  */
      DWORD total = 0;
      DWORD n = 1;
      while(total < KWSYSPE_PIPE_BUFFER_SIZE && n > 0)
        {
        if(ReadFile(si->ErrorPipeRead, cp->ErrorMessage+total,
                    KWSYSPE_PIPE_BUFFER_SIZE-total, &n, 0))
          {
          total += n;
          }
        else
          {
          n = 0;
          }
        }
      if(total > 0 || GetLastError() != ERROR_BROKEN_PIPE)
        {
        /* The forwarding executable could not run the process, or
           there was an error reading from its error pipe.  Preserve
           the last error while cleaning up the forwarding executable
           so the cleanup our caller does reports the proper error.  */
        DWORD error = GetLastError();
        kwsysProcessCleanupHandle(&cp->ProcessInformation[index].hThread);
        kwsysProcessCleanupHandle(&cp->ProcessInformation[index].hProcess);
        SetLastError(error);
        return 0;
        }
      }
    kwsysProcessCleanupHandle(&si->ErrorPipeRead);
    }

  if(!r)
    {
    return 0;
    }
  }

  /* Successfully created this child process.  Close the current
     process's copies of the inherited stdout and stdin handles.  The
","      }
    }

  /* Create the child in a suspended state so we can wait until all
     children have been created before running any one.  */
  if(!CreateProcess(0, cp->Commands[index], 0, 0, TRUE, CREATE_SUSPENDED, 0,
                    0, &si->StartupInfo, &cp->ProcessInformation[index]))
    {
    return 0;
    }

  /* Successfully created this child process.  Close the current
     process's copies of the inherited stdout and stdin handles.  The
",1815,1653,1848,-1,"sprintf(realCommand, ""%s %p %p %p %d %s"", cp->Win9x,
            si->ErrorPipeWrite, cp->Win9xResumeEvent, cp->Win9xKillEvent,
            cp->HideWindow, cp->Commands[index]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_390.cpp,"{
    /* Create an error reporting pipe for the forwarding executable.
       Neither end is directly inherited.  */
    if(!CreatePipe(&si->ErrorPipeRead, &si->ErrorPipeWrite, 0, 0))
      {
      return 0;
      }

    /* Create an inherited duplicate of the write end.  This also closes
       the non-inherited version. */
    if(!DuplicateHandle(GetCurrentProcess(), si->ErrorPipeWrite,
                        GetCurrentProcess(), &si->ErrorPipeWrite,
                        0, TRUE, (DUPLICATE_CLOSE_SOURCE |
                                  DUPLICATE_SAME_ACCESS)))
      {
      return 0;
      }

    /* The forwarding executable is given a handle to the error pipe
       and resume and kill events.  */
    realCommand = (char*)malloc(strlen(cp->Win9x)+strlen(cp->Commands[index])+100);
    if(!realCommand)
      {
      return 0;
      }
    sprintf(realCommand, ""%s %p %p %p %d %s"", cp->Win9x,
            si->ErrorPipeWrite, cp->Win9xResumeEvent, cp->Win9xKillEvent,
            cp->HideWindow, cp->Commands[index]);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_390.cpp,"[3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 0, 53, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 3, 0, 0, 8, 0, 0, 2, 0, 22, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_390.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2012-12-19T13:08:36,Brad King,79
a0f91f1daa7765066a784e4479da7e231374a065,"KWSys 2012-12-19 (933eb822)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ 933eb822 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 3b17de34..933eb822
Brad King (2):
      fea37696 Process: Remove support for Windows 98
      01e15c22 Remove KWSys Registry

Rolf Eike Beer (7):
      f376ec32 SystemInformation: fix typos
      bfee5174 SystemInformation: sum up all caches found in /proc/cpuinfo
      5690d711 SystemInformation: fix value extraction from /proc/cpuinfo
      36295981 SystemInformation: PA-RISC chips are from HP
      72e9d02e SystemInformation: try harder to find a useful processor name
      b39de34c SystemInformation: try harder to find the CPU family
      933eb822 SystemInformation: extract CPU stepping information from /proc/cpuinfo, too

Sean McBride (2):
      5e17bfde Process: Dereference NULL++ instead of NULL to force crash
      86a78cb7 SystemTools: Add check for empty strings to prevent integer underflow

Change-Id: Id7194f434fe67be81e6ee9e96d705010a1171a06",[],ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_376.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_376.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_711.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_711.cpp,"  GetVersionEx(&osv);
  if(osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
    /* This is Win9x.  We need the console forwarding executable to
       work-around a Windows 9x bug.  */
    char fwdName[_MAX_FNAME+1] = """";
    char tempDir[_MAX_PATH+1] = """";

    /* We will try putting the executable in the system temp
       directory.  Note that the returned path already has a trailing
       slash.  */
    DWORD length = GetTempPath(_MAX_PATH+1, tempDir);

    /* Construct the executable name from the process id and kwsysProcess
       instance.  This should be unique.  */
    sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%ld_%p.exe"",
            GetCurrentProcessId(), cp);

    /* If we have a temp directory, use it.  */
    if(length > 0 && length <= _MAX_PATH)
      {
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }

    /* If we found a place to put the forwarding executable, try to
       write it. */
    if(win9x)
      {
      if(!kwsysEncodedWriteArrayProcessFwd9x(win9x))
        {
        /* Failed to create forwarding executable.  Give up.  */
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Get a handle to the file that will delete it when closed.  */
      cp->Win9xHandle = CreateFile(win9x, GENERIC_READ, FILE_SHARE_READ, 0,
                                   OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
      if(cp->Win9xHandle == INVALID_HANDLE_VALUE)
        {
        /* We were not able to get a read handle for the forwarding
           executable.  It will not be deleted properly.  Give up.  */
        _unlink(win9x);
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }
      }
    else
      {
      /* Failed to find a place to put forwarding executable.  */
      kwsysProcess_Delete(cp);
      return 0;
      }
    }

  /* Save the path to the forwarding executable.  */
  cp->Win9x = win9x;

  /* Initially no thread owns the mutex.  Initialize semaphore to 1.  */
  if(!(cp->SharedIndexMutex = CreateSemaphore(0, 1, 1, 0)))
    {
","  GetVersionEx(&osv);
  if(osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
    /* Win9x no longer supported.  */
    kwsysProcess_Delete(cp);
    return 0;
    }

  /* Initially no thread owns the mutex.  Initialize semaphore to 1.  */
  if(!(cp->SharedIndexMutex = CreateSemaphore(0, 1, 1, 0)))
    {
",365,335,380,-1,"sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%ld_%p.exe"",
            GetCurrentProcessId(), cp);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_391.cpp,"{
    /* This is Win9x.  We need the console forwarding executable to
       work-around a Windows 9x bug.  */
    char fwdName[_MAX_FNAME+1] = """";
    char tempDir[_MAX_PATH+1] = """";

    /* We will try putting the executable in the system temp
       directory.  Note that the returned path already has a trailing
       slash.  */
    DWORD length = GetTempPath(_MAX_PATH+1, tempDir);

    /* Construct the executable name from the process id and kwsysProcess
       instance.  This should be unique.  */
    sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%ld_%p.exe"",
            GetCurrentProcessId(), cp);

    /* If we have a temp directory, use it.  */
    if(length > 0 && length <= _MAX_PATH)
      {
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }

    /* If we found a place to put the forwarding executable, try to
       write it. */
    if(win9x)
      {
      if(!kwsysEncodedWriteArrayProcessFwd9x(win9x))
        {
        /* Failed to create forwarding executable.  Give up.  */
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Get a handle to the file that will delete it when closed.  */
      cp->Win9xHandle = CreateFile(win9x, GENERIC_READ, FILE_SHARE_READ, 0,
                                   OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
      if(cp->Win9xHandle == INVALID_HANDLE_VALUE)
        {
        /* We were not able to get a read handle for the forwarding
           executable.  It will not be deleted properly.  Give up.  */
        _unlink(win9x);
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }
      }
    else
      {
      /* Failed to find a place to put forwarding executable.  */
      kwsysProcess_Delete(cp);
      return 0;
      }
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_391.cpp,"[5, 0, 0, 0, 0, 0, 4, 0, 0, 0, 7, 0, 0, 0, 0, 66, 0, 0, 4, 4, 0, 0, 4, 15, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 5, 5, 1, 0, 16, 0, 0, 11, 0, 28, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_391.cpp,"name****name****expr****argument
name****literal****expr****argument
name****argument_list****call****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2012-12-19T13:08:36,Brad King,77
a0f91f1daa7765066a784e4479da7e231374a065,"KWSys 2012-12-19 (933eb822)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ 933eb822 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 3b17de34..933eb822
Brad King (2):
      fea37696 Process: Remove support for Windows 98
      01e15c22 Remove KWSys Registry

Rolf Eike Beer (7):
      f376ec32 SystemInformation: fix typos
      bfee5174 SystemInformation: sum up all caches found in /proc/cpuinfo
      5690d711 SystemInformation: fix value extraction from /proc/cpuinfo
      36295981 SystemInformation: PA-RISC chips are from HP
      72e9d02e SystemInformation: try harder to find a useful processor name
      b39de34c SystemInformation: try harder to find the CPU family
      933eb822 SystemInformation: extract CPU stepping information from /proc/cpuinfo, too

Sean McBride (2):
      5e17bfde Process: Dereference NULL++ instead of NULL to force crash
      86a78cb7 SystemTools: Add check for empty strings to prevent integer underflow

Change-Id: Id7194f434fe67be81e6ee9e96d705010a1171a06",[],ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_376.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_376.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_711.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_711.cpp,"  GetVersionEx(&osv);
  if(osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
    /* This is Win9x.  We need the console forwarding executable to
       work-around a Windows 9x bug.  */
    char fwdName[_MAX_FNAME+1] = """";
    char tempDir[_MAX_PATH+1] = """";

    /* We will try putting the executable in the system temp
       directory.  Note that the returned path already has a trailing
       slash.  */
    DWORD length = GetTempPath(_MAX_PATH+1, tempDir);

    /* Construct the executable name from the process id and kwsysProcess
       instance.  This should be unique.  */
    sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%ld_%p.exe"",
            GetCurrentProcessId(), cp);

    /* If we have a temp directory, use it.  */
    if(length > 0 && length <= _MAX_PATH)
      {
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }

    /* If we found a place to put the forwarding executable, try to
       write it. */
    if(win9x)
      {
      if(!kwsysEncodedWriteArrayProcessFwd9x(win9x))
        {
        /* Failed to create forwarding executable.  Give up.  */
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Get a handle to the file that will delete it when closed.  */
      cp->Win9xHandle = CreateFile(win9x, GENERIC_READ, FILE_SHARE_READ, 0,
                                   OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
      if(cp->Win9xHandle == INVALID_HANDLE_VALUE)
        {
        /* We were not able to get a read handle for the forwarding
           executable.  It will not be deleted properly.  Give up.  */
        _unlink(win9x);
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }
      }
    else
      {
      /* Failed to find a place to put forwarding executable.  */
      kwsysProcess_Delete(cp);
      return 0;
      }
    }

  /* Save the path to the forwarding executable.  */
  cp->Win9x = win9x;

  /* Initially no thread owns the mutex.  Initialize semaphore to 1.  */
  if(!(cp->SharedIndexMutex = CreateSemaphore(0, 1, 1, 0)))
    {
","  GetVersionEx(&osv);
  if(osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
    /* Win9x no longer supported.  */
    kwsysProcess_Delete(cp);
    return 0;
    }

  /* Initially no thread owns the mutex.  Initialize semaphore to 1.  */
  if(!(cp->SharedIndexMutex = CreateSemaphore(0, 1, 1, 0)))
    {
",365,335,396,-1,"sprintf(win9x, ""%s%s"", tempDir, fwdName);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_392.cpp,"{
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_392.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 17, 0, 0, 1, 1, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_392.cpp,"name****name****expr****argument
literal****expr****argument
name****expr****argument
name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2012-12-19T13:08:36,Brad King,78
a0f91f1daa7765066a784e4479da7e231374a065,"KWSys 2012-12-19 (933eb822)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ 933eb822 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 3b17de34..933eb822
Brad King (2):
      fea37696 Process: Remove support for Windows 98
      01e15c22 Remove KWSys Registry

Rolf Eike Beer (7):
      f376ec32 SystemInformation: fix typos
      bfee5174 SystemInformation: sum up all caches found in /proc/cpuinfo
      5690d711 SystemInformation: fix value extraction from /proc/cpuinfo
      36295981 SystemInformation: PA-RISC chips are from HP
      72e9d02e SystemInformation: try harder to find a useful processor name
      b39de34c SystemInformation: try harder to find the CPU family
      933eb822 SystemInformation: extract CPU stepping information from /proc/cpuinfo, too

Sean McBride (2):
      5e17bfde Process: Dereference NULL++ instead of NULL to force crash
      86a78cb7 SystemTools: Add check for empty strings to prevent integer underflow

Change-Id: Id7194f434fe67be81e6ee9e96d705010a1171a06",[],ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_376.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_376.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_712.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_712.cpp,"      }
    }

  /* Create the child process.  */
  {
  BOOL r;
  char* realCommand;
  if(cp->Win9x)
    {
    /* Create an error reporting pipe for the forwarding executable.
       Neither end is directly inherited.  */
    if(!CreatePipe(&si->ErrorPipeRead, &si->ErrorPipeWrite, 0, 0))
      {
      return 0;
      }

    /* Create an inherited duplicate of the write end.  This also closes
       the non-inherited version. */
    if(!DuplicateHandle(GetCurrentProcess(), si->ErrorPipeWrite,
                        GetCurrentProcess(), &si->ErrorPipeWrite,
                        0, TRUE, (DUPLICATE_CLOSE_SOURCE |
                                  DUPLICATE_SAME_ACCESS)))
      {
      return 0;
      }

    /* The forwarding executable is given a handle to the error pipe
       and resume and kill events.  */
    realCommand = (char*)malloc(strlen(cp->Win9x)+strlen(cp->Commands[index])+100);
    if(!realCommand)
      {
      return 0;
      }
    sprintf(realCommand, ""%s %p %p %p %d %s"", cp->Win9x,
            si->ErrorPipeWrite, cp->Win9xResumeEvent, cp->Win9xKillEvent,
            cp->HideWindow, cp->Commands[index]);
    }
  else
    {
    realCommand = cp->Commands[index];
    }

  /* Create the child in a suspended state so we can wait until all
     children have been created before running any one.  */
  r = CreateProcess(0, realCommand, 0, 0, TRUE,
                    cp->Win9x? 0 : CREATE_SUSPENDED, 0, 0,
                    &si->StartupInfo, &cp->ProcessInformation[index]);
  if(cp->Win9x)
    {
    /* Free memory.  */
    free(realCommand);

    /* Close the error pipe write end so we can detect when the
       forwarding executable closes it.  */
    kwsysProcessCleanupHandle(&si->ErrorPipeWrite);
    if(r)
      {
      /* Wait for the forwarding executable to report an error or
         close the error pipe to report success.  */
      DWORD total = 0;
      DWORD n = 1;
      while(total < KWSYSPE_PIPE_BUFFER_SIZE && n > 0)
        {
        if(ReadFile(si->ErrorPipeRead, cp->ErrorMessage+total,
                    KWSYSPE_PIPE_BUFFER_SIZE-total, &n, 0))
          {
          total += n;
          }
        else
          {
          n = 0;
          }
        }
      if(total > 0 || GetLastError() != ERROR_BROKEN_PIPE)
        {
        /* The forwarding executable could not run the process, or
           there was an error reading from its error pipe.  Preserve
           the last error while cleaning up the forwarding executable
           so the cleanup our caller does reports the proper error.  */
        DWORD error = GetLastError();
        kwsysProcessCleanupHandle(&cp->ProcessInformation[index].hThread);
        kwsysProcessCleanupHandle(&cp->ProcessInformation[index].hProcess);
        SetLastError(error);
        return 0;
        }
      }
    kwsysProcessCleanupHandle(&si->ErrorPipeRead);
    }

  if(!r)
    {
    return 0;
    }
  }

  /* Successfully created this child process.  Close the current
     process's copies of the inherited stdout and stdin handles.  The
","      }
    }

  /* Create the child in a suspended state so we can wait until all
     children have been created before running any one.  */
  if(!CreateProcess(0, cp->Commands[index], 0, 0, TRUE, CREATE_SUSPENDED, 0,
                    0, &si->StartupInfo, &cp->ProcessInformation[index]))
    {
    return 0;
    }

  /* Successfully created this child process.  Close the current
     process's copies of the inherited stdout and stdin handles.  The
",1815,1653,1848,-1,"sprintf(realCommand, ""%s %p %p %p %d %s"", cp->Win9x,
            si->ErrorPipeWrite, cp->Win9xResumeEvent, cp->Win9xKillEvent,
            cp->HideWindow, cp->Commands[index]);",,7,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_old_log_393.cpp,"{
    /* Create an error reporting pipe for the forwarding executable.
       Neither end is directly inherited.  */
    if(!CreatePipe(&si->ErrorPipeRead, &si->ErrorPipeWrite, 0, 0))
      {
      return 0;
      }

    /* Create an inherited duplicate of the write end.  This also closes
       the non-inherited version. */
    if(!DuplicateHandle(GetCurrentProcess(), si->ErrorPipeWrite,
                        GetCurrentProcess(), &si->ErrorPipeWrite,
                        0, TRUE, (DUPLICATE_CLOSE_SOURCE |
                                  DUPLICATE_SAME_ACCESS)))
      {
      return 0;
      }

    /* The forwarding executable is given a handle to the error pipe
       and resume and kill events.  */
    realCommand = (char*)malloc(strlen(cp->Win9x)+strlen(cp->Commands[index])+100);
    if(!realCommand)
      {
      return 0;
      }
    sprintf(realCommand, ""%s %p %p %p %d %s"", cp->Win9x,
            si->ErrorPipeWrite, cp->Win9xResumeEvent, cp->Win9xKillEvent,
            cp->HideWindow, cp->Commands[index]);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_393.cpp,"[3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 0, 53, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 3, 0, 0, 8, 0, 0, 2, 0, 22, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_new_log_393.cpp,"name****name****expr****argument
literal****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****argument
name****operator****name****name****expr****index****name****expr****argument
argument_list****call****expr****expr_stmt****unit****",2012-12-19T13:08:36,Brad King,79
