commit_message,file_name,change_type,log_statement,context,up_context,down_context
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/RValue.cpp,-,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,"  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(SGF, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = SGF.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !SGF.silConv.useLoweredAddresses());

      ManagedValue elt = SGF.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = SGF.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

","  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(SGF, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());

","
      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = SGF.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !SGF.silConv.useLoweredAddresses());

      ManagedValue elt = SGF.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = SGF.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/RValue.cpp,+,assert(eltTI.isLoadable() || !SGF.silConv.useLoweredAddresses());,"  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(SGF, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = SGF.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !SGF.silConv.useLoweredAddresses());

      ManagedValue elt = SGF.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = SGF.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

","  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(SGF, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = SGF.getTypeLowering(eltTy);



      // Project the element.

     ","
      ManagedValue elt = SGF.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = SGF.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,assert(gen.SGM.getASTContext().Diags.hadAnyError() &&,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

","
      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



   ","
           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,if (loweredBridgedTy == gen.SGM.Types.getNSErrorType()) {,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }
","

  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,"return gen.emitNativeToBridgedError(loc, v, loweredBridgedTy);","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }
","

  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

 ","
    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,"return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

   ","
  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,assert(v.getType().isTrivial(gen.SGM.M) || v.hasCleanup());,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

","
    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

   ","
    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,assert(gen.SGM.getASTContext().Diags.hadAnyError() &&,"static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

","
                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&,"static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



   ","
           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,if (loweredBridgedTy == gen.SGM.Types.getNSErrorType()),"static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.
","      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,"return gen.emitBridgedToNativeError(loc, v);","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.
","      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()),"static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

 ","
    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,"return SGF.emitBridgedToNativeError(loc, v);","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

   ","


  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"static void pushWriteback(SILGenFunction &gen,","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

",,"
                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"static void pushWriteback(SILGenFunction &SGF,","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}
","
                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope);,"static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,
","                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope);,"static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

 ","


  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope &&,"    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

","


      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope &&,"    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

     ","
             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"pushWriteback(gen, loc, std::move(clonedComponent), base, materialized);","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

","
        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

     ","


      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"void writeback(SILGenFunction &gen, SILLocation loc,","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

","    void writeback(SILGenFunction &SGF, SILLocation loc,
","                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"void writeback(SILGenFunction &SGF, SILLocation loc,","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

",   ,"
                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"LogicalPathComponent::writeback(gen, loc,","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize
","      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"LogicalPathComponent::writeback(SGF, loc,","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

       ","
                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope &&,"    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&
","             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope &&,"    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

     ","
             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"pushWriteback(gen, loc, std::move(component), result.second,","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

","
        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"pushWriteback(SGF, loc, std::move(component), result.second,","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

       ","
                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"auto typeData = getLogicalStorageTypeData(gen.SGM, formalRValueType);","static LValue emitLValueForNonMemberVarDecl(SILGenFunction &SGF,

                                            SILLocation loc, VarDecl *var,

                                            CanType formalRValueType,

                                            AccessKind accessKind,

                                            AccessSemantics semantics) {

  LValue lv;



  switch (var->getAccessStrategy(semantics, accessKind)) {



  case AccessStrategy::DispatchToAccessor:

    llvm_unreachable(""can't polymorphically access non-member variable"");



  // If it's a computed variable, push a reference to the getter and setter.

  case AccessStrategy::DirectToAccessor: {

    auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);

    lv.add<GetterSetterComponent>(var, /*isSuper=*/false, /*direct*/ true,

                                  SGF.SGM.getNonMemberVarDeclSubstitutions(var),

                                  CanType(), typeData);

    break;

  }



  case AccessStrategy::Addressor: {

    addNonMemberVarDeclAddressorComponent(SGF.SGM, var, formalRValueType, lv);

    break;

  }



  case AccessStrategy::Storage: {

    // If it's a physical value (e.g. a local variable in memory), push its

    // address.

    auto address = SGF.emitLValueForDecl(loc, var, formalRValueType,

                                         accessKind, semantics);

    assert(address.isLValue() &&

           ""physical lvalue decl ref must evaluate to an address"");

    auto typeData = getPhysicalStorageTypeData(SGF.SGM, var, formalRValueType);

    lv.add<ValueComponent>(address, typeData);



    if (address.getType().is<ReferenceStorageType>())

      lv.add<OwnershipComponent>(typeData);

    break;

  }

  

  case AccessStrategy::BehaviorStorage:

    // TODO: Behaviors aren't supported for non-instance properties yet.

    llvm_unreachable(""not implemented"");

  }



  return lv;

}

","static LValue emitLValueForNonMemberVarDecl(SILGenFunction &SGF,

                                            SILLocation loc, VarDecl *var,

                                            CanType formalRValueType,

                                            AccessKind accessKind,

                                            AccessSemantics semantics) {

  LValue lv;



","


  case AccessStrategy::DispatchToAccessor:

    llvm_unreachable(""can't polymorphically access non-member variable"");



  // If it's a computed variable, push a reference to the getter and setter.

  case AccessStrategy::DirectToAccessor: {

    auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);

    lv.add<GetterSetterComponent>(var, /*isSuper=*/false, /*direct*/ true,

                                  SGF.SGM.getNonMemberVarDeclSubstitutions(var),

                                  CanType(), typeData);

    break;

  }



  case AccessStrategy::Addressor: {

    addNonMemberVarDeclAddressorComponent(SGF.SGM, var, formalRValueType, lv);

    break;

  }



  case AccessStrategy::Storage: {

    // If it's a physical value (e.g. a local variable in memory), push its

    // address.

    auto address = SGF.emitLValueForDecl(loc, var, formalRValueType,

                                         accessKind, semantics);

    assert(address.isLValue() &&

           ""physical lvalue decl ref must evaluate to an address"");

    auto typeData = getPhysicalStorageTypeData(SGF.SGM, var, formalRValueType);

    lv.add<ValueComponent>(address, typeData);



    if (address.getType().is<ReferenceStorageType>())

      lv.add<OwnershipComponent>(typeData);

    break;

  }

  

  case AccessStrategy::BehaviorStorage:

    // TODO: Behaviors aren't supported for non-instance properties yet.

    llvm_unreachable(""not implemented"");

  }



  return lv;

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);","static LValue emitLValueForNonMemberVarDecl(SILGenFunction &SGF,

                                            SILLocation loc, VarDecl *var,

                                            CanType formalRValueType,

                                            AccessKind accessKind,

                                            AccessSemantics semantics) {

  LValue lv;



  switch (var->getAccessStrategy(semantics, accessKind)) {



  case AccessStrategy::DispatchToAccessor:

    llvm_unreachable(""can't polymorphically access non-member variable"");



  // If it's a computed variable, push a reference to the getter and setter.

  case AccessStrategy::DirectToAccessor: {

    auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);

    lv.add<GetterSetterComponent>(var, /*isSuper=*/false, /*direct*/ true,

                                  SGF.SGM.getNonMemberVarDeclSubstitutions(var),

                                  CanType(), typeData);

    break;

  }



  case AccessStrategy::Addressor: {

    addNonMemberVarDeclAddressorComponent(SGF.SGM, var, formalRValueType, lv);

    break;

  }



  case AccessStrategy::Storage: {

    // If it's a physical value (e.g. a local variable in memory), push its

    // address.

    auto address = SGF.emitLValueForDecl(loc, var, formalRValueType,

                                         accessKind, semantics);

    assert(address.isLValue() &&

           ""physical lvalue decl ref must evaluate to an address"");

    auto typeData = getPhysicalStorageTypeData(SGF.SGM, var, formalRValueType);

    lv.add<ValueComponent>(address, typeData);



    if (address.getType().is<ReferenceStorageType>())

      lv.add<OwnershipComponent>(typeData);

    break;

  }

  

  case AccessStrategy::BehaviorStorage:

    // TODO: Behaviors aren't supported for non-instance properties yet.

    llvm_unreachable(""not implemented"");

  }



  return lv;

}

","static LValue emitLValueForNonMemberVarDecl(SILGenFunction &SGF,

                                            SILLocation loc, VarDecl *var,

                                            CanType formalRValueType,

                                            AccessKind accessKind,

                                            AccessSemantics semantics) {

  LValue lv;



  switch (var->getAccessStrategy(semantics, accessKind)) {



  case AccessStrategy::DispatchToAccessor:

    llvm_unreachable(""can't polymorphically access non-member variable"");



  // If it's a computed variable, push a reference to the getter and setter.

  case AccessStrategy::DirectToAccessor: {

   ","
    lv.add<GetterSetterComponent>(var, /*isSuper=*/false, /*direct*/ true,

                                  SGF.SGM.getNonMemberVarDeclSubstitutions(var),

                                  CanType(), typeData);

    break;

  }



  case AccessStrategy::Addressor: {

    addNonMemberVarDeclAddressorComponent(SGF.SGM, var, formalRValueType, lv);

    break;

  }



  case AccessStrategy::Storage: {

    // If it's a physical value (e.g. a local variable in memory), push its

    // address.

    auto address = SGF.emitLValueForDecl(loc, var, formalRValueType,

                                         accessKind, semantics);

    assert(address.isLValue() &&

           ""physical lvalue decl ref must evaluate to an address"");

    auto typeData = getPhysicalStorageTypeData(SGF.SGM, var, formalRValueType);

    lv.add<ValueComponent>(address, typeData);



    if (address.getType().is<ReferenceStorageType>())

      lv.add<OwnershipComponent>(typeData);

    break;

  }

  

  case AccessStrategy::BehaviorStorage:

    // TODO: Behaviors aren't supported for non-instance properties yet.

    llvm_unreachable(""not implemented"");

  }



  return lv;

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/RValue.cpp,-,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,"  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(SGF, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = SGF.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !SGF.silConv.useLoweredAddresses());

      ManagedValue elt = SGF.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = SGF.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

","  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(SGF, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());

","
      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = SGF.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !SGF.silConv.useLoweredAddresses());

      ManagedValue elt = SGF.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = SGF.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/RValue.cpp,+,assert(eltTI.isLoadable() || !SGF.silConv.useLoweredAddresses());,"  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(SGF, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = SGF.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !SGF.silConv.useLoweredAddresses());

      ManagedValue elt = SGF.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = SGF.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

","  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(SGF, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = SGF.getTypeLowering(eltTy);



      // Project the element.

     ","
      ManagedValue elt = SGF.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = SGF.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,assert(gen.SGM.getASTContext().Diags.hadAnyError() &&,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

","
      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



   ","
           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,if (loweredBridgedTy == gen.SGM.Types.getNSErrorType()) {,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }
","

  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,"return gen.emitNativeToBridgedError(loc, v, loweredBridgedTy);","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }
","

  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

 ","
    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,"return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

   ","
  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,assert(v.getType().isTrivial(gen.SGM.M) || v.hasCleanup());,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

","
    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

   ","
    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,assert(gen.SGM.getASTContext().Diags.hadAnyError() &&,"static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

","
                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&,"static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



   ","
           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,if (loweredBridgedTy == gen.SGM.Types.getNSErrorType()),"static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.
","      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,"return gen.emitBridgedToNativeError(loc, v);","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.
","      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()),"static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

 ","
    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,"return SGF.emitBridgedToNativeError(loc, v);","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

   ","


  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"static void pushWriteback(SILGenFunction &gen,","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

",,"
                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"static void pushWriteback(SILGenFunction &SGF,","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}
","
                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope);,"static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,
","                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope);,"static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

 ","


  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope &&,"    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

","


      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope &&,"    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

     ","
             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"pushWriteback(gen, loc, std::move(clonedComponent), base, materialized);","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

","
        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

     ","


      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"void writeback(SILGenFunction &gen, SILLocation loc,","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

","    void writeback(SILGenFunction &SGF, SILLocation loc,
","                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"void writeback(SILGenFunction &SGF, SILLocation loc,","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

",   ,"
                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"LogicalPathComponent::writeback(gen, loc,","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize
","      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"LogicalPathComponent::writeback(SGF, loc,","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

       ","
                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope &&,"    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&
","             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope &&,"    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

     ","
             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"pushWriteback(gen, loc, std::move(component), result.second,","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

","
        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"pushWriteback(SGF, loc, std::move(component), result.second,","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

       ","
                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"auto typeData = getLogicalStorageTypeData(gen.SGM, formalRValueType);","static LValue emitLValueForNonMemberVarDecl(SILGenFunction &SGF,

                                            SILLocation loc, VarDecl *var,

                                            CanType formalRValueType,

                                            AccessKind accessKind,

                                            AccessSemantics semantics) {

  LValue lv;



  switch (var->getAccessStrategy(semantics, accessKind)) {



  case AccessStrategy::DispatchToAccessor:

    llvm_unreachable(""can't polymorphically access non-member variable"");



  // If it's a computed variable, push a reference to the getter and setter.

  case AccessStrategy::DirectToAccessor: {

    auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);

    lv.add<GetterSetterComponent>(var, /*isSuper=*/false, /*direct*/ true,

                                  SGF.SGM.getNonMemberVarDeclSubstitutions(var),

                                  CanType(), typeData);

    break;

  }



  case AccessStrategy::Addressor: {

    addNonMemberVarDeclAddressorComponent(SGF.SGM, var, formalRValueType, lv);

    break;

  }



  case AccessStrategy::Storage: {

    // If it's a physical value (e.g. a local variable in memory), push its

    // address.

    auto address = SGF.emitLValueForDecl(loc, var, formalRValueType,

                                         accessKind, semantics);

    assert(address.isLValue() &&

           ""physical lvalue decl ref must evaluate to an address"");

    auto typeData = getPhysicalStorageTypeData(SGF.SGM, var, formalRValueType);

    lv.add<ValueComponent>(address, typeData);



    if (address.getType().is<ReferenceStorageType>())

      lv.add<OwnershipComponent>(typeData);

    break;

  }

  

  case AccessStrategy::BehaviorStorage:

    // TODO: Behaviors aren't supported for non-instance properties yet.

    llvm_unreachable(""not implemented"");

  }



  return lv;

}

","static LValue emitLValueForNonMemberVarDecl(SILGenFunction &SGF,

                                            SILLocation loc, VarDecl *var,

                                            CanType formalRValueType,

                                            AccessKind accessKind,

                                            AccessSemantics semantics) {

  LValue lv;



","


  case AccessStrategy::DispatchToAccessor:

    llvm_unreachable(""can't polymorphically access non-member variable"");



  // If it's a computed variable, push a reference to the getter and setter.

  case AccessStrategy::DirectToAccessor: {

    auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);

    lv.add<GetterSetterComponent>(var, /*isSuper=*/false, /*direct*/ true,

                                  SGF.SGM.getNonMemberVarDeclSubstitutions(var),

                                  CanType(), typeData);

    break;

  }



  case AccessStrategy::Addressor: {

    addNonMemberVarDeclAddressorComponent(SGF.SGM, var, formalRValueType, lv);

    break;

  }



  case AccessStrategy::Storage: {

    // If it's a physical value (e.g. a local variable in memory), push its

    // address.

    auto address = SGF.emitLValueForDecl(loc, var, formalRValueType,

                                         accessKind, semantics);

    assert(address.isLValue() &&

           ""physical lvalue decl ref must evaluate to an address"");

    auto typeData = getPhysicalStorageTypeData(SGF.SGM, var, formalRValueType);

    lv.add<ValueComponent>(address, typeData);



    if (address.getType().is<ReferenceStorageType>())

      lv.add<OwnershipComponent>(typeData);

    break;

  }

  

  case AccessStrategy::BehaviorStorage:

    // TODO: Behaviors aren't supported for non-instance properties yet.

    llvm_unreachable(""not implemented"");

  }



  return lv;

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);","static LValue emitLValueForNonMemberVarDecl(SILGenFunction &SGF,

                                            SILLocation loc, VarDecl *var,

                                            CanType formalRValueType,

                                            AccessKind accessKind,

                                            AccessSemantics semantics) {

  LValue lv;



  switch (var->getAccessStrategy(semantics, accessKind)) {



  case AccessStrategy::DispatchToAccessor:

    llvm_unreachable(""can't polymorphically access non-member variable"");



  // If it's a computed variable, push a reference to the getter and setter.

  case AccessStrategy::DirectToAccessor: {

    auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);

    lv.add<GetterSetterComponent>(var, /*isSuper=*/false, /*direct*/ true,

                                  SGF.SGM.getNonMemberVarDeclSubstitutions(var),

                                  CanType(), typeData);

    break;

  }



  case AccessStrategy::Addressor: {

    addNonMemberVarDeclAddressorComponent(SGF.SGM, var, formalRValueType, lv);

    break;

  }



  case AccessStrategy::Storage: {

    // If it's a physical value (e.g. a local variable in memory), push its

    // address.

    auto address = SGF.emitLValueForDecl(loc, var, formalRValueType,

                                         accessKind, semantics);

    assert(address.isLValue() &&

           ""physical lvalue decl ref must evaluate to an address"");

    auto typeData = getPhysicalStorageTypeData(SGF.SGM, var, formalRValueType);

    lv.add<ValueComponent>(address, typeData);



    if (address.getType().is<ReferenceStorageType>())

      lv.add<OwnershipComponent>(typeData);

    break;

  }

  

  case AccessStrategy::BehaviorStorage:

    // TODO: Behaviors aren't supported for non-instance properties yet.

    llvm_unreachable(""not implemented"");

  }



  return lv;

}

","static LValue emitLValueForNonMemberVarDecl(SILGenFunction &SGF,

                                            SILLocation loc, VarDecl *var,

                                            CanType formalRValueType,

                                            AccessKind accessKind,

                                            AccessSemantics semantics) {

  LValue lv;



  switch (var->getAccessStrategy(semantics, accessKind)) {



  case AccessStrategy::DispatchToAccessor:

    llvm_unreachable(""can't polymorphically access non-member variable"");



  // If it's a computed variable, push a reference to the getter and setter.

  case AccessStrategy::DirectToAccessor: {

   ","
    lv.add<GetterSetterComponent>(var, /*isSuper=*/false, /*direct*/ true,

                                  SGF.SGM.getNonMemberVarDeclSubstitutions(var),

                                  CanType(), typeData);

    break;

  }



  case AccessStrategy::Addressor: {

    addNonMemberVarDeclAddressorComponent(SGF.SGM, var, formalRValueType, lv);

    break;

  }



  case AccessStrategy::Storage: {

    // If it's a physical value (e.g. a local variable in memory), push its

    // address.

    auto address = SGF.emitLValueForDecl(loc, var, formalRValueType,

                                         accessKind, semantics);

    assert(address.isLValue() &&

           ""physical lvalue decl ref must evaluate to an address"");

    auto typeData = getPhysicalStorageTypeData(SGF.SGM, var, formalRValueType);

    lv.add<ValueComponent>(address, typeData);



    if (address.getType().is<ReferenceStorageType>())

      lv.add<OwnershipComponent>(typeData);

    break;

  }

  

  case AccessStrategy::BehaviorStorage:

    // TODO: Behaviors aren't supported for non-instance properties yet.

    llvm_unreachable(""not implemented"");

  }



  return lv;

}

"
Merge pull request #8023 from huonw/tweak,lib/AST/ASTDumper.cpp,-,Super.getType().print(OS);,"    void visitImportDecl(ImportDecl *ID) {

      printCommon(ID, ""import_decl"");



      if (ID->isExported())

        OS << "" exported"";



      if (ID->getImportKind() != ImportKind::Module)

        OS << "" kind="" << getImportKindString(ID->getImportKind());



      OS << "" '"";

      interleave(ID->getFullAccessPath(),

                 [&](const ImportDecl::AccessPathElement &Elem) {

                   OS << Elem.first;

                 },

                 [&] { OS << '.'; });

      OS << ""')"";

    }

","    void visitImportDecl(ImportDecl *ID) {

      printCommon(ID, ""import_decl"");
","

      if (ID->isExported())

        OS << "" exported"";



      if (ID->getImportKind() != ImportKind::Module)

        OS << "" kind="" << getImportKindString(ID->getImportKind());



      OS << "" '"";

      interleave(ID->getFullAccessPath(),

                 [&](const ImportDecl::AccessPathElement &Elem) {

                   OS << Elem.first;

                 },

                 [&] { OS << '.'; });

      OS << ""')"";

    }


"
"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ASTDumper.cpp,-,Super.getType().print(OS);,"    void visitImportDecl(ImportDecl *ID) {

      printCommon(ID, ""import_decl"");



      if (ID->isExported())

        OS << "" exported"";



      if (ID->getImportKind() != ImportKind::Module)

        OS << "" kind="" << getImportKindString(ID->getImportKind());



      OS << "" '"";

      interleave(ID->getFullAccessPath(),

                 [&](const ImportDecl::AccessPathElement &Elem) {

                   OS << Elem.first;

                 },

                 [&] { OS << '.'; });

      OS << ""')"";

    }

","    void visitImportDecl(ImportDecl *ID) {

      printCommon(ID, ""import_decl"");
","

      if (ID->isExported())

        OS << "" exported"";



      if (ID->getImportKind() != ImportKind::Module)

        OS << "" kind="" << getImportKindString(ID->getImportKind());



      OS << "" '"";

      interleave(ID->getFullAccessPath(),

                 [&](const ImportDecl::AccessPathElement &Elem) {

                   OS << Elem.first;

                 },

                 [&] { OS << '.'; });

      OS << ""')"";

    }


"
"Merge pull request #7973 from swiftix/wip-fso-fixes

[function-signature-opt] Allow FSO on witness_methods when performing  the dead argument signature optimization for partial_apply instructions",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,"DEBUG(llvm::dbgs() << ""  cannot specialize function -> abort\n"");","  void run() override {

    auto *F = getFunction();



    // Don't optimize callees that should not be optimized.

    if (!F->shouldOptimize())

      return;



    // This is the function to optimize.

    DEBUG(llvm::dbgs() << ""*** FSO on function: "" << F->getName() << "" ***\n"");



    // Check the signature of F to make sure that it is a function that we

    // can specialize. These are conditions independent of the call graph.

    // No need for CallerAnalysis if we are not optimizing for partial

    // applies.

    if (!OptForPartialApply &&

        !canSpecializeFunction(F, nullptr, OptForPartialApply)) {

      DEBUG(llvm::dbgs() << ""  cannot specialize function -> abort\n"");

      return;

    }



    CallerAnalysis *CA = PM->getAnalysis<CallerAnalysis>();

    const CallerAnalysis::FunctionInfo &FuncInfo = CA->getCallerInfo(F);



    // Check the signature of F to make sure that it is a function that we

    // can specialize. These are conditions independent of the call graph.

    if (OptForPartialApply &&

        !canSpecializeFunction(F, &FuncInfo, OptForPartialApply)) {

      DEBUG(llvm::dbgs() << ""  cannot specialize function -> abort\n"");

      return;

    }



    auto *RCIA = getAnalysis<RCIdentityAnalysis>();

    auto *EA = PM->getAnalysis<EpilogueARCAnalysis>();



    // Lock BCA so it's not invalidated along with the rest of the call graph.

    AnalysisPreserver BCAP(PM->getAnalysis<BasicCalleeAnalysis>());



    // As we optimize the function more and more, the name of the function is

    // going to change, make sure the mangler is aware of all the changes done

    // to the function.

    Mangle::Mangler M;

    auto P = Demangle::SpecializationPass::FunctionSignatureOpts;

    FunctionSignatureSpecializationMangler OldFM(P, M, F->isFragile(), F);

    NewMangling::FunctionSignatureSpecializationMangler NewFM(P, F->isFragile(),

                                                              F);



    /// Keep a map between the exploded argument index and the original argument

    /// index.

    llvm::SmallDenseMap<int, int> AIM;

    int asize = F->begin()->getArguments().size();

    for (auto i = 0; i < asize; ++i) {

      AIM[i] = i;

    }



    // Allocate the argument and result descriptors.

    llvm::SmallVector<ArgumentDescriptor, 4> ArgumentDescList;

    llvm::SmallVector<ResultDescriptor, 4> ResultDescList;

    auto Args = F->begin()->getFunctionArguments();

    for (unsigned i = 0, e = Args.size(); i != e; ++i) {

      ArgumentDescList.emplace_back(Args[i]);

    }

    for (SILResultInfo IR : F->getLoweredFunctionType()->getResults()) {

      ResultDescList.emplace_back(IR);

    }



    // Owned to guaranteed optimization.

    FunctionSignatureTransform FST(F, RCIA, EA, OldFM, NewFM, AIM,

                                   ArgumentDescList, ResultDescList);



    bool Changed = false;

    if (OptForPartialApply) {

      Changed = FST.removeDeadArgs(FuncInfo.getMinPartialAppliedArgs());

    } else {

      Changed = FST.run(FuncInfo.hasCaller());

    }

    if (Changed) {

      ++ NumFunctionSignaturesOptimized;

      // The old function must be a thunk now.

      assert(F->isThunk() && ""Old function should have been turned into a thunk"");



      PM->invalidateAnalysis(F, SILAnalysis::InvalidationKind::Everything);



      // Make sure the PM knows about this function. This will also help us

      // with self-recursion.

      notifyPassManagerOfFunction(FST.getOptimizedFunction(), F);



      if (!OptForPartialApply) {

        // We have to restart the pipeline for this thunk in order to run the

        // inliner (and other opts) again. This is important if the new

        // specialized function (which is called from this thunk) is

        // function-signature-optimized again and also becomes an

        // always-inline-thunk.

        restartPassPipeline();

      }

    }

  }

","  void run() override {

    auto *F = getFunction();



    // Don't optimize callees that should not be optimized.

    if (!F->shouldOptimize())

      return;



    // This is the function to optimize.

    DEBUG(llvm::dbgs() << ""*** FSO on function: "" << F->getName() << "" ***\n"");



    // Check the signature of F to make sure that it is a function that we

    // can specialize. These are conditions independent of the call graph.

    // No need for CallerAnalysis if we are not optimizing for partial

    // applies.

    if (!OptForPartialApply &&

        !canSpecializeFunction(F, nullptr, OptForPartialApply)) {

     ","
      return;

    }



    CallerAnalysis *CA = PM->getAnalysis<CallerAnalysis>();

    const CallerAnalysis::FunctionInfo &FuncInfo = CA->getCallerInfo(F);



    // Check the signature of F to make sure that it is a function that we

    // can specialize. These are conditions independent of the call graph.

    if (OptForPartialApply &&

        !canSpecializeFunction(F, &FuncInfo, OptForPartialApply)) {

      DEBUG(llvm::dbgs() << ""  cannot specialize function -> abort\n"");

      return;

    }



    auto *RCIA = getAnalysis<RCIdentityAnalysis>();

    auto *EA = PM->getAnalysis<EpilogueARCAnalysis>();



    // Lock BCA so it's not invalidated along with the rest of the call graph.

    AnalysisPreserver BCAP(PM->getAnalysis<BasicCalleeAnalysis>());



    // As we optimize the function more and more, the name of the function is

    // going to change, make sure the mangler is aware of all the changes done

    // to the function.

    Mangle::Mangler M;

    auto P = Demangle::SpecializationPass::FunctionSignatureOpts;

    FunctionSignatureSpecializationMangler OldFM(P, M, F->isFragile(), F);

    NewMangling::FunctionSignatureSpecializationMangler NewFM(P, F->isFragile(),

                                                              F);



    /// Keep a map between the exploded argument index and the original argument

    /// index.

    llvm::SmallDenseMap<int, int> AIM;

    int asize = F->begin()->getArguments().size();

    for (auto i = 0; i < asize; ++i) {

      AIM[i] = i;

    }



    // Allocate the argument and result descriptors.

    llvm::SmallVector<ArgumentDescriptor, 4> ArgumentDescList;

    llvm::SmallVector<ResultDescriptor, 4> ResultDescList;

    auto Args = F->begin()->getFunctionArguments();

    for (unsigned i = 0, e = Args.size(); i != e; ++i) {

      ArgumentDescList.emplace_back(Args[i]);

    }

    for (SILResultInfo IR : F->getLoweredFunctionType()->getResults()) {

      ResultDescList.emplace_back(IR);

    }



    // Owned to guaranteed optimization.

    FunctionSignatureTransform FST(F, RCIA, EA, OldFM, NewFM, AIM,

                                   ArgumentDescList, ResultDescList);



    bool Changed = false;

    if (OptForPartialApply) {

      Changed = FST.removeDeadArgs(FuncInfo.getMinPartialAppliedArgs());

    } else {

      Changed = FST.run(FuncInfo.hasCaller());

    }

    if (Changed) {

      ++ NumFunctionSignaturesOptimized;

      // The old function must be a thunk now.

      assert(F->isThunk() && ""Old function should have been turned into a thunk"");



      PM->invalidateAnalysis(F, SILAnalysis::InvalidationKind::Everything);



      // Make sure the PM knows about this function. This will also help us

      // with self-recursion.

      notifyPassManagerOfFunction(FST.getOptimizedFunction(), F);



      if (!OptForPartialApply) {

        // We have to restart the pipeline for this thunk in order to run the

        // inliner (and other opts) again. This is important if the new

        // specialized function (which is called from this thunk) is

        // function-signature-optimized again and also becomes an

        // always-inline-thunk.

        restartPassPipeline();

      }

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/DemangleWrappers.cpp,-,"printNode(Out, child, depth + 1);","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }
","  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}


"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/DemangleWrappers.cpp,-,void NodeDumper::dump() const { print(llvm::errs()); },"static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

","
    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}


"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/DemangleWrappers.cpp,-,void NodeDumper::print(llvm::raw_ostream &Out) const {,"static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {
","    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}


"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/DemangleWrappers.cpp,-,"printNode(Out, Root, 0);","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {
","    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}


"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/DemangleWrappers.cpp,-,"printNode(out, TheNode, 4);","  PrettyStackTraceNode(const char *action, Node *node)

    : Action(action), TheNode(node) {}

","  PrettyStackTraceNode(const char *action, Node *node)
","    : Action(action), TheNode(node) {}


"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodeDumper.cpp,+,"static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {","static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {

  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {

  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}
","
  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodeDumper.cpp,+,"printNode(Out, child, depth + 1);","static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {

  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {

  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

   ","
  }

}

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad directness"");","static StringRef toString(Directness d) {

  switch (d) {

  case Directness::Direct:

    return ""direct"";

  case Directness::Indirect:

    return ""indirect"";

  }

  printer_unreachable(""bad directness"");

}

","static StringRef toString(Directness d) {

  switch (d) {

  case Directness::Direct:

    return ""direct"";

  case Directness::Indirect:

    return ""indirect"";

  }

 ","
}

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,NodePrinter(DemangleOptions options) : Options(options) {},"  NodePrinter(DemangleOptions options) : Options(options) {}

", ,"
"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,std::string printRoot(NodePointer root) {,"  std::string printRoot(NodePointer root) {

    print(root);

    return std::move(Printer).str();

  }

", ,"
    print(root);

    return std::move(Printer).str();

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(root);,"  std::string printRoot(NodePointer root) {

    print(root);

    return std::move(Printer).str();

  }

","  std::string printRoot(NodePointer root) {

   ","
    return std::move(Printer).str();

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"void printChildren(Node::iterator begin,","  void printChildren(Node::iterator begin,

                     Node::iterator end,

                     const char *sep = nullptr) {

    for (; begin != end;) {

      print(*begin);

      ++begin;

      if (sep && begin != end)

        Printer << sep;

    }

  }

", ,"
                     Node::iterator end,

                     const char *sep = nullptr) {

    for (; begin != end;) {

      print(*begin);

      ++begin;

      if (sep && begin != end)

        Printer << sep;

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(*begin);,"  void printChildren(Node::iterator begin,

                     Node::iterator end,

                     const char *sep = nullptr) {

    for (; begin != end;) {

      print(*begin);

      ++begin;

      if (sep && begin != end)

        Printer << sep;

    }

  }

","  void printChildren(Node::iterator begin,

                     Node::iterator end,

                     const char *sep = nullptr) {

    for (; begin != end;) {

     ","
      ++begin;

      if (sep && begin != end)

        Printer << sep;

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,void printBoundGenericNoSugar(NodePointer pointer) {,"  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

", ,"
    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,"  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

","  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

   ","
    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printChildren(typelist, "", "");","  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

","  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

   ","
    Printer << "">"";

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,static bool isDebuggerGeneratedModule(NodePointer node) {,"  static bool isDebuggerGeneratedModule(NodePointer node) {

      return (node->getKind() == Node::Kind::Module &&

              node->getText().startswith(LLDB_EXPRESSIONS_MODULE_NAME_PREFIX));

    }

", ,"
      return (node->getKind() == Node::Kind::Module &&

              node->getText().startswith(LLDB_EXPRESSIONS_MODULE_NAME_PREFIX));

    }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad node kind"");","  bool isSimpleType(NodePointer pointer) {

    switch (pointer->getKind()) {

    case Node::Kind::AssociatedType:

    case Node::Kind::AssociatedTypeRef:

    case Node::Kind::BoundGenericClass:

    case Node::Kind::BoundGenericEnum:

    case Node::Kind::BoundGenericStructure:

    case Node::Kind::BuiltinTypeName:

    case Node::Kind::Class:

    case Node::Kind::DependentGenericType:

    case Node::Kind::DependentMemberType:

    case Node::Kind::DependentGenericParamType:

    case Node::Kind::DynamicSelf:

    case Node::Kind::Enum:

    case Node::Kind::ErrorType:

    case Node::Kind::ExistentialMetatype:

    case Node::Kind::Metatype:

    case Node::Kind::MetatypeRepresentation:

    case Node::Kind::Module:

    case Node::Kind::NonVariadicTuple:

    case Node::Kind::Protocol:

    case Node::Kind::QualifiedArchetype:

    case Node::Kind::ReturnType:

    case Node::Kind::SILBoxType:

    case Node::Kind::SILBoxTypeWithLayout:

    case Node::Kind::Structure:

    case Node::Kind::TupleElementName:

    case Node::Kind::Type:

    case Node::Kind::TypeAlias:

    case Node::Kind::TypeList:

    case Node::Kind::VariadicTuple:

      return true;



    case Node::Kind::ProtocolList:

      if (pointer->getChild(0)->getNumChildren() <= 1)

        return true;

      return false;



    case Node::Kind::Allocator:

    case Node::Kind::ArgumentTuple:

    case Node::Kind::AssociatedTypeMetadataAccessor:

    case Node::Kind::AssociatedTypeWitnessTableAccessor:

    case Node::Kind::AutoClosureType:

    case Node::Kind::CFunctionPointer:

    case Node::Kind::Constructor:

    case Node::Kind::CurryThunk:

    case Node::Kind::Deallocator:

    case Node::Kind::DeclContext:

    case Node::Kind::DefaultArgumentInitializer:

    case Node::Kind::DependentAssociatedTypeRef:

    case Node::Kind::DependentGenericSignature:

    case Node::Kind::DependentGenericParamCount:

    case Node::Kind::DependentGenericConformanceRequirement:

    case Node::Kind::DependentGenericLayoutRequirement:

    case Node::Kind::DependentGenericSameTypeRequirement:

    case Node::Kind::DependentPseudogenericSignature:

    case Node::Kind::Destructor:

    case Node::Kind::DidSet:

    case Node::Kind::DirectMethodReferenceAttribute:

    case Node::Kind::Directness:

    case Node::Kind::DynamicAttribute:

    case Node::Kind::ExplicitClosure:

    case Node::Kind::Extension:

    case Node::Kind::FieldOffset:

    case Node::Kind::FullTypeMetadata:

    case Node::Kind::Function:

    case Node::Kind::FunctionSignatureSpecialization:

    case Node::Kind::FunctionSignatureSpecializationParam:

    case Node::Kind::FunctionSignatureSpecializationParamKind:

    case Node::Kind::FunctionSignatureSpecializationParamPayload:

    case Node::Kind::FunctionType:

    case Node::Kind::GenericProtocolWitnessTable:

    case Node::Kind::GenericProtocolWitnessTableInstantiationFunction:

    case Node::Kind::GenericPartialSpecialization:

    case Node::Kind::GenericPartialSpecializationNotReAbstracted:

    case Node::Kind::GenericSpecialization:

    case Node::Kind::GenericSpecializationNotReAbstracted:

    case Node::Kind::GenericSpecializationParam:

    case Node::Kind::GenericTypeMetadataPattern:

    case Node::Kind::Getter:

    case Node::Kind::Global:

    case Node::Kind::GlobalGetter:

    case Node::Kind::Identifier:

    case Node::Kind::Index:

    case Node::Kind::IVarInitializer:

    case Node::Kind::IVarDestroyer:

    case Node::Kind::ImplConvention:

    case Node::Kind::ImplFunctionAttribute:

    case Node::Kind::ImplFunctionType:

    case Node::Kind::ImplicitClosure:

    case Node::Kind::ImplParameter:

    case Node::Kind::ImplResult:

    case Node::Kind::ImplErrorResult:

    case Node::Kind::InOut:

    case Node::Kind::InfixOperator:

    case Node::Kind::Initializer:

    case Node::Kind::LazyProtocolWitnessTableAccessor:

    case Node::Kind::LazyProtocolWitnessTableCacheVariable:

    case Node::Kind::LocalDeclName:

    case Node::Kind::PrivateDeclName:

    case Node::Kind::MaterializeForSet:

    case Node::Kind::Metaclass:

    case Node::Kind::NativeOwningAddressor:

    case Node::Kind::NativeOwningMutableAddressor:

    case Node::Kind::NativePinningAddressor:

    case Node::Kind::NativePinningMutableAddressor:

    case Node::Kind::NominalTypeDescriptor:

    case Node::Kind::NonObjCAttribute:

    case Node::Kind::Number:

    case Node::Kind::ObjCAttribute:

    case Node::Kind::ObjCBlock:

    case Node::Kind::OwningAddressor:

    case Node::Kind::OwningMutableAddressor:

    case Node::Kind::PartialApplyForwarder:

    case Node::Kind::PartialApplyObjCForwarder:

    case Node::Kind::PostfixOperator:

    case Node::Kind::PrefixOperator:

    case Node::Kind::ProtocolConformance:

    case Node::Kind::ProtocolDescriptor:

    case Node::Kind::ProtocolWitness:

    case Node::Kind::ProtocolWitnessTable:

    case Node::Kind::ProtocolWitnessTableAccessor:

    case Node::Kind::ReabstractionThunk:

    case Node::Kind::ReabstractionThunkHelper:

    case Node::Kind::Setter:

    case Node::Kind::SILBoxLayout:

    case Node::Kind::SILBoxMutableField:

    case Node::Kind::SILBoxImmutableField:

    case Node::Kind::SpecializationIsFragile:

    case Node::Kind::SpecializationPassID:

    case Node::Kind::Static:

    case Node::Kind::Subscript:

    case Node::Kind::Suffix:

    case Node::Kind::ThinFunctionType:

    case Node::Kind::TupleElement:

    case Node::Kind::TypeMangling:

    case Node::Kind::TypeMetadata:

    case Node::Kind::TypeMetadataAccessFunction:

    case Node::Kind::TypeMetadataLazyCache:

    case Node::Kind::UncurriedFunctionType:

    case Node::Kind::Unmanaged:

    case Node::Kind::Unowned:

    case Node::Kind::UnsafeAddressor:

    case Node::Kind::UnsafeMutableAddressor:

    case Node::Kind::ValueWitness:

    case Node::Kind::ValueWitnessTable:

    case Node::Kind::Variable:

    case Node::Kind::VTableAttribute:

    case Node::Kind::Weak:

    case Node::Kind::WillSet:

    case Node::Kind::WitnessTableOffset:

    case Node::Kind::ReflectionMetadataBuiltinDescriptor:

    case Node::Kind::ReflectionMetadataFieldDescriptor:

    case Node::Kind::ReflectionMetadataAssocTypeDescriptor:

    case Node::Kind::ReflectionMetadataSuperclassDescriptor:

    case Node::Kind::GenericTypeParamDecl:

    case Node::Kind::ThrowsAnnotation:

    case Node::Kind::EmptyList:

    case Node::Kind::FirstElementMarker:

    case Node::Kind::VariadicMarker:

    case Node::Kind::OutlinedCopy:

    case Node::Kind::OutlinedConsume:

      return false;

    }

    printer_unreachable(""bad node kind"");

  }

","  bool isSimpleType(NodePointer pointer) {

    switch (pointer->getKind()) {

    case Node::Kind::AssociatedType:

    case Node::Kind::AssociatedTypeRef:

    case Node::Kind::BoundGenericClass:

    case Node::Kind::BoundGenericEnum:

    case Node::Kind::BoundGenericStructure:

    case Node::Kind::BuiltinTypeName:

    case Node::Kind::Class:

    case Node::Kind::DependentGenericType:

    case Node::Kind::DependentMemberType:

    case Node::Kind::DependentGenericParamType:

    case Node::Kind::DynamicSelf:

    case Node::Kind::Enum:

    case Node::Kind::ErrorType:

    case Node::Kind::ExistentialMetatype:

    case Node::Kind::Metatype:

    case Node::Kind::MetatypeRepresentation:

    case Node::Kind::Module:

    case Node::Kind::NonVariadicTuple:

    case Node::Kind::Protocol:

    case Node::Kind::QualifiedArchetype:

    case Node::Kind::ReturnType:

    case Node::Kind::SILBoxType:

    case Node::Kind::SILBoxTypeWithLayout:

    case Node::Kind::Structure:

    case Node::Kind::TupleElementName:

    case Node::Kind::Type:

    case Node::Kind::TypeAlias:

    case Node::Kind::TypeList:

    case Node::Kind::VariadicTuple:

      return true;



    case Node::Kind::ProtocolList:

      if (pointer->getChild(0)->getNumChildren() <= 1)

        return true;

      return false;



    case Node::Kind::Allocator:

    case Node::Kind::ArgumentTuple:

    case Node::Kind::AssociatedTypeMetadataAccessor:

    case Node::Kind::AssociatedTypeWitnessTableAccessor:

    case Node::Kind::AutoClosureType:

    case Node::Kind::CFunctionPointer:

    case Node::Kind::Constructor:

    case Node::Kind::CurryThunk:

    case Node::Kind::Deallocator:

    case Node::Kind::DeclContext:

    case Node::Kind::DefaultArgumentInitializer:

    case Node::Kind::DependentAssociatedTypeRef:

    case Node::Kind::DependentGenericSignature:

    case Node::Kind::DependentGenericParamCount:

    case Node::Kind::DependentGenericConformanceRequirement:

    case Node::Kind::DependentGenericLayoutRequirement:

    case Node::Kind::DependentGenericSameTypeRequirement:

    case Node::Kind::DependentPseudogenericSignature:

    case Node::Kind::Destructor:

    case Node::Kind::DidSet:

    case Node::Kind::DirectMethodReferenceAttribute:

    case Node::Kind::Directness:

    case Node::Kind::DynamicAttribute:

    case Node::Kind::ExplicitClosure:

    case Node::Kind::Extension:

    case Node::Kind::FieldOffset:

    case Node::Kind::FullTypeMetadata:

    case Node::Kind::Function:

    case Node::Kind::FunctionSignatureSpecialization:

    case Node::Kind::FunctionSignatureSpecializationParam:

    case Node::Kind::FunctionSignatureSpecializationParamKind:

    case Node::Kind::FunctionSignatureSpecializationParamPayload:

    case Node::Kind::FunctionType:

    case Node::Kind::GenericProtocolWitnessTable:

    case Node::Kind::GenericProtocolWitnessTableInstantiationFunction:

    case Node::Kind::GenericPartialSpecialization:

    case Node::Kind::GenericPartialSpecializationNotReAbstracted:

    case Node::Kind::GenericSpecialization:

    case Node::Kind::GenericSpecializationNotReAbstracted:

    case Node::Kind::GenericSpecializationParam:

    case Node::Kind::GenericTypeMetadataPattern:

    case Node::Kind::Getter:

    case Node::Kind::Global:

    case Node::Kind::GlobalGetter:

    case Node::Kind::Identifier:

    case Node::Kind::Index:

    case Node::Kind::IVarInitializer:

    case Node::Kind::IVarDestroyer:

    case Node::Kind::ImplConvention:

    case Node::Kind::ImplFunctionAttribute:

    case Node::Kind::ImplFunctionType:

    case Node::Kind::ImplicitClosure:

    case Node::Kind::ImplParameter:

    case Node::Kind::ImplResult:

    case Node::Kind::ImplErrorResult:

    case Node::Kind::InOut:

    case Node::Kind::InfixOperator:

    case Node::Kind::Initializer:

    case Node::Kind::LazyProtocolWitnessTableAccessor:

    case Node::Kind::LazyProtocolWitnessTableCacheVariable:

    case Node::Kind::LocalDeclName:

    case Node::Kind::PrivateDeclName:

    case Node::Kind::MaterializeForSet:

    case Node::Kind::Metaclass:

    case Node::Kind::NativeOwningAddressor:

    case Node::Kind::NativeOwningMutableAddressor:

    case Node::Kind::NativePinningAddressor:

    case Node::Kind::NativePinningMutableAddressor:

    case Node::Kind::NominalTypeDescriptor:

    case Node::Kind::NonObjCAttribute:

    case Node::Kind::Number:

    case Node::Kind::ObjCAttribute:

    case Node::Kind::ObjCBlock:

    case Node::Kind::OwningAddressor:

    case Node::Kind::OwningMutableAddressor:

    case Node::Kind::PartialApplyForwarder:

    case Node::Kind::PartialApplyObjCForwarder:

    case Node::Kind::PostfixOperator:

    case Node::Kind::PrefixOperator:

    case Node::Kind::ProtocolConformance:

    case Node::Kind::ProtocolDescriptor:

    case Node::Kind::ProtocolWitness:

    case Node::Kind::ProtocolWitnessTable:

    case Node::Kind::ProtocolWitnessTableAccessor:

    case Node::Kind::ReabstractionThunk:

    case Node::Kind::ReabstractionThunkHelper:

    case Node::Kind::Setter:

    case Node::Kind::SILBoxLayout:

    case Node::Kind::SILBoxMutableField:

    case Node::Kind::SILBoxImmutableField:

    case Node::Kind::SpecializationIsFragile:

    case Node::Kind::SpecializationPassID:

    case Node::Kind::Static:

    case Node::Kind::Subscript:

    case Node::Kind::Suffix:

    case Node::Kind::ThinFunctionType:

    case Node::Kind::TupleElement:

    case Node::Kind::TypeMangling:

    case Node::Kind::TypeMetadata:

    case Node::Kind::TypeMetadataAccessFunction:

    case Node::Kind::TypeMetadataLazyCache:

    case Node::Kind::UncurriedFunctionType:

    case Node::Kind::Unmanaged:

    case Node::Kind::Unowned:

    case Node::Kind::UnsafeAddressor:

    case Node::Kind::UnsafeMutableAddressor:

    case Node::Kind::ValueWitness:

    case Node::Kind::ValueWitnessTable:

    case Node::Kind::Variable:

    case Node::Kind::VTableAttribute:

    case Node::Kind::Weak:

    case Node::Kind::WillSet:

    case Node::Kind::WitnessTableOffset:

    case Node::Kind::ReflectionMetadataBuiltinDescriptor:

    case Node::Kind::ReflectionMetadataFieldDescriptor:

    case Node::Kind::ReflectionMetadataAssocTypeDescriptor:

    case Node::Kind::ReflectionMetadataSuperclassDescriptor:

    case Node::Kind::GenericTypeParamDecl:

    case Node::Kind::ThrowsAnnotation:

    case Node::Kind::EmptyList:

    case Node::Kind::FirstElementMarker:

    case Node::Kind::VariadicMarker:

    case Node::Kind::OutlinedCopy:

    case Node::Kind::OutlinedConsume:

      return false;

    }

   ","
  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(pointer->getKind() == Node::Kind::BoundGenericStructure);,"  SugarType findSugar(NodePointer pointer) {

    if (pointer->getNumChildren() == 1 && 

        pointer->getKind() == Node::Kind::Type)

      return findSugar(pointer->getChild(0));

    

    if (pointer->getNumChildren() != 2)

      return SugarType::None;

    

    if (pointer->getKind() != Node::Kind::BoundGenericEnum &&

        pointer->getKind() != Node::Kind::BoundGenericStructure)

      return SugarType::None;



    auto unboundType = pointer->getChild(0)->getChild(0); // drill through Type

    auto typeArgs = pointer->getChild(1);

    

    if (pointer->getKind() == Node::Kind::BoundGenericEnum) {

      // Swift.Optional

      if (isIdentifier(unboundType->getChild(1), ""Optional"") &&

          typeArgs->getNumChildren() == 1 &&

          isSwiftModule(unboundType->getChild(0))) {

        return SugarType::Optional;

      }



      // Swift.ImplicitlyUnwrappedOptional

      if (isIdentifier(unboundType->getChild(1), 

                       ""ImplicitlyUnwrappedOptional"") &&

          typeArgs->getNumChildren() == 1 &&

          isSwiftModule(unboundType->getChild(0))) {

        return SugarType::ImplicitlyUnwrappedOptional;

      }



      return SugarType::None;

    }



    assert(pointer->getKind() == Node::Kind::BoundGenericStructure);



    // Array

    if (isIdentifier(unboundType->getChild(1), ""Array"") &&

        typeArgs->getNumChildren() == 1 &&

        isSwiftModule(unboundType->getChild(0))) {

      return SugarType::Array;

    }



    // Dictionary

    if (isIdentifier(unboundType->getChild(1), ""Dictionary"") &&

        typeArgs->getNumChildren() == 2 &&

        isSwiftModule(unboundType->getChild(0))) {

      return SugarType::Dictionary;

    }



    return SugarType::None;

  }

","  SugarType findSugar(NodePointer pointer) {

    if (pointer->getNumChildren() == 1 && 

        pointer->getKind() == Node::Kind::Type)

      return findSugar(pointer->getChild(0));

    

    if (pointer->getNumChildren() != 2)

      return SugarType::None;

    

    if (pointer->getKind() != Node::Kind::BoundGenericEnum &&

        pointer->getKind() != Node::Kind::BoundGenericStructure)

      return SugarType::None;



    auto unboundType = pointer->getChild(0)->getChild(0); // drill through Type

    auto typeArgs = pointer->getChild(1);

    

    if (pointer->getKind() == Node::Kind::BoundGenericEnum) {

      // Swift.Optional

      if (isIdentifier(unboundType->getChild(1), ""Optional"") &&

          typeArgs->getNumChildren() == 1 &&

          isSwiftModule(unboundType->getChild(0))) {

        return SugarType::Optional;

      }



      // Swift.ImplicitlyUnwrappedOptional

      if (isIdentifier(unboundType->getChild(1), 

                       ""ImplicitlyUnwrappedOptional"") &&

          typeArgs->getNumChildren() == 1 &&

          isSwiftModule(unboundType->getChild(0))) {

        return SugarType::ImplicitlyUnwrappedOptional;

      }



      return SugarType::None;

    }



   ","


    // Array

    if (isIdentifier(unboundType->getChild(1), ""Array"") &&

        typeArgs->getNumChildren() == 1 &&

        isSwiftModule(unboundType->getChild(0))) {

      return SugarType::Array;

    }



    // Dictionary

    if (isIdentifier(unboundType->getChild(1), ""Dictionary"") &&

        typeArgs->getNumChildren() == 2 &&

        isSwiftModule(unboundType->getChild(0))) {

      return SugarType::Dictionary;

    }



    return SugarType::None;

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,void printBoundGeneric(NodePointer pointer) {,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

", ,"
    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printBoundGenericNoSugar(pointer);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

     ","
      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printBoundGenericNoSugar(pointer);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

     ","
      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printBoundGenericNoSugar(pointer);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

     ","
      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(type);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

       ","
        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(type);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

       ","
        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(keyType);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

       ","
        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(valueType);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

       ","
        Printer << ""]"";

        break;

      }

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,void printFunctionType(NodePointer node) {,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

", ,"
    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

","  void printFunctionType(NodePointer node) {

   ","
    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

","  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

     ","
      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(node->getChild(startIndex));,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

","  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

   ","
    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(node->getChild(startIndex+1));,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

","  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

   ","
  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,void printImplFunctionType(NodePointer fn) {,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

", ,"
    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(newState >= curState);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

     ","
      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"case Results: printer_unreachable(""no state after Results"");","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

       ","
        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad state"");","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

       ","
      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(child);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

       ","
      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(child);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

       ","
      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(curState == Attrs);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

       ","
        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(child);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

       ","
      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,void printContext(NodePointer context) {,"  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

", ,"
    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,!isDebuggerGeneratedModule(context)),"  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

","  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

      ","
    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"print(context, /*asContext*/ true);","  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

","  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

     ","
      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""not an entity"");","static bool useColonForEntityType(NodePointer entity, NodePointer type) {

  switch (entity->getKind()) {

  case Node::Kind::Variable:

  case Node::Kind::Initializer:

  case Node::Kind::DefaultArgumentInitializer:

  case Node::Kind::IVarInitializer:

  case Node::Kind::Class:

  case Node::Kind::Structure:

  case Node::Kind::Enum:

  case Node::Kind::Protocol:

  case Node::Kind::TypeAlias:

  case Node::Kind::OwningAddressor:

  case Node::Kind::OwningMutableAddressor:

  case Node::Kind::NativeOwningAddressor:

  case Node::Kind::NativeOwningMutableAddressor:

  case Node::Kind::NativePinningAddressor:

  case Node::Kind::NativePinningMutableAddressor:

  case Node::Kind::UnsafeAddressor:

  case Node::Kind::UnsafeMutableAddressor:

  case Node::Kind::GlobalGetter:

  case Node::Kind::Getter:

  case Node::Kind::Setter:

  case Node::Kind::MaterializeForSet:

  case Node::Kind::WillSet:

  case Node::Kind::DidSet:

    return true;



  case Node::Kind::Subscript:

  case Node::Kind::Function:

  case Node::Kind::ExplicitClosure:

  case Node::Kind::ImplicitClosure:

  case Node::Kind::Allocator:

  case Node::Kind::Constructor:

  case Node::Kind::Destructor:

  case Node::Kind::Deallocator:

  case Node::Kind::IVarDestroyer: {

    // We expect to see a function type here, but if we don't, use the colon.

    type = type->getChild(0);

    while (type->getKind() == Node::Kind::DependentGenericType)

      type = type->getChild(1)->getChild(0);

    return (type->getKind() != Node::Kind::FunctionType &&

            type->getKind() != Node::Kind::UncurriedFunctionType &&

            type->getKind() != Node::Kind::CFunctionPointer &&

            type->getKind() != Node::Kind::ThinFunctionType);

  }



  default:

    printer_unreachable(""not an entity"");

  }

}

","static bool useColonForEntityType(NodePointer entity, NodePointer type) {

  switch (entity->getKind()) {

  case Node::Kind::Variable:

  case Node::Kind::Initializer:

  case Node::Kind::DefaultArgumentInitializer:

  case Node::Kind::IVarInitializer:

  case Node::Kind::Class:

  case Node::Kind::Structure:

  case Node::Kind::Enum:

  case Node::Kind::Protocol:

  case Node::Kind::TypeAlias:

  case Node::Kind::OwningAddressor:

  case Node::Kind::OwningMutableAddressor:

  case Node::Kind::NativeOwningAddressor:

  case Node::Kind::NativeOwningMutableAddressor:

  case Node::Kind::NativePinningAddressor:

  case Node::Kind::NativePinningMutableAddressor:

  case Node::Kind::UnsafeAddressor:

  case Node::Kind::UnsafeMutableAddressor:

  case Node::Kind::GlobalGetter:

  case Node::Kind::Getter:

  case Node::Kind::Setter:

  case Node::Kind::MaterializeForSet:

  case Node::Kind::WillSet:

  case Node::Kind::DidSet:

    return true;



  case Node::Kind::Subscript:

  case Node::Kind::Function:

  case Node::Kind::ExplicitClosure:

  case Node::Kind::ImplicitClosure:

  case Node::Kind::Allocator:

  case Node::Kind::Constructor:

  case Node::Kind::Destructor:

  case Node::Kind::Deallocator:

  case Node::Kind::IVarDestroyer: {

    // We expect to see a function type here, but if we don't, use the colon.

    type = type->getChild(0);

    while (type->getKind() == Node::Kind::DependentGenericType)

      type = type->getChild(1)->getChild(0);

    return (type->getKind() != Node::Kind::FunctionType &&

            type->getKind() != Node::Kind::UncurriedFunctionType &&

            type->getKind() != Node::Kind::CFunctionPointer &&

            type->getKind() != Node::Kind::ThinFunctionType);

  }



  default:

   ","
  }

}

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"snprintf(buffer, sizeof(buffer), ""%llu"", n);","    FindPtr(Node *v) : Target(v) {}

",,"

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",tools/swift-demangle/swift-demangle.cpp,-,swift::demangle_wrappers::NodeDumper(pointer).print(llvm::outs());,"static void demangle(llvm::raw_ostream &os, llvm::StringRef name,

                     swift::Demangle::Context &DCtx,

                     const swift::Demangle::DemangleOptions &options) {

  bool hadLeadingUnderscore = false;

  if (name.startswith(""__"")) {

    hadLeadingUnderscore = true;

    name = name.substr(1);

  }

  swift::Demangle::NodePointer pointer = DCtx.demangleSymbolAsNode(name);

  if (ExpandMode || TreeOnly) {

    llvm::outs() << ""Demangling for "" << name << '\n';

    llvm::outs() << getNodeTreeAsString(pointer);

  }

  if (RemangleMode) {

    std::string remangled;

    if (!pointer) {

      // Just reprint the original mangled name if it didn't demangle.

      // This makes it easier to share the same database between the

      // mangling and demangling tests.

      remangled = name;

    } else {

      // Also accept the future mangling prefix.

      // TODO: remove the ""_S"" as soon as MANGLING_PREFIX_STR gets ""_S"".

      remangled = swift::Demangle::mangleNode(pointer,

                          /*NewMangling*/ name.startswith(MANGLING_PREFIX_STR)

                                          || name.startswith(""_S""));

      if (name.startswith(""_S"")) {

        assert(remangled.find(MANGLING_PREFIX_STR) == 0);

        remangled = ""_S"" + remangled.substr(3);

      }

      if (name != remangled) {

        llvm::errs() << ""\nError: re-mangled name \n  "" << remangled

                     << ""\ndoes not match original name\n  "" << name << '\n';

        exit(1);

      }

    }

    if (hadLeadingUnderscore) llvm::outs() << '_';

    llvm::outs() << remangled;

    return;

  }

  if (!TreeOnly) {

    if (RemangleNew) {

      if (!pointer) {

        llvm::errs() << ""Can't de-mangle "" << name << '\n';

        exit(1);

      }

      std::string remangled = swift::Demangle::mangleNode(pointer);

      llvm::outs() << remangled;

      return;

    }

    std::string string = swift::Demangle::nodeToString(pointer, options);

    if (!CompactMode)

      llvm::outs() << name << "" ---> "";



    if (Classify) {

      std::string Classifications;

      std::string cName = name.str();

      if (!swift::Demangle::isSwiftSymbol(cName.c_str()))

        Classifications += 'N';

      if (DCtx.isThunkSymbol(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += ""T:"";

        Classifications += DCtx.getThunkTarget(name);

      } else {

        assert(DCtx.getThunkTarget(name).empty());

      }

      if (pointer && !DCtx.hasSwiftCallingConvention(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += 'C';

      }

      if (!Classifications.empty())

        llvm::outs() << '{' << Classifications << ""} "";

    }

    llvm::outs() << (string.empty() ? name : llvm::StringRef(string));

  }

  DCtx.clear();

}

","static void demangle(llvm::raw_ostream &os, llvm::StringRef name,

                     swift::Demangle::Context &DCtx,

                     const swift::Demangle::DemangleOptions &options) {

  bool hadLeadingUnderscore = false;

  if (name.startswith(""__"")) {

    hadLeadingUnderscore = true;
","    name = name.substr(1);

  }

  swift::Demangle::NodePointer pointer = DCtx.demangleSymbolAsNode(name);

  if (ExpandMode || TreeOnly) {

    llvm::outs() << ""Demangling for "" << name << '\n';

    llvm::outs() << getNodeTreeAsString(pointer);

  }

  if (RemangleMode) {

    std::string remangled;

    if (!pointer) {

      // Just reprint the original mangled name if it didn't demangle.

      // This makes it easier to share the same database between the

      // mangling and demangling tests.

      remangled = name;

    } else {

      // Also accept the future mangling prefix.

      // TODO: remove the ""_S"" as soon as MANGLING_PREFIX_STR gets ""_S"".

      remangled = swift::Demangle::mangleNode(pointer,

                          /*NewMangling*/ name.startswith(MANGLING_PREFIX_STR)

                                          || name.startswith(""_S""));

      if (name.startswith(""_S"")) {

        assert(remangled.find(MANGLING_PREFIX_STR) == 0);

        remangled = ""_S"" + remangled.substr(3);

      }

      if (name != remangled) {

        llvm::errs() << ""\nError: re-mangled name \n  "" << remangled

                     << ""\ndoes not match original name\n  "" << name << '\n';

        exit(1);

      }

    }

    if (hadLeadingUnderscore) llvm::outs() << '_';

    llvm::outs() << remangled;

    return;

  }

  if (!TreeOnly) {

    if (RemangleNew) {

      if (!pointer) {

        llvm::errs() << ""Can't de-mangle "" << name << '\n';

        exit(1);

      }

      std::string remangled = swift::Demangle::mangleNode(pointer);

      llvm::outs() << remangled;

      return;

    }

    std::string string = swift::Demangle::nodeToString(pointer, options);

    if (!CompactMode)

      llvm::outs() << name << "" ---> "";



    if (Classify) {

      std::string Classifications;

      std::string cName = name.str();

      if (!swift::Demangle::isSwiftSymbol(cName.c_str()))

        Classifications += 'N';

      if (DCtx.isThunkSymbol(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += ""T:"";

        Classifications += DCtx.getThunkTarget(name);

      } else {

        assert(DCtx.getThunkTarget(name).empty());

      }

      if (pointer && !DCtx.hasSwiftCallingConvention(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += 'C';

      }

      if (!Classifications.empty())

        llvm::outs() << '{' << Classifications << ""} "";

    }

    llvm::outs() << (string.empty() ? name : llvm::StringRef(string));

  }

  DCtx.clear();

}


"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/DemangleWrappers.cpp,-,"printNode(Out, child, depth + 1);","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }
","  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}


"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/DemangleWrappers.cpp,-,void NodeDumper::dump() const { print(llvm::errs()); },"static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

","
    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}


"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/DemangleWrappers.cpp,-,void NodeDumper::print(llvm::raw_ostream &Out) const {,"static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {
","    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}


"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/DemangleWrappers.cpp,-,"printNode(Out, Root, 0);","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {
","    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}


"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/DemangleWrappers.cpp,-,"printNode(out, TheNode, 4);","  PrettyStackTraceNode(const char *action, Node *node)

    : Action(action), TheNode(node) {}

","  PrettyStackTraceNode(const char *action, Node *node)
","    : Action(action), TheNode(node) {}


"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodeDumper.cpp,+,"static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {","static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {

  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {

  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}
","
  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodeDumper.cpp,+,"printNode(Out, child, depth + 1);","static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {

  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {

  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

   ","
  }

}

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad directness"");","static StringRef toString(Directness d) {

  switch (d) {

  case Directness::Direct:

    return ""direct"";

  case Directness::Indirect:

    return ""indirect"";

  }

  printer_unreachable(""bad directness"");

}

","static StringRef toString(Directness d) {

  switch (d) {

  case Directness::Direct:

    return ""direct"";

  case Directness::Indirect:

    return ""indirect"";

  }

 ","
}

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,NodePrinter(DemangleOptions options) : Options(options) {},"  NodePrinter(DemangleOptions options) : Options(options) {}

", ,"
"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,std::string printRoot(NodePointer root) {,"  std::string printRoot(NodePointer root) {

    print(root);

    return std::move(Printer).str();

  }

", ,"
    print(root);

    return std::move(Printer).str();

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(root);,"  std::string printRoot(NodePointer root) {

    print(root);

    return std::move(Printer).str();

  }

","  std::string printRoot(NodePointer root) {

   ","
    return std::move(Printer).str();

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"void printChildren(Node::iterator begin,","  void printChildren(Node::iterator begin,

                     Node::iterator end,

                     const char *sep = nullptr) {

    for (; begin != end;) {

      print(*begin);

      ++begin;

      if (sep && begin != end)

        Printer << sep;

    }

  }

", ,"
                     Node::iterator end,

                     const char *sep = nullptr) {

    for (; begin != end;) {

      print(*begin);

      ++begin;

      if (sep && begin != end)

        Printer << sep;

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(*begin);,"  void printChildren(Node::iterator begin,

                     Node::iterator end,

                     const char *sep = nullptr) {

    for (; begin != end;) {

      print(*begin);

      ++begin;

      if (sep && begin != end)

        Printer << sep;

    }

  }

","  void printChildren(Node::iterator begin,

                     Node::iterator end,

                     const char *sep = nullptr) {

    for (; begin != end;) {

     ","
      ++begin;

      if (sep && begin != end)

        Printer << sep;

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,void printBoundGenericNoSugar(NodePointer pointer) {,"  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

", ,"
    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,"  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

","  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

   ","
    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printChildren(typelist, "", "");","  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

","  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

   ","
    Printer << "">"";

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,static bool isDebuggerGeneratedModule(NodePointer node) {,"  static bool isDebuggerGeneratedModule(NodePointer node) {

      return (node->getKind() == Node::Kind::Module &&

              node->getText().startswith(LLDB_EXPRESSIONS_MODULE_NAME_PREFIX));

    }

", ,"
      return (node->getKind() == Node::Kind::Module &&

              node->getText().startswith(LLDB_EXPRESSIONS_MODULE_NAME_PREFIX));

    }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad node kind"");","  bool isSimpleType(NodePointer pointer) {

    switch (pointer->getKind()) {

    case Node::Kind::AssociatedType:

    case Node::Kind::AssociatedTypeRef:

    case Node::Kind::BoundGenericClass:

    case Node::Kind::BoundGenericEnum:

    case Node::Kind::BoundGenericStructure:

    case Node::Kind::BuiltinTypeName:

    case Node::Kind::Class:

    case Node::Kind::DependentGenericType:

    case Node::Kind::DependentMemberType:

    case Node::Kind::DependentGenericParamType:

    case Node::Kind::DynamicSelf:

    case Node::Kind::Enum:

    case Node::Kind::ErrorType:

    case Node::Kind::ExistentialMetatype:

    case Node::Kind::Metatype:

    case Node::Kind::MetatypeRepresentation:

    case Node::Kind::Module:

    case Node::Kind::NonVariadicTuple:

    case Node::Kind::Protocol:

    case Node::Kind::QualifiedArchetype:

    case Node::Kind::ReturnType:

    case Node::Kind::SILBoxType:

    case Node::Kind::SILBoxTypeWithLayout:

    case Node::Kind::Structure:

    case Node::Kind::TupleElementName:

    case Node::Kind::Type:

    case Node::Kind::TypeAlias:

    case Node::Kind::TypeList:

    case Node::Kind::VariadicTuple:

      return true;



    case Node::Kind::ProtocolList:

      if (pointer->getChild(0)->getNumChildren() <= 1)

        return true;

      return false;



    case Node::Kind::Allocator:

    case Node::Kind::ArgumentTuple:

    case Node::Kind::AssociatedTypeMetadataAccessor:

    case Node::Kind::AssociatedTypeWitnessTableAccessor:

    case Node::Kind::AutoClosureType:

    case Node::Kind::CFunctionPointer:

    case Node::Kind::Constructor:

    case Node::Kind::CurryThunk:

    case Node::Kind::Deallocator:

    case Node::Kind::DeclContext:

    case Node::Kind::DefaultArgumentInitializer:

    case Node::Kind::DependentAssociatedTypeRef:

    case Node::Kind::DependentGenericSignature:

    case Node::Kind::DependentGenericParamCount:

    case Node::Kind::DependentGenericConformanceRequirement:

    case Node::Kind::DependentGenericLayoutRequirement:

    case Node::Kind::DependentGenericSameTypeRequirement:

    case Node::Kind::DependentPseudogenericSignature:

    case Node::Kind::Destructor:

    case Node::Kind::DidSet:

    case Node::Kind::DirectMethodReferenceAttribute:

    case Node::Kind::Directness:

    case Node::Kind::DynamicAttribute:

    case Node::Kind::ExplicitClosure:

    case Node::Kind::Extension:

    case Node::Kind::FieldOffset:

    case Node::Kind::FullTypeMetadata:

    case Node::Kind::Function:

    case Node::Kind::FunctionSignatureSpecialization:

    case Node::Kind::FunctionSignatureSpecializationParam:

    case Node::Kind::FunctionSignatureSpecializationParamKind:

    case Node::Kind::FunctionSignatureSpecializationParamPayload:

    case Node::Kind::FunctionType:

    case Node::Kind::GenericProtocolWitnessTable:

    case Node::Kind::GenericProtocolWitnessTableInstantiationFunction:

    case Node::Kind::GenericPartialSpecialization:

    case Node::Kind::GenericPartialSpecializationNotReAbstracted:

    case Node::Kind::GenericSpecialization:

    case Node::Kind::GenericSpecializationNotReAbstracted:

    case Node::Kind::GenericSpecializationParam:

    case Node::Kind::GenericTypeMetadataPattern:

    case Node::Kind::Getter:

    case Node::Kind::Global:

    case Node::Kind::GlobalGetter:

    case Node::Kind::Identifier:

    case Node::Kind::Index:

    case Node::Kind::IVarInitializer:

    case Node::Kind::IVarDestroyer:

    case Node::Kind::ImplConvention:

    case Node::Kind::ImplFunctionAttribute:

    case Node::Kind::ImplFunctionType:

    case Node::Kind::ImplicitClosure:

    case Node::Kind::ImplParameter:

    case Node::Kind::ImplResult:

    case Node::Kind::ImplErrorResult:

    case Node::Kind::InOut:

    case Node::Kind::InfixOperator:

    case Node::Kind::Initializer:

    case Node::Kind::LazyProtocolWitnessTableAccessor:

    case Node::Kind::LazyProtocolWitnessTableCacheVariable:

    case Node::Kind::LocalDeclName:

    case Node::Kind::PrivateDeclName:

    case Node::Kind::MaterializeForSet:

    case Node::Kind::Metaclass:

    case Node::Kind::NativeOwningAddressor:

    case Node::Kind::NativeOwningMutableAddressor:

    case Node::Kind::NativePinningAddressor:

    case Node::Kind::NativePinningMutableAddressor:

    case Node::Kind::NominalTypeDescriptor:

    case Node::Kind::NonObjCAttribute:

    case Node::Kind::Number:

    case Node::Kind::ObjCAttribute:

    case Node::Kind::ObjCBlock:

    case Node::Kind::OwningAddressor:

    case Node::Kind::OwningMutableAddressor:

    case Node::Kind::PartialApplyForwarder:

    case Node::Kind::PartialApplyObjCForwarder:

    case Node::Kind::PostfixOperator:

    case Node::Kind::PrefixOperator:

    case Node::Kind::ProtocolConformance:

    case Node::Kind::ProtocolDescriptor:

    case Node::Kind::ProtocolWitness:

    case Node::Kind::ProtocolWitnessTable:

    case Node::Kind::ProtocolWitnessTableAccessor:

    case Node::Kind::ReabstractionThunk:

    case Node::Kind::ReabstractionThunkHelper:

    case Node::Kind::Setter:

    case Node::Kind::SILBoxLayout:

    case Node::Kind::SILBoxMutableField:

    case Node::Kind::SILBoxImmutableField:

    case Node::Kind::SpecializationIsFragile:

    case Node::Kind::SpecializationPassID:

    case Node::Kind::Static:

    case Node::Kind::Subscript:

    case Node::Kind::Suffix:

    case Node::Kind::ThinFunctionType:

    case Node::Kind::TupleElement:

    case Node::Kind::TypeMangling:

    case Node::Kind::TypeMetadata:

    case Node::Kind::TypeMetadataAccessFunction:

    case Node::Kind::TypeMetadataLazyCache:

    case Node::Kind::UncurriedFunctionType:

    case Node::Kind::Unmanaged:

    case Node::Kind::Unowned:

    case Node::Kind::UnsafeAddressor:

    case Node::Kind::UnsafeMutableAddressor:

    case Node::Kind::ValueWitness:

    case Node::Kind::ValueWitnessTable:

    case Node::Kind::Variable:

    case Node::Kind::VTableAttribute:

    case Node::Kind::Weak:

    case Node::Kind::WillSet:

    case Node::Kind::WitnessTableOffset:

    case Node::Kind::ReflectionMetadataBuiltinDescriptor:

    case Node::Kind::ReflectionMetadataFieldDescriptor:

    case Node::Kind::ReflectionMetadataAssocTypeDescriptor:

    case Node::Kind::ReflectionMetadataSuperclassDescriptor:

    case Node::Kind::GenericTypeParamDecl:

    case Node::Kind::ThrowsAnnotation:

    case Node::Kind::EmptyList:

    case Node::Kind::FirstElementMarker:

    case Node::Kind::VariadicMarker:

    case Node::Kind::OutlinedCopy:

    case Node::Kind::OutlinedConsume:

      return false;

    }

    printer_unreachable(""bad node kind"");

  }

","  bool isSimpleType(NodePointer pointer) {

    switch (pointer->getKind()) {

    case Node::Kind::AssociatedType:

    case Node::Kind::AssociatedTypeRef:

    case Node::Kind::BoundGenericClass:

    case Node::Kind::BoundGenericEnum:

    case Node::Kind::BoundGenericStructure:

    case Node::Kind::BuiltinTypeName:

    case Node::Kind::Class:

    case Node::Kind::DependentGenericType:

    case Node::Kind::DependentMemberType:

    case Node::Kind::DependentGenericParamType:

    case Node::Kind::DynamicSelf:

    case Node::Kind::Enum:

    case Node::Kind::ErrorType:

    case Node::Kind::ExistentialMetatype:

    case Node::Kind::Metatype:

    case Node::Kind::MetatypeRepresentation:

    case Node::Kind::Module:

    case Node::Kind::NonVariadicTuple:

    case Node::Kind::Protocol:

    case Node::Kind::QualifiedArchetype:

    case Node::Kind::ReturnType:

    case Node::Kind::SILBoxType:

    case Node::Kind::SILBoxTypeWithLayout:

    case Node::Kind::Structure:

    case Node::Kind::TupleElementName:

    case Node::Kind::Type:

    case Node::Kind::TypeAlias:

    case Node::Kind::TypeList:

    case Node::Kind::VariadicTuple:

      return true;



    case Node::Kind::ProtocolList:

      if (pointer->getChild(0)->getNumChildren() <= 1)

        return true;

      return false;



    case Node::Kind::Allocator:

    case Node::Kind::ArgumentTuple:

    case Node::Kind::AssociatedTypeMetadataAccessor:

    case Node::Kind::AssociatedTypeWitnessTableAccessor:

    case Node::Kind::AutoClosureType:

    case Node::Kind::CFunctionPointer:

    case Node::Kind::Constructor:

    case Node::Kind::CurryThunk:

    case Node::Kind::Deallocator:

    case Node::Kind::DeclContext:

    case Node::Kind::DefaultArgumentInitializer:

    case Node::Kind::DependentAssociatedTypeRef:

    case Node::Kind::DependentGenericSignature:

    case Node::Kind::DependentGenericParamCount:

    case Node::Kind::DependentGenericConformanceRequirement:

    case Node::Kind::DependentGenericLayoutRequirement:

    case Node::Kind::DependentGenericSameTypeRequirement:

    case Node::Kind::DependentPseudogenericSignature:

    case Node::Kind::Destructor:

    case Node::Kind::DidSet:

    case Node::Kind::DirectMethodReferenceAttribute:

    case Node::Kind::Directness:

    case Node::Kind::DynamicAttribute:

    case Node::Kind::ExplicitClosure:

    case Node::Kind::Extension:

    case Node::Kind::FieldOffset:

    case Node::Kind::FullTypeMetadata:

    case Node::Kind::Function:

    case Node::Kind::FunctionSignatureSpecialization:

    case Node::Kind::FunctionSignatureSpecializationParam:

    case Node::Kind::FunctionSignatureSpecializationParamKind:

    case Node::Kind::FunctionSignatureSpecializationParamPayload:

    case Node::Kind::FunctionType:

    case Node::Kind::GenericProtocolWitnessTable:

    case Node::Kind::GenericProtocolWitnessTableInstantiationFunction:

    case Node::Kind::GenericPartialSpecialization:

    case Node::Kind::GenericPartialSpecializationNotReAbstracted:

    case Node::Kind::GenericSpecialization:

    case Node::Kind::GenericSpecializationNotReAbstracted:

    case Node::Kind::GenericSpecializationParam:

    case Node::Kind::GenericTypeMetadataPattern:

    case Node::Kind::Getter:

    case Node::Kind::Global:

    case Node::Kind::GlobalGetter:

    case Node::Kind::Identifier:

    case Node::Kind::Index:

    case Node::Kind::IVarInitializer:

    case Node::Kind::IVarDestroyer:

    case Node::Kind::ImplConvention:

    case Node::Kind::ImplFunctionAttribute:

    case Node::Kind::ImplFunctionType:

    case Node::Kind::ImplicitClosure:

    case Node::Kind::ImplParameter:

    case Node::Kind::ImplResult:

    case Node::Kind::ImplErrorResult:

    case Node::Kind::InOut:

    case Node::Kind::InfixOperator:

    case Node::Kind::Initializer:

    case Node::Kind::LazyProtocolWitnessTableAccessor:

    case Node::Kind::LazyProtocolWitnessTableCacheVariable:

    case Node::Kind::LocalDeclName:

    case Node::Kind::PrivateDeclName:

    case Node::Kind::MaterializeForSet:

    case Node::Kind::Metaclass:

    case Node::Kind::NativeOwningAddressor:

    case Node::Kind::NativeOwningMutableAddressor:

    case Node::Kind::NativePinningAddressor:

    case Node::Kind::NativePinningMutableAddressor:

    case Node::Kind::NominalTypeDescriptor:

    case Node::Kind::NonObjCAttribute:

    case Node::Kind::Number:

    case Node::Kind::ObjCAttribute:

    case Node::Kind::ObjCBlock:

    case Node::Kind::OwningAddressor:

    case Node::Kind::OwningMutableAddressor:

    case Node::Kind::PartialApplyForwarder:

    case Node::Kind::PartialApplyObjCForwarder:

    case Node::Kind::PostfixOperator:

    case Node::Kind::PrefixOperator:

    case Node::Kind::ProtocolConformance:

    case Node::Kind::ProtocolDescriptor:

    case Node::Kind::ProtocolWitness:

    case Node::Kind::ProtocolWitnessTable:

    case Node::Kind::ProtocolWitnessTableAccessor:

    case Node::Kind::ReabstractionThunk:

    case Node::Kind::ReabstractionThunkHelper:

    case Node::Kind::Setter:

    case Node::Kind::SILBoxLayout:

    case Node::Kind::SILBoxMutableField:

    case Node::Kind::SILBoxImmutableField:

    case Node::Kind::SpecializationIsFragile:

    case Node::Kind::SpecializationPassID:

    case Node::Kind::Static:

    case Node::Kind::Subscript:

    case Node::Kind::Suffix:

    case Node::Kind::ThinFunctionType:

    case Node::Kind::TupleElement:

    case Node::Kind::TypeMangling:

    case Node::Kind::TypeMetadata:

    case Node::Kind::TypeMetadataAccessFunction:

    case Node::Kind::TypeMetadataLazyCache:

    case Node::Kind::UncurriedFunctionType:

    case Node::Kind::Unmanaged:

    case Node::Kind::Unowned:

    case Node::Kind::UnsafeAddressor:

    case Node::Kind::UnsafeMutableAddressor:

    case Node::Kind::ValueWitness:

    case Node::Kind::ValueWitnessTable:

    case Node::Kind::Variable:

    case Node::Kind::VTableAttribute:

    case Node::Kind::Weak:

    case Node::Kind::WillSet:

    case Node::Kind::WitnessTableOffset:

    case Node::Kind::ReflectionMetadataBuiltinDescriptor:

    case Node::Kind::ReflectionMetadataFieldDescriptor:

    case Node::Kind::ReflectionMetadataAssocTypeDescriptor:

    case Node::Kind::ReflectionMetadataSuperclassDescriptor:

    case Node::Kind::GenericTypeParamDecl:

    case Node::Kind::ThrowsAnnotation:

    case Node::Kind::EmptyList:

    case Node::Kind::FirstElementMarker:

    case Node::Kind::VariadicMarker:

    case Node::Kind::OutlinedCopy:

    case Node::Kind::OutlinedConsume:

      return false;

    }

   ","
  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(pointer->getKind() == Node::Kind::BoundGenericStructure);,"  SugarType findSugar(NodePointer pointer) {

    if (pointer->getNumChildren() == 1 && 

        pointer->getKind() == Node::Kind::Type)

      return findSugar(pointer->getChild(0));

    

    if (pointer->getNumChildren() != 2)

      return SugarType::None;

    

    if (pointer->getKind() != Node::Kind::BoundGenericEnum &&

        pointer->getKind() != Node::Kind::BoundGenericStructure)

      return SugarType::None;



    auto unboundType = pointer->getChild(0)->getChild(0); // drill through Type

    auto typeArgs = pointer->getChild(1);

    

    if (pointer->getKind() == Node::Kind::BoundGenericEnum) {

      // Swift.Optional

      if (isIdentifier(unboundType->getChild(1), ""Optional"") &&

          typeArgs->getNumChildren() == 1 &&

          isSwiftModule(unboundType->getChild(0))) {

        return SugarType::Optional;

      }



      // Swift.ImplicitlyUnwrappedOptional

      if (isIdentifier(unboundType->getChild(1), 

                       ""ImplicitlyUnwrappedOptional"") &&

          typeArgs->getNumChildren() == 1 &&

          isSwiftModule(unboundType->getChild(0))) {

        return SugarType::ImplicitlyUnwrappedOptional;

      }



      return SugarType::None;

    }



    assert(pointer->getKind() == Node::Kind::BoundGenericStructure);



    // Array

    if (isIdentifier(unboundType->getChild(1), ""Array"") &&

        typeArgs->getNumChildren() == 1 &&

        isSwiftModule(unboundType->getChild(0))) {

      return SugarType::Array;

    }



    // Dictionary

    if (isIdentifier(unboundType->getChild(1), ""Dictionary"") &&

        typeArgs->getNumChildren() == 2 &&

        isSwiftModule(unboundType->getChild(0))) {

      return SugarType::Dictionary;

    }



    return SugarType::None;

  }

","  SugarType findSugar(NodePointer pointer) {

    if (pointer->getNumChildren() == 1 && 

        pointer->getKind() == Node::Kind::Type)

      return findSugar(pointer->getChild(0));

    

    if (pointer->getNumChildren() != 2)

      return SugarType::None;

    

    if (pointer->getKind() != Node::Kind::BoundGenericEnum &&

        pointer->getKind() != Node::Kind::BoundGenericStructure)

      return SugarType::None;



    auto unboundType = pointer->getChild(0)->getChild(0); // drill through Type

    auto typeArgs = pointer->getChild(1);

    

    if (pointer->getKind() == Node::Kind::BoundGenericEnum) {

      // Swift.Optional

      if (isIdentifier(unboundType->getChild(1), ""Optional"") &&

          typeArgs->getNumChildren() == 1 &&

          isSwiftModule(unboundType->getChild(0))) {

        return SugarType::Optional;

      }



      // Swift.ImplicitlyUnwrappedOptional

      if (isIdentifier(unboundType->getChild(1), 

                       ""ImplicitlyUnwrappedOptional"") &&

          typeArgs->getNumChildren() == 1 &&

          isSwiftModule(unboundType->getChild(0))) {

        return SugarType::ImplicitlyUnwrappedOptional;

      }



      return SugarType::None;

    }



   ","


    // Array

    if (isIdentifier(unboundType->getChild(1), ""Array"") &&

        typeArgs->getNumChildren() == 1 &&

        isSwiftModule(unboundType->getChild(0))) {

      return SugarType::Array;

    }



    // Dictionary

    if (isIdentifier(unboundType->getChild(1), ""Dictionary"") &&

        typeArgs->getNumChildren() == 2 &&

        isSwiftModule(unboundType->getChild(0))) {

      return SugarType::Dictionary;

    }



    return SugarType::None;

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,void printBoundGeneric(NodePointer pointer) {,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

", ,"
    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printBoundGenericNoSugar(pointer);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

     ","
      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printBoundGenericNoSugar(pointer);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

     ","
      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printBoundGenericNoSugar(pointer);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

     ","
      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(type);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

       ","
        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(type);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

       ","
        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(keyType);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

       ","
        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(valueType);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

       ","
        Printer << ""]"";

        break;

      }

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,void printFunctionType(NodePointer node) {,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

", ,"
    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

","  void printFunctionType(NodePointer node) {

   ","
    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

","  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

     ","
      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(node->getChild(startIndex));,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

","  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

   ","
    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(node->getChild(startIndex+1));,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

","  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

   ","
  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,void printImplFunctionType(NodePointer fn) {,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

", ,"
    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(newState >= curState);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

     ","
      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"case Results: printer_unreachable(""no state after Results"");","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

       ","
        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad state"");","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

       ","
      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(child);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

       ","
      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(child);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

       ","
      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(curState == Attrs);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

       ","
        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(child);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

       ","
      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,void printContext(NodePointer context) {,"  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

", ,"
    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,!isDebuggerGeneratedModule(context)),"  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

","  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

      ","
    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"print(context, /*asContext*/ true);","  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

","  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

     ","
      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""not an entity"");","static bool useColonForEntityType(NodePointer entity, NodePointer type) {

  switch (entity->getKind()) {

  case Node::Kind::Variable:

  case Node::Kind::Initializer:

  case Node::Kind::DefaultArgumentInitializer:

  case Node::Kind::IVarInitializer:

  case Node::Kind::Class:

  case Node::Kind::Structure:

  case Node::Kind::Enum:

  case Node::Kind::Protocol:

  case Node::Kind::TypeAlias:

  case Node::Kind::OwningAddressor:

  case Node::Kind::OwningMutableAddressor:

  case Node::Kind::NativeOwningAddressor:

  case Node::Kind::NativeOwningMutableAddressor:

  case Node::Kind::NativePinningAddressor:

  case Node::Kind::NativePinningMutableAddressor:

  case Node::Kind::UnsafeAddressor:

  case Node::Kind::UnsafeMutableAddressor:

  case Node::Kind::GlobalGetter:

  case Node::Kind::Getter:

  case Node::Kind::Setter:

  case Node::Kind::MaterializeForSet:

  case Node::Kind::WillSet:

  case Node::Kind::DidSet:

    return true;



  case Node::Kind::Subscript:

  case Node::Kind::Function:

  case Node::Kind::ExplicitClosure:

  case Node::Kind::ImplicitClosure:

  case Node::Kind::Allocator:

  case Node::Kind::Constructor:

  case Node::Kind::Destructor:

  case Node::Kind::Deallocator:

  case Node::Kind::IVarDestroyer: {

    // We expect to see a function type here, but if we don't, use the colon.

    type = type->getChild(0);

    while (type->getKind() == Node::Kind::DependentGenericType)

      type = type->getChild(1)->getChild(0);

    return (type->getKind() != Node::Kind::FunctionType &&

            type->getKind() != Node::Kind::UncurriedFunctionType &&

            type->getKind() != Node::Kind::CFunctionPointer &&

            type->getKind() != Node::Kind::ThinFunctionType);

  }



  default:

    printer_unreachable(""not an entity"");

  }

}

","static bool useColonForEntityType(NodePointer entity, NodePointer type) {

  switch (entity->getKind()) {

  case Node::Kind::Variable:

  case Node::Kind::Initializer:

  case Node::Kind::DefaultArgumentInitializer:

  case Node::Kind::IVarInitializer:

  case Node::Kind::Class:

  case Node::Kind::Structure:

  case Node::Kind::Enum:

  case Node::Kind::Protocol:

  case Node::Kind::TypeAlias:

  case Node::Kind::OwningAddressor:

  case Node::Kind::OwningMutableAddressor:

  case Node::Kind::NativeOwningAddressor:

  case Node::Kind::NativeOwningMutableAddressor:

  case Node::Kind::NativePinningAddressor:

  case Node::Kind::NativePinningMutableAddressor:

  case Node::Kind::UnsafeAddressor:

  case Node::Kind::UnsafeMutableAddressor:

  case Node::Kind::GlobalGetter:

  case Node::Kind::Getter:

  case Node::Kind::Setter:

  case Node::Kind::MaterializeForSet:

  case Node::Kind::WillSet:

  case Node::Kind::DidSet:

    return true;



  case Node::Kind::Subscript:

  case Node::Kind::Function:

  case Node::Kind::ExplicitClosure:

  case Node::Kind::ImplicitClosure:

  case Node::Kind::Allocator:

  case Node::Kind::Constructor:

  case Node::Kind::Destructor:

  case Node::Kind::Deallocator:

  case Node::Kind::IVarDestroyer: {

    // We expect to see a function type here, but if we don't, use the colon.

    type = type->getChild(0);

    while (type->getKind() == Node::Kind::DependentGenericType)

      type = type->getChild(1)->getChild(0);

    return (type->getKind() != Node::Kind::FunctionType &&

            type->getKind() != Node::Kind::UncurriedFunctionType &&

            type->getKind() != Node::Kind::CFunctionPointer &&

            type->getKind() != Node::Kind::ThinFunctionType);

  }



  default:

   ","
  }

}

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"snprintf(buffer, sizeof(buffer), ""%llu"", n);","    FindPtr(Node *v) : Target(v) {}

",,"

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",tools/swift-demangle/swift-demangle.cpp,-,swift::demangle_wrappers::NodeDumper(pointer).print(llvm::outs());,"static void demangle(llvm::raw_ostream &os, llvm::StringRef name,

                     swift::Demangle::Context &DCtx,

                     const swift::Demangle::DemangleOptions &options) {

  bool hadLeadingUnderscore = false;

  if (name.startswith(""__"")) {

    hadLeadingUnderscore = true;

    name = name.substr(1);

  }

  swift::Demangle::NodePointer pointer = DCtx.demangleSymbolAsNode(name);

  if (ExpandMode || TreeOnly) {

    llvm::outs() << ""Demangling for "" << name << '\n';

    llvm::outs() << getNodeTreeAsString(pointer);

  }

  if (RemangleMode) {

    std::string remangled;

    if (!pointer) {

      // Just reprint the original mangled name if it didn't demangle.

      // This makes it easier to share the same database between the

      // mangling and demangling tests.

      remangled = name;

    } else {

      // Also accept the future mangling prefix.

      // TODO: remove the ""_S"" as soon as MANGLING_PREFIX_STR gets ""_S"".

      remangled = swift::Demangle::mangleNode(pointer,

                          /*NewMangling*/ name.startswith(MANGLING_PREFIX_STR)

                                          || name.startswith(""_S""));

      if (name.startswith(""_S"")) {

        assert(remangled.find(MANGLING_PREFIX_STR) == 0);

        remangled = ""_S"" + remangled.substr(3);

      }

      if (name != remangled) {

        llvm::errs() << ""\nError: re-mangled name \n  "" << remangled

                     << ""\ndoes not match original name\n  "" << name << '\n';

        exit(1);

      }

    }

    if (hadLeadingUnderscore) llvm::outs() << '_';

    llvm::outs() << remangled;

    return;

  }

  if (!TreeOnly) {

    if (RemangleNew) {

      if (!pointer) {

        llvm::errs() << ""Can't de-mangle "" << name << '\n';

        exit(1);

      }

      std::string remangled = swift::Demangle::mangleNode(pointer);

      llvm::outs() << remangled;

      return;

    }

    std::string string = swift::Demangle::nodeToString(pointer, options);

    if (!CompactMode)

      llvm::outs() << name << "" ---> "";



    if (Classify) {

      std::string Classifications;

      std::string cName = name.str();

      if (!swift::Demangle::isSwiftSymbol(cName.c_str()))

        Classifications += 'N';

      if (DCtx.isThunkSymbol(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += ""T:"";

        Classifications += DCtx.getThunkTarget(name);

      } else {

        assert(DCtx.getThunkTarget(name).empty());

      }

      if (pointer && !DCtx.hasSwiftCallingConvention(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += 'C';

      }

      if (!Classifications.empty())

        llvm::outs() << '{' << Classifications << ""} "";

    }

    llvm::outs() << (string.empty() ? name : llvm::StringRef(string));

  }

  DCtx.clear();

}

","static void demangle(llvm::raw_ostream &os, llvm::StringRef name,

                     swift::Demangle::Context &DCtx,

                     const swift::Demangle::DemangleOptions &options) {

  bool hadLeadingUnderscore = false;

  if (name.startswith(""__"")) {

    hadLeadingUnderscore = true;
","    name = name.substr(1);

  }

  swift::Demangle::NodePointer pointer = DCtx.demangleSymbolAsNode(name);

  if (ExpandMode || TreeOnly) {

    llvm::outs() << ""Demangling for "" << name << '\n';

    llvm::outs() << getNodeTreeAsString(pointer);

  }

  if (RemangleMode) {

    std::string remangled;

    if (!pointer) {

      // Just reprint the original mangled name if it didn't demangle.

      // This makes it easier to share the same database between the

      // mangling and demangling tests.

      remangled = name;

    } else {

      // Also accept the future mangling prefix.

      // TODO: remove the ""_S"" as soon as MANGLING_PREFIX_STR gets ""_S"".

      remangled = swift::Demangle::mangleNode(pointer,

                          /*NewMangling*/ name.startswith(MANGLING_PREFIX_STR)

                                          || name.startswith(""_S""));

      if (name.startswith(""_S"")) {

        assert(remangled.find(MANGLING_PREFIX_STR) == 0);

        remangled = ""_S"" + remangled.substr(3);

      }

      if (name != remangled) {

        llvm::errs() << ""\nError: re-mangled name \n  "" << remangled

                     << ""\ndoes not match original name\n  "" << name << '\n';

        exit(1);

      }

    }

    if (hadLeadingUnderscore) llvm::outs() << '_';

    llvm::outs() << remangled;

    return;

  }

  if (!TreeOnly) {

    if (RemangleNew) {

      if (!pointer) {

        llvm::errs() << ""Can't de-mangle "" << name << '\n';

        exit(1);

      }

      std::string remangled = swift::Demangle::mangleNode(pointer);

      llvm::outs() << remangled;

      return;

    }

    std::string string = swift::Demangle::nodeToString(pointer, options);

    if (!CompactMode)

      llvm::outs() << name << "" ---> "";



    if (Classify) {

      std::string Classifications;

      std::string cName = name.str();

      if (!swift::Demangle::isSwiftSymbol(cName.c_str()))

        Classifications += 'N';

      if (DCtx.isThunkSymbol(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += ""T:"";

        Classifications += DCtx.getThunkTarget(name);

      } else {

        assert(DCtx.getThunkTarget(name).empty());

      }

      if (pointer && !DCtx.hasSwiftCallingConvention(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += 'C';

      }

      if (!Classifications.empty())

        llvm::outs() << '{' << Classifications << ""} "";

    }

    llvm::outs() << (string.empty() ? name : llvm::StringRef(string));

  }

  DCtx.clear();

}


"
"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/SILGen/SILGenDynamicCast.cpp,-,assert(fnGenericParams.size() == fromSubsts.size() + toSubsts.size() &&,"static ManagedValue

adjustForConditionalCheckedCastOperand(SILLocation loc, ManagedValue src,

                                       CanType sourceType, CanType targetType,

                                       SILGenFunction &SGF) {

  // Reabstract to the most general abstraction, and put it into a

  // temporary if necessary.

  

  // Figure out if we need the value to be in a temporary.

  bool requiresAddress =

    !canUseScalarCheckedCastInstructions(SGF.SGM.M, sourceType, targetType);

  

  AbstractionPattern abstraction = SGF.SGM.M.Types.getMostGeneralAbstraction();

  auto &srcAbstractTL = SGF.getTypeLowering(abstraction, sourceType);

  

  bool hasAbstraction = (src.getType() != srcAbstractTL.getLoweredType());

  

  // Fast path: no re-abstraction required.

  if (!hasAbstraction &&

      (!requiresAddress ||

       (src.getType().isAddress() || !SGF.silConv.useLoweredAddresses()))) {

    return src;

  }

  

  std::unique_ptr<TemporaryInitialization> init;

  if (requiresAddress) {

    init = SGF.emitTemporary(loc, srcAbstractTL);



    if (hasAbstraction)

      src = SGF.emitSubstToOrigValue(loc, src, abstraction, sourceType);



    // Okay, if all we need to do is drop the value in an address,

    // this is easy.

    SGF.B.emitStoreValueOperation(loc, src.forward(SGF), init->getAddress(),

                                  StoreOwnershipQualifier::Init);

    init->finishInitialization(SGF);

    return init->getManagedAddress();

  }

  

  assert(hasAbstraction);

  assert(src.getType().isObject() &&

         ""address-only type with abstraction difference?"");

  

  // Produce the value at +1.

  return SGF.emitSubstToOrigValue(loc, src, abstraction, sourceType);

}

","static ManagedValue

adjustForConditionalCheckedCastOperand(SILLocation loc, ManagedValue src,

                                       CanType sourceType, CanType targetType,

                                       SILGenFunction &SGF) {

  // Reabstract to the most general abstraction, and put it into a

  // temporary if necessary.
","  

  // Figure out if we need the value to be in a temporary.

  bool requiresAddress =

    !canUseScalarCheckedCastInstructions(SGF.SGM.M, sourceType, targetType);

  

  AbstractionPattern abstraction = SGF.SGM.M.Types.getMostGeneralAbstraction();

  auto &srcAbstractTL = SGF.getTypeLowering(abstraction, sourceType);

  

  bool hasAbstraction = (src.getType() != srcAbstractTL.getLoweredType());

  

  // Fast path: no re-abstraction required.

  if (!hasAbstraction &&

      (!requiresAddress ||

       (src.getType().isAddress() || !SGF.silConv.useLoweredAddresses()))) {

    return src;

  }

  

  std::unique_ptr<TemporaryInitialization> init;

  if (requiresAddress) {

    init = SGF.emitTemporary(loc, srcAbstractTL);



    if (hasAbstraction)

      src = SGF.emitSubstToOrigValue(loc, src, abstraction, sourceType);



    // Okay, if all we need to do is drop the value in an address,

    // this is easy.

    SGF.B.emitStoreValueOperation(loc, src.forward(SGF), init->getAddress(),

                                  StoreOwnershipQualifier::Init);

    init->finishInitialization(SGF);

    return init->getManagedAddress();

  }

  

  assert(hasAbstraction);

  assert(src.getType().isObject() &&

         ""address-only type with abstraction difference?"");

  

  // Produce the value at +1.

  return SGF.emitSubstToOrigValue(loc, src, abstraction, sourceType);

}


"
"SILGen: Clean up ad-hoc SubstitutionList construction when calling intrinsics

Change emitApplyOfLibraryIntrinsic() to take a SubstitutionMap,
and use the correct abstractions to build the map.

This gets rid of the last remaining uses of gatherAllSubstitutions()
in SIL.",lib/SILGen/SILGenDynamicCast.cpp,-,assert(fnGenericParams.size() == fromSubsts.size() + toSubsts.size() &&,"static ManagedValue

adjustForConditionalCheckedCastOperand(SILLocation loc, ManagedValue src,

                                       CanType sourceType, CanType targetType,

                                       SILGenFunction &SGF) {

  // Reabstract to the most general abstraction, and put it into a

  // temporary if necessary.

  

  // Figure out if we need the value to be in a temporary.

  bool requiresAddress =

    !canUseScalarCheckedCastInstructions(SGF.SGM.M, sourceType, targetType);

  

  AbstractionPattern abstraction = SGF.SGM.M.Types.getMostGeneralAbstraction();

  auto &srcAbstractTL = SGF.getTypeLowering(abstraction, sourceType);

  

  bool hasAbstraction = (src.getType() != srcAbstractTL.getLoweredType());

  

  // Fast path: no re-abstraction required.

  if (!hasAbstraction &&

      (!requiresAddress ||

       (src.getType().isAddress() || !SGF.silConv.useLoweredAddresses()))) {

    return src;

  }

  

  std::unique_ptr<TemporaryInitialization> init;

  if (requiresAddress) {

    init = SGF.emitTemporary(loc, srcAbstractTL);



    if (hasAbstraction)

      src = SGF.emitSubstToOrigValue(loc, src, abstraction, sourceType);



    // Okay, if all we need to do is drop the value in an address,

    // this is easy.

    SGF.B.emitStoreValueOperation(loc, src.forward(SGF), init->getAddress(),

                                  StoreOwnershipQualifier::Init);

    init->finishInitialization(SGF);

    return init->getManagedAddress();

  }

  

  assert(hasAbstraction);

  assert(src.getType().isObject() &&

         ""address-only type with abstraction difference?"");

  

  // Produce the value at +1.

  return SGF.emitSubstToOrigValue(loc, src, abstraction, sourceType);

}

","static ManagedValue

adjustForConditionalCheckedCastOperand(SILLocation loc, ManagedValue src,

                                       CanType sourceType, CanType targetType,

                                       SILGenFunction &SGF) {

  // Reabstract to the most general abstraction, and put it into a

  // temporary if necessary.
","  

  // Figure out if we need the value to be in a temporary.

  bool requiresAddress =

    !canUseScalarCheckedCastInstructions(SGF.SGM.M, sourceType, targetType);

  

  AbstractionPattern abstraction = SGF.SGM.M.Types.getMostGeneralAbstraction();

  auto &srcAbstractTL = SGF.getTypeLowering(abstraction, sourceType);

  

  bool hasAbstraction = (src.getType() != srcAbstractTL.getLoweredType());

  

  // Fast path: no re-abstraction required.

  if (!hasAbstraction &&

      (!requiresAddress ||

       (src.getType().isAddress() || !SGF.silConv.useLoweredAddresses()))) {

    return src;

  }

  

  std::unique_ptr<TemporaryInitialization> init;

  if (requiresAddress) {

    init = SGF.emitTemporary(loc, srcAbstractTL);



    if (hasAbstraction)

      src = SGF.emitSubstToOrigValue(loc, src, abstraction, sourceType);



    // Okay, if all we need to do is drop the value in an address,

    // this is easy.

    SGF.B.emitStoreValueOperation(loc, src.forward(SGF), init->getAddress(),

                                  StoreOwnershipQualifier::Init);

    init->finishInitialization(SGF);

    return init->getManagedAddress();

  }

  

  assert(hasAbstraction);

  assert(src.getType().isObject() &&

         ""address-only type with abstraction difference?"");

  

  // Produce the value at +1.

  return SGF.emitSubstToOrigValue(loc, src, abstraction, sourceType);

}


"
"[function-signature-opt] Allow FSO on witness_methods when performing the dead argument signature optimization for partial_apply instructions

This improves performance of some benchmarks, which pass static operators like `Int.<` as closure arguments.

Fixes rdar://23428804",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,"DEBUG(llvm::dbgs() << ""  cannot specialize function -> abort\n"");","  void run() override {

    auto *F = getFunction();



    // Don't optimize callees that should not be optimized.

    if (!F->shouldOptimize())

      return;



    // This is the function to optimize.

    DEBUG(llvm::dbgs() << ""*** FSO on function: "" << F->getName() << "" ***\n"");



    // Check the signature of F to make sure that it is a function that we

    // can specialize. These are conditions independent of the call graph.

    // No need for CallerAnalysis if we are not optimizing for partial

    // applies.

    if (!OptForPartialApply &&

        !canSpecializeFunction(F, nullptr, OptForPartialApply)) {

      DEBUG(llvm::dbgs() << ""  cannot specialize function -> abort\n"");

      return;

    }



    CallerAnalysis *CA = PM->getAnalysis<CallerAnalysis>();

    const CallerAnalysis::FunctionInfo &FuncInfo = CA->getCallerInfo(F);



    // Check the signature of F to make sure that it is a function that we

    // can specialize. These are conditions independent of the call graph.

    if (OptForPartialApply &&

        !canSpecializeFunction(F, &FuncInfo, OptForPartialApply)) {

      DEBUG(llvm::dbgs() << ""  cannot specialize function -> abort\n"");

      return;

    }



    auto *RCIA = getAnalysis<RCIdentityAnalysis>();

    auto *EA = PM->getAnalysis<EpilogueARCAnalysis>();



    // Lock BCA so it's not invalidated along with the rest of the call graph.

    AnalysisPreserver BCAP(PM->getAnalysis<BasicCalleeAnalysis>());



    // As we optimize the function more and more, the name of the function is

    // going to change, make sure the mangler is aware of all the changes done

    // to the function.

    Mangle::Mangler M;

    auto P = Demangle::SpecializationPass::FunctionSignatureOpts;

    FunctionSignatureSpecializationMangler OldFM(P, M, F->isFragile(), F);

    NewMangling::FunctionSignatureSpecializationMangler NewFM(P, F->isFragile(),

                                                              F);



    /// Keep a map between the exploded argument index and the original argument

    /// index.

    llvm::SmallDenseMap<int, int> AIM;

    int asize = F->begin()->getArguments().size();

    for (auto i = 0; i < asize; ++i) {

      AIM[i] = i;

    }



    // Allocate the argument and result descriptors.

    llvm::SmallVector<ArgumentDescriptor, 4> ArgumentDescList;

    llvm::SmallVector<ResultDescriptor, 4> ResultDescList;

    auto Args = F->begin()->getFunctionArguments();

    for (unsigned i = 0, e = Args.size(); i != e; ++i) {

      ArgumentDescList.emplace_back(Args[i]);

    }

    for (SILResultInfo IR : F->getLoweredFunctionType()->getResults()) {

      ResultDescList.emplace_back(IR);

    }



    // Owned to guaranteed optimization.

    FunctionSignatureTransform FST(F, RCIA, EA, OldFM, NewFM, AIM,

                                   ArgumentDescList, ResultDescList);



    bool Changed = false;

    if (OptForPartialApply) {

      Changed = FST.removeDeadArgs(FuncInfo.getMinPartialAppliedArgs());

    } else {

      Changed = FST.run(FuncInfo.hasCaller());

    }

    if (Changed) {

      ++ NumFunctionSignaturesOptimized;

      // The old function must be a thunk now.

      assert(F->isThunk() && ""Old function should have been turned into a thunk"");



      PM->invalidateAnalysis(F, SILAnalysis::InvalidationKind::Everything);



      // Make sure the PM knows about this function. This will also help us

      // with self-recursion.

      notifyPassManagerOfFunction(FST.getOptimizedFunction(), F);



      if (!OptForPartialApply) {

        // We have to restart the pipeline for this thunk in order to run the

        // inliner (and other opts) again. This is important if the new

        // specialized function (which is called from this thunk) is

        // function-signature-optimized again and also becomes an

        // always-inline-thunk.

        restartPassPipeline();

      }

    }

  }

","  void run() override {

    auto *F = getFunction();



    // Don't optimize callees that should not be optimized.

    if (!F->shouldOptimize())

      return;



    // This is the function to optimize.

    DEBUG(llvm::dbgs() << ""*** FSO on function: "" << F->getName() << "" ***\n"");



    // Check the signature of F to make sure that it is a function that we

    // can specialize. These are conditions independent of the call graph.

    // No need for CallerAnalysis if we are not optimizing for partial

    // applies.

    if (!OptForPartialApply &&

        !canSpecializeFunction(F, nullptr, OptForPartialApply)) {

     ","
      return;

    }



    CallerAnalysis *CA = PM->getAnalysis<CallerAnalysis>();

    const CallerAnalysis::FunctionInfo &FuncInfo = CA->getCallerInfo(F);



    // Check the signature of F to make sure that it is a function that we

    // can specialize. These are conditions independent of the call graph.

    if (OptForPartialApply &&

        !canSpecializeFunction(F, &FuncInfo, OptForPartialApply)) {

      DEBUG(llvm::dbgs() << ""  cannot specialize function -> abort\n"");

      return;

    }



    auto *RCIA = getAnalysis<RCIdentityAnalysis>();

    auto *EA = PM->getAnalysis<EpilogueARCAnalysis>();



    // Lock BCA so it's not invalidated along with the rest of the call graph.

    AnalysisPreserver BCAP(PM->getAnalysis<BasicCalleeAnalysis>());



    // As we optimize the function more and more, the name of the function is

    // going to change, make sure the mangler is aware of all the changes done

    // to the function.

    Mangle::Mangler M;

    auto P = Demangle::SpecializationPass::FunctionSignatureOpts;

    FunctionSignatureSpecializationMangler OldFM(P, M, F->isFragile(), F);

    NewMangling::FunctionSignatureSpecializationMangler NewFM(P, F->isFragile(),

                                                              F);



    /// Keep a map between the exploded argument index and the original argument

    /// index.

    llvm::SmallDenseMap<int, int> AIM;

    int asize = F->begin()->getArguments().size();

    for (auto i = 0; i < asize; ++i) {

      AIM[i] = i;

    }



    // Allocate the argument and result descriptors.

    llvm::SmallVector<ArgumentDescriptor, 4> ArgumentDescList;

    llvm::SmallVector<ResultDescriptor, 4> ResultDescList;

    auto Args = F->begin()->getFunctionArguments();

    for (unsigned i = 0, e = Args.size(); i != e; ++i) {

      ArgumentDescList.emplace_back(Args[i]);

    }

    for (SILResultInfo IR : F->getLoweredFunctionType()->getResults()) {

      ResultDescList.emplace_back(IR);

    }



    // Owned to guaranteed optimization.

    FunctionSignatureTransform FST(F, RCIA, EA, OldFM, NewFM, AIM,

                                   ArgumentDescList, ResultDescList);



    bool Changed = false;

    if (OptForPartialApply) {

      Changed = FST.removeDeadArgs(FuncInfo.getMinPartialAppliedArgs());

    } else {

      Changed = FST.run(FuncInfo.hasCaller());

    }

    if (Changed) {

      ++ NumFunctionSignaturesOptimized;

      // The old function must be a thunk now.

      assert(F->isThunk() && ""Old function should have been turned into a thunk"");



      PM->invalidateAnalysis(F, SILAnalysis::InvalidationKind::Everything);



      // Make sure the PM knows about this function. This will also help us

      // with self-recursion.

      notifyPassManagerOfFunction(FST.getOptimizedFunction(), F);



      if (!OptForPartialApply) {

        // We have to restart the pipeline for this thunk in order to run the

        // inliner (and other opts) again. This is important if the new

        // specialized function (which is called from this thunk) is

        // function-signature-optimized again and also becomes an

        // always-inline-thunk.

        restartPassPipeline();

      }

    }

  }

"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(numIndirectResults == loweredFnConv.getNumIndirectSILResults());,"void OpaqueStorageAllocation::convertIndirectFunctionArgs() {

  // Insert temporary argument loads at the top of the function.

  SILBuilder argBuilder(pass.F->getEntryBlock()->begin());



  auto fnConv = pass.F->getConventions();

  unsigned argIdx = fnConv.getSILArgIndexOfFirstParam();

  for (SILParameterInfo param :

       pass.F->getLoweredFunctionType()->getParameters()) {



    if (param.isFormalIndirect() && !fnConv.isSILIndirect(param)) {

      SILArgument *arg = pass.F->getArgument(argIdx);

      SILType addrType = arg->getType().getAddressType();



      LoadInst *loadArg = argBuilder.createLoad(

          RegularLocation(const_cast<ValueDecl *>(arg->getDecl())),

          SILUndef::get(addrType, pass.F->getModule()),

          LoadOwnershipQualifier::Unqualified);



      arg->replaceAllUsesWith(loadArg);

      assert(!pass.valueStorageMap.contains(arg));



      arg = arg->getParent()->replaceFunctionArgument(

          arg->getIndex(), addrType, ValueOwnershipKind::Trivial,

          arg->getDecl());



      loadArg->setOperand(arg);



      pass.valueStorageMap.insertValue(loadArg).storageAddress = arg;

    }

    ++argIdx;

  }

  assert(argIdx

         == fnConv.getSILArgIndexOfFirstParam() + fnConv.getNumSILArguments());

}

","void OpaqueStorageAllocation::convertIndirectFunctionArgs() {

  // Insert temporary argument loads at the top of the function.

  SILBuilder argBuilder(pass.F->getEntryBlock()->begin());


","  auto fnConv = pass.F->getConventions();

  unsigned argIdx = fnConv.getSILArgIndexOfFirstParam();

  for (SILParameterInfo param :

       pass.F->getLoweredFunctionType()->getParameters()) {



    if (param.isFormalIndirect() && !fnConv.isSILIndirect(param)) {

      SILArgument *arg = pass.F->getArgument(argIdx);

      SILType addrType = arg->getType().getAddressType();



      LoadInst *loadArg = argBuilder.createLoad(

          RegularLocation(const_cast<ValueDecl *>(arg->getDecl())),

          SILUndef::get(addrType, pass.F->getModule()),

          LoadOwnershipQualifier::Unqualified);



      arg->replaceAllUsesWith(loadArg);

      assert(!pass.valueStorageMap.contains(arg));



      arg = arg->getParent()->replaceFunctionArgument(

          arg->getIndex(), addrType, ValueOwnershipKind::Trivial,

          arg->getDecl());



      loadArg->setOperand(arg);



      pass.valueStorageMap.insertValue(loadArg).storageAddress = arg;

    }

    ++argIdx;

  }

  assert(argIdx

         == fnConv.getSILArgIndexOfFirstParam() + fnConv.getNumSILArguments());

}


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter(SILInstruction *origCall, AddressLoweringState &pass)","  ApplyRewriter(SILInstruction *origCall, AddressLoweringState &pass)

      : pass(pass), apply(origCall), argBuilder(origCall) {}

", ,"
      : pass(pass), apply(origCall), argBuilder(origCall) {}

"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void rewriteParameters();,"  void rewriteParameters();

", ,"
"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void ApplyRewriter::rewriteParameters() {,"void ApplyRewriter::rewriteParameters() {

  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

        rewriteIndirectParameter(&operand);

    }

    ++calleeArgIdx;

  }

}

","void ApplyRewriter::rewriteParameters() {

  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

        rewriteIndirectParameter(&operand);

    }

    ++calleeArgIdx;

  }

}
","
  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

        rewriteIndirectParameter(&operand);

    }

    ++calleeArgIdx;

  }

}

"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,rewriteIndirectParameter(&operand);,"void ApplyRewriter::rewriteParameters() {

  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

        rewriteIndirectParameter(&operand);

    }

    ++calleeArgIdx;

  }

}

","void ApplyRewriter::rewriteParameters() {

  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

       ","
    }

    ++calleeArgIdx;

  }

}

"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,void rewriteFunction() {,"  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

    storage.storageAddress = addr;

    storage.markRewritten();

  }

","  void markRewritten(SILValue addr) {
","    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

    storage.storageAddress = addr;

    storage.markRewritten();

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""VALUE   ""; valueDef->dump());","  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

    storage.storageAddress = addr;

    storage.markRewritten();

  }

","  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

","
    storage.markRewritten();

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,DEBUG(if (valueStorage.storageAddress) {,"  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

    storage.storageAddress = addr;

    storage.markRewritten();

  }

","  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

","
    storage.markRewritten();

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,DEBUG(V->dump());,"  void visitCopyValueInst(CopyValueInst *copyInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(copyInst);

    // Fold a copy into a store.

    if (storage.isProjection()

        && isa<StoreInst>(storage.getComposedOperand()->getUser())) {

      return;

    }

    SILValue srcVal = copyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    SILValue destAddr = addrMat.materializeAddress(copyInst);

    B.createCopyAddr(copyInst->getLoc(), srcAddr, destAddr, IsNotTake,

                     IsInitialization);

    markRewritten(destAddr);

  }

","  void visitCopyValueInst(CopyValueInst *copyInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(copyInst);
","    // Fold a copy into a store.

    if (storage.isProjection()

        && isa<StoreInst>(storage.getComposedOperand()->getUser())) {

      return;

    }

    SILValue srcVal = copyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    SILValue destAddr = addrMat.materializeAddress(copyInst);

    B.createCopyAddr(copyInst->getLoc(), srcAddr, destAddr, IsNotTake,

                     IsInitialization);

    markRewritten(destAddr);

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""  REWRITE ""; V->dump());","  void visitCopyValueInst(CopyValueInst *copyInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(copyInst);

    // Fold a copy into a store.

    if (storage.isProjection()

        && isa<StoreInst>(storage.getComposedOperand()->getUser())) {

      return;

    }

    SILValue srcVal = copyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    SILValue destAddr = addrMat.materializeAddress(copyInst);

    B.createCopyAddr(copyInst->getLoc(), srcAddr, destAddr, IsNotTake,

                     IsInitialization);

    markRewritten(destAddr);

  }

","  void visitCopyValueInst(CopyValueInst *copyInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(copyInst);

    // Fold a copy into a store.

    if (storage.isProjection()

        && isa<StoreInst>(storage.getComposedOperand()->getUser())) {

      return;
","    }

    SILValue srcVal = copyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    SILValue destAddr = addrMat.materializeAddress(copyInst);

    B.createCopyAddr(copyInst->getLoc(), srcAddr, destAddr, IsNotTake,

                     IsInitialization);

    markRewritten(destAddr);

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""  CALL ""; applyInst->dump();","  void visitDestroyValueInst(DestroyValueInst *destroyInst) {

    SILValue srcVal = destroyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    B.createDestroyAddr(destroyInst->getLoc(), srcAddr);

    pass.markDead(destroyInst);

  }

","  void visitDestroyValueInst(DestroyValueInst *destroyInst) {

    SILValue srcVal = destroyInst->getOperand();
","    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    B.createDestroyAddr(destroyInst->getLoc(), srcAddr);

    pass.markDead(destroyInst);

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"B.createDebugValueAddr(debugInst->getLoc(), addr);","  void visitStoreInst(StoreInst *storeInst) {

    SILValue srcVal = storeInst->getSrc();

    assert(currOper->get() == srcVal);



    ValueStorage &storage = pass.valueStorageMap.getStorage(srcVal);

    SILValue srcAddr = storage.storageAddress;



    IsTake_t isTakeFlag = IsTake;

    assert(storeInst->getOwnershipQualifier()

           == StoreOwnershipQualifier::Unqualified);



    if (storage.isProjection()) {

      assert(!srcAddr);

      auto *copyInst = cast<CopyValueInst>(srcVal);

      ValueStorage &srcStorage =

          pass.valueStorageMap.getStorage(copyInst->getOperand());

      assert(!srcStorage.isProjection());

      srcAddr = srcStorage.storageAddress;

      isTakeFlag = IsNotTake;

    }

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    B.createCopyAddr(storeInst->getLoc(), srcAddr, storeInst->getDest(),

                     isTakeFlag, IsInitialization);

    pass.markDead(storeInst);

  }

","  void visitStoreInst(StoreInst *storeInst) {

    SILValue srcVal = storeInst->getSrc();

    assert(currOper->get() == srcVal);



    ValueStorage &storage = pass.valueStorageMap.getStorage(srcVal);

    SILValue srcAddr = storage.storageAddress;

","
    IsTake_t isTakeFlag = IsTake;

    assert(storeInst->getOwnershipQualifier()

           == StoreOwnershipQualifier::Unqualified);



    if (storage.isProjection()) {

      assert(!srcAddr);

      auto *copyInst = cast<CopyValueInst>(srcVal);

      ValueStorage &srcStorage =

          pass.valueStorageMap.getStorage(copyInst->getOperand());

      assert(!srcStorage.isProjection());

      srcAddr = srcStorage.storageAddress;

      isTakeFlag = IsNotTake;

    }

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    B.createCopyAddr(storeInst->getLoc(), srcAddr, storeInst->getDest(),

                     isTakeFlag, IsInitialization);

    pass.markDead(storeInst);

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(currOper->get() == destroyInst->getOperand());,"  void visitStoreInst(StoreInst *storeInst) {

    SILValue srcVal = storeInst->getSrc();

    assert(currOper->get() == srcVal);



    ValueStorage &storage = pass.valueStorageMap.getStorage(srcVal);

    SILValue srcAddr = storage.storageAddress;



    IsTake_t isTakeFlag = IsTake;

    assert(storeInst->getOwnershipQualifier()

           == StoreOwnershipQualifier::Unqualified);



    if (storage.isProjection()) {

      assert(!srcAddr);

      auto *copyInst = cast<CopyValueInst>(srcVal);

      ValueStorage &srcStorage =

          pass.valueStorageMap.getStorage(copyInst->getOperand());

      assert(!srcStorage.isProjection());

      srcAddr = srcStorage.storageAddress;

      isTakeFlag = IsNotTake;

    }

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    B.createCopyAddr(storeInst->getLoc(), srcAddr, storeInst->getDest(),

                     isTakeFlag, IsInitialization);

    pass.markDead(storeInst);

  }

","  void visitStoreInst(StoreInst *storeInst) {

    SILValue srcVal = storeInst->getSrc();

    assert(currOper->get() == srcVal);



    ValueStorage &storage = pass.valueStorageMap.getStorage(srcVal);

    SILValue srcAddr = storage.storageAddress;



    IsTake_t isTakeFlag = IsTake;

    assert(storeInst->getOwnershipQualifier()

           == StoreOwnershipQualifier::Unqualified);

","
    if (storage.isProjection()) {

      assert(!srcAddr);

      auto *copyInst = cast<CopyValueInst>(srcVal);

      ValueStorage &srcStorage =

          pass.valueStorageMap.getStorage(copyInst->getOperand());

      assert(!srcStorage.isProjection());

      srcAddr = srcStorage.storageAddress;

      isTakeFlag = IsNotTake;

    }

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    B.createCopyAddr(storeInst->getLoc(), srcAddr, storeInst->getDest(),

                     isTakeFlag, IsInitialization);

    pass.markDead(storeInst);

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(origDirectResultValues.size() == numOrigDirectResults);,"  void visitEnumInst(EnumInst *enumInst) {

    SILValue enumAddr;

    if (enumInst->hasOperand()) {

      addrMat.initializeOperandMem(&enumInst->getOperandRef());



      assert(storage->storageAddress);

      enumAddr = storage->storageAddress;

    } else

      enumAddr = addrMat.materializeAddress(enumInst);



    B.createInjectEnumAddr(enumInst->getLoc(), enumAddr,

                           enumInst->getElement());



    storage->markRewritten();

  }

","  void visitEnumInst(EnumInst *enumInst) {

    SILValue enumAddr;

    if (enumInst->hasOperand()) {

      addrMat.initializeOperandMem(&enumInst->getOperandRef());
","

      assert(storage->storageAddress);

      enumAddr = storage->storageAddress;

    } else

      enumAddr = addrMat.materializeAddress(enumInst);



    B.createInjectEnumAddr(enumInst->getLoc(), enumAddr,

                           enumInst->getElement());



    storage->markRewritten();

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(!origFnConv.isSILIndirect(resultInfo));,"  void visitLoadInst(LoadInst *loadInst) {

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    SILValue addr = pass.valueStorageMap.getStorage(loadInst).storageAddress;

    if (addr != loadInst->getOperand()) {

      B.createCopyAddr(loadInst->getLoc(), loadInst->getOperand(), addr, IsTake,

                       IsInitialization);

    }

    storage->markRewritten();

  }

","  void visitLoadInst(LoadInst *loadInst) {

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.
","    SILValue addr = pass.valueStorageMap.getStorage(loadInst).storageAddress;

    if (addr != loadInst->getOperand()) {

      B.createCopyAddr(loadInst->getLoc(), loadInst->getOperand(), addr, IsTake,

                       IsInitialization);

    }

    storage->markRewritten();

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(newResultArgIdx < loweredFnConv.getSILArgIndexOfFirstParam());,"  void visitLoadInst(LoadInst *loadInst) {

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    SILValue addr = pass.valueStorageMap.getStorage(loadInst).storageAddress;

    if (addr != loadInst->getOperand()) {

      B.createCopyAddr(loadInst->getLoc(), loadInst->getOperand(), addr, IsTake,

                       IsInitialization);

    }

    storage->markRewritten();

  }

","  void visitLoadInst(LoadInst *loadInst) {

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

","
    if (addr != loadInst->getOperand()) {

      B.createCopyAddr(loadInst->getLoc(), loadInst->getOperand(), addr, IsTake,

                       IsInitialization);

    }

    storage->markRewritten();

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(newDirectResults.size() == loweredFnConv.getNumDirectSILResults());,"  void visitTupleInst(TupleInst *tupleInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(tupleInst);

    if (storage.isProjection()

        && isa<ReturnInst>(storage.getComposedOperand()->getUser())) {

      // For indirectly returned values, each element has its own storage.

      return;

    }

    // For each element, initialize the operand's memory. Some tuple elements

    // may be loadable types.

    SILValue tupleAddr = addrMat.materializeAddress(tupleInst);

    unsigned eltIdx = 0;

    for (Operand &operand : tupleInst->getAllOperands()) {

      SILType eltTy = operand.get()->getType();

      if (eltTy.isAddressOnly(pass.F->getModule()))

        addrMat.initializeOperandMem(&operand);

      else {

        auto *elementAddr = B.createTupleElementAddr(

            tupleInst->getLoc(), tupleAddr, eltIdx, eltTy.getAddressType());

        B.createStore(tupleInst->getLoc(), operand.get(), elementAddr,

                      StoreOwnershipQualifier::Unqualified);

      }

      ++eltIdx;

    }

  }

","  void visitTupleInst(TupleInst *tupleInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(tupleInst);

    if (storage.isProjection()

        && isa<ReturnInst>(storage.getComposedOperand()->getUser())) {

      // For indirectly returned values, each element has its own storage.

      return;

    }

    // For each element, initialize the operand's memory. Some tuple elements

    // may be loadable types.
","    SILValue tupleAddr = addrMat.materializeAddress(tupleInst);

    unsigned eltIdx = 0;

    for (Operand &operand : tupleInst->getAllOperands()) {

      SILType eltTy = operand.get()->getType();

      if (eltTy.isAddressOnly(pass.F->getModule()))

        addrMat.initializeOperandMem(&operand);

      else {

        auto *elementAddr = B.createTupleElementAddr(

            tupleInst->getLoc(), tupleAddr, eltIdx, eltTy.getAddressType());

        B.createStore(tupleInst->getLoc(), operand.get(), elementAddr,

                      StoreOwnershipQualifier::Unqualified);

      }

      ++eltIdx;

    }

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(currOper->get() == storeInst->getSrc());,"static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);
","  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(storeInst->getOwnershipQualifier() ==,"static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }
","

  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter rewriter(applyInst, pass);","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

       ","
        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,rewriter.rewriteParameters();,"static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

       ","
        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

"
"Merge pull request #7959 from DougGregor/inferred-requirements-are-not-redundant

[GSB] Don't complain about redundant requirements with inferred sources.",lib/AST/DiagnosticEngine.cpp,+,Arg.getAsValueDecl()->getFullName().printPretty(Out);,"static void formatDiagnosticArgument(StringRef Modifier, 

                                     StringRef ModifierArguments,

                                     ArrayRef<DiagnosticArgument> Args,

                                     unsigned ArgIndex,

                                     llvm::raw_ostream &Out) {

  const DiagnosticArgument &Arg = Args[ArgIndex];

  switch (Arg.getKind()) {

  case DiagnosticArgumentKind::Integer:

    if (Modifier == ""select"") {

      assert(Arg.getAsInteger() >= 0 && ""Negative selection index"");

      formatSelectionArgument(ModifierArguments, Args, Arg.getAsInteger(), 

                              Out);

    } else if (Modifier == ""s"") {

      if (Arg.getAsInteger() != 1)

        Out << 's';

    } else {

      assert(Modifier.empty() && ""Improper modifier for integer argument"");

      Out << Arg.getAsInteger();

    }

    break;



  case DiagnosticArgumentKind::Unsigned:

    if (Modifier == ""select"") {

      formatSelectionArgument(ModifierArguments, Args, Arg.getAsUnsigned(), 

                              Out);

    } else if (Modifier == ""s"") {

      if (Arg.getAsUnsigned() != 1)

        Out << 's';

    } else {

      assert(Modifier.empty() && ""Improper modifier for unsigned argument"");

      Out << Arg.getAsUnsigned();

    }

    break;



  case DiagnosticArgumentKind::String:

    assert(Modifier.empty() && ""Improper modifier for string argument"");

    Out << Arg.getAsString();

    break;



  case DiagnosticArgumentKind::Identifier:

    assert(Modifier.empty() && ""Improper modifier for identifier argument"");

    Out << '\'';

    Arg.getAsIdentifier().printPretty(Out);

    Out << '\'';

    break;



  case DiagnosticArgumentKind::ObjCSelector:

    assert(Modifier.empty() && ""Improper modifier for selector argument"");

    Out << '\'' << Arg.getAsObjCSelector() << '\'';

    break;



  case DiagnosticArgumentKind::ValueDecl:

    Out << '\'';

    Arg.getAsValueDecl()->getFullName().printPretty(Out);

    Out << '\'';

    break;



  case DiagnosticArgumentKind::Type: {

    assert(Modifier.empty() && ""Improper modifier for Type argument"");

    

    // Strip extraneous parentheses; they add no value.

    auto type = Arg.getAsType()->getWithoutParens();

    std::string typeName = type->getString();

    Out << '\'' << typeName << '\'';





    // Decide whether to show the desugared type or not.  We filter out some

    // cases to avoid too much noise.

    bool showAKA = !type->isCanonical();



    // If we're complaining about a function type, don't ""aka"" just because of

    // differences in the argument or result types.

    if (showAKA && type->is<AnyFunctionType>() &&

        isa<AnyFunctionType>(type.getPointer()))

      showAKA = false;



    // Don't unwrap intentional sugar types like T? or [T].

    if (showAKA && (isa<SyntaxSugarType>(type.getPointer()) ||

                    isa<DictionaryType>(type.getPointer()) ||

                    type->is<BuiltinType>()))

      showAKA = false;



    // If they are textually the same, don't show them.  This can happen when

    // they are actually different types, because they exist in different scopes

    // (e.g. everyone names their type parameters 'T').

    if (showAKA && typeName == type->getCanonicalType()->getString())

      showAKA = false;



    // Don't show generic type parameters.

    if (showAKA && type->hasTypeParameter())

      showAKA = false;



    if (showAKA)

      Out << "" (aka '"" << type->getCanonicalType() << ""')"";

    break;

  }

  case DiagnosticArgumentKind::TypeRepr:

    assert(Modifier.empty() && ""Improper modifier for TypeRepr argument"");

    Out << '\'' << Arg.getAsTypeRepr() << '\'';

    break;

  case DiagnosticArgumentKind::PatternKind:

    assert(Modifier.empty() && ""Improper modifier for PatternKind argument"");

    Out << Arg.getAsPatternKind();

    break;

  case DiagnosticArgumentKind::StaticSpellingKind:

    if (Modifier == ""select"") {

      formatSelectionArgument(ModifierArguments, Args,

                              unsigned(Arg.getAsStaticSpellingKind()), Out);

    } else {

      assert(Modifier.empty() &&

             ""Improper modifier for StaticSpellingKind argument"");

      Out << Arg.getAsStaticSpellingKind();

    }

    break;



  case DiagnosticArgumentKind::DescriptiveDeclKind:

    assert(Modifier.empty() &&

           ""Improper modifier for DescriptiveDeclKind argument"");

    Out << Decl::getDescriptiveKindName(Arg.getAsDescriptiveDeclKind());

    break;



  case DiagnosticArgumentKind::DeclAttribute:

    assert(Modifier.empty() &&

           ""Improper modifier for DeclAttribute argument"");

    if (Arg.getAsDeclAttribute()->isDeclModifier())

      Out << '\'' << Arg.getAsDeclAttribute()->getAttrName() << '\'';

    else

      Out << '@' << Arg.getAsDeclAttribute()->getAttrName();

    break;



  case DiagnosticArgumentKind::VersionTuple:

    assert(Modifier.empty() &&

           ""Improper modifier for VersionTuple argument"");

    Out << Arg.getAsVersionTuple().getAsString();

    break;

  case DiagnosticArgumentKind::LayoutConstraint:

    assert(Modifier.empty() && ""Improper modifier for LayoutConstraint argument"");

    Out << '\'' << Arg.getAsLayoutConstraint() << '\'';

    break;

  }

}

","static void formatDiagnosticArgument(StringRef Modifier, 

                                     StringRef ModifierArguments,

                                     ArrayRef<DiagnosticArgument> Args,

                                     unsigned ArgIndex,

                                     llvm::raw_ostream &Out) {

  const DiagnosticArgument &Arg = Args[ArgIndex];

  switch (Arg.getKind()) {

  case DiagnosticArgumentKind::Integer:

    if (Modifier == ""select"") {

      assert(Arg.getAsInteger() >= 0 && ""Negative selection index"");

      formatSelectionArgument(ModifierArguments, Args, Arg.getAsInteger(), 

                              Out);

    } else if (Modifier == ""s"") {

      if (Arg.getAsInteger() != 1)

        Out << 's';

    } else {

      assert(Modifier.empty() && ""Improper modifier for integer argument"");

      Out << Arg.getAsInteger();

    }

    break;



  case DiagnosticArgumentKind::Unsigned:

    if (Modifier == ""select"") {

      formatSelectionArgument(ModifierArguments, Args, Arg.getAsUnsigned(), 

                              Out);

    } else if (Modifier == ""s"") {

      if (Arg.getAsUnsigned() != 1)

        Out << 's';

    } else {

      assert(Modifier.empty() && ""Improper modifier for unsigned argument"");

      Out << Arg.getAsUnsigned();

    }

    break;



  case DiagnosticArgumentKind::String:

    assert(Modifier.empty() && ""Improper modifier for string argument"");

    Out << Arg.getAsString();

    break;



  case DiagnosticArgumentKind::Identifier:

    assert(Modifier.empty() && ""Improper modifier for identifier argument"");

    Out << '\'';

    Arg.getAsIdentifier().printPretty(Out);

    Out << '\'';

    break;



  case DiagnosticArgumentKind::ObjCSelector:

    assert(Modifier.empty() && ""Improper modifier for selector argument"");

    Out << '\'' << Arg.getAsObjCSelector() << '\'';

    break;



  case DiagnosticArgumentKind::ValueDecl:

    Out << '\'';

   ","
    Out << '\'';

    break;



  case DiagnosticArgumentKind::Type: {

    assert(Modifier.empty() && ""Improper modifier for Type argument"");

    

    // Strip extraneous parentheses; they add no value.

    auto type = Arg.getAsType()->getWithoutParens();

    std::string typeName = type->getString();

    Out << '\'' << typeName << '\'';





    // Decide whether to show the desugared type or not.  We filter out some

    // cases to avoid too much noise.

    bool showAKA = !type->isCanonical();



    // If we're complaining about a function type, don't ""aka"" just because of

    // differences in the argument or result types.

    if (showAKA && type->is<AnyFunctionType>() &&

        isa<AnyFunctionType>(type.getPointer()))

      showAKA = false;



    // Don't unwrap intentional sugar types like T? or [T].

    if (showAKA && (isa<SyntaxSugarType>(type.getPointer()) ||

                    isa<DictionaryType>(type.getPointer()) ||

                    type->is<BuiltinType>()))

      showAKA = false;



    // If they are textually the same, don't show them.  This can happen when

    // they are actually different types, because they exist in different scopes

    // (e.g. everyone names their type parameters 'T').

    if (showAKA && typeName == type->getCanonicalType()->getString())

      showAKA = false;



    // Don't show generic type parameters.

    if (showAKA && type->hasTypeParameter())

      showAKA = false;



    if (showAKA)

      Out << "" (aka '"" << type->getCanonicalType() << ""')"";

    break;

  }

  case DiagnosticArgumentKind::TypeRepr:

    assert(Modifier.empty() && ""Improper modifier for TypeRepr argument"");

    Out << '\'' << Arg.getAsTypeRepr() << '\'';

    break;

  case DiagnosticArgumentKind::PatternKind:

    assert(Modifier.empty() && ""Improper modifier for PatternKind argument"");

    Out << Arg.getAsPatternKind();

    break;

  case DiagnosticArgumentKind::StaticSpellingKind:

    if (Modifier == ""select"") {

      formatSelectionArgument(ModifierArguments, Args,

                              unsigned(Arg.getAsStaticSpellingKind()), Out);

    } else {

      assert(Modifier.empty() &&

             ""Improper modifier for StaticSpellingKind argument"");

      Out << Arg.getAsStaticSpellingKind();

    }

    break;



  case DiagnosticArgumentKind::DescriptiveDeclKind:

    assert(Modifier.empty() &&

           ""Improper modifier for DescriptiveDeclKind argument"");

    Out << Decl::getDescriptiveKindName(Arg.getAsDescriptiveDeclKind());

    break;



  case DiagnosticArgumentKind::DeclAttribute:

    assert(Modifier.empty() &&

           ""Improper modifier for DeclAttribute argument"");

    if (Arg.getAsDeclAttribute()->isDeclModifier())

      Out << '\'' << Arg.getAsDeclAttribute()->getAttrName() << '\'';

    else

      Out << '@' << Arg.getAsDeclAttribute()->getAttrName();

    break;



  case DiagnosticArgumentKind::VersionTuple:

    assert(Modifier.empty() &&

           ""Improper modifier for VersionTuple argument"");

    Out << Arg.getAsVersionTuple().getAsString();

    break;

  case DiagnosticArgumentKind::LayoutConstraint:

    assert(Modifier.empty() && ""Improper modifier for LayoutConstraint argument"");

    Out << '\'' << Arg.getAsLayoutConstraint() << '\'';

    break;

  }

}

"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(numIndirectResults == loweredFnConv.getNumIndirectSILResults());,"void OpaqueStorageAllocation::convertIndirectFunctionArgs() {

  // Insert temporary argument loads at the top of the function.

  SILBuilder argBuilder(pass.F->getEntryBlock()->begin());



  auto fnConv = pass.F->getConventions();

  unsigned argIdx = fnConv.getSILArgIndexOfFirstParam();

  for (SILParameterInfo param :

       pass.F->getLoweredFunctionType()->getParameters()) {



    if (param.isFormalIndirect() && !fnConv.isSILIndirect(param)) {

      SILArgument *arg = pass.F->getArgument(argIdx);

      SILType addrType = arg->getType().getAddressType();



      LoadInst *loadArg = argBuilder.createLoad(

          RegularLocation(const_cast<ValueDecl *>(arg->getDecl())),

          SILUndef::get(addrType, pass.F->getModule()),

          LoadOwnershipQualifier::Unqualified);



      arg->replaceAllUsesWith(loadArg);

      assert(!pass.valueStorageMap.contains(arg));



      arg = arg->getParent()->replaceFunctionArgument(

          arg->getIndex(), addrType, ValueOwnershipKind::Trivial,

          arg->getDecl());



      loadArg->setOperand(arg);



      pass.valueStorageMap.insertValue(loadArg).storageAddress = arg;

    }

    ++argIdx;

  }

  assert(argIdx

         == fnConv.getSILArgIndexOfFirstParam() + fnConv.getNumSILArguments());

}

","void OpaqueStorageAllocation::convertIndirectFunctionArgs() {

  // Insert temporary argument loads at the top of the function.

  SILBuilder argBuilder(pass.F->getEntryBlock()->begin());


","  auto fnConv = pass.F->getConventions();

  unsigned argIdx = fnConv.getSILArgIndexOfFirstParam();

  for (SILParameterInfo param :

       pass.F->getLoweredFunctionType()->getParameters()) {



    if (param.isFormalIndirect() && !fnConv.isSILIndirect(param)) {

      SILArgument *arg = pass.F->getArgument(argIdx);

      SILType addrType = arg->getType().getAddressType();



      LoadInst *loadArg = argBuilder.createLoad(

          RegularLocation(const_cast<ValueDecl *>(arg->getDecl())),

          SILUndef::get(addrType, pass.F->getModule()),

          LoadOwnershipQualifier::Unqualified);



      arg->replaceAllUsesWith(loadArg);

      assert(!pass.valueStorageMap.contains(arg));



      arg = arg->getParent()->replaceFunctionArgument(

          arg->getIndex(), addrType, ValueOwnershipKind::Trivial,

          arg->getDecl());



      loadArg->setOperand(arg);



      pass.valueStorageMap.insertValue(loadArg).storageAddress = arg;

    }

    ++argIdx;

  }

  assert(argIdx

         == fnConv.getSILArgIndexOfFirstParam() + fnConv.getNumSILArguments());

}


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter(SILInstruction *origCall, AddressLoweringState &pass)","  ApplyRewriter(SILInstruction *origCall, AddressLoweringState &pass)

      : pass(pass), apply(origCall), argBuilder(origCall) {}

", ,"
      : pass(pass), apply(origCall), argBuilder(origCall) {}

"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void rewriteParameters();,"  void rewriteParameters();

", ,"
"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void ApplyRewriter::rewriteParameters() {,"void ApplyRewriter::rewriteParameters() {

  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

        rewriteIndirectParameter(&operand);

    }

    ++calleeArgIdx;

  }

}

","void ApplyRewriter::rewriteParameters() {

  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

        rewriteIndirectParameter(&operand);

    }

    ++calleeArgIdx;

  }

}
","
  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

        rewriteIndirectParameter(&operand);

    }

    ++calleeArgIdx;

  }

}

"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,rewriteIndirectParameter(&operand);,"void ApplyRewriter::rewriteParameters() {

  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

        rewriteIndirectParameter(&operand);

    }

    ++calleeArgIdx;

  }

}

","void ApplyRewriter::rewriteParameters() {

  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

       ","
    }

    ++calleeArgIdx;

  }

}

"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,void rewriteFunction() {,"  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

    storage.storageAddress = addr;

    storage.markRewritten();

  }

","  void markRewritten(SILValue addr) {
","    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

    storage.storageAddress = addr;

    storage.markRewritten();

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""VALUE   ""; valueDef->dump());","  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

    storage.storageAddress = addr;

    storage.markRewritten();

  }

","  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

","
    storage.markRewritten();

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,DEBUG(if (valueStorage.storageAddress) {,"  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

    storage.storageAddress = addr;

    storage.markRewritten();

  }

","  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

","
    storage.markRewritten();

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,DEBUG(V->dump());,"  void visitCopyValueInst(CopyValueInst *copyInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(copyInst);

    // Fold a copy into a store.

    if (storage.isProjection()

        && isa<StoreInst>(storage.getComposedOperand()->getUser())) {

      return;

    }

    SILValue srcVal = copyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    SILValue destAddr = addrMat.materializeAddress(copyInst);

    B.createCopyAddr(copyInst->getLoc(), srcAddr, destAddr, IsNotTake,

                     IsInitialization);

    markRewritten(destAddr);

  }

","  void visitCopyValueInst(CopyValueInst *copyInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(copyInst);
","    // Fold a copy into a store.

    if (storage.isProjection()

        && isa<StoreInst>(storage.getComposedOperand()->getUser())) {

      return;

    }

    SILValue srcVal = copyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    SILValue destAddr = addrMat.materializeAddress(copyInst);

    B.createCopyAddr(copyInst->getLoc(), srcAddr, destAddr, IsNotTake,

                     IsInitialization);

    markRewritten(destAddr);

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""  REWRITE ""; V->dump());","  void visitCopyValueInst(CopyValueInst *copyInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(copyInst);

    // Fold a copy into a store.

    if (storage.isProjection()

        && isa<StoreInst>(storage.getComposedOperand()->getUser())) {

      return;

    }

    SILValue srcVal = copyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    SILValue destAddr = addrMat.materializeAddress(copyInst);

    B.createCopyAddr(copyInst->getLoc(), srcAddr, destAddr, IsNotTake,

                     IsInitialization);

    markRewritten(destAddr);

  }

","  void visitCopyValueInst(CopyValueInst *copyInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(copyInst);

    // Fold a copy into a store.

    if (storage.isProjection()

        && isa<StoreInst>(storage.getComposedOperand()->getUser())) {

      return;
","    }

    SILValue srcVal = copyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    SILValue destAddr = addrMat.materializeAddress(copyInst);

    B.createCopyAddr(copyInst->getLoc(), srcAddr, destAddr, IsNotTake,

                     IsInitialization);

    markRewritten(destAddr);

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""  CALL ""; applyInst->dump();","  void visitDestroyValueInst(DestroyValueInst *destroyInst) {

    SILValue srcVal = destroyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    B.createDestroyAddr(destroyInst->getLoc(), srcAddr);

    pass.markDead(destroyInst);

  }

","  void visitDestroyValueInst(DestroyValueInst *destroyInst) {

    SILValue srcVal = destroyInst->getOperand();
","    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    B.createDestroyAddr(destroyInst->getLoc(), srcAddr);

    pass.markDead(destroyInst);

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"B.createDebugValueAddr(debugInst->getLoc(), addr);","  void visitStoreInst(StoreInst *storeInst) {

    SILValue srcVal = storeInst->getSrc();

    assert(currOper->get() == srcVal);



    ValueStorage &storage = pass.valueStorageMap.getStorage(srcVal);

    SILValue srcAddr = storage.storageAddress;



    IsTake_t isTakeFlag = IsTake;

    assert(storeInst->getOwnershipQualifier()

           == StoreOwnershipQualifier::Unqualified);



    if (storage.isProjection()) {

      assert(!srcAddr);

      auto *copyInst = cast<CopyValueInst>(srcVal);

      ValueStorage &srcStorage =

          pass.valueStorageMap.getStorage(copyInst->getOperand());

      assert(!srcStorage.isProjection());

      srcAddr = srcStorage.storageAddress;

      isTakeFlag = IsNotTake;

    }

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    B.createCopyAddr(storeInst->getLoc(), srcAddr, storeInst->getDest(),

                     isTakeFlag, IsInitialization);

    pass.markDead(storeInst);

  }

","  void visitStoreInst(StoreInst *storeInst) {

    SILValue srcVal = storeInst->getSrc();

    assert(currOper->get() == srcVal);



    ValueStorage &storage = pass.valueStorageMap.getStorage(srcVal);

    SILValue srcAddr = storage.storageAddress;

","
    IsTake_t isTakeFlag = IsTake;

    assert(storeInst->getOwnershipQualifier()

           == StoreOwnershipQualifier::Unqualified);



    if (storage.isProjection()) {

      assert(!srcAddr);

      auto *copyInst = cast<CopyValueInst>(srcVal);

      ValueStorage &srcStorage =

          pass.valueStorageMap.getStorage(copyInst->getOperand());

      assert(!srcStorage.isProjection());

      srcAddr = srcStorage.storageAddress;

      isTakeFlag = IsNotTake;

    }

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    B.createCopyAddr(storeInst->getLoc(), srcAddr, storeInst->getDest(),

                     isTakeFlag, IsInitialization);

    pass.markDead(storeInst);

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(currOper->get() == destroyInst->getOperand());,"  void visitStoreInst(StoreInst *storeInst) {

    SILValue srcVal = storeInst->getSrc();

    assert(currOper->get() == srcVal);



    ValueStorage &storage = pass.valueStorageMap.getStorage(srcVal);

    SILValue srcAddr = storage.storageAddress;



    IsTake_t isTakeFlag = IsTake;

    assert(storeInst->getOwnershipQualifier()

           == StoreOwnershipQualifier::Unqualified);



    if (storage.isProjection()) {

      assert(!srcAddr);

      auto *copyInst = cast<CopyValueInst>(srcVal);

      ValueStorage &srcStorage =

          pass.valueStorageMap.getStorage(copyInst->getOperand());

      assert(!srcStorage.isProjection());

      srcAddr = srcStorage.storageAddress;

      isTakeFlag = IsNotTake;

    }

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    B.createCopyAddr(storeInst->getLoc(), srcAddr, storeInst->getDest(),

                     isTakeFlag, IsInitialization);

    pass.markDead(storeInst);

  }

","  void visitStoreInst(StoreInst *storeInst) {

    SILValue srcVal = storeInst->getSrc();

    assert(currOper->get() == srcVal);



    ValueStorage &storage = pass.valueStorageMap.getStorage(srcVal);

    SILValue srcAddr = storage.storageAddress;



    IsTake_t isTakeFlag = IsTake;

    assert(storeInst->getOwnershipQualifier()

           == StoreOwnershipQualifier::Unqualified);

","
    if (storage.isProjection()) {

      assert(!srcAddr);

      auto *copyInst = cast<CopyValueInst>(srcVal);

      ValueStorage &srcStorage =

          pass.valueStorageMap.getStorage(copyInst->getOperand());

      assert(!srcStorage.isProjection());

      srcAddr = srcStorage.storageAddress;

      isTakeFlag = IsNotTake;

    }

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    B.createCopyAddr(storeInst->getLoc(), srcAddr, storeInst->getDest(),

                     isTakeFlag, IsInitialization);

    pass.markDead(storeInst);

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(origDirectResultValues.size() == numOrigDirectResults);,"  void visitEnumInst(EnumInst *enumInst) {

    SILValue enumAddr;

    if (enumInst->hasOperand()) {

      addrMat.initializeOperandMem(&enumInst->getOperandRef());



      assert(storage->storageAddress);

      enumAddr = storage->storageAddress;

    } else

      enumAddr = addrMat.materializeAddress(enumInst);



    B.createInjectEnumAddr(enumInst->getLoc(), enumAddr,

                           enumInst->getElement());



    storage->markRewritten();

  }

","  void visitEnumInst(EnumInst *enumInst) {

    SILValue enumAddr;

    if (enumInst->hasOperand()) {

      addrMat.initializeOperandMem(&enumInst->getOperandRef());
","

      assert(storage->storageAddress);

      enumAddr = storage->storageAddress;

    } else

      enumAddr = addrMat.materializeAddress(enumInst);



    B.createInjectEnumAddr(enumInst->getLoc(), enumAddr,

                           enumInst->getElement());



    storage->markRewritten();

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(!origFnConv.isSILIndirect(resultInfo));,"  void visitLoadInst(LoadInst *loadInst) {

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    SILValue addr = pass.valueStorageMap.getStorage(loadInst).storageAddress;

    if (addr != loadInst->getOperand()) {

      B.createCopyAddr(loadInst->getLoc(), loadInst->getOperand(), addr, IsTake,

                       IsInitialization);

    }

    storage->markRewritten();

  }

","  void visitLoadInst(LoadInst *loadInst) {

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.
","    SILValue addr = pass.valueStorageMap.getStorage(loadInst).storageAddress;

    if (addr != loadInst->getOperand()) {

      B.createCopyAddr(loadInst->getLoc(), loadInst->getOperand(), addr, IsTake,

                       IsInitialization);

    }

    storage->markRewritten();

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(newResultArgIdx < loweredFnConv.getSILArgIndexOfFirstParam());,"  void visitLoadInst(LoadInst *loadInst) {

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    SILValue addr = pass.valueStorageMap.getStorage(loadInst).storageAddress;

    if (addr != loadInst->getOperand()) {

      B.createCopyAddr(loadInst->getLoc(), loadInst->getOperand(), addr, IsTake,

                       IsInitialization);

    }

    storage->markRewritten();

  }

","  void visitLoadInst(LoadInst *loadInst) {

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

","
    if (addr != loadInst->getOperand()) {

      B.createCopyAddr(loadInst->getLoc(), loadInst->getOperand(), addr, IsTake,

                       IsInitialization);

    }

    storage->markRewritten();

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(newDirectResults.size() == loweredFnConv.getNumDirectSILResults());,"  void visitTupleInst(TupleInst *tupleInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(tupleInst);

    if (storage.isProjection()

        && isa<ReturnInst>(storage.getComposedOperand()->getUser())) {

      // For indirectly returned values, each element has its own storage.

      return;

    }

    // For each element, initialize the operand's memory. Some tuple elements

    // may be loadable types.

    SILValue tupleAddr = addrMat.materializeAddress(tupleInst);

    unsigned eltIdx = 0;

    for (Operand &operand : tupleInst->getAllOperands()) {

      SILType eltTy = operand.get()->getType();

      if (eltTy.isAddressOnly(pass.F->getModule()))

        addrMat.initializeOperandMem(&operand);

      else {

        auto *elementAddr = B.createTupleElementAddr(

            tupleInst->getLoc(), tupleAddr, eltIdx, eltTy.getAddressType());

        B.createStore(tupleInst->getLoc(), operand.get(), elementAddr,

                      StoreOwnershipQualifier::Unqualified);

      }

      ++eltIdx;

    }

  }

","  void visitTupleInst(TupleInst *tupleInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(tupleInst);

    if (storage.isProjection()

        && isa<ReturnInst>(storage.getComposedOperand()->getUser())) {

      // For indirectly returned values, each element has its own storage.

      return;

    }

    // For each element, initialize the operand's memory. Some tuple elements

    // may be loadable types.
","    SILValue tupleAddr = addrMat.materializeAddress(tupleInst);

    unsigned eltIdx = 0;

    for (Operand &operand : tupleInst->getAllOperands()) {

      SILType eltTy = operand.get()->getType();

      if (eltTy.isAddressOnly(pass.F->getModule()))

        addrMat.initializeOperandMem(&operand);

      else {

        auto *elementAddr = B.createTupleElementAddr(

            tupleInst->getLoc(), tupleAddr, eltIdx, eltTy.getAddressType());

        B.createStore(tupleInst->getLoc(), operand.get(), elementAddr,

                      StoreOwnershipQualifier::Unqualified);

      }

      ++eltIdx;

    }

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(currOper->get() == storeInst->getSrc());,"static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);
","  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(storeInst->getOwnershipQualifier() ==,"static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }
","

  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter rewriter(applyInst, pass);","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

       ","
        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,rewriter.rewriteParameters();,"static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

       ","
        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

"
Merge CheckedCastValueBranch with new master,lib/ClangImporter/ImportType.cpp,-,assert(resultTy &&,"static Type

adjustResultTypeForThrowingFunction(ForeignErrorConvention::Info errorInfo,

                                    Type resultTy) {

  switch (errorInfo.TheKind) {

  case ForeignErrorConvention::ZeroResult:

  case ForeignErrorConvention::NonZeroResult:

    // Check for a bad override.

    if (resultTy->isVoid())

      return Type();

    return TupleType::getEmpty(resultTy->getASTContext());



  case ForeignErrorConvention::NilResult:

    if (Type unwrappedTy = resultTy->getAnyOptionalObjectType())

      return unwrappedTy;

    // Check for a bad override.

    if (resultTy->isVoid())

      return Type();

    // It's possible an Objective-C method overrides the base method to never

    // fail, and marks the method _Nonnull to indicate that. Swift can't

    // represent that, but it shouldn't fall over either.

    return resultTy;



  case ForeignErrorConvention::ZeroPreservedResult:

    // Check for a bad override.

    if (resultTy->isVoid())

      return Type();

    return resultTy;



  case ForeignErrorConvention::NonNilError:

    return resultTy;

  }



  llvm_unreachable(""Invalid ForeignErrorConvention."");

}

","static Type

adjustResultTypeForThrowingFunction(ForeignErrorConvention::Info errorInfo,

                                    Type resultTy) {

  switch (errorInfo.TheKind) {

  case ForeignErrorConvention::ZeroResult:

  case ForeignErrorConvention::NonZeroResult:

    // Check for a bad override.
","    if (resultTy->isVoid())

      return Type();

    return TupleType::getEmpty(resultTy->getASTContext());



  case ForeignErrorConvention::NilResult:

    if (Type unwrappedTy = resultTy->getAnyOptionalObjectType())

      return unwrappedTy;

    // Check for a bad override.

    if (resultTy->isVoid())

      return Type();

    // It's possible an Objective-C method overrides the base method to never

    // fail, and marks the method _Nonnull to indicate that. Swift can't

    // represent that, but it shouldn't fall over either.

    return resultTy;



  case ForeignErrorConvention::ZeroPreservedResult:

    // Check for a bad override.

    if (resultTy->isVoid())

      return Type();

    return resultTy;



  case ForeignErrorConvention::NonNilError:

    return resultTy;

  }



  llvm_unreachable(""Invalid ForeignErrorConvention."");

}


"
Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,LogJob(const Job *j) : j(j) {},"  LogJob(const Job *j) : j(j) {}

", ,"
"
Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,LogJobArray(const ArrayRef<const Job *> js) : js(js) {},"  LogJobArray(const ArrayRef<const Job *> js) : js(js) {}

", ,"
"
Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,LogJobSet(const SmallPtrSetImpl<const Job*> &js) : js(js) {},"  LogJobSet(const SmallPtrSetImpl<const Job*> &js) : js(js) {}

", ,"
"
Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,lj.j->printSummary(os);,"llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJob &lj) {

  lj.j->printSummary(os);

  return os;

}

","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJob &lj) {

 ","
  return os;

}

"
Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,"[&](Job const *j) { os << LogJob(j); },","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobArray &ljs) {

  os << ""["";

  interleave(ljs.js,

             [&](Job const *j) { os << LogJob(j); },

             [&]() { os << ' '; });

  os << ""]"";

  return os;

}

","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobArray &ljs) {

  os << ""["";

  interleave(ljs.js,

            ","
             [&]() { os << ' '; });

  os << ""]"";

  return os;

}

"
Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,"[&](Job const *j) { os << LogJob(j); },","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobSet &ljs) {

  os << ""{"";

  interleave(ljs.js,

             [&](Job const *j) { os << LogJob(j); },

             [&]() { os << ' '; });

  os << ""}"";

  return os;

}

","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobSet &ljs) {

  os << ""{"";

  interleave(ljs.js,

            ","
             [&]() { os << ' '; });

  os << ""}"";

  return os;

}

"
Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,-,"static_assert(IsTriviallyCopyable<CompileJobAction::InputInfo>::value,","    void

    dependencyLoadFailed(StringRef DependenciesFile, bool Warn=true) {

      if (Warn && Comp.ShowIncrementalBuildDecisions)

        Comp.Diags.diagnose(SourceLoc(),

                            diag::warn_unable_to_load_dependencies,

                            DependenciesFile);

      Comp.disableIncrementalBuild();

      for (const Job *Cmd : DeferredCommands)

        scheduleCommandIfNecessaryAndPossible(Cmd);

      DeferredCommands.clear();

    }

","    void
","    dependencyLoadFailed(StringRef DependenciesFile, bool Warn=true) {

      if (Warn && Comp.ShowIncrementalBuildDecisions)

        Comp.Diags.diagnose(SourceLoc(),

                            diag::warn_unable_to_load_dependencies,

                            DependenciesFile);

      Comp.disableIncrementalBuild();

      for (const Job *Cmd : DeferredCommands)

        scheduleCommandIfNecessaryAndPossible(Cmd);

      DeferredCommands.clear();

    }


"
Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,assert(FinishedCmd->getCondition() == Job::Condition::Always);,"    void reloadAndRemarkDeps(const Job *FinishedCmd,

                             int ReturnCode,

                             SmallVector<const Job *, N> &Dependents) {

      const CommandOutput &Output = FinishedCmd->getOutput();

      StringRef DependenciesFile =

        Output.getAdditionalOutputForType(types::TY_SwiftDeps);



      if (DependenciesFile.empty()) {

        // If this job doesn't track dependencies, it must always be run.

        // Note: In theory CheckDependencies makes sense as well (for a leaf

        // node in the dependency graph), and maybe even NewlyAdded (for very

        // coarse dependencies that always affect downstream nodes), but we're

        // not using either of those right now, and this logic should probably

        // be revisited when we are.

        assert(FinishedCmd->getCondition() == Job::Condition::Always);

      } else {

        // If we have a dependency file /and/ the frontend task exited normally,

        // we can be discerning about what downstream files to rebuild.

        if (ReturnCode == EXIT_SUCCESS || ReturnCode == EXIT_FAILURE) {

          bool wasCascading = DepGraph.isMarked(FinishedCmd);



          switch (DepGraph.loadFromPath(FinishedCmd, DependenciesFile)) {

          case DependencyGraphImpl::LoadResult::HadError:

            if (ReturnCode == EXIT_SUCCESS) {

              dependencyLoadFailed(DependenciesFile);

              Dependents.clear();

            } // else, let the next build handle it.

            break;

          case DependencyGraphImpl::LoadResult::UpToDate:

            if (!wasCascading)

              break;

            LLVM_FALLTHROUGH;

          case DependencyGraphImpl::LoadResult::AffectsDownstream:

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          }

        } else {

          // If there's an abnormal exit (a crash), assume the worst.

          switch (FinishedCmd->getCondition()) {

          case Job::Condition::NewlyAdded:

            // The job won't be treated as newly added next time. Conservatively

            // mark it as affecting other jobs, because some of them may have

            // completed already.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::Always:

            // Any incremental task that shows up here has already been marked;

            // we didn't need to wait for it to finish to start downstream

            // tasks.

            assert(DepGraph.isMarked(FinishedCmd));

            break;

          case Job::Condition::RunWithoutCascading:

            // If this file changed, it might have been a non-cascading change

            // and it might not. Unfortunately, the interface hash has been

            // updated or compromised, so we don't actually know anymore; we

            // have to conservatively assume the changes could affect other

            // files.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::CheckDependencies:

            // If the only reason we're running this is because something else

            // changed, then we can trust the dependency graph as to whether

            // it's a cascading or non-cascading change. That is, if whatever

            // /caused/ the error isn't supposed to affect other files, and

            // whatever /fixes/ the error isn't supposed to affect other files,

            // then there's no need to recompile any other inputs. If either of

            // those are false, we /do/ need to recompile other inputs.

            break;

          }

        }

      }

    }

","    void reloadAndRemarkDeps(const Job *FinishedCmd,

                             int ReturnCode,

                             SmallVector<const Job *, N> &Dependents) {

      const CommandOutput &Output = FinishedCmd->getOutput();

      StringRef DependenciesFile =

        Output.getAdditionalOutputForType(types::TY_SwiftDeps);



      if (DependenciesFile.empty()) {

        // If this job doesn't track dependencies, it must always be run.

        // Note: In theory CheckDependencies makes sense as well (for a leaf

        // node in the dependency graph), and maybe even NewlyAdded (for very

        // coarse dependencies that always affect downstream nodes), but we're

        // not using either of those right now, and this logic should probably

        // be revisited when we are.

       ","
      } else {

        // If we have a dependency file /and/ the frontend task exited normally,

        // we can be discerning about what downstream files to rebuild.

        if (ReturnCode == EXIT_SUCCESS || ReturnCode == EXIT_FAILURE) {

          bool wasCascading = DepGraph.isMarked(FinishedCmd);



          switch (DepGraph.loadFromPath(FinishedCmd, DependenciesFile)) {

          case DependencyGraphImpl::LoadResult::HadError:

            if (ReturnCode == EXIT_SUCCESS) {

              dependencyLoadFailed(DependenciesFile);

              Dependents.clear();

            } // else, let the next build handle it.

            break;

          case DependencyGraphImpl::LoadResult::UpToDate:

            if (!wasCascading)

              break;

            LLVM_FALLTHROUGH;

          case DependencyGraphImpl::LoadResult::AffectsDownstream:

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          }

        } else {

          // If there's an abnormal exit (a crash), assume the worst.

          switch (FinishedCmd->getCondition()) {

          case Job::Condition::NewlyAdded:

            // The job won't be treated as newly added next time. Conservatively

            // mark it as affecting other jobs, because some of them may have

            // completed already.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::Always:

            // Any incremental task that shows up here has already been marked;

            // we didn't need to wait for it to finish to start downstream

            // tasks.

            assert(DepGraph.isMarked(FinishedCmd));

            break;

          case Job::Condition::RunWithoutCascading:

            // If this file changed, it might have been a non-cascading change

            // and it might not. Unfortunately, the interface hash has been

            // updated or compromised, so we don't actually know anymore; we

            // have to conservatively assume the changes could affect other

            // files.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::CheckDependencies:

            // If the only reason we're running this is because something else

            // changed, then we can trust the dependency graph as to whether

            // it's a cascading or non-cascading change. That is, if whatever

            // /caused/ the error isn't supposed to affect other files, and

            // whatever /fixes/ the error isn't supposed to affect other files,

            // then there's no need to recompile any other inputs. If either of

            // those are false, we /do/ need to recompile other inputs.

            break;

          }

        }

      }

    }

"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,+,"assert(fn && ""null impl provided"");","      static MethodDescriptor getIVarInitializer(llvm::Function *fn) {

        assert(fn && ""null impl provided"");

        return MethodDescriptor(Kind::IVarInitializer, fn);

      }

","      static MethodDescriptor getIVarInitializer(llvm::Function *fn) {

       ","
        return MethodDescriptor(Kind::IVarInitializer, fn);

      }

"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,+,"assert(fn && ""null impl provided"");","      static MethodDescriptor getIVarDestroyer(llvm::Function *fn) {

        assert(fn && ""null impl provided"");

        return MethodDescriptor(Kind::IVarDestroyer, fn);

      }

","      static MethodDescriptor getIVarDestroyer(llvm::Function *fn) {

       ","
        return MethodDescriptor(Kind::IVarDestroyer, fn);

      }

"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,+,assert(getKind() == Kind::Method);,"      AbstractFunctionDecl *getMethod() {

        assert(getKind() == Kind::Method);

        return static_cast<AbstractFunctionDecl*>(Data.getPointer());

      }

","      AbstractFunctionDecl *getMethod() {

       ","
        return static_cast<AbstractFunctionDecl*>(Data.getPointer());

      }

"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,+,assert(getKind() != Kind::Method);,"      llvm::Function *getImpl() {

        assert(getKind() != Kind::Method);

        return static_cast<llvm::Function*>(Data.getPointer());

      }

","      llvm::Function *getImpl() {

       ","
        return static_cast<llvm::Function*>(Data.getPointer());

      }

"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,-,assert(baseEntry.isBase());,"    bool findBetterPath(ProtocolDecl *proto, const ProtocolInfo &protoInfo,

                        unsigned lengthSoFar) {

      assert(lengthSoFar < BestPathLength);

      assert(proto != Dest);



      // Keep track of whether we found a better path than the

      // previous best.

      bool foundBetter = false;

      for (auto base : proto->getInheritedProtocols()) {

        // ObjC protocols do not have witnesses.

        if (!Lowering::TypeConverter::protocolRequiresWitnessTable(base))

          continue;



        auto baseIndex = protoInfo.getBaseIndex(base);



        // Compute the length down to this base.

        unsigned lengthToBase = lengthSoFar;

        if (!baseIndex.isPrefix()) {

          lengthToBase++;



          // Don't consider this path if we reach a length that can't

          // possibly be better than the best so far.

          if (lengthToBase == BestPathLength) continue;

        }

        assert(lengthToBase < BestPathLength);



        // If this base *is* the destination, go ahead and start

        // building the path into ReversePath.

        if (base == Dest) {

          // Reset the collected best-path information.

          BestPathLength = lengthToBase;

          ReversePath.clear();



        // Otherwise, if there isn't a better path through this base,

        // don't accumulate anything in the path.

        } else if (!findBetterPath(base, IGM.getProtocolInfo(base),

                                   lengthToBase)) {

          continue;

        }



        // Okay, we've found a better path, and ReversePath contains a

        // path leading from base to Dest.

        assert(BestPathLength >= lengthToBase);

        foundBetter = true;



        // Add the link from proto to base if necessary.

        if (!baseIndex.isPrefix()) {

          ReversePath.push_back(baseIndex);



        // If it isn't necessary, then we might be able to

        // short-circuit considering the bases of this protocol.

        } else {

          if (lengthSoFar == BestPathLength)

            return true;

        }

      }



      return foundBetter;

    }

","    bool findBetterPath(ProtocolDecl *proto, const ProtocolInfo &protoInfo,

                        unsigned lengthSoFar) {

      assert(lengthSoFar < BestPathLength);

      assert(proto != Dest);



      // Keep track of whether we found a better path than the

      // previous best.

","
      for (auto base : proto->getInheritedProtocols()) {

        // ObjC protocols do not have witnesses.

        if (!Lowering::TypeConverter::protocolRequiresWitnessTable(base))

          continue;



        auto baseIndex = protoInfo.getBaseIndex(base);



        // Compute the length down to this base.

        unsigned lengthToBase = lengthSoFar;

        if (!baseIndex.isPrefix()) {

          lengthToBase++;



          // Don't consider this path if we reach a length that can't

          // possibly be better than the best so far.

          if (lengthToBase == BestPathLength) continue;

        }

        assert(lengthToBase < BestPathLength);



        // If this base *is* the destination, go ahead and start

        // building the path into ReversePath.

        if (base == Dest) {

          // Reset the collected best-path information.

          BestPathLength = lengthToBase;

          ReversePath.clear();



        // Otherwise, if there isn't a better path through this base,

        // don't accumulate anything in the path.

        } else if (!findBetterPath(base, IGM.getProtocolInfo(base),

                                   lengthToBase)) {

          continue;

        }



        // Okay, we've found a better path, and ReversePath contains a

        // path leading from base to Dest.

        assert(BestPathLength >= lengthToBase);

        foundBetter = true;



        // Add the link from proto to base if necessary.

        if (!baseIndex.isPrefix()) {

          ReversePath.push_back(baseIndex);



        // If it isn't necessary, then we might be able to

        // short-circuit considering the bases of this protocol.

        } else {

          if (lengthSoFar == BestPathLength)

            return true;

        }

      }



      return foundBetter;

    }


"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,-,assert(piEntry.getOutOfLineBaseIndex().getValue() == Table.size(),"    void addOutOfLineBaseProtocol(ProtocolDecl *baseProto) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::BaseProtocol

             && ""sil witness table does not match protocol"");

      assert(entry.getBaseProtocolWitness().Requirement == baseProto

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getBaseIndex(baseProto);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif

      

      SILEntries = SILEntries.slice(1);



      // TODO: Use the witness entry instead of falling through here.



      // Look for a protocol type info.

      const ProtocolInfo &basePI = IGM.getProtocolInfo(baseProto);

      const ProtocolConformance *astConf

        = Conformance.getInheritedConformance(baseProto);

      const ConformanceInfo &conf =

        basePI.getConformance(IGM, baseProto, astConf);



      // If we can emit the base witness table as a constant, do so.

      llvm::Constant *baseWitness = conf.tryGetConstantTable(IGM, ConcreteType);

      if (baseWitness) {

        Table.addBitCast(baseWitness, IGM.Int8PtrTy);

        return;

      }



      // Otherwise, we'll need to derive it at instantiation time.

      RequiresSpecialization = true;

      SpecializedBaseConformances.push_back({Table.size(), &conf});

      Table.addNullPointer(IGM.Int8PtrTy);

    }

","    void addOutOfLineBaseProtocol(ProtocolDecl *baseProto) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::BaseProtocol

","
      assert(entry.getBaseProtocolWitness().Requirement == baseProto

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getBaseIndex(baseProto);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif

      

      SILEntries = SILEntries.slice(1);



      // TODO: Use the witness entry instead of falling through here.



      // Look for a protocol type info.

      const ProtocolInfo &basePI = IGM.getProtocolInfo(baseProto);

      const ProtocolConformance *astConf

        = Conformance.getInheritedConformance(baseProto);

      const ConformanceInfo &conf =

        basePI.getConformance(IGM, baseProto, astConf);



      // If we can emit the base witness table as a constant, do so.

      llvm::Constant *baseWitness = conf.tryGetConstantTable(IGM, ConcreteType);

      if (baseWitness) {

        Table.addBitCast(baseWitness, IGM.Int8PtrTy);

        return;

      }



      // Otherwise, we'll need to derive it at instantiation time.

      RequiresSpecialization = true;

      SpecializedBaseConformances.push_back({Table.size(), &conf});

      Table.addNullPointer(IGM.Int8PtrTy);

    }


"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),"    void addOutOfLineBaseProtocol(ProtocolDecl *baseProto) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::BaseProtocol

             && ""sil witness table does not match protocol"");

      assert(entry.getBaseProtocolWitness().Requirement == baseProto

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getBaseIndex(baseProto);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif

      

      SILEntries = SILEntries.slice(1);



      // TODO: Use the witness entry instead of falling through here.



      // Look for a protocol type info.

      const ProtocolInfo &basePI = IGM.getProtocolInfo(baseProto);

      const ProtocolConformance *astConf

        = Conformance.getInheritedConformance(baseProto);

      const ConformanceInfo &conf =

        basePI.getConformance(IGM, baseProto, astConf);



      // If we can emit the base witness table as a constant, do so.

      llvm::Constant *baseWitness = conf.tryGetConstantTable(IGM, ConcreteType);

      if (baseWitness) {

        Table.addBitCast(baseWitness, IGM.Int8PtrTy);

        return;

      }



      // Otherwise, we'll need to derive it at instantiation time.

      RequiresSpecialization = true;

      SpecializedBaseConformances.push_back({Table.size(), &conf});

      Table.addNullPointer(IGM.Int8PtrTy);

    }

","    void addOutOfLineBaseProtocol(ProtocolDecl *baseProto) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::BaseProtocol

             && ""sil witness table does not match protocol"");

      assert(entry.getBaseProtocolWitness().Requirement == baseProto

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getBaseIndex(baseProto);

     ","
             && ""offset doesn't match ProtocolInfo layout"");

#endif

      

      SILEntries = SILEntries.slice(1);



      // TODO: Use the witness entry instead of falling through here.



      // Look for a protocol type info.

      const ProtocolInfo &basePI = IGM.getProtocolInfo(baseProto);

      const ProtocolConformance *astConf

        = Conformance.getInheritedConformance(baseProto);

      const ConformanceInfo &conf =

        basePI.getConformance(IGM, baseProto, astConf);



      // If we can emit the base witness table as a constant, do so.

      llvm::Constant *baseWitness = conf.tryGetConstantTable(IGM, ConcreteType);

      if (baseWitness) {

        Table.addBitCast(baseWitness, IGM.Int8PtrTy);

        return;

      }



      // Otherwise, we'll need to derive it at instantiation time.

      RequiresSpecialization = true;

      SpecializedBaseConformances.push_back({Table.size(), &conf});

      Table.addNullPointer(IGM.Int8PtrTy);

    }

"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,-,assert(piEntry.getFunctionIndex().getValue() == Table.size(),"    void addMethodFromSILWitnessTable(AbstractFunctionDecl *requirement) {

      auto &entry = SILEntries.front();

      SILEntries = SILEntries.slice(1);



      // Handle missing optional requirements.

      if (entry.getKind() == SILWitnessTable::MissingOptional) {

        Table.addNullPointer(IGM.Int8PtrTy);

        return;

      }



#ifndef NDEBUG

      assert(entry.getKind() == SILWitnessTable::Method

             && ""sil witness table does not match protocol"");

      assert(entry.getMethodWitness().Requirement.getDecl() == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getFunctionIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILFunction *Func = entry.getMethodWitness().Witness;

      llvm::Constant *witness = nullptr;

      if (Func) {

        witness = IGM.getAddrOfSILFunction(Func, NotForDefinition);

      } else {

        // The method is removed by dead method elimination.

        // It should be never called. We add a pointer to an error function.

        witness = IGM.getDeletedMethodErrorFn();

      }

      Table.addBitCast(witness, IGM.Int8PtrTy);

      return;

    }

","    void addMethodFromSILWitnessTable(AbstractFunctionDecl *requirement) {

      auto &entry = SILEntries.front();

      SILEntries = SILEntries.slice(1);



      // Handle missing optional requirements.

      if (entry.getKind() == SILWitnessTable::MissingOptional) {

        Table.addNullPointer(IGM.Int8PtrTy);

        return;

","


#ifndef NDEBUG

      assert(entry.getKind() == SILWitnessTable::Method

             && ""sil witness table does not match protocol"");

      assert(entry.getMethodWitness().Requirement.getDecl() == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getFunctionIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILFunction *Func = entry.getMethodWitness().Witness;

      llvm::Constant *witness = nullptr;

      if (Func) {

        witness = IGM.getAddrOfSILFunction(Func, NotForDefinition);

      } else {

        // The method is removed by dead method elimination.

        // It should be never called. We add a pointer to an error function.

        witness = IGM.getDeletedMethodErrorFn();

      }

      Table.addBitCast(witness, IGM.Int8PtrTy);

      return;

    }


"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),"    void addMethodFromSILWitnessTable(AbstractFunctionDecl *requirement) {

      auto &entry = SILEntries.front();

      SILEntries = SILEntries.slice(1);



      // Handle missing optional requirements.

      if (entry.getKind() == SILWitnessTable::MissingOptional) {

        Table.addNullPointer(IGM.Int8PtrTy);

        return;

      }



#ifndef NDEBUG

      assert(entry.getKind() == SILWitnessTable::Method

             && ""sil witness table does not match protocol"");

      assert(entry.getMethodWitness().Requirement.getDecl() == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getFunctionIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILFunction *Func = entry.getMethodWitness().Witness;

      llvm::Constant *witness = nullptr;

      if (Func) {

        witness = IGM.getAddrOfSILFunction(Func, NotForDefinition);

      } else {

        // The method is removed by dead method elimination.

        // It should be never called. We add a pointer to an error function.

        witness = IGM.getDeletedMethodErrorFn();

      }

      Table.addBitCast(witness, IGM.Int8PtrTy);

      return;

    }

","    void addMethodFromSILWitnessTable(AbstractFunctionDecl *requirement) {

      auto &entry = SILEntries.front();

      SILEntries = SILEntries.slice(1);



      // Handle missing optional requirements.

      if (entry.getKind() == SILWitnessTable::MissingOptional) {

        Table.addNullPointer(IGM.Int8PtrTy);

        return;

      }



#ifndef NDEBUG

      assert(entry.getKind() == SILWitnessTable::Method

             && ""sil witness table does not match protocol"");

      assert(entry.getMethodWitness().Requirement.getDecl() == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getFunctionIndex(requirement);

     ","
             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILFunction *Func = entry.getMethodWitness().Witness;

      llvm::Constant *witness = nullptr;

      if (Func) {

        witness = IGM.getAddrOfSILFunction(Func, NotForDefinition);

      } else {

        // The method is removed by dead method elimination.

        // It should be never called. We add a pointer to an error function.

        witness = IGM.getDeletedMethodErrorFn();

      }

      Table.addBitCast(witness, IGM.Int8PtrTy);

      return;

    }

"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,-,assert(piEntry.getAssociatedTypeIndex().getValue() == Table.size(),"    void addAssociatedType(AssociatedTypeDecl *requirement) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::AssociatedType

             && ""sil witness table does not match protocol"");

      assert(entry.getAssociatedTypeWitness().Requirement == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getAssociatedTypeIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      const Substitution &sub =

        Conformance.getTypeWitness(requirement, nullptr);



      // This type will be expressed in terms of the archetypes

      // of the conforming context.

      CanType associate = sub.getReplacement()->getCanonicalType();

      assert(!associate->hasTypeParameter());



      llvm::Constant *metadataAccessFunction =

        getAssociatedTypeMetadataAccessFunction(requirement, associate);

      Table.addBitCast(metadataAccessFunction, IGM.Int8PtrTy);

    }

","    void addAssociatedType(AssociatedTypeDecl *requirement) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::AssociatedType

             && ""sil witness table does not match protocol"");

","
             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getAssociatedTypeIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      const Substitution &sub =

        Conformance.getTypeWitness(requirement, nullptr);



      // This type will be expressed in terms of the archetypes

      // of the conforming context.

      CanType associate = sub.getReplacement()->getCanonicalType();

      assert(!associate->hasTypeParameter());



      llvm::Constant *metadataAccessFunction =

        getAssociatedTypeMetadataAccessFunction(requirement, associate);

      Table.addBitCast(metadataAccessFunction, IGM.Int8PtrTy);

    }


"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),"    void addAssociatedType(AssociatedTypeDecl *requirement) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::AssociatedType

             && ""sil witness table does not match protocol"");

      assert(entry.getAssociatedTypeWitness().Requirement == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getAssociatedTypeIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      const Substitution &sub =

        Conformance.getTypeWitness(requirement, nullptr);



      // This type will be expressed in terms of the archetypes

      // of the conforming context.

      CanType associate = sub.getReplacement()->getCanonicalType();

      assert(!associate->hasTypeParameter());



      llvm::Constant *metadataAccessFunction =

        getAssociatedTypeMetadataAccessFunction(requirement, associate);

      Table.addBitCast(metadataAccessFunction, IGM.Int8PtrTy);

    }

","    void addAssociatedType(AssociatedTypeDecl *requirement) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::AssociatedType

             && ""sil witness table does not match protocol"");

      assert(entry.getAssociatedTypeWitness().Requirement == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getAssociatedTypeIndex(requirement);

     ","
             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      const Substitution &sub =

        Conformance.getTypeWitness(requirement, nullptr);



      // This type will be expressed in terms of the archetypes

      // of the conforming context.

      CanType associate = sub.getReplacement()->getCanonicalType();

      assert(!associate->hasTypeParameter());



      llvm::Constant *metadataAccessFunction =

        getAssociatedTypeMetadataAccessFunction(requirement, associate);

      Table.addBitCast(metadataAccessFunction, IGM.Int8PtrTy);

    }

"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,-,assert(protos.size() == sub.getConformances().size());,"    void addAssociatedType(AssociatedTypeDecl *requirement) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::AssociatedType

             && ""sil witness table does not match protocol"");

      assert(entry.getAssociatedTypeWitness().Requirement == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getAssociatedTypeIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      const Substitution &sub =

        Conformance.getTypeWitness(requirement, nullptr);



      // This type will be expressed in terms of the archetypes

      // of the conforming context.

      CanType associate = sub.getReplacement()->getCanonicalType();

      assert(!associate->hasTypeParameter());



      llvm::Constant *metadataAccessFunction =

        getAssociatedTypeMetadataAccessFunction(requirement, associate);

      Table.addBitCast(metadataAccessFunction, IGM.Int8PtrTy);

    }

","    void addAssociatedType(AssociatedTypeDecl *requirement) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::AssociatedType

             && ""sil witness table does not match protocol"");

      assert(entry.getAssociatedTypeWitness().Requirement == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getAssociatedTypeIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");
","#endif



      SILEntries = SILEntries.slice(1);



      const Substitution &sub =

        Conformance.getTypeWitness(requirement, nullptr);



      // This type will be expressed in terms of the archetypes

      // of the conforming context.

      CanType associate = sub.getReplacement()->getCanonicalType();

      assert(!associate->hasTypeParameter());



      llvm::Constant *metadataAccessFunction =

        getAssociatedTypeMetadataAccessFunction(requirement, associate);

      Table.addBitCast(metadataAccessFunction, IGM.Int8PtrTy);

    }


"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,+,assert(!associate->hasTypeParameter());,"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.addBitCast(wtableAccessFunction, IGM.Int8PtrTy);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

     ","


      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.addBitCast(wtableAccessFunction, IGM.Int8PtrTy);

    }

"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,-,assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol,"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.addBitCast(wtableAccessFunction, IGM.Int8PtrTy);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);


","#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.addBitCast(wtableAccessFunction, IGM.Int8PtrTy);

    }


"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,-,assert(associatedWitness.Requirement == requirement,"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.addBitCast(wtableAccessFunction, IGM.Int8PtrTy);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG
","      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.addBitCast(wtableAccessFunction, IGM.Int8PtrTy);

    }


"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,-,assert(associatedWitness.Protocol == protocol,"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.addBitCast(wtableAccessFunction, IGM.Int8PtrTy);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

","
      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.addBitCast(wtableAccessFunction, IGM.Int8PtrTy);

    }


"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,+,assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol,"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.addBitCast(wtableAccessFunction, IGM.Int8PtrTy);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

     ","
             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.addBitCast(wtableAccessFunction, IGM.Int8PtrTy);

    }

"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,+,assert(associatedWitness.Requirement->isEqual(associatedType),"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.addBitCast(wtableAccessFunction, IGM.Int8PtrTy);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

     ","
             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.addBitCast(wtableAccessFunction, IGM.Int8PtrTy);

    }

"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,+,assert(associatedWitness.Protocol == protocol,"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.addBitCast(wtableAccessFunction, IGM.Int8PtrTy);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

     ","
             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.addBitCast(wtableAccessFunction, IGM.Int8PtrTy);

    }

"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,+,assert(isa<GenericTypeParamType>(depAssociatedType)); // Self,"static void buildAssociatedTypeValueName(CanType depAssociatedType,

                                         SmallString<128> &name) {

  if (auto memberType = dyn_cast<DependentMemberType>(depAssociatedType)) {

    buildAssociatedTypeValueName(memberType.getBase(), name);

    name += '.';

    name += memberType->getName().str();

  } else {

    assert(isa<GenericTypeParamType>(depAssociatedType)); // Self

  }

}

","static void buildAssociatedTypeValueName(CanType depAssociatedType,

                                         SmallString<128> &name) {

  if (auto memberType = dyn_cast<DependentMemberType>(depAssociatedType)) {

    buildAssociatedTypeValueName(memberType.getBase(), name);

    name += '.';

    name += memberType->getName().str();

  } else {

   ","
  }

}

"
Merge CheckedCastValueBranch with new master,lib/IRGen/Linking.cpp,+,assert(isa<GenericTypeParamType>(assocType));,"static void mangleAssociatedTypePath(Mangler &mangler, CanType assocType) {

  if (auto memberType = dyn_cast<DependentMemberType>(assocType)) {

    mangleAssociatedTypePath(mangler, memberType.getBase());

    mangler.mangleIdentifier(memberType->getName().str());

  } else {

    assert(isa<GenericTypeParamType>(assocType));

  }

}

","static void mangleAssociatedTypePath(Mangler &mangler, CanType assocType) {

  if (auto memberType = dyn_cast<DependentMemberType>(assocType)) {

    mangleAssociatedTypePath(mangler, memberType.getBase());

    mangler.mangleIdentifier(memberType->getName().str());

  } else {

   ","
  }

}

"
Merge CheckedCastValueBranch with new master,lib/SIL/SILPrinter.cpp,+,"static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {","static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {

  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

    if (printAssociatedTypePath(OS, memberType.getBase()))

      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

    assert(isa<GenericTypeParamType>(path));

    return false;

  }

}

","static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {

  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

    if (printAssociatedTypePath(OS, memberType.getBase()))

      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

    assert(isa<GenericTypeParamType>(path));

    return false;

  }

}
","
  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

    if (printAssociatedTypePath(OS, memberType.getBase()))

      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

    assert(isa<GenericTypeParamType>(path));

    return false;

  }

}

"
Merge CheckedCastValueBranch with new master,lib/SIL/SILPrinter.cpp,+,"if (printAssociatedTypePath(OS, memberType.getBase()))","static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {

  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

    if (printAssociatedTypePath(OS, memberType.getBase()))

      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

    assert(isa<GenericTypeParamType>(path));

    return false;

  }

}

","static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {

  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

   ","
      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

    assert(isa<GenericTypeParamType>(path));

    return false;

  }

}

"
Merge CheckedCastValueBranch with new master,lib/SIL/SILPrinter.cpp,+,assert(isa<GenericTypeParamType>(path));,"static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {

  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

    if (printAssociatedTypePath(OS, memberType.getBase()))

      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

    assert(isa<GenericTypeParamType>(path));

    return false;

  }

}

","static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {

  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

    if (printAssociatedTypePath(OS, memberType.getBase()))

      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

   ","
    return false;

  }

}

"
Merge CheckedCastValueBranch with new master,lib/SILGen/RValue.cpp,+,assert(eltFormalType->isMaterializable());,"  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(gen, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

      ManagedValue elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = gen.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

","  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(gen, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

     ","


      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

      ManagedValue elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = gen.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

"
Merge CheckedCastValueBranch with new master,lib/SILGen/RValue.cpp,+,assert(eltTy.isAddress() == tuple.getType().isAddress());,"  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(gen, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

      ManagedValue elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = gen.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

","  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(gen, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

     ","
      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

      ManagedValue elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = gen.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

"
Merge CheckedCastValueBranch with new master,lib/SILGen/RValue.cpp,+,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,"  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(gen, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

      ManagedValue elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = gen.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

","  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(gen, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

     ","
      ManagedValue elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = gen.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

"
Merge CheckedCastValueBranch with new master,lib/SILGen/RValue.cpp,-,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,"  void visitAddressTupleType(CanTupleType tupleFormalType,

                             ManagedValue tupleMV) {

    bool isPlusZero = tupleMV.isPlusZeroRValueOrTrivial();

    SILValue tuple = tupleMV.forward(gen);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple->getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple->getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      SILValue elt = gen.B.createTupleElementAddr(loc, tuple, i, eltTy);



      // RValue has an invariant that loadable values have been

      // loaded.  Except it's not really an invariant, because

      // argument emission likes to lie sometimes.

      if (eltTI.isLoadable()) {

        elt = eltTI.emitLoad(gen.B, loc, elt, LoadOwnershipQualifier::Take);

      }



      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      auto eltMV = isPlusZero ? ManagedValue::forUnmanaged(elt)

                              : gen.emitManagedRValueWithCleanup(elt, eltTI);



      visit(eltFormalType, eltMV);

    }

  }

","  void visitAddressTupleType(CanTupleType tupleFormalType,

                             ManagedValue tupleMV) {

    bool isPlusZero = tupleMV.isPlusZeroRValueOrTrivial();

    SILValue tuple = tupleMV.forward(gen);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());

","
      auto eltTy = tuple->getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple->getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      SILValue elt = gen.B.createTupleElementAddr(loc, tuple, i, eltTy);



      // RValue has an invariant that loadable values have been

      // loaded.  Except it's not really an invariant, because

      // argument emission likes to lie sometimes.

      if (eltTI.isLoadable()) {

        elt = eltTI.emitLoad(gen.B, loc, elt, LoadOwnershipQualifier::Take);

      }



      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      auto eltMV = isPlusZero ? ManagedValue::forUnmanaged(elt)

                              : gen.emitManagedRValueWithCleanup(elt, eltTI);



      visit(eltFormalType, eltMV);

    }

  }


"
Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenDecl.cpp,-,assert(protos.size() == witness.getConformances().size(),"  void addAssociatedConformance(CanType dependentType, ProtocolDecl *protocol) {

    auto assocConformance =

      Conformance->getAssociatedConformance(dependentType, protocol);



    SGM.useConformance(assocConformance);



    Entries.push_back(SILWitnessTable::AssociatedTypeProtocolWitness{

        dependentType, protocol, assocConformance});

  }

","  void addAssociatedConformance(CanType dependentType, ProtocolDecl *protocol) {

","
      Conformance->getAssociatedConformance(dependentType, protocol);



    SGM.useConformance(assocConformance);



    Entries.push_back(SILWitnessTable::AssociatedTypeProtocolWitness{

        dependentType, protocol, assocConformance});

  }


"
Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenDecl.cpp,-,assert(witness.getConformances().empty(),"  void addAssociatedConformance(CanType dependentType, ProtocolDecl *protocol) {

    auto assocConformance =

      Conformance->getAssociatedConformance(dependentType, protocol);



    SGM.useConformance(assocConformance);



    Entries.push_back(SILWitnessTable::AssociatedTypeProtocolWitness{

        dependentType, protocol, assocConformance});

  }

","  void addAssociatedConformance(CanType dependentType, ProtocolDecl *protocol) {

    auto assocConformance =

      Conformance->getAssociatedConformance(dependentType, protocol);
","

    SGM.useConformance(assocConformance);



    Entries.push_back(SILWitnessTable::AssociatedTypeProtocolWitness{

        dependentType, protocol, assocConformance});

  }


"
Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenDecl.cpp,-,assert(foundConformance != witness.getConformances().end());,"static SILWitnessTable *

getWitnessTableToInsertAfter(SILGenModule &SGM,

                             NormalProtocolConformance *insertAfter) {

  while (insertAfter) {

    // If the table was emitted, emit after it.

    auto found = SGM.emittedWitnessTables.find(insertAfter);

    if (found != SGM.emittedWitnessTables.end())

      return found->second;



    // Otherwise, try inserting after the table we would transitively be

    // inserted after.

    auto foundDelayed = SGM.delayedConformances.find(insertAfter);

    if (foundDelayed != SGM.delayedConformances.end())

      insertAfter = foundDelayed->second.insertAfter;

    else

      break;

  }



  return nullptr;

}

","static SILWitnessTable *

getWitnessTableToInsertAfter(SILGenModule &SGM,

                             NormalProtocolConformance *insertAfter) {

  while (insertAfter) {

    // If the table was emitted, emit after it.

    auto found = SGM.emittedWitnessTables.find(insertAfter);

    if (found != SGM.emittedWitnessTables.end())
","      return found->second;



    // Otherwise, try inserting after the table we would transitively be

    // inserted after.

    auto foundDelayed = SGM.delayedConformances.find(insertAfter);

    if (foundDelayed != SGM.delayedConformances.end())

      insertAfter = foundDelayed->second.insertAfter;

    else

      break;

  }



  return nullptr;

}


"
Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,-,"F->getEffectsKind(), nullptr, F->getDebugScope());","void FunctionSignatureTransform::createFunctionSignatureOptimizedFunction() {

  // Create the optimized function !

  SILModule &M = F->getModule();

  std::string Name = createOptimizedSILFunctionName();

  SILLinkage linkage = F->getLinkage();

  if (isAvailableExternally(linkage))

    linkage = SILLinkage::Shared;



  DEBUG(llvm::dbgs() << ""  -> create specialized function "" << Name << ""\n"");



  NewF = M.createFunction(linkage, Name, createOptimizedSILFunctionType(),

                          F->getGenericEnvironment(), F->getLocation(),

                          F->isBare(), F->isTransparent(), F->isFragile(),

                          F->isThunk(), F->getClassVisibility(),

                          F->getInlineStrategy(), F->getEffectsKind(), nullptr,

                          F->getDebugScope());

  if (F->hasUnqualifiedOwnership()) {

    NewF->setUnqualifiedOwnership();

  }



  // Then we transfer the body of F to NewF.

  NewF->spliceBody(F);



  // Array semantic clients rely on the signature being as in the original

  // version.

  for (auto &Attr : F->getSemanticsAttrs()) {

    if (!StringRef(Attr).startswith(""array.""))

      NewF->addSemanticsAttr(Attr);

  }



  // Do the last bit of work to the newly created optimized function.

  ArgumentExplosionFinalizeOptimizedFunction();

  DeadArgumentFinalizeOptimizedFunction();



  // Create the thunk body !

  F->setThunk(IsThunk);

  // The thunk now carries the information on how the signature is

  // optimized. If we inline the thunk, we will get the benefit of calling

  // the signature optimized function without additional setup on the

  // caller side.

  F->setInlineStrategy(AlwaysInline);

  SILBasicBlock *ThunkBody = F->createBasicBlock();

  for (auto &ArgDesc : ArgumentDescList) {

    ThunkBody->createFunctionArgument(ArgDesc.Arg->getType(), ArgDesc.Decl);

  }



  SILLocation Loc = ThunkBody->getParent()->getLocation();

  SILBuilder Builder(ThunkBody);

  Builder.setCurrentDebugScope(ThunkBody->getParent()->getDebugScope());



  FunctionRefInst *FRI = Builder.createFunctionRef(Loc, NewF);



  // Create the args for the thunk's apply, ignoring any dead arguments.

  llvm::SmallVector<SILValue, 8> ThunkArgs;

  for (auto &ArgDesc : ArgumentDescList) {

    addThunkArgument(ArgDesc, Builder, ThunkBody, ThunkArgs);

  }



  // We are ignoring generic functions and functions with out parameters for

  // now.

  SILValue ReturnValue;

  SILType LoweredType = NewF->getLoweredType();

  SILType ResultType = NewF->getConventions().getSILResultType();

  auto FunctionTy = LoweredType.castTo<SILFunctionType>();

  if (FunctionTy->hasErrorResult()) {

    // We need a try_apply to call a function with an error result.

    SILFunction *Thunk = ThunkBody->getParent();

    SILBasicBlock *NormalBlock = Thunk->createBasicBlock();

    ReturnValue =

        NormalBlock->createPHIArgument(ResultType, ValueOwnershipKind::Owned);

    SILBasicBlock *ErrorBlock = Thunk->createBasicBlock();

    SILType Error =

        SILType::getPrimitiveObjectType(FunctionTy->getErrorResult().getType());

    auto *ErrorArg =

        ErrorBlock->createPHIArgument(Error, ValueOwnershipKind::Owned);

    Builder.createTryApply(Loc, FRI, LoweredType, SubstitutionList(),

                           ThunkArgs, NormalBlock, ErrorBlock);



    Builder.setInsertionPoint(ErrorBlock);

    Builder.createThrow(Loc, ErrorArg);

    Builder.setInsertionPoint(NormalBlock);

  } else {

    ReturnValue = Builder.createApply(Loc, FRI, LoweredType, ResultType,

                                      SubstitutionList(), ThunkArgs,

                                      false);

  }



  // Set up the return results.

  if (NewF->isNoReturnFunction()) {

    Builder.createUnreachable(Loc);

  } else {

    Builder.createReturn(Loc, ReturnValue);

  }



  // Do the last bit work to finalize the thunk.

  OwnedToGuaranteedFinalizeThunkFunction(Builder, F);

  assert(F->getDebugScope()->Parent != NewF->getDebugScope()->Parent);

}

","void FunctionSignatureTransform::createFunctionSignatureOptimizedFunction() {

  // Create the optimized function !

  SILModule &M = F->getModule();

  std::string Name = createOptimizedSILFunctionName();

  SILLinkage linkage = F->getLinkage();

  if (isAvailableExternally(linkage))

    linkage = SILLinkage::Shared;

","
  DEBUG(llvm::dbgs() << ""  -> create specialized function "" << Name << ""\n"");



  NewF = M.createFunction(linkage, Name, createOptimizedSILFunctionType(),

                          F->getGenericEnvironment(), F->getLocation(),

                          F->isBare(), F->isTransparent(), F->isFragile(),

                          F->isThunk(), F->getClassVisibility(),

                          F->getInlineStrategy(), F->getEffectsKind(), nullptr,

                          F->getDebugScope());

  if (F->hasUnqualifiedOwnership()) {

    NewF->setUnqualifiedOwnership();

  }



  // Then we transfer the body of F to NewF.

  NewF->spliceBody(F);



  // Array semantic clients rely on the signature being as in the original

  // version.

  for (auto &Attr : F->getSemanticsAttrs()) {

    if (!StringRef(Attr).startswith(""array.""))

      NewF->addSemanticsAttr(Attr);

  }



  // Do the last bit of work to the newly created optimized function.

  ArgumentExplosionFinalizeOptimizedFunction();

  DeadArgumentFinalizeOptimizedFunction();



  // Create the thunk body !

  F->setThunk(IsThunk);

  // The thunk now carries the information on how the signature is

  // optimized. If we inline the thunk, we will get the benefit of calling

  // the signature optimized function without additional setup on the

  // caller side.

  F->setInlineStrategy(AlwaysInline);

  SILBasicBlock *ThunkBody = F->createBasicBlock();

  for (auto &ArgDesc : ArgumentDescList) {

    ThunkBody->createFunctionArgument(ArgDesc.Arg->getType(), ArgDesc.Decl);

  }



  SILLocation Loc = ThunkBody->getParent()->getLocation();

  SILBuilder Builder(ThunkBody);

  Builder.setCurrentDebugScope(ThunkBody->getParent()->getDebugScope());



  FunctionRefInst *FRI = Builder.createFunctionRef(Loc, NewF);



  // Create the args for the thunk's apply, ignoring any dead arguments.

  llvm::SmallVector<SILValue, 8> ThunkArgs;

  for (auto &ArgDesc : ArgumentDescList) {

    addThunkArgument(ArgDesc, Builder, ThunkBody, ThunkArgs);

  }



  // We are ignoring generic functions and functions with out parameters for

  // now.

  SILValue ReturnValue;

  SILType LoweredType = NewF->getLoweredType();

  SILType ResultType = NewF->getConventions().getSILResultType();

  auto FunctionTy = LoweredType.castTo<SILFunctionType>();

  if (FunctionTy->hasErrorResult()) {

    // We need a try_apply to call a function with an error result.

    SILFunction *Thunk = ThunkBody->getParent();

    SILBasicBlock *NormalBlock = Thunk->createBasicBlock();

    ReturnValue =

        NormalBlock->createPHIArgument(ResultType, ValueOwnershipKind::Owned);

    SILBasicBlock *ErrorBlock = Thunk->createBasicBlock();

    SILType Error =

        SILType::getPrimitiveObjectType(FunctionTy->getErrorResult().getType());

    auto *ErrorArg =

        ErrorBlock->createPHIArgument(Error, ValueOwnershipKind::Owned);

    Builder.createTryApply(Loc, FRI, LoweredType, SubstitutionList(),

                           ThunkArgs, NormalBlock, ErrorBlock);



    Builder.setInsertionPoint(ErrorBlock);

    Builder.createThrow(Loc, ErrorArg);

    Builder.setInsertionPoint(NormalBlock);

  } else {

    ReturnValue = Builder.createApply(Loc, FRI, LoweredType, ResultType,

                                      SubstitutionList(), ThunkArgs,

                                      false);

  }



  // Set up the return results.

  if (NewF->isNoReturnFunction()) {

    Builder.createUnreachable(Loc);

  } else {

    Builder.createReturn(Loc, ReturnValue);

  }



  // Do the last bit work to finalize the thunk.

  OwnedToGuaranteedFinalizeThunkFunction(Builder, F);

  assert(F->getDebugScope()->Parent != NewF->getDebugScope()->Parent);

}


"
Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,F->getDebugScope());,"void FunctionSignatureTransform::createFunctionSignatureOptimizedFunction() {

  // Create the optimized function !

  SILModule &M = F->getModule();

  std::string Name = createOptimizedSILFunctionName();

  SILLinkage linkage = F->getLinkage();

  if (isAvailableExternally(linkage))

    linkage = SILLinkage::Shared;



  DEBUG(llvm::dbgs() << ""  -> create specialized function "" << Name << ""\n"");



  NewF = M.createFunction(linkage, Name, createOptimizedSILFunctionType(),

                          F->getGenericEnvironment(), F->getLocation(),

                          F->isBare(), F->isTransparent(), F->isFragile(),

                          F->isThunk(), F->getClassVisibility(),

                          F->getInlineStrategy(), F->getEffectsKind(), nullptr,

                          F->getDebugScope());

  if (F->hasUnqualifiedOwnership()) {

    NewF->setUnqualifiedOwnership();

  }



  // Then we transfer the body of F to NewF.

  NewF->spliceBody(F);



  // Array semantic clients rely on the signature being as in the original

  // version.

  for (auto &Attr : F->getSemanticsAttrs()) {

    if (!StringRef(Attr).startswith(""array.""))

      NewF->addSemanticsAttr(Attr);

  }



  // Do the last bit of work to the newly created optimized function.

  ArgumentExplosionFinalizeOptimizedFunction();

  DeadArgumentFinalizeOptimizedFunction();



  // Create the thunk body !

  F->setThunk(IsThunk);

  // The thunk now carries the information on how the signature is

  // optimized. If we inline the thunk, we will get the benefit of calling

  // the signature optimized function without additional setup on the

  // caller side.

  F->setInlineStrategy(AlwaysInline);

  SILBasicBlock *ThunkBody = F->createBasicBlock();

  for (auto &ArgDesc : ArgumentDescList) {

    ThunkBody->createFunctionArgument(ArgDesc.Arg->getType(), ArgDesc.Decl);

  }



  SILLocation Loc = ThunkBody->getParent()->getLocation();

  SILBuilder Builder(ThunkBody);

  Builder.setCurrentDebugScope(ThunkBody->getParent()->getDebugScope());



  FunctionRefInst *FRI = Builder.createFunctionRef(Loc, NewF);



  // Create the args for the thunk's apply, ignoring any dead arguments.

  llvm::SmallVector<SILValue, 8> ThunkArgs;

  for (auto &ArgDesc : ArgumentDescList) {

    addThunkArgument(ArgDesc, Builder, ThunkBody, ThunkArgs);

  }



  // We are ignoring generic functions and functions with out parameters for

  // now.

  SILValue ReturnValue;

  SILType LoweredType = NewF->getLoweredType();

  SILType ResultType = NewF->getConventions().getSILResultType();

  auto FunctionTy = LoweredType.castTo<SILFunctionType>();

  if (FunctionTy->hasErrorResult()) {

    // We need a try_apply to call a function with an error result.

    SILFunction *Thunk = ThunkBody->getParent();

    SILBasicBlock *NormalBlock = Thunk->createBasicBlock();

    ReturnValue =

        NormalBlock->createPHIArgument(ResultType, ValueOwnershipKind::Owned);

    SILBasicBlock *ErrorBlock = Thunk->createBasicBlock();

    SILType Error =

        SILType::getPrimitiveObjectType(FunctionTy->getErrorResult().getType());

    auto *ErrorArg =

        ErrorBlock->createPHIArgument(Error, ValueOwnershipKind::Owned);

    Builder.createTryApply(Loc, FRI, LoweredType, SubstitutionList(),

                           ThunkArgs, NormalBlock, ErrorBlock);



    Builder.setInsertionPoint(ErrorBlock);

    Builder.createThrow(Loc, ErrorArg);

    Builder.setInsertionPoint(NormalBlock);

  } else {

    ReturnValue = Builder.createApply(Loc, FRI, LoweredType, ResultType,

                                      SubstitutionList(), ThunkArgs,

                                      false);

  }



  // Set up the return results.

  if (NewF->isNoReturnFunction()) {

    Builder.createUnreachable(Loc);

  } else {

    Builder.createReturn(Loc, ReturnValue);

  }



  // Do the last bit work to finalize the thunk.

  OwnedToGuaranteedFinalizeThunkFunction(Builder, F);

  assert(F->getDebugScope()->Parent != NewF->getDebugScope()->Parent);

}

","void FunctionSignatureTransform::createFunctionSignatureOptimizedFunction() {

  // Create the optimized function !

  SILModule &M = F->getModule();

  std::string Name = createOptimizedSILFunctionName();

  SILLinkage linkage = F->getLinkage();

  if (isAvailableExternally(linkage))

    linkage = SILLinkage::Shared;



  DEBUG(llvm::dbgs() << ""  -> create specialized function "" << Name << ""\n"");



  NewF = M.createFunction(linkage, Name, createOptimizedSILFunctionType(),

                          F->getGenericEnvironment(), F->getLocation(),

                          F->isBare(), F->isTransparent(), F->isFragile(),

                          F->isThunk(), F->getClassVisibility(),

                          F->getInlineStrategy(), F->getEffectsKind(), nullptr,

                         ","
  if (F->hasUnqualifiedOwnership()) {

    NewF->setUnqualifiedOwnership();

  }



  // Then we transfer the body of F to NewF.

  NewF->spliceBody(F);



  // Array semantic clients rely on the signature being as in the original

  // version.

  for (auto &Attr : F->getSemanticsAttrs()) {

    if (!StringRef(Attr).startswith(""array.""))

      NewF->addSemanticsAttr(Attr);

  }



  // Do the last bit of work to the newly created optimized function.

  ArgumentExplosionFinalizeOptimizedFunction();

  DeadArgumentFinalizeOptimizedFunction();



  // Create the thunk body !

  F->setThunk(IsThunk);

  // The thunk now carries the information on how the signature is

  // optimized. If we inline the thunk, we will get the benefit of calling

  // the signature optimized function without additional setup on the

  // caller side.

  F->setInlineStrategy(AlwaysInline);

  SILBasicBlock *ThunkBody = F->createBasicBlock();

  for (auto &ArgDesc : ArgumentDescList) {

    ThunkBody->createFunctionArgument(ArgDesc.Arg->getType(), ArgDesc.Decl);

  }



  SILLocation Loc = ThunkBody->getParent()->getLocation();

  SILBuilder Builder(ThunkBody);

  Builder.setCurrentDebugScope(ThunkBody->getParent()->getDebugScope());



  FunctionRefInst *FRI = Builder.createFunctionRef(Loc, NewF);



  // Create the args for the thunk's apply, ignoring any dead arguments.

  llvm::SmallVector<SILValue, 8> ThunkArgs;

  for (auto &ArgDesc : ArgumentDescList) {

    addThunkArgument(ArgDesc, Builder, ThunkBody, ThunkArgs);

  }



  // We are ignoring generic functions and functions with out parameters for

  // now.

  SILValue ReturnValue;

  SILType LoweredType = NewF->getLoweredType();

  SILType ResultType = NewF->getConventions().getSILResultType();

  auto FunctionTy = LoweredType.castTo<SILFunctionType>();

  if (FunctionTy->hasErrorResult()) {

    // We need a try_apply to call a function with an error result.

    SILFunction *Thunk = ThunkBody->getParent();

    SILBasicBlock *NormalBlock = Thunk->createBasicBlock();

    ReturnValue =

        NormalBlock->createPHIArgument(ResultType, ValueOwnershipKind::Owned);

    SILBasicBlock *ErrorBlock = Thunk->createBasicBlock();

    SILType Error =

        SILType::getPrimitiveObjectType(FunctionTy->getErrorResult().getType());

    auto *ErrorArg =

        ErrorBlock->createPHIArgument(Error, ValueOwnershipKind::Owned);

    Builder.createTryApply(Loc, FRI, LoweredType, SubstitutionList(),

                           ThunkArgs, NormalBlock, ErrorBlock);



    Builder.setInsertionPoint(ErrorBlock);

    Builder.createThrow(Loc, ErrorArg);

    Builder.setInsertionPoint(NormalBlock);

  } else {

    ReturnValue = Builder.createApply(Loc, FRI, LoweredType, ResultType,

                                      SubstitutionList(), ThunkArgs,

                                      false);

  }



  // Set up the return results.

  if (NewF->isNoReturnFunction()) {

    Builder.createUnreachable(Loc);

  } else {

    Builder.createReturn(Loc, ReturnValue);

  }



  // Do the last bit work to finalize the thunk.

  OwnedToGuaranteedFinalizeThunkFunction(Builder, F);

  assert(F->getDebugScope()->Parent != NewF->getDebugScope()->Parent);

}

"
Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,-,"DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << OrigF->getName()","static bool shouldNotSpecializeCallee(SILFunction *Callee) {

  if (!Callee->shouldOptimize()) {

    DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << Callee->getName()

          << "" marked to be excluded from optimizations.\n"");

    return true;

  }



  if (Callee->hasSemanticsAttr(""optimize.sil.specialize.generic.never""))

    return true;



  return false;

}

","static bool shouldNotSpecializeCallee(SILFunction *Callee) {

  if (!Callee->shouldOptimize()) {

    DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << Callee->getName()
","          << "" marked to be excluded from optimizations.\n"");

    return true;

  }



  if (Callee->hasSemanticsAttr(""optimize.sil.specialize.generic.never""))

    return true;



  return false;

}


"
Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << Callee->getName()","static bool shouldNotSpecializeCallee(SILFunction *Callee) {

  if (!Callee->shouldOptimize()) {

    DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << Callee->getName()

          << "" marked to be excluded from optimizations.\n"");

    return true;

  }



  if (Callee->hasSemanticsAttr(""optimize.sil.specialize.generic.never""))

    return true;



  return false;

}

","static bool shouldNotSpecializeCallee(SILFunction *Callee) {

  if (!Callee->shouldOptimize()) {

   ","
          << "" marked to be excluded from optimizations.\n"");

    return true;

  }



  if (Callee->hasSemanticsAttr(""optimize.sil.specialize.generic.never""))

    return true;



  return false;

}

"
Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,assert(!CalleeSubstFnTy->isPolymorphic() &&,"static CanSILFunctionType

getCalleeSubstFunctionType(SILValue Callee, SubstitutionList Subs) {

  // Create a substituted callee type.

  auto CanFnTy =

      dyn_cast<SILFunctionType>(Callee->getType().getSwiftRValueType());

  auto CalleeSubstFnTy = CanFnTy;



  if (CanFnTy->isPolymorphic() && !Subs.empty()) {

    CalleeSubstFnTy = CanFnTy->substGenericArgs(*Callee->getModule(), Subs);

    assert(!CalleeSubstFnTy->isPolymorphic() &&

           ""Substituted callee type should not be polymorphic"");

    assert(!CalleeSubstFnTy->hasTypeParameter() &&

           ""Substituted callee type should not have type parameters"");

  }



  return CalleeSubstFnTy;

}

","static CanSILFunctionType

getCalleeSubstFunctionType(SILValue Callee, SubstitutionList Subs) {

  // Create a substituted callee type.

  auto CanFnTy =

      dyn_cast<SILFunctionType>(Callee->getType().getSwiftRValueType());

  auto CalleeSubstFnTy = CanFnTy;



  if (CanFnTy->isPolymorphic() && !Subs.empty()) {

    CalleeSubstFnTy = CanFnTy->substGenericArgs(*Callee->getModule(), Subs);

   ","
           ""Substituted callee type should not be polymorphic"");

    assert(!CalleeSubstFnTy->hasTypeParameter() &&

           ""Substituted callee type should not have type parameters"");

  }



  return CalleeSubstFnTy;

}

"
Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,assert(!CalleeSubstFnTy->hasTypeParameter() &&,"static CanSILFunctionType

getCalleeSubstFunctionType(SILValue Callee, SubstitutionList Subs) {

  // Create a substituted callee type.

  auto CanFnTy =

      dyn_cast<SILFunctionType>(Callee->getType().getSwiftRValueType());

  auto CalleeSubstFnTy = CanFnTy;



  if (CanFnTy->isPolymorphic() && !Subs.empty()) {

    CalleeSubstFnTy = CanFnTy->substGenericArgs(*Callee->getModule(), Subs);

    assert(!CalleeSubstFnTy->isPolymorphic() &&

           ""Substituted callee type should not be polymorphic"");

    assert(!CalleeSubstFnTy->hasTypeParameter() &&

           ""Substituted callee type should not have type parameters"");

  }



  return CalleeSubstFnTy;

}

","static CanSILFunctionType

getCalleeSubstFunctionType(SILValue Callee, SubstitutionList Subs) {

  // Create a substituted callee type.

  auto CanFnTy =

      dyn_cast<SILFunctionType>(Callee->getType().getSwiftRValueType());

  auto CalleeSubstFnTy = CanFnTy;



  if (CanFnTy->isPolymorphic() && !Subs.empty()) {

    CalleeSubstFnTy = CanFnTy->substGenericArgs(*Callee->getModule(), Subs);

    assert(!CalleeSubstFnTy->isPolymorphic() &&

           ""Substituted callee type should not be polymorphic"");

   ","
           ""Substituted callee type should not have type parameters"");

  }



  return CalleeSubstFnTy;

}

"
Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,-,"Arguments, ResultBB, TAI->getErrorBB());","static ApplySite replaceWithSpecializedCallee(ApplySite AI,

                                              SILValue Callee,

                                              SILBuilder &Builder,

                                              const ReabstractionInfo &ReInfo) {

  SILLocation Loc = AI.getLoc();

  SmallVector<SILValue, 4> Arguments;

  SILValue StoreResultTo;



  prepareCallArguments(AI, Builder, ReInfo, Arguments, StoreResultTo);



  // Create a substituted callee type.

  ArrayRef<Substitution> Subs;

  if (ReInfo.getSpecializedType()->isPolymorphic()) {

    Subs = ReInfo.getCallerParamSubstitutions();

  }



  auto CalleeSubstFnTy = getCalleeSubstFunctionType(Callee, Subs);

  auto CalleeSILSubstFnTy = SILType::getPrimitiveObjectType(CalleeSubstFnTy);

  SILFunctionConventions substConv(CalleeSubstFnTy, Builder.getModule());



  if (auto *TAI = dyn_cast<TryApplyInst>(AI)) {

    SILBasicBlock *ResultBB = TAI->getNormalBB();

    assert(ResultBB->getSinglePredecessorBlock() == TAI->getParent());

    auto *NewTAI =

        Builder.createTryApply(Loc, Callee, CalleeSILSubstFnTy, Subs, Arguments,

                               ResultBB, TAI->getErrorBB());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // The original normal result of the try_apply is an empty tuple.

      assert(ResultBB->getNumArguments() == 1);

      Builder.setInsertionPoint(ResultBB->begin());

      fixUsedVoidType(ResultBB->getArgument(0), Loc, Builder);



      SILArgument *Arg = ResultBB->replacePHIArgument(

          0, StoreResultTo->getType().getObjectType(),

          ValueOwnershipKind::Owned);

      // Store the direct result to the original result address.

      Builder.createStore(Loc, Arg, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    return NewTAI;

  }

  if (auto *A = dyn_cast<ApplyInst>(AI)) {

    auto *NewAI = Builder.createApply(Loc, Callee, CalleeSILSubstFnTy,

                                      substConv.getSILResultType(), Subs,

                                      Arguments, A->isNonThrowing());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // Store the direct result to the original result address.

      fixUsedVoidType(A, Loc, Builder);

      Builder.createStore(Loc, NewAI, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    A->replaceAllUsesWith(NewAI);

    return NewAI;

  }

  if (auto *PAI = dyn_cast<PartialApplyInst>(AI)) {

    CanSILFunctionType NewPAType = ReInfo.createSpecializedType(

        PAI->getFunctionType(), Builder.getModule());

    // SILType PTy =

    // SILType::getPrimitiveObjectType(ReInfo.getSpecializedType());

    SILType PTy = CalleeSILSubstFnTy;

    auto *NewPAI =

        Builder.createPartialApply(Loc, Callee, PTy, Subs, Arguments,

                                   SILType::getPrimitiveObjectType(NewPAType));

    PAI->replaceAllUsesWith(NewPAI);

    return NewPAI;

  }

  llvm_unreachable(""unhandled kind of apply"");

}

","static ApplySite replaceWithSpecializedCallee(ApplySite AI,

                                              SILValue Callee,

                                              SILBuilder &Builder,

                                              const ReabstractionInfo &ReInfo) {

  SILLocation Loc = AI.getLoc();

  SmallVector<SILValue, 4> Arguments;

  SILValue StoreResultTo;



  prepareCallArguments(AI, Builder, ReInfo, Arguments, StoreResultTo);



  // Create a substituted callee type.

  ArrayRef<Substitution> Subs;

  if (ReInfo.getSpecializedType()->isPolymorphic()) {
","    Subs = ReInfo.getCallerParamSubstitutions();

  }



  auto CalleeSubstFnTy = getCalleeSubstFunctionType(Callee, Subs);

  auto CalleeSILSubstFnTy = SILType::getPrimitiveObjectType(CalleeSubstFnTy);

  SILFunctionConventions substConv(CalleeSubstFnTy, Builder.getModule());



  if (auto *TAI = dyn_cast<TryApplyInst>(AI)) {

    SILBasicBlock *ResultBB = TAI->getNormalBB();

    assert(ResultBB->getSinglePredecessorBlock() == TAI->getParent());

    auto *NewTAI =

        Builder.createTryApply(Loc, Callee, CalleeSILSubstFnTy, Subs, Arguments,

                               ResultBB, TAI->getErrorBB());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // The original normal result of the try_apply is an empty tuple.

      assert(ResultBB->getNumArguments() == 1);

      Builder.setInsertionPoint(ResultBB->begin());

      fixUsedVoidType(ResultBB->getArgument(0), Loc, Builder);



      SILArgument *Arg = ResultBB->replacePHIArgument(

          0, StoreResultTo->getType().getObjectType(),

          ValueOwnershipKind::Owned);

      // Store the direct result to the original result address.

      Builder.createStore(Loc, Arg, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    return NewTAI;

  }

  if (auto *A = dyn_cast<ApplyInst>(AI)) {

    auto *NewAI = Builder.createApply(Loc, Callee, CalleeSILSubstFnTy,

                                      substConv.getSILResultType(), Subs,

                                      Arguments, A->isNonThrowing());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // Store the direct result to the original result address.

      fixUsedVoidType(A, Loc, Builder);

      Builder.createStore(Loc, NewAI, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    A->replaceAllUsesWith(NewAI);

    return NewAI;

  }

  if (auto *PAI = dyn_cast<PartialApplyInst>(AI)) {

    CanSILFunctionType NewPAType = ReInfo.createSpecializedType(

        PAI->getFunctionType(), Builder.getModule());

    // SILType PTy =

    // SILType::getPrimitiveObjectType(ReInfo.getSpecializedType());

    SILType PTy = CalleeSILSubstFnTy;

    auto *NewPAI =

        Builder.createPartialApply(Loc, Callee, PTy, Subs, Arguments,

                                   SILType::getPrimitiveObjectType(NewPAType));

    PAI->replaceAllUsesWith(NewPAI);

    return NewPAI;

  }

  llvm_unreachable(""unhandled kind of apply"");

}


"
Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,"ResultBB, TAI->getErrorBB());","static ApplySite replaceWithSpecializedCallee(ApplySite AI,

                                              SILValue Callee,

                                              SILBuilder &Builder,

                                              const ReabstractionInfo &ReInfo) {

  SILLocation Loc = AI.getLoc();

  SmallVector<SILValue, 4> Arguments;

  SILValue StoreResultTo;



  prepareCallArguments(AI, Builder, ReInfo, Arguments, StoreResultTo);



  // Create a substituted callee type.

  ArrayRef<Substitution> Subs;

  if (ReInfo.getSpecializedType()->isPolymorphic()) {

    Subs = ReInfo.getCallerParamSubstitutions();

  }



  auto CalleeSubstFnTy = getCalleeSubstFunctionType(Callee, Subs);

  auto CalleeSILSubstFnTy = SILType::getPrimitiveObjectType(CalleeSubstFnTy);

  SILFunctionConventions substConv(CalleeSubstFnTy, Builder.getModule());



  if (auto *TAI = dyn_cast<TryApplyInst>(AI)) {

    SILBasicBlock *ResultBB = TAI->getNormalBB();

    assert(ResultBB->getSinglePredecessorBlock() == TAI->getParent());

    auto *NewTAI =

        Builder.createTryApply(Loc, Callee, CalleeSILSubstFnTy, Subs, Arguments,

                               ResultBB, TAI->getErrorBB());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // The original normal result of the try_apply is an empty tuple.

      assert(ResultBB->getNumArguments() == 1);

      Builder.setInsertionPoint(ResultBB->begin());

      fixUsedVoidType(ResultBB->getArgument(0), Loc, Builder);



      SILArgument *Arg = ResultBB->replacePHIArgument(

          0, StoreResultTo->getType().getObjectType(),

          ValueOwnershipKind::Owned);

      // Store the direct result to the original result address.

      Builder.createStore(Loc, Arg, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    return NewTAI;

  }

  if (auto *A = dyn_cast<ApplyInst>(AI)) {

    auto *NewAI = Builder.createApply(Loc, Callee, CalleeSILSubstFnTy,

                                      substConv.getSILResultType(), Subs,

                                      Arguments, A->isNonThrowing());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // Store the direct result to the original result address.

      fixUsedVoidType(A, Loc, Builder);

      Builder.createStore(Loc, NewAI, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    A->replaceAllUsesWith(NewAI);

    return NewAI;

  }

  if (auto *PAI = dyn_cast<PartialApplyInst>(AI)) {

    CanSILFunctionType NewPAType = ReInfo.createSpecializedType(

        PAI->getFunctionType(), Builder.getModule());

    // SILType PTy =

    // SILType::getPrimitiveObjectType(ReInfo.getSpecializedType());

    SILType PTy = CalleeSILSubstFnTy;

    auto *NewPAI =

        Builder.createPartialApply(Loc, Callee, PTy, Subs, Arguments,

                                   SILType::getPrimitiveObjectType(NewPAType));

    PAI->replaceAllUsesWith(NewPAI);

    return NewPAI;

  }

  llvm_unreachable(""unhandled kind of apply"");

}

","static ApplySite replaceWithSpecializedCallee(ApplySite AI,

                                              SILValue Callee,

                                              SILBuilder &Builder,

                                              const ReabstractionInfo &ReInfo) {

  SILLocation Loc = AI.getLoc();

  SmallVector<SILValue, 4> Arguments;

  SILValue StoreResultTo;



  prepareCallArguments(AI, Builder, ReInfo, Arguments, StoreResultTo);



  // Create a substituted callee type.

  ArrayRef<Substitution> Subs;

  if (ReInfo.getSpecializedType()->isPolymorphic()) {

    Subs = ReInfo.getCallerParamSubstitutions();

  }



  auto CalleeSubstFnTy = getCalleeSubstFunctionType(Callee, Subs);

  auto CalleeSILSubstFnTy = SILType::getPrimitiveObjectType(CalleeSubstFnTy);

  SILFunctionConventions substConv(CalleeSubstFnTy, Builder.getModule());



  if (auto *TAI = dyn_cast<TryApplyInst>(AI)) {

    SILBasicBlock *ResultBB = TAI->getNormalBB();

    assert(ResultBB->getSinglePredecessorBlock() == TAI->getParent());

    auto *NewTAI =

        Builder.createTryApply(Loc, Callee, CalleeSILSubstFnTy, Subs, Arguments,

                              ","
    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // The original normal result of the try_apply is an empty tuple.

      assert(ResultBB->getNumArguments() == 1);

      Builder.setInsertionPoint(ResultBB->begin());

      fixUsedVoidType(ResultBB->getArgument(0), Loc, Builder);



      SILArgument *Arg = ResultBB->replacePHIArgument(

          0, StoreResultTo->getType().getObjectType(),

          ValueOwnershipKind::Owned);

      // Store the direct result to the original result address.

      Builder.createStore(Loc, Arg, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    return NewTAI;

  }

  if (auto *A = dyn_cast<ApplyInst>(AI)) {

    auto *NewAI = Builder.createApply(Loc, Callee, CalleeSILSubstFnTy,

                                      substConv.getSILResultType(), Subs,

                                      Arguments, A->isNonThrowing());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // Store the direct result to the original result address.

      fixUsedVoidType(A, Loc, Builder);

      Builder.createStore(Loc, NewAI, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    A->replaceAllUsesWith(NewAI);

    return NewAI;

  }

  if (auto *PAI = dyn_cast<PartialApplyInst>(AI)) {

    CanSILFunctionType NewPAType = ReInfo.createSpecializedType(

        PAI->getFunctionType(), Builder.getModule());

    // SILType PTy =

    // SILType::getPrimitiveObjectType(ReInfo.getSpecializedType());

    SILType PTy = CalleeSILSubstFnTy;

    auto *NewPAI =

        Builder.createPartialApply(Loc, Callee, PTy, Subs, Arguments,

                                   SILType::getPrimitiveObjectType(NewPAType));

    PAI->replaceAllUsesWith(NewPAI);

    return NewPAI;

  }

  llvm_unreachable(""unhandled kind of apply"");

}

"
"[Diagnostics] Allow ValueDecl* diagnostic arguments.

Render these via their full names.",lib/AST/DiagnosticEngine.cpp,+,Arg.getAsValueDecl()->getFullName().printPretty(Out);,"static void formatDiagnosticArgument(StringRef Modifier, 

                                     StringRef ModifierArguments,

                                     ArrayRef<DiagnosticArgument> Args,

                                     unsigned ArgIndex,

                                     llvm::raw_ostream &Out) {

  const DiagnosticArgument &Arg = Args[ArgIndex];

  switch (Arg.getKind()) {

  case DiagnosticArgumentKind::Integer:

    if (Modifier == ""select"") {

      assert(Arg.getAsInteger() >= 0 && ""Negative selection index"");

      formatSelectionArgument(ModifierArguments, Args, Arg.getAsInteger(), 

                              Out);

    } else if (Modifier == ""s"") {

      if (Arg.getAsInteger() != 1)

        Out << 's';

    } else {

      assert(Modifier.empty() && ""Improper modifier for integer argument"");

      Out << Arg.getAsInteger();

    }

    break;



  case DiagnosticArgumentKind::Unsigned:

    if (Modifier == ""select"") {

      formatSelectionArgument(ModifierArguments, Args, Arg.getAsUnsigned(), 

                              Out);

    } else if (Modifier == ""s"") {

      if (Arg.getAsUnsigned() != 1)

        Out << 's';

    } else {

      assert(Modifier.empty() && ""Improper modifier for unsigned argument"");

      Out << Arg.getAsUnsigned();

    }

    break;



  case DiagnosticArgumentKind::String:

    assert(Modifier.empty() && ""Improper modifier for string argument"");

    Out << Arg.getAsString();

    break;



  case DiagnosticArgumentKind::Identifier:

    assert(Modifier.empty() && ""Improper modifier for identifier argument"");

    Out << '\'';

    Arg.getAsIdentifier().printPretty(Out);

    Out << '\'';

    break;



  case DiagnosticArgumentKind::ObjCSelector:

    assert(Modifier.empty() && ""Improper modifier for selector argument"");

    Out << '\'' << Arg.getAsObjCSelector() << '\'';

    break;



  case DiagnosticArgumentKind::ValueDecl:

    Out << '\'';

    Arg.getAsValueDecl()->getFullName().printPretty(Out);

    Out << '\'';

    break;



  case DiagnosticArgumentKind::Type: {

    assert(Modifier.empty() && ""Improper modifier for Type argument"");

    

    // Strip extraneous parentheses; they add no value.

    auto type = Arg.getAsType()->getWithoutParens();

    std::string typeName = type->getString();

    Out << '\'' << typeName << '\'';





    // Decide whether to show the desugared type or not.  We filter out some

    // cases to avoid too much noise.

    bool showAKA = !type->isCanonical();



    // If we're complaining about a function type, don't ""aka"" just because of

    // differences in the argument or result types.

    if (showAKA && type->is<AnyFunctionType>() &&

        isa<AnyFunctionType>(type.getPointer()))

      showAKA = false;



    // Don't unwrap intentional sugar types like T? or [T].

    if (showAKA && (isa<SyntaxSugarType>(type.getPointer()) ||

                    isa<DictionaryType>(type.getPointer()) ||

                    type->is<BuiltinType>()))

      showAKA = false;



    // If they are textually the same, don't show them.  This can happen when

    // they are actually different types, because they exist in different scopes

    // (e.g. everyone names their type parameters 'T').

    if (showAKA && typeName == type->getCanonicalType()->getString())

      showAKA = false;



    // Don't show generic type parameters.

    if (showAKA && type->hasTypeParameter())

      showAKA = false;



    if (showAKA)

      Out << "" (aka '"" << type->getCanonicalType() << ""')"";

    break;

  }

  case DiagnosticArgumentKind::TypeRepr:

    assert(Modifier.empty() && ""Improper modifier for TypeRepr argument"");

    Out << '\'' << Arg.getAsTypeRepr() << '\'';

    break;

  case DiagnosticArgumentKind::PatternKind:

    assert(Modifier.empty() && ""Improper modifier for PatternKind argument"");

    Out << Arg.getAsPatternKind();

    break;

  case DiagnosticArgumentKind::StaticSpellingKind:

    if (Modifier == ""select"") {

      formatSelectionArgument(ModifierArguments, Args,

                              unsigned(Arg.getAsStaticSpellingKind()), Out);

    } else {

      assert(Modifier.empty() &&

             ""Improper modifier for StaticSpellingKind argument"");

      Out << Arg.getAsStaticSpellingKind();

    }

    break;



  case DiagnosticArgumentKind::DescriptiveDeclKind:

    assert(Modifier.empty() &&

           ""Improper modifier for DescriptiveDeclKind argument"");

    Out << Decl::getDescriptiveKindName(Arg.getAsDescriptiveDeclKind());

    break;



  case DiagnosticArgumentKind::DeclAttribute:

    assert(Modifier.empty() &&

           ""Improper modifier for DeclAttribute argument"");

    if (Arg.getAsDeclAttribute()->isDeclModifier())

      Out << '\'' << Arg.getAsDeclAttribute()->getAttrName() << '\'';

    else

      Out << '@' << Arg.getAsDeclAttribute()->getAttrName();

    break;



  case DiagnosticArgumentKind::VersionTuple:

    assert(Modifier.empty() &&

           ""Improper modifier for VersionTuple argument"");

    Out << Arg.getAsVersionTuple().getAsString();

    break;

  case DiagnosticArgumentKind::LayoutConstraint:

    assert(Modifier.empty() && ""Improper modifier for LayoutConstraint argument"");

    Out << '\'' << Arg.getAsLayoutConstraint() << '\'';

    break;

  }

}

","static void formatDiagnosticArgument(StringRef Modifier, 

                                     StringRef ModifierArguments,

                                     ArrayRef<DiagnosticArgument> Args,

                                     unsigned ArgIndex,

                                     llvm::raw_ostream &Out) {

  const DiagnosticArgument &Arg = Args[ArgIndex];

  switch (Arg.getKind()) {

  case DiagnosticArgumentKind::Integer:

    if (Modifier == ""select"") {

      assert(Arg.getAsInteger() >= 0 && ""Negative selection index"");

      formatSelectionArgument(ModifierArguments, Args, Arg.getAsInteger(), 

                              Out);

    } else if (Modifier == ""s"") {

      if (Arg.getAsInteger() != 1)

        Out << 's';

    } else {

      assert(Modifier.empty() && ""Improper modifier for integer argument"");

      Out << Arg.getAsInteger();

    }

    break;



  case DiagnosticArgumentKind::Unsigned:

    if (Modifier == ""select"") {

      formatSelectionArgument(ModifierArguments, Args, Arg.getAsUnsigned(), 

                              Out);

    } else if (Modifier == ""s"") {

      if (Arg.getAsUnsigned() != 1)

        Out << 's';

    } else {

      assert(Modifier.empty() && ""Improper modifier for unsigned argument"");

      Out << Arg.getAsUnsigned();

    }

    break;



  case DiagnosticArgumentKind::String:

    assert(Modifier.empty() && ""Improper modifier for string argument"");

    Out << Arg.getAsString();

    break;



  case DiagnosticArgumentKind::Identifier:

    assert(Modifier.empty() && ""Improper modifier for identifier argument"");

    Out << '\'';

    Arg.getAsIdentifier().printPretty(Out);

    Out << '\'';

    break;



  case DiagnosticArgumentKind::ObjCSelector:

    assert(Modifier.empty() && ""Improper modifier for selector argument"");

    Out << '\'' << Arg.getAsObjCSelector() << '\'';

    break;



  case DiagnosticArgumentKind::ValueDecl:

    Out << '\'';

   ","
    Out << '\'';

    break;



  case DiagnosticArgumentKind::Type: {

    assert(Modifier.empty() && ""Improper modifier for Type argument"");

    

    // Strip extraneous parentheses; they add no value.

    auto type = Arg.getAsType()->getWithoutParens();

    std::string typeName = type->getString();

    Out << '\'' << typeName << '\'';





    // Decide whether to show the desugared type or not.  We filter out some

    // cases to avoid too much noise.

    bool showAKA = !type->isCanonical();



    // If we're complaining about a function type, don't ""aka"" just because of

    // differences in the argument or result types.

    if (showAKA && type->is<AnyFunctionType>() &&

        isa<AnyFunctionType>(type.getPointer()))

      showAKA = false;



    // Don't unwrap intentional sugar types like T? or [T].

    if (showAKA && (isa<SyntaxSugarType>(type.getPointer()) ||

                    isa<DictionaryType>(type.getPointer()) ||

                    type->is<BuiltinType>()))

      showAKA = false;



    // If they are textually the same, don't show them.  This can happen when

    // they are actually different types, because they exist in different scopes

    // (e.g. everyone names their type parameters 'T').

    if (showAKA && typeName == type->getCanonicalType()->getString())

      showAKA = false;



    // Don't show generic type parameters.

    if (showAKA && type->hasTypeParameter())

      showAKA = false;



    if (showAKA)

      Out << "" (aka '"" << type->getCanonicalType() << ""')"";

    break;

  }

  case DiagnosticArgumentKind::TypeRepr:

    assert(Modifier.empty() && ""Improper modifier for TypeRepr argument"");

    Out << '\'' << Arg.getAsTypeRepr() << '\'';

    break;

  case DiagnosticArgumentKind::PatternKind:

    assert(Modifier.empty() && ""Improper modifier for PatternKind argument"");

    Out << Arg.getAsPatternKind();

    break;

  case DiagnosticArgumentKind::StaticSpellingKind:

    if (Modifier == ""select"") {

      formatSelectionArgument(ModifierArguments, Args,

                              unsigned(Arg.getAsStaticSpellingKind()), Out);

    } else {

      assert(Modifier.empty() &&

             ""Improper modifier for StaticSpellingKind argument"");

      Out << Arg.getAsStaticSpellingKind();

    }

    break;



  case DiagnosticArgumentKind::DescriptiveDeclKind:

    assert(Modifier.empty() &&

           ""Improper modifier for DescriptiveDeclKind argument"");

    Out << Decl::getDescriptiveKindName(Arg.getAsDescriptiveDeclKind());

    break;



  case DiagnosticArgumentKind::DeclAttribute:

    assert(Modifier.empty() &&

           ""Improper modifier for DeclAttribute argument"");

    if (Arg.getAsDeclAttribute()->isDeclModifier())

      Out << '\'' << Arg.getAsDeclAttribute()->getAttrName() << '\'';

    else

      Out << '@' << Arg.getAsDeclAttribute()->getAttrName();

    break;



  case DiagnosticArgumentKind::VersionTuple:

    assert(Modifier.empty() &&

           ""Improper modifier for VersionTuple argument"");

    Out << Arg.getAsVersionTuple().getAsString();

    break;

  case DiagnosticArgumentKind::LayoutConstraint:

    assert(Modifier.empty() && ""Improper modifier for LayoutConstraint argument"");

    Out << '\'' << Arg.getAsLayoutConstraint() << '\'';

    break;

  }

}

"
"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,+,"assert(fn && ""null impl provided"");","      static MethodDescriptor getIVarInitializer(llvm::Function *fn) {

        assert(fn && ""null impl provided"");

        return MethodDescriptor(Kind::IVarInitializer, fn);

      }

","      static MethodDescriptor getIVarInitializer(llvm::Function *fn) {

       ","
        return MethodDescriptor(Kind::IVarInitializer, fn);

      }

"
"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,+,"assert(fn && ""null impl provided"");","      static MethodDescriptor getIVarDestroyer(llvm::Function *fn) {

        assert(fn && ""null impl provided"");

        return MethodDescriptor(Kind::IVarDestroyer, fn);

      }

","      static MethodDescriptor getIVarDestroyer(llvm::Function *fn) {

       ","
        return MethodDescriptor(Kind::IVarDestroyer, fn);

      }

"
"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,+,assert(getKind() == Kind::Method);,"      AbstractFunctionDecl *getMethod() {

        assert(getKind() == Kind::Method);

        return static_cast<AbstractFunctionDecl*>(Data.getPointer());

      }

","      AbstractFunctionDecl *getMethod() {

       ","
        return static_cast<AbstractFunctionDecl*>(Data.getPointer());

      }

"
"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,+,assert(getKind() != Kind::Method);,"      llvm::Function *getImpl() {

        assert(getKind() != Kind::Method);

        return static_cast<llvm::Function*>(Data.getPointer());

      }

","      llvm::Function *getImpl() {

       ","
        return static_cast<llvm::Function*>(Data.getPointer());

      }

"
"[ClangImporter] Don't crash when a bad override affects NSErrors. (#7907)

Most of the time the name importer does a good job deciding whether to
import a particular method as throwing or not. However, when a method
is an override, it skips all that work and assumes the decisions made
for the superclass method apply here as well---which makes sense,
since you're going to get the subclass implementation if you call the
superclass's entry point. This can really throw things off if the
types /don't/ match up, though. Handle the one case where this is
legal according to the rules of Objective-C, and make sure we don't
import methods in the other cases.

rdar://problem/30705461",lib/ClangImporter/ImportType.cpp,-,assert(resultTy &&,"static Type

adjustResultTypeForThrowingFunction(ForeignErrorConvention::Info errorInfo,

                                    Type resultTy) {

  switch (errorInfo.TheKind) {

  case ForeignErrorConvention::ZeroResult:

  case ForeignErrorConvention::NonZeroResult:

    // Check for a bad override.

    if (resultTy->isVoid())

      return Type();

    return TupleType::getEmpty(resultTy->getASTContext());



  case ForeignErrorConvention::NilResult:

    if (Type unwrappedTy = resultTy->getAnyOptionalObjectType())

      return unwrappedTy;

    // Check for a bad override.

    if (resultTy->isVoid())

      return Type();

    // It's possible an Objective-C method overrides the base method to never

    // fail, and marks the method _Nonnull to indicate that. Swift can't

    // represent that, but it shouldn't fall over either.

    return resultTy;



  case ForeignErrorConvention::ZeroPreservedResult:

    // Check for a bad override.

    if (resultTy->isVoid())

      return Type();

    return resultTy;



  case ForeignErrorConvention::NonNilError:

    return resultTy;

  }



  llvm_unreachable(""Invalid ForeignErrorConvention."");

}

","static Type

adjustResultTypeForThrowingFunction(ForeignErrorConvention::Info errorInfo,

                                    Type resultTy) {

  switch (errorInfo.TheKind) {

  case ForeignErrorConvention::ZeroResult:

  case ForeignErrorConvention::NonZeroResult:

    // Check for a bad override.
","    if (resultTy->isVoid())

      return Type();

    return TupleType::getEmpty(resultTy->getASTContext());



  case ForeignErrorConvention::NilResult:

    if (Type unwrappedTy = resultTy->getAnyOptionalObjectType())

      return unwrappedTy;

    // Check for a bad override.

    if (resultTy->isVoid())

      return Type();

    // It's possible an Objective-C method overrides the base method to never

    // fail, and marks the method _Nonnull to indicate that. Swift can't

    // represent that, but it shouldn't fall over either.

    return resultTy;



  case ForeignErrorConvention::ZeroPreservedResult:

    // Check for a bad override.

    if (resultTy->isVoid())

      return Type();

    return resultTy;



  case ForeignErrorConvention::NonNilError:

    return resultTy;

  }



  llvm_unreachable(""Invalid ForeignErrorConvention."");

}


"
"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,+,"assert(fn && ""null impl provided"");","      static MethodDescriptor getIVarInitializer(llvm::Function *fn) {

        assert(fn && ""null impl provided"");

        return MethodDescriptor(Kind::IVarInitializer, fn);

      }

","      static MethodDescriptor getIVarInitializer(llvm::Function *fn) {

       ","
        return MethodDescriptor(Kind::IVarInitializer, fn);

      }

"
"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,+,"assert(fn && ""null impl provided"");","      static MethodDescriptor getIVarDestroyer(llvm::Function *fn) {

        assert(fn && ""null impl provided"");

        return MethodDescriptor(Kind::IVarDestroyer, fn);

      }

","      static MethodDescriptor getIVarDestroyer(llvm::Function *fn) {

       ","
        return MethodDescriptor(Kind::IVarDestroyer, fn);

      }

"
"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,+,assert(getKind() == Kind::Method);,"      AbstractFunctionDecl *getMethod() {

        assert(getKind() == Kind::Method);

        return static_cast<AbstractFunctionDecl*>(Data.getPointer());

      }

","      AbstractFunctionDecl *getMethod() {

       ","
        return static_cast<AbstractFunctionDecl*>(Data.getPointer());

      }

"
"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,+,assert(getKind() != Kind::Method);,"      llvm::Function *getImpl() {

        assert(getKind() != Kind::Method);

        return static_cast<llvm::Function*>(Data.getPointer());

      }

","      llvm::Function *getImpl() {

       ","
        return static_cast<llvm::Function*>(Data.getPointer());

      }

"
Merge pull request #7902 from gottesmm/mo_tuples_mo_problems,lib/SILGen/RValue.cpp,+,assert(eltFormalType->isMaterializable());,"  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(gen, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

      ManagedValue elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = gen.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

","  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(gen, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

     ","


      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

      ManagedValue elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = gen.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

"
Merge pull request #7902 from gottesmm/mo_tuples_mo_problems,lib/SILGen/RValue.cpp,+,assert(eltTy.isAddress() == tuple.getType().isAddress());,"  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(gen, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

      ManagedValue elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = gen.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

","  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(gen, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

     ","
      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

      ManagedValue elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = gen.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

"
Merge pull request #7902 from gottesmm/mo_tuples_mo_problems,lib/SILGen/RValue.cpp,+,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,"  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(gen, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

      ManagedValue elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = gen.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

","  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(gen, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

     ","
      ManagedValue elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = gen.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

"
Merge pull request #7902 from gottesmm/mo_tuples_mo_problems,lib/SILGen/RValue.cpp,-,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,"  void visitAddressTupleType(CanTupleType tupleFormalType,

                             ManagedValue tupleMV) {

    bool isPlusZero = tupleMV.isPlusZeroRValueOrTrivial();

    SILValue tuple = tupleMV.forward(gen);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple->getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple->getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      SILValue elt = gen.B.createTupleElementAddr(loc, tuple, i, eltTy);



      // RValue has an invariant that loadable values have been

      // loaded.  Except it's not really an invariant, because

      // argument emission likes to lie sometimes.

      if (eltTI.isLoadable()) {

        elt = eltTI.emitLoad(gen.B, loc, elt, LoadOwnershipQualifier::Take);

      }



      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      auto eltMV = isPlusZero ? ManagedValue::forUnmanaged(elt)

                              : gen.emitManagedRValueWithCleanup(elt, eltTI);



      visit(eltFormalType, eltMV);

    }

  }

","  void visitAddressTupleType(CanTupleType tupleFormalType,

                             ManagedValue tupleMV) {

    bool isPlusZero = tupleMV.isPlusZeroRValueOrTrivial();

    SILValue tuple = tupleMV.forward(gen);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());

","
      auto eltTy = tuple->getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple->getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      SILValue elt = gen.B.createTupleElementAddr(loc, tuple, i, eltTy);



      // RValue has an invariant that loadable values have been

      // loaded.  Except it's not really an invariant, because

      // argument emission likes to lie sometimes.

      if (eltTI.isLoadable()) {

        elt = eltTI.emitLoad(gen.B, loc, elt, LoadOwnershipQualifier::Take);

      }



      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      auto eltMV = isPlusZero ? ManagedValue::forUnmanaged(elt)

                              : gen.emitManagedRValueWithCleanup(elt, eltTI);



      visit(eltFormalType, eltMV);

    }

  }


"
"[silgen] Fix another tuple explosion -> borrow + copy since we do not have the destructure operation yet.

rdar://29791263",lib/SILGen/RValue.cpp,+,assert(eltFormalType->isMaterializable());,"  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(gen, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

      ManagedValue elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = gen.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

","  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(gen, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

     ","


      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

      ManagedValue elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = gen.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

"
"[silgen] Fix another tuple explosion -> borrow + copy since we do not have the destructure operation yet.

rdar://29791263",lib/SILGen/RValue.cpp,+,assert(eltTy.isAddress() == tuple.getType().isAddress());,"  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(gen, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

      ManagedValue elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = gen.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

","  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(gen, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

     ","
      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

      ManagedValue elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = gen.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

"
"[silgen] Fix another tuple explosion -> borrow + copy since we do not have the destructure operation yet.

rdar://29791263",lib/SILGen/RValue.cpp,+,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,"  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(gen, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

      ManagedValue elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = gen.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

","  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(gen, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

     ","
      ManagedValue elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = gen.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

"
"[silgen] Fix another tuple explosion -> borrow + copy since we do not have the destructure operation yet.

rdar://29791263",lib/SILGen/RValue.cpp,-,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,"  void visitAddressTupleType(CanTupleType tupleFormalType,

                             ManagedValue tupleMV) {

    bool isPlusZero = tupleMV.isPlusZeroRValueOrTrivial();

    SILValue tuple = tupleMV.forward(gen);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple->getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple->getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      SILValue elt = gen.B.createTupleElementAddr(loc, tuple, i, eltTy);



      // RValue has an invariant that loadable values have been

      // loaded.  Except it's not really an invariant, because

      // argument emission likes to lie sometimes.

      if (eltTI.isLoadable()) {

        elt = eltTI.emitLoad(gen.B, loc, elt, LoadOwnershipQualifier::Take);

      }



      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      auto eltMV = isPlusZero ? ManagedValue::forUnmanaged(elt)

                              : gen.emitManagedRValueWithCleanup(elt, eltTI);



      visit(eltFormalType, eltMV);

    }

  }

","  void visitAddressTupleType(CanTupleType tupleFormalType,

                             ManagedValue tupleMV) {

    bool isPlusZero = tupleMV.isPlusZeroRValueOrTrivial();

    SILValue tuple = tupleMV.forward(gen);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());

","
      auto eltTy = tuple->getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple->getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      SILValue elt = gen.B.createTupleElementAddr(loc, tuple, i, eltTy);



      // RValue has an invariant that loadable values have been

      // loaded.  Except it's not really an invariant, because

      // argument emission likes to lie sometimes.

      if (eltTI.isLoadable()) {

        elt = eltTI.emitLoad(gen.B, loc, elt, LoadOwnershipQualifier::Take);

      }



      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      auto eltMV = isPlusZero ? ManagedValue::forUnmanaged(elt)

                              : gen.emitManagedRValueWithCleanup(elt, eltTI);



      visit(eltFormalType, eltMV);

    }

  }


"
"Merge pull request #7915 from slavapestov/debug-info-generics-inlining-fix

DebugInfo generics inlining fix",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,-,"F->getEffectsKind(), nullptr, F->getDebugScope());","void FunctionSignatureTransform::createFunctionSignatureOptimizedFunction() {

  // Create the optimized function !

  SILModule &M = F->getModule();

  std::string Name = createOptimizedSILFunctionName();

  SILLinkage linkage = F->getLinkage();

  if (isAvailableExternally(linkage))

    linkage = SILLinkage::Shared;



  DEBUG(llvm::dbgs() << ""  -> create specialized function "" << Name << ""\n"");



  NewF = M.createFunction(linkage, Name, createOptimizedSILFunctionType(),

                          F->getGenericEnvironment(), F->getLocation(),

                          F->isBare(), F->isTransparent(), F->isFragile(),

                          F->isThunk(), F->getClassVisibility(),

                          F->getInlineStrategy(), F->getEffectsKind(), nullptr,

                          F->getDebugScope());

  if (F->hasUnqualifiedOwnership()) {

    NewF->setUnqualifiedOwnership();

  }



  // Then we transfer the body of F to NewF.

  NewF->spliceBody(F);



  // Array semantic clients rely on the signature being as in the original

  // version.

  for (auto &Attr : F->getSemanticsAttrs()) {

    if (!StringRef(Attr).startswith(""array.""))

      NewF->addSemanticsAttr(Attr);

  }



  // Do the last bit of work to the newly created optimized function.

  ArgumentExplosionFinalizeOptimizedFunction();

  DeadArgumentFinalizeOptimizedFunction();



  // Create the thunk body !

  F->setThunk(IsThunk);

  // The thunk now carries the information on how the signature is

  // optimized. If we inline the thunk, we will get the benefit of calling

  // the signature optimized function without additional setup on the

  // caller side.

  F->setInlineStrategy(AlwaysInline);

  SILBasicBlock *ThunkBody = F->createBasicBlock();

  for (auto &ArgDesc : ArgumentDescList) {

    ThunkBody->createFunctionArgument(ArgDesc.Arg->getType(), ArgDesc.Decl);

  }



  SILLocation Loc = ThunkBody->getParent()->getLocation();

  SILBuilder Builder(ThunkBody);

  Builder.setCurrentDebugScope(ThunkBody->getParent()->getDebugScope());



  FunctionRefInst *FRI = Builder.createFunctionRef(Loc, NewF);



  // Create the args for the thunk's apply, ignoring any dead arguments.

  llvm::SmallVector<SILValue, 8> ThunkArgs;

  for (auto &ArgDesc : ArgumentDescList) {

    addThunkArgument(ArgDesc, Builder, ThunkBody, ThunkArgs);

  }



  // We are ignoring generic functions and functions with out parameters for

  // now.

  SILValue ReturnValue;

  SILType LoweredType = NewF->getLoweredType();

  SILType ResultType = NewF->getConventions().getSILResultType();

  auto FunctionTy = LoweredType.castTo<SILFunctionType>();

  if (FunctionTy->hasErrorResult()) {

    // We need a try_apply to call a function with an error result.

    SILFunction *Thunk = ThunkBody->getParent();

    SILBasicBlock *NormalBlock = Thunk->createBasicBlock();

    ReturnValue =

        NormalBlock->createPHIArgument(ResultType, ValueOwnershipKind::Owned);

    SILBasicBlock *ErrorBlock = Thunk->createBasicBlock();

    SILType Error =

        SILType::getPrimitiveObjectType(FunctionTy->getErrorResult().getType());

    auto *ErrorArg =

        ErrorBlock->createPHIArgument(Error, ValueOwnershipKind::Owned);

    Builder.createTryApply(Loc, FRI, LoweredType, SubstitutionList(),

                           ThunkArgs, NormalBlock, ErrorBlock);



    Builder.setInsertionPoint(ErrorBlock);

    Builder.createThrow(Loc, ErrorArg);

    Builder.setInsertionPoint(NormalBlock);

  } else {

    ReturnValue = Builder.createApply(Loc, FRI, LoweredType, ResultType,

                                      SubstitutionList(), ThunkArgs,

                                      false);

  }



  // Set up the return results.

  if (NewF->isNoReturnFunction()) {

    Builder.createUnreachable(Loc);

  } else {

    Builder.createReturn(Loc, ReturnValue);

  }



  // Do the last bit work to finalize the thunk.

  OwnedToGuaranteedFinalizeThunkFunction(Builder, F);

  assert(F->getDebugScope()->Parent != NewF->getDebugScope()->Parent);

}

","void FunctionSignatureTransform::createFunctionSignatureOptimizedFunction() {

  // Create the optimized function !

  SILModule &M = F->getModule();

  std::string Name = createOptimizedSILFunctionName();

  SILLinkage linkage = F->getLinkage();

  if (isAvailableExternally(linkage))

    linkage = SILLinkage::Shared;

","
  DEBUG(llvm::dbgs() << ""  -> create specialized function "" << Name << ""\n"");



  NewF = M.createFunction(linkage, Name, createOptimizedSILFunctionType(),

                          F->getGenericEnvironment(), F->getLocation(),

                          F->isBare(), F->isTransparent(), F->isFragile(),

                          F->isThunk(), F->getClassVisibility(),

                          F->getInlineStrategy(), F->getEffectsKind(), nullptr,

                          F->getDebugScope());

  if (F->hasUnqualifiedOwnership()) {

    NewF->setUnqualifiedOwnership();

  }



  // Then we transfer the body of F to NewF.

  NewF->spliceBody(F);



  // Array semantic clients rely on the signature being as in the original

  // version.

  for (auto &Attr : F->getSemanticsAttrs()) {

    if (!StringRef(Attr).startswith(""array.""))

      NewF->addSemanticsAttr(Attr);

  }



  // Do the last bit of work to the newly created optimized function.

  ArgumentExplosionFinalizeOptimizedFunction();

  DeadArgumentFinalizeOptimizedFunction();



  // Create the thunk body !

  F->setThunk(IsThunk);

  // The thunk now carries the information on how the signature is

  // optimized. If we inline the thunk, we will get the benefit of calling

  // the signature optimized function without additional setup on the

  // caller side.

  F->setInlineStrategy(AlwaysInline);

  SILBasicBlock *ThunkBody = F->createBasicBlock();

  for (auto &ArgDesc : ArgumentDescList) {

    ThunkBody->createFunctionArgument(ArgDesc.Arg->getType(), ArgDesc.Decl);

  }



  SILLocation Loc = ThunkBody->getParent()->getLocation();

  SILBuilder Builder(ThunkBody);

  Builder.setCurrentDebugScope(ThunkBody->getParent()->getDebugScope());



  FunctionRefInst *FRI = Builder.createFunctionRef(Loc, NewF);



  // Create the args for the thunk's apply, ignoring any dead arguments.

  llvm::SmallVector<SILValue, 8> ThunkArgs;

  for (auto &ArgDesc : ArgumentDescList) {

    addThunkArgument(ArgDesc, Builder, ThunkBody, ThunkArgs);

  }



  // We are ignoring generic functions and functions with out parameters for

  // now.

  SILValue ReturnValue;

  SILType LoweredType = NewF->getLoweredType();

  SILType ResultType = NewF->getConventions().getSILResultType();

  auto FunctionTy = LoweredType.castTo<SILFunctionType>();

  if (FunctionTy->hasErrorResult()) {

    // We need a try_apply to call a function with an error result.

    SILFunction *Thunk = ThunkBody->getParent();

    SILBasicBlock *NormalBlock = Thunk->createBasicBlock();

    ReturnValue =

        NormalBlock->createPHIArgument(ResultType, ValueOwnershipKind::Owned);

    SILBasicBlock *ErrorBlock = Thunk->createBasicBlock();

    SILType Error =

        SILType::getPrimitiveObjectType(FunctionTy->getErrorResult().getType());

    auto *ErrorArg =

        ErrorBlock->createPHIArgument(Error, ValueOwnershipKind::Owned);

    Builder.createTryApply(Loc, FRI, LoweredType, SubstitutionList(),

                           ThunkArgs, NormalBlock, ErrorBlock);



    Builder.setInsertionPoint(ErrorBlock);

    Builder.createThrow(Loc, ErrorArg);

    Builder.setInsertionPoint(NormalBlock);

  } else {

    ReturnValue = Builder.createApply(Loc, FRI, LoweredType, ResultType,

                                      SubstitutionList(), ThunkArgs,

                                      false);

  }



  // Set up the return results.

  if (NewF->isNoReturnFunction()) {

    Builder.createUnreachable(Loc);

  } else {

    Builder.createReturn(Loc, ReturnValue);

  }



  // Do the last bit work to finalize the thunk.

  OwnedToGuaranteedFinalizeThunkFunction(Builder, F);

  assert(F->getDebugScope()->Parent != NewF->getDebugScope()->Parent);

}


"
"Merge pull request #7915 from slavapestov/debug-info-generics-inlining-fix

DebugInfo generics inlining fix",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,F->getDebugScope());,"void FunctionSignatureTransform::createFunctionSignatureOptimizedFunction() {

  // Create the optimized function !

  SILModule &M = F->getModule();

  std::string Name = createOptimizedSILFunctionName();

  SILLinkage linkage = F->getLinkage();

  if (isAvailableExternally(linkage))

    linkage = SILLinkage::Shared;



  DEBUG(llvm::dbgs() << ""  -> create specialized function "" << Name << ""\n"");



  NewF = M.createFunction(linkage, Name, createOptimizedSILFunctionType(),

                          F->getGenericEnvironment(), F->getLocation(),

                          F->isBare(), F->isTransparent(), F->isFragile(),

                          F->isThunk(), F->getClassVisibility(),

                          F->getInlineStrategy(), F->getEffectsKind(), nullptr,

                          F->getDebugScope());

  if (F->hasUnqualifiedOwnership()) {

    NewF->setUnqualifiedOwnership();

  }



  // Then we transfer the body of F to NewF.

  NewF->spliceBody(F);



  // Array semantic clients rely on the signature being as in the original

  // version.

  for (auto &Attr : F->getSemanticsAttrs()) {

    if (!StringRef(Attr).startswith(""array.""))

      NewF->addSemanticsAttr(Attr);

  }



  // Do the last bit of work to the newly created optimized function.

  ArgumentExplosionFinalizeOptimizedFunction();

  DeadArgumentFinalizeOptimizedFunction();



  // Create the thunk body !

  F->setThunk(IsThunk);

  // The thunk now carries the information on how the signature is

  // optimized. If we inline the thunk, we will get the benefit of calling

  // the signature optimized function without additional setup on the

  // caller side.

  F->setInlineStrategy(AlwaysInline);

  SILBasicBlock *ThunkBody = F->createBasicBlock();

  for (auto &ArgDesc : ArgumentDescList) {

    ThunkBody->createFunctionArgument(ArgDesc.Arg->getType(), ArgDesc.Decl);

  }



  SILLocation Loc = ThunkBody->getParent()->getLocation();

  SILBuilder Builder(ThunkBody);

  Builder.setCurrentDebugScope(ThunkBody->getParent()->getDebugScope());



  FunctionRefInst *FRI = Builder.createFunctionRef(Loc, NewF);



  // Create the args for the thunk's apply, ignoring any dead arguments.

  llvm::SmallVector<SILValue, 8> ThunkArgs;

  for (auto &ArgDesc : ArgumentDescList) {

    addThunkArgument(ArgDesc, Builder, ThunkBody, ThunkArgs);

  }



  // We are ignoring generic functions and functions with out parameters for

  // now.

  SILValue ReturnValue;

  SILType LoweredType = NewF->getLoweredType();

  SILType ResultType = NewF->getConventions().getSILResultType();

  auto FunctionTy = LoweredType.castTo<SILFunctionType>();

  if (FunctionTy->hasErrorResult()) {

    // We need a try_apply to call a function with an error result.

    SILFunction *Thunk = ThunkBody->getParent();

    SILBasicBlock *NormalBlock = Thunk->createBasicBlock();

    ReturnValue =

        NormalBlock->createPHIArgument(ResultType, ValueOwnershipKind::Owned);

    SILBasicBlock *ErrorBlock = Thunk->createBasicBlock();

    SILType Error =

        SILType::getPrimitiveObjectType(FunctionTy->getErrorResult().getType());

    auto *ErrorArg =

        ErrorBlock->createPHIArgument(Error, ValueOwnershipKind::Owned);

    Builder.createTryApply(Loc, FRI, LoweredType, SubstitutionList(),

                           ThunkArgs, NormalBlock, ErrorBlock);



    Builder.setInsertionPoint(ErrorBlock);

    Builder.createThrow(Loc, ErrorArg);

    Builder.setInsertionPoint(NormalBlock);

  } else {

    ReturnValue = Builder.createApply(Loc, FRI, LoweredType, ResultType,

                                      SubstitutionList(), ThunkArgs,

                                      false);

  }



  // Set up the return results.

  if (NewF->isNoReturnFunction()) {

    Builder.createUnreachable(Loc);

  } else {

    Builder.createReturn(Loc, ReturnValue);

  }



  // Do the last bit work to finalize the thunk.

  OwnedToGuaranteedFinalizeThunkFunction(Builder, F);

  assert(F->getDebugScope()->Parent != NewF->getDebugScope()->Parent);

}

","void FunctionSignatureTransform::createFunctionSignatureOptimizedFunction() {

  // Create the optimized function !

  SILModule &M = F->getModule();

  std::string Name = createOptimizedSILFunctionName();

  SILLinkage linkage = F->getLinkage();

  if (isAvailableExternally(linkage))

    linkage = SILLinkage::Shared;



  DEBUG(llvm::dbgs() << ""  -> create specialized function "" << Name << ""\n"");



  NewF = M.createFunction(linkage, Name, createOptimizedSILFunctionType(),

                          F->getGenericEnvironment(), F->getLocation(),

                          F->isBare(), F->isTransparent(), F->isFragile(),

                          F->isThunk(), F->getClassVisibility(),

                          F->getInlineStrategy(), F->getEffectsKind(), nullptr,

                         ","
  if (F->hasUnqualifiedOwnership()) {

    NewF->setUnqualifiedOwnership();

  }



  // Then we transfer the body of F to NewF.

  NewF->spliceBody(F);



  // Array semantic clients rely on the signature being as in the original

  // version.

  for (auto &Attr : F->getSemanticsAttrs()) {

    if (!StringRef(Attr).startswith(""array.""))

      NewF->addSemanticsAttr(Attr);

  }



  // Do the last bit of work to the newly created optimized function.

  ArgumentExplosionFinalizeOptimizedFunction();

  DeadArgumentFinalizeOptimizedFunction();



  // Create the thunk body !

  F->setThunk(IsThunk);

  // The thunk now carries the information on how the signature is

  // optimized. If we inline the thunk, we will get the benefit of calling

  // the signature optimized function without additional setup on the

  // caller side.

  F->setInlineStrategy(AlwaysInline);

  SILBasicBlock *ThunkBody = F->createBasicBlock();

  for (auto &ArgDesc : ArgumentDescList) {

    ThunkBody->createFunctionArgument(ArgDesc.Arg->getType(), ArgDesc.Decl);

  }



  SILLocation Loc = ThunkBody->getParent()->getLocation();

  SILBuilder Builder(ThunkBody);

  Builder.setCurrentDebugScope(ThunkBody->getParent()->getDebugScope());



  FunctionRefInst *FRI = Builder.createFunctionRef(Loc, NewF);



  // Create the args for the thunk's apply, ignoring any dead arguments.

  llvm::SmallVector<SILValue, 8> ThunkArgs;

  for (auto &ArgDesc : ArgumentDescList) {

    addThunkArgument(ArgDesc, Builder, ThunkBody, ThunkArgs);

  }



  // We are ignoring generic functions and functions with out parameters for

  // now.

  SILValue ReturnValue;

  SILType LoweredType = NewF->getLoweredType();

  SILType ResultType = NewF->getConventions().getSILResultType();

  auto FunctionTy = LoweredType.castTo<SILFunctionType>();

  if (FunctionTy->hasErrorResult()) {

    // We need a try_apply to call a function with an error result.

    SILFunction *Thunk = ThunkBody->getParent();

    SILBasicBlock *NormalBlock = Thunk->createBasicBlock();

    ReturnValue =

        NormalBlock->createPHIArgument(ResultType, ValueOwnershipKind::Owned);

    SILBasicBlock *ErrorBlock = Thunk->createBasicBlock();

    SILType Error =

        SILType::getPrimitiveObjectType(FunctionTy->getErrorResult().getType());

    auto *ErrorArg =

        ErrorBlock->createPHIArgument(Error, ValueOwnershipKind::Owned);

    Builder.createTryApply(Loc, FRI, LoweredType, SubstitutionList(),

                           ThunkArgs, NormalBlock, ErrorBlock);



    Builder.setInsertionPoint(ErrorBlock);

    Builder.createThrow(Loc, ErrorArg);

    Builder.setInsertionPoint(NormalBlock);

  } else {

    ReturnValue = Builder.createApply(Loc, FRI, LoweredType, ResultType,

                                      SubstitutionList(), ThunkArgs,

                                      false);

  }



  // Set up the return results.

  if (NewF->isNoReturnFunction()) {

    Builder.createUnreachable(Loc);

  } else {

    Builder.createReturn(Loc, ReturnValue);

  }



  // Do the last bit work to finalize the thunk.

  OwnedToGuaranteedFinalizeThunkFunction(Builder, F);

  assert(F->getDebugScope()->Parent != NewF->getDebugScope()->Parent);

}

"
SILOptimizer: Always create SILFunctions with a generic environment,lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,-,"F->getEffectsKind(), nullptr, F->getDebugScope());","void FunctionSignatureTransform::createFunctionSignatureOptimizedFunction() {

  // Create the optimized function !

  SILModule &M = F->getModule();

  std::string Name = createOptimizedSILFunctionName();

  SILLinkage linkage = F->getLinkage();

  if (isAvailableExternally(linkage))

    linkage = SILLinkage::Shared;



  DEBUG(llvm::dbgs() << ""  -> create specialized function "" << Name << ""\n"");



  NewF = M.createFunction(linkage, Name, createOptimizedSILFunctionType(),

                          F->getGenericEnvironment(), F->getLocation(),

                          F->isBare(), F->isTransparent(), F->isFragile(),

                          F->isThunk(), F->getClassVisibility(),

                          F->getInlineStrategy(), F->getEffectsKind(), nullptr,

                          F->getDebugScope());

  if (F->hasUnqualifiedOwnership()) {

    NewF->setUnqualifiedOwnership();

  }



  // Then we transfer the body of F to NewF.

  NewF->spliceBody(F);



  // Array semantic clients rely on the signature being as in the original

  // version.

  for (auto &Attr : F->getSemanticsAttrs()) {

    if (!StringRef(Attr).startswith(""array.""))

      NewF->addSemanticsAttr(Attr);

  }



  // Do the last bit of work to the newly created optimized function.

  ArgumentExplosionFinalizeOptimizedFunction();

  DeadArgumentFinalizeOptimizedFunction();



  // Create the thunk body !

  F->setThunk(IsThunk);

  // The thunk now carries the information on how the signature is

  // optimized. If we inline the thunk, we will get the benefit of calling

  // the signature optimized function without additional setup on the

  // caller side.

  F->setInlineStrategy(AlwaysInline);

  SILBasicBlock *ThunkBody = F->createBasicBlock();

  for (auto &ArgDesc : ArgumentDescList) {

    ThunkBody->createFunctionArgument(ArgDesc.Arg->getType(), ArgDesc.Decl);

  }



  SILLocation Loc = ThunkBody->getParent()->getLocation();

  SILBuilder Builder(ThunkBody);

  Builder.setCurrentDebugScope(ThunkBody->getParent()->getDebugScope());



  FunctionRefInst *FRI = Builder.createFunctionRef(Loc, NewF);



  // Create the args for the thunk's apply, ignoring any dead arguments.

  llvm::SmallVector<SILValue, 8> ThunkArgs;

  for (auto &ArgDesc : ArgumentDescList) {

    addThunkArgument(ArgDesc, Builder, ThunkBody, ThunkArgs);

  }



  // We are ignoring generic functions and functions with out parameters for

  // now.

  SILValue ReturnValue;

  SILType LoweredType = NewF->getLoweredType();

  SILType ResultType = NewF->getConventions().getSILResultType();

  auto FunctionTy = LoweredType.castTo<SILFunctionType>();

  if (FunctionTy->hasErrorResult()) {

    // We need a try_apply to call a function with an error result.

    SILFunction *Thunk = ThunkBody->getParent();

    SILBasicBlock *NormalBlock = Thunk->createBasicBlock();

    ReturnValue =

        NormalBlock->createPHIArgument(ResultType, ValueOwnershipKind::Owned);

    SILBasicBlock *ErrorBlock = Thunk->createBasicBlock();

    SILType Error =

        SILType::getPrimitiveObjectType(FunctionTy->getErrorResult().getType());

    auto *ErrorArg =

        ErrorBlock->createPHIArgument(Error, ValueOwnershipKind::Owned);

    Builder.createTryApply(Loc, FRI, LoweredType, SubstitutionList(),

                           ThunkArgs, NormalBlock, ErrorBlock);



    Builder.setInsertionPoint(ErrorBlock);

    Builder.createThrow(Loc, ErrorArg);

    Builder.setInsertionPoint(NormalBlock);

  } else {

    ReturnValue = Builder.createApply(Loc, FRI, LoweredType, ResultType,

                                      SubstitutionList(), ThunkArgs,

                                      false);

  }



  // Set up the return results.

  if (NewF->isNoReturnFunction()) {

    Builder.createUnreachable(Loc);

  } else {

    Builder.createReturn(Loc, ReturnValue);

  }



  // Do the last bit work to finalize the thunk.

  OwnedToGuaranteedFinalizeThunkFunction(Builder, F);

  assert(F->getDebugScope()->Parent != NewF->getDebugScope()->Parent);

}

","void FunctionSignatureTransform::createFunctionSignatureOptimizedFunction() {

  // Create the optimized function !

  SILModule &M = F->getModule();

  std::string Name = createOptimizedSILFunctionName();

  SILLinkage linkage = F->getLinkage();

  if (isAvailableExternally(linkage))

    linkage = SILLinkage::Shared;

","
  DEBUG(llvm::dbgs() << ""  -> create specialized function "" << Name << ""\n"");



  NewF = M.createFunction(linkage, Name, createOptimizedSILFunctionType(),

                          F->getGenericEnvironment(), F->getLocation(),

                          F->isBare(), F->isTransparent(), F->isFragile(),

                          F->isThunk(), F->getClassVisibility(),

                          F->getInlineStrategy(), F->getEffectsKind(), nullptr,

                          F->getDebugScope());

  if (F->hasUnqualifiedOwnership()) {

    NewF->setUnqualifiedOwnership();

  }



  // Then we transfer the body of F to NewF.

  NewF->spliceBody(F);



  // Array semantic clients rely on the signature being as in the original

  // version.

  for (auto &Attr : F->getSemanticsAttrs()) {

    if (!StringRef(Attr).startswith(""array.""))

      NewF->addSemanticsAttr(Attr);

  }



  // Do the last bit of work to the newly created optimized function.

  ArgumentExplosionFinalizeOptimizedFunction();

  DeadArgumentFinalizeOptimizedFunction();



  // Create the thunk body !

  F->setThunk(IsThunk);

  // The thunk now carries the information on how the signature is

  // optimized. If we inline the thunk, we will get the benefit of calling

  // the signature optimized function without additional setup on the

  // caller side.

  F->setInlineStrategy(AlwaysInline);

  SILBasicBlock *ThunkBody = F->createBasicBlock();

  for (auto &ArgDesc : ArgumentDescList) {

    ThunkBody->createFunctionArgument(ArgDesc.Arg->getType(), ArgDesc.Decl);

  }



  SILLocation Loc = ThunkBody->getParent()->getLocation();

  SILBuilder Builder(ThunkBody);

  Builder.setCurrentDebugScope(ThunkBody->getParent()->getDebugScope());



  FunctionRefInst *FRI = Builder.createFunctionRef(Loc, NewF);



  // Create the args for the thunk's apply, ignoring any dead arguments.

  llvm::SmallVector<SILValue, 8> ThunkArgs;

  for (auto &ArgDesc : ArgumentDescList) {

    addThunkArgument(ArgDesc, Builder, ThunkBody, ThunkArgs);

  }



  // We are ignoring generic functions and functions with out parameters for

  // now.

  SILValue ReturnValue;

  SILType LoweredType = NewF->getLoweredType();

  SILType ResultType = NewF->getConventions().getSILResultType();

  auto FunctionTy = LoweredType.castTo<SILFunctionType>();

  if (FunctionTy->hasErrorResult()) {

    // We need a try_apply to call a function with an error result.

    SILFunction *Thunk = ThunkBody->getParent();

    SILBasicBlock *NormalBlock = Thunk->createBasicBlock();

    ReturnValue =

        NormalBlock->createPHIArgument(ResultType, ValueOwnershipKind::Owned);

    SILBasicBlock *ErrorBlock = Thunk->createBasicBlock();

    SILType Error =

        SILType::getPrimitiveObjectType(FunctionTy->getErrorResult().getType());

    auto *ErrorArg =

        ErrorBlock->createPHIArgument(Error, ValueOwnershipKind::Owned);

    Builder.createTryApply(Loc, FRI, LoweredType, SubstitutionList(),

                           ThunkArgs, NormalBlock, ErrorBlock);



    Builder.setInsertionPoint(ErrorBlock);

    Builder.createThrow(Loc, ErrorArg);

    Builder.setInsertionPoint(NormalBlock);

  } else {

    ReturnValue = Builder.createApply(Loc, FRI, LoweredType, ResultType,

                                      SubstitutionList(), ThunkArgs,

                                      false);

  }



  // Set up the return results.

  if (NewF->isNoReturnFunction()) {

    Builder.createUnreachable(Loc);

  } else {

    Builder.createReturn(Loc, ReturnValue);

  }



  // Do the last bit work to finalize the thunk.

  OwnedToGuaranteedFinalizeThunkFunction(Builder, F);

  assert(F->getDebugScope()->Parent != NewF->getDebugScope()->Parent);

}


"
SILOptimizer: Always create SILFunctions with a generic environment,lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,F->getDebugScope());,"void FunctionSignatureTransform::createFunctionSignatureOptimizedFunction() {

  // Create the optimized function !

  SILModule &M = F->getModule();

  std::string Name = createOptimizedSILFunctionName();

  SILLinkage linkage = F->getLinkage();

  if (isAvailableExternally(linkage))

    linkage = SILLinkage::Shared;



  DEBUG(llvm::dbgs() << ""  -> create specialized function "" << Name << ""\n"");



  NewF = M.createFunction(linkage, Name, createOptimizedSILFunctionType(),

                          F->getGenericEnvironment(), F->getLocation(),

                          F->isBare(), F->isTransparent(), F->isFragile(),

                          F->isThunk(), F->getClassVisibility(),

                          F->getInlineStrategy(), F->getEffectsKind(), nullptr,

                          F->getDebugScope());

  if (F->hasUnqualifiedOwnership()) {

    NewF->setUnqualifiedOwnership();

  }



  // Then we transfer the body of F to NewF.

  NewF->spliceBody(F);



  // Array semantic clients rely on the signature being as in the original

  // version.

  for (auto &Attr : F->getSemanticsAttrs()) {

    if (!StringRef(Attr).startswith(""array.""))

      NewF->addSemanticsAttr(Attr);

  }



  // Do the last bit of work to the newly created optimized function.

  ArgumentExplosionFinalizeOptimizedFunction();

  DeadArgumentFinalizeOptimizedFunction();



  // Create the thunk body !

  F->setThunk(IsThunk);

  // The thunk now carries the information on how the signature is

  // optimized. If we inline the thunk, we will get the benefit of calling

  // the signature optimized function without additional setup on the

  // caller side.

  F->setInlineStrategy(AlwaysInline);

  SILBasicBlock *ThunkBody = F->createBasicBlock();

  for (auto &ArgDesc : ArgumentDescList) {

    ThunkBody->createFunctionArgument(ArgDesc.Arg->getType(), ArgDesc.Decl);

  }



  SILLocation Loc = ThunkBody->getParent()->getLocation();

  SILBuilder Builder(ThunkBody);

  Builder.setCurrentDebugScope(ThunkBody->getParent()->getDebugScope());



  FunctionRefInst *FRI = Builder.createFunctionRef(Loc, NewF);



  // Create the args for the thunk's apply, ignoring any dead arguments.

  llvm::SmallVector<SILValue, 8> ThunkArgs;

  for (auto &ArgDesc : ArgumentDescList) {

    addThunkArgument(ArgDesc, Builder, ThunkBody, ThunkArgs);

  }



  // We are ignoring generic functions and functions with out parameters for

  // now.

  SILValue ReturnValue;

  SILType LoweredType = NewF->getLoweredType();

  SILType ResultType = NewF->getConventions().getSILResultType();

  auto FunctionTy = LoweredType.castTo<SILFunctionType>();

  if (FunctionTy->hasErrorResult()) {

    // We need a try_apply to call a function with an error result.

    SILFunction *Thunk = ThunkBody->getParent();

    SILBasicBlock *NormalBlock = Thunk->createBasicBlock();

    ReturnValue =

        NormalBlock->createPHIArgument(ResultType, ValueOwnershipKind::Owned);

    SILBasicBlock *ErrorBlock = Thunk->createBasicBlock();

    SILType Error =

        SILType::getPrimitiveObjectType(FunctionTy->getErrorResult().getType());

    auto *ErrorArg =

        ErrorBlock->createPHIArgument(Error, ValueOwnershipKind::Owned);

    Builder.createTryApply(Loc, FRI, LoweredType, SubstitutionList(),

                           ThunkArgs, NormalBlock, ErrorBlock);



    Builder.setInsertionPoint(ErrorBlock);

    Builder.createThrow(Loc, ErrorArg);

    Builder.setInsertionPoint(NormalBlock);

  } else {

    ReturnValue = Builder.createApply(Loc, FRI, LoweredType, ResultType,

                                      SubstitutionList(), ThunkArgs,

                                      false);

  }



  // Set up the return results.

  if (NewF->isNoReturnFunction()) {

    Builder.createUnreachable(Loc);

  } else {

    Builder.createReturn(Loc, ReturnValue);

  }



  // Do the last bit work to finalize the thunk.

  OwnedToGuaranteedFinalizeThunkFunction(Builder, F);

  assert(F->getDebugScope()->Parent != NewF->getDebugScope()->Parent);

}

","void FunctionSignatureTransform::createFunctionSignatureOptimizedFunction() {

  // Create the optimized function !

  SILModule &M = F->getModule();

  std::string Name = createOptimizedSILFunctionName();

  SILLinkage linkage = F->getLinkage();

  if (isAvailableExternally(linkage))

    linkage = SILLinkage::Shared;



  DEBUG(llvm::dbgs() << ""  -> create specialized function "" << Name << ""\n"");



  NewF = M.createFunction(linkage, Name, createOptimizedSILFunctionType(),

                          F->getGenericEnvironment(), F->getLocation(),

                          F->isBare(), F->isTransparent(), F->isFragile(),

                          F->isThunk(), F->getClassVisibility(),

                          F->getInlineStrategy(), F->getEffectsKind(), nullptr,

                         ","
  if (F->hasUnqualifiedOwnership()) {

    NewF->setUnqualifiedOwnership();

  }



  // Then we transfer the body of F to NewF.

  NewF->spliceBody(F);



  // Array semantic clients rely on the signature being as in the original

  // version.

  for (auto &Attr : F->getSemanticsAttrs()) {

    if (!StringRef(Attr).startswith(""array.""))

      NewF->addSemanticsAttr(Attr);

  }



  // Do the last bit of work to the newly created optimized function.

  ArgumentExplosionFinalizeOptimizedFunction();

  DeadArgumentFinalizeOptimizedFunction();



  // Create the thunk body !

  F->setThunk(IsThunk);

  // The thunk now carries the information on how the signature is

  // optimized. If we inline the thunk, we will get the benefit of calling

  // the signature optimized function without additional setup on the

  // caller side.

  F->setInlineStrategy(AlwaysInline);

  SILBasicBlock *ThunkBody = F->createBasicBlock();

  for (auto &ArgDesc : ArgumentDescList) {

    ThunkBody->createFunctionArgument(ArgDesc.Arg->getType(), ArgDesc.Decl);

  }



  SILLocation Loc = ThunkBody->getParent()->getLocation();

  SILBuilder Builder(ThunkBody);

  Builder.setCurrentDebugScope(ThunkBody->getParent()->getDebugScope());



  FunctionRefInst *FRI = Builder.createFunctionRef(Loc, NewF);



  // Create the args for the thunk's apply, ignoring any dead arguments.

  llvm::SmallVector<SILValue, 8> ThunkArgs;

  for (auto &ArgDesc : ArgumentDescList) {

    addThunkArgument(ArgDesc, Builder, ThunkBody, ThunkArgs);

  }



  // We are ignoring generic functions and functions with out parameters for

  // now.

  SILValue ReturnValue;

  SILType LoweredType = NewF->getLoweredType();

  SILType ResultType = NewF->getConventions().getSILResultType();

  auto FunctionTy = LoweredType.castTo<SILFunctionType>();

  if (FunctionTy->hasErrorResult()) {

    // We need a try_apply to call a function with an error result.

    SILFunction *Thunk = ThunkBody->getParent();

    SILBasicBlock *NormalBlock = Thunk->createBasicBlock();

    ReturnValue =

        NormalBlock->createPHIArgument(ResultType, ValueOwnershipKind::Owned);

    SILBasicBlock *ErrorBlock = Thunk->createBasicBlock();

    SILType Error =

        SILType::getPrimitiveObjectType(FunctionTy->getErrorResult().getType());

    auto *ErrorArg =

        ErrorBlock->createPHIArgument(Error, ValueOwnershipKind::Owned);

    Builder.createTryApply(Loc, FRI, LoweredType, SubstitutionList(),

                           ThunkArgs, NormalBlock, ErrorBlock);



    Builder.setInsertionPoint(ErrorBlock);

    Builder.createThrow(Loc, ErrorArg);

    Builder.setInsertionPoint(NormalBlock);

  } else {

    ReturnValue = Builder.createApply(Loc, FRI, LoweredType, ResultType,

                                      SubstitutionList(), ThunkArgs,

                                      false);

  }



  // Set up the return results.

  if (NewF->isNoReturnFunction()) {

    Builder.createUnreachable(Loc);

  } else {

    Builder.createReturn(Loc, ReturnValue);

  }



  // Do the last bit work to finalize the thunk.

  OwnedToGuaranteedFinalizeThunkFunction(Builder, F);

  assert(F->getDebugScope()->Parent != NewF->getDebugScope()->Parent);

}

"
"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,-,"DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << OrigF->getName()","static bool shouldNotSpecializeCallee(SILFunction *Callee) {

  if (!Callee->shouldOptimize()) {

    DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << Callee->getName()

          << "" marked to be excluded from optimizations.\n"");

    return true;

  }



  if (Callee->hasSemanticsAttr(""optimize.sil.specialize.generic.never""))

    return true;



  return false;

}

","static bool shouldNotSpecializeCallee(SILFunction *Callee) {

  if (!Callee->shouldOptimize()) {

    DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << Callee->getName()
","          << "" marked to be excluded from optimizations.\n"");

    return true;

  }



  if (Callee->hasSemanticsAttr(""optimize.sil.specialize.generic.never""))

    return true;



  return false;

}


"
"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << Callee->getName()","static bool shouldNotSpecializeCallee(SILFunction *Callee) {

  if (!Callee->shouldOptimize()) {

    DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << Callee->getName()

          << "" marked to be excluded from optimizations.\n"");

    return true;

  }



  if (Callee->hasSemanticsAttr(""optimize.sil.specialize.generic.never""))

    return true;



  return false;

}

","static bool shouldNotSpecializeCallee(SILFunction *Callee) {

  if (!Callee->shouldOptimize()) {

   ","
          << "" marked to be excluded from optimizations.\n"");

    return true;

  }



  if (Callee->hasSemanticsAttr(""optimize.sil.specialize.generic.never""))

    return true;



  return false;

}

"
"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(!CalleeSubstFnTy->isPolymorphic() &&,"static CanSILFunctionType

getCalleeSubstFunctionType(SILValue Callee, const ReabstractionInfo &ReInfo) {

  // Create a substituted callee type.

  auto CanFnTy =

      dyn_cast<SILFunctionType>(Callee->getType().getSwiftRValueType());

  auto CalleeSubstFnTy = CanFnTy;



  if (ReInfo.getSpecializedType()->isPolymorphic() &&

      !ReInfo.getCallerParamSubstitutions().empty()) {

    CalleeSubstFnTy = CanFnTy->substGenericArgs(

        ReInfo.getNonSpecializedFunction()->getModule(),

        ReInfo.getCallerParamSubstitutions());

    assert(!CalleeSubstFnTy->isPolymorphic() &&

           ""Substituted callee type should not be polymorphic"");

    assert(!CalleeSubstFnTy->hasTypeParameter() &&

           ""Substituted callee type should not have type parameters"");

  }



  return CalleeSubstFnTy;

}

","static CanSILFunctionType

getCalleeSubstFunctionType(SILValue Callee, const ReabstractionInfo &ReInfo) {

  // Create a substituted callee type.

  auto CanFnTy =

      dyn_cast<SILFunctionType>(Callee->getType().getSwiftRValueType());

  auto CalleeSubstFnTy = CanFnTy;



  if (ReInfo.getSpecializedType()->isPolymorphic() &&

      !ReInfo.getCallerParamSubstitutions().empty()) {

    CalleeSubstFnTy = CanFnTy->substGenericArgs(

        ReInfo.getNonSpecializedFunction()->getModule(),

        ReInfo.getCallerParamSubstitutions());

   ","
           ""Substituted callee type should not be polymorphic"");

    assert(!CalleeSubstFnTy->hasTypeParameter() &&

           ""Substituted callee type should not have type parameters"");

  }



  return CalleeSubstFnTy;

}

"
"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(!CalleeSubstFnTy->hasTypeParameter() &&,"static CanSILFunctionType

getCalleeSubstFunctionType(SILValue Callee, const ReabstractionInfo &ReInfo) {

  // Create a substituted callee type.

  auto CanFnTy =

      dyn_cast<SILFunctionType>(Callee->getType().getSwiftRValueType());

  auto CalleeSubstFnTy = CanFnTy;



  if (ReInfo.getSpecializedType()->isPolymorphic() &&

      !ReInfo.getCallerParamSubstitutions().empty()) {

    CalleeSubstFnTy = CanFnTy->substGenericArgs(

        ReInfo.getNonSpecializedFunction()->getModule(),

        ReInfo.getCallerParamSubstitutions());

    assert(!CalleeSubstFnTy->isPolymorphic() &&

           ""Substituted callee type should not be polymorphic"");

    assert(!CalleeSubstFnTy->hasTypeParameter() &&

           ""Substituted callee type should not have type parameters"");

  }



  return CalleeSubstFnTy;

}

","static CanSILFunctionType

getCalleeSubstFunctionType(SILValue Callee, const ReabstractionInfo &ReInfo) {

  // Create a substituted callee type.

  auto CanFnTy =

      dyn_cast<SILFunctionType>(Callee->getType().getSwiftRValueType());

  auto CalleeSubstFnTy = CanFnTy;



  if (ReInfo.getSpecializedType()->isPolymorphic() &&

      !ReInfo.getCallerParamSubstitutions().empty()) {

    CalleeSubstFnTy = CanFnTy->substGenericArgs(

        ReInfo.getNonSpecializedFunction()->getModule(),

        ReInfo.getCallerParamSubstitutions());

    assert(!CalleeSubstFnTy->isPolymorphic() &&

           ""Substituted callee type should not be polymorphic"");

   ","
           ""Substituted callee type should not have type parameters"");

  }



  return CalleeSubstFnTy;

}

"
"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,-,"Arguments, ResultBB, TAI->getErrorBB());","static ApplySite replaceWithSpecializedCallee(ApplySite AI,

                                              SILValue Callee,

                                              SILBuilder &Builder,

                                              const ReabstractionInfo &ReInfo) {

  SILLocation Loc = AI.getLoc();

  SmallVector<SILValue, 4> Arguments;

  SILValue StoreResultTo;



  prepareCallArguments(AI, Builder, ReInfo, Arguments, StoreResultTo);



  // Create a substituted callee type.

  ArrayRef<Substitution> Subs;

  if (ReInfo.getSpecializedType()->isPolymorphic()) {

    Subs = ReInfo.getCallerParamSubstitutions();

  }



  auto CalleeSubstFnTy = getCalleeSubstFunctionType(Callee, ReInfo);

  auto CalleeSILSubstFnTy = SILType::getPrimitiveObjectType(CalleeSubstFnTy);

  SILFunctionConventions substConv(CalleeSubstFnTy, Builder.getModule());



  if (auto *TAI = dyn_cast<TryApplyInst>(AI)) {

    SILBasicBlock *ResultBB = TAI->getNormalBB();

    assert(ResultBB->getSinglePredecessorBlock() == TAI->getParent());

    auto *NewTAI =

        Builder.createTryApply(Loc, Callee, CalleeSILSubstFnTy, Subs, Arguments,

                               ResultBB, TAI->getErrorBB());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // The original normal result of the try_apply is an empty tuple.

      assert(ResultBB->getNumArguments() == 1);

      Builder.setInsertionPoint(ResultBB->begin());

      fixUsedVoidType(ResultBB->getArgument(0), Loc, Builder);



      SILArgument *Arg = ResultBB->replacePHIArgument(

          0, StoreResultTo->getType().getObjectType(),

          ValueOwnershipKind::Owned);

      // Store the direct result to the original result address.

      Builder.createStore(Loc, Arg, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    return NewTAI;

  }

  if (auto *A = dyn_cast<ApplyInst>(AI)) {

    auto *NewAI = Builder.createApply(Loc, Callee, CalleeSILSubstFnTy,

                                      substConv.getSILResultType(), Subs,

                                      Arguments, A->isNonThrowing());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // Store the direct result to the original result address.

      fixUsedVoidType(A, Loc, Builder);

      Builder.createStore(Loc, NewAI, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    A->replaceAllUsesWith(NewAI);

    return NewAI;

  }

  if (auto *PAI = dyn_cast<PartialApplyInst>(AI)) {

    CanSILFunctionType NewPAType = ReInfo.createSpecializedType(

        PAI->getFunctionType(), Builder.getModule());

    // SILType PTy =

    // SILType::getPrimitiveObjectType(ReInfo.getSpecializedType());

    SILType PTy = CalleeSILSubstFnTy;

    auto *NewPAI =

        Builder.createPartialApply(Loc, Callee, PTy, Subs, Arguments,

                                   SILType::getPrimitiveObjectType(NewPAType));

    PAI->replaceAllUsesWith(NewPAI);

    return NewPAI;

  }

  llvm_unreachable(""unhandled kind of apply"");

}

","static ApplySite replaceWithSpecializedCallee(ApplySite AI,

                                              SILValue Callee,

                                              SILBuilder &Builder,

                                              const ReabstractionInfo &ReInfo) {

  SILLocation Loc = AI.getLoc();

  SmallVector<SILValue, 4> Arguments;

  SILValue StoreResultTo;



  prepareCallArguments(AI, Builder, ReInfo, Arguments, StoreResultTo);



  // Create a substituted callee type.

  ArrayRef<Substitution> Subs;

  if (ReInfo.getSpecializedType()->isPolymorphic()) {
","    Subs = ReInfo.getCallerParamSubstitutions();

  }



  auto CalleeSubstFnTy = getCalleeSubstFunctionType(Callee, ReInfo);

  auto CalleeSILSubstFnTy = SILType::getPrimitiveObjectType(CalleeSubstFnTy);

  SILFunctionConventions substConv(CalleeSubstFnTy, Builder.getModule());



  if (auto *TAI = dyn_cast<TryApplyInst>(AI)) {

    SILBasicBlock *ResultBB = TAI->getNormalBB();

    assert(ResultBB->getSinglePredecessorBlock() == TAI->getParent());

    auto *NewTAI =

        Builder.createTryApply(Loc, Callee, CalleeSILSubstFnTy, Subs, Arguments,

                               ResultBB, TAI->getErrorBB());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // The original normal result of the try_apply is an empty tuple.

      assert(ResultBB->getNumArguments() == 1);

      Builder.setInsertionPoint(ResultBB->begin());

      fixUsedVoidType(ResultBB->getArgument(0), Loc, Builder);



      SILArgument *Arg = ResultBB->replacePHIArgument(

          0, StoreResultTo->getType().getObjectType(),

          ValueOwnershipKind::Owned);

      // Store the direct result to the original result address.

      Builder.createStore(Loc, Arg, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    return NewTAI;

  }

  if (auto *A = dyn_cast<ApplyInst>(AI)) {

    auto *NewAI = Builder.createApply(Loc, Callee, CalleeSILSubstFnTy,

                                      substConv.getSILResultType(), Subs,

                                      Arguments, A->isNonThrowing());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // Store the direct result to the original result address.

      fixUsedVoidType(A, Loc, Builder);

      Builder.createStore(Loc, NewAI, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    A->replaceAllUsesWith(NewAI);

    return NewAI;

  }

  if (auto *PAI = dyn_cast<PartialApplyInst>(AI)) {

    CanSILFunctionType NewPAType = ReInfo.createSpecializedType(

        PAI->getFunctionType(), Builder.getModule());

    // SILType PTy =

    // SILType::getPrimitiveObjectType(ReInfo.getSpecializedType());

    SILType PTy = CalleeSILSubstFnTy;

    auto *NewPAI =

        Builder.createPartialApply(Loc, Callee, PTy, Subs, Arguments,

                                   SILType::getPrimitiveObjectType(NewPAType));

    PAI->replaceAllUsesWith(NewPAI);

    return NewPAI;

  }

  llvm_unreachable(""unhandled kind of apply"");

}


"
"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,"ResultBB, TAI->getErrorBB());","static ApplySite replaceWithSpecializedCallee(ApplySite AI,

                                              SILValue Callee,

                                              SILBuilder &Builder,

                                              const ReabstractionInfo &ReInfo) {

  SILLocation Loc = AI.getLoc();

  SmallVector<SILValue, 4> Arguments;

  SILValue StoreResultTo;



  prepareCallArguments(AI, Builder, ReInfo, Arguments, StoreResultTo);



  // Create a substituted callee type.

  ArrayRef<Substitution> Subs;

  if (ReInfo.getSpecializedType()->isPolymorphic()) {

    Subs = ReInfo.getCallerParamSubstitutions();

  }



  auto CalleeSubstFnTy = getCalleeSubstFunctionType(Callee, ReInfo);

  auto CalleeSILSubstFnTy = SILType::getPrimitiveObjectType(CalleeSubstFnTy);

  SILFunctionConventions substConv(CalleeSubstFnTy, Builder.getModule());



  if (auto *TAI = dyn_cast<TryApplyInst>(AI)) {

    SILBasicBlock *ResultBB = TAI->getNormalBB();

    assert(ResultBB->getSinglePredecessorBlock() == TAI->getParent());

    auto *NewTAI =

        Builder.createTryApply(Loc, Callee, CalleeSILSubstFnTy, Subs, Arguments,

                               ResultBB, TAI->getErrorBB());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // The original normal result of the try_apply is an empty tuple.

      assert(ResultBB->getNumArguments() == 1);

      Builder.setInsertionPoint(ResultBB->begin());

      fixUsedVoidType(ResultBB->getArgument(0), Loc, Builder);



      SILArgument *Arg = ResultBB->replacePHIArgument(

          0, StoreResultTo->getType().getObjectType(),

          ValueOwnershipKind::Owned);

      // Store the direct result to the original result address.

      Builder.createStore(Loc, Arg, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    return NewTAI;

  }

  if (auto *A = dyn_cast<ApplyInst>(AI)) {

    auto *NewAI = Builder.createApply(Loc, Callee, CalleeSILSubstFnTy,

                                      substConv.getSILResultType(), Subs,

                                      Arguments, A->isNonThrowing());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // Store the direct result to the original result address.

      fixUsedVoidType(A, Loc, Builder);

      Builder.createStore(Loc, NewAI, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    A->replaceAllUsesWith(NewAI);

    return NewAI;

  }

  if (auto *PAI = dyn_cast<PartialApplyInst>(AI)) {

    CanSILFunctionType NewPAType = ReInfo.createSpecializedType(

        PAI->getFunctionType(), Builder.getModule());

    // SILType PTy =

    // SILType::getPrimitiveObjectType(ReInfo.getSpecializedType());

    SILType PTy = CalleeSILSubstFnTy;

    auto *NewPAI =

        Builder.createPartialApply(Loc, Callee, PTy, Subs, Arguments,

                                   SILType::getPrimitiveObjectType(NewPAType));

    PAI->replaceAllUsesWith(NewPAI);

    return NewPAI;

  }

  llvm_unreachable(""unhandled kind of apply"");

}

","static ApplySite replaceWithSpecializedCallee(ApplySite AI,

                                              SILValue Callee,

                                              SILBuilder &Builder,

                                              const ReabstractionInfo &ReInfo) {

  SILLocation Loc = AI.getLoc();

  SmallVector<SILValue, 4> Arguments;

  SILValue StoreResultTo;



  prepareCallArguments(AI, Builder, ReInfo, Arguments, StoreResultTo);



  // Create a substituted callee type.

  ArrayRef<Substitution> Subs;

  if (ReInfo.getSpecializedType()->isPolymorphic()) {

    Subs = ReInfo.getCallerParamSubstitutions();

  }



  auto CalleeSubstFnTy = getCalleeSubstFunctionType(Callee, ReInfo);

  auto CalleeSILSubstFnTy = SILType::getPrimitiveObjectType(CalleeSubstFnTy);

  SILFunctionConventions substConv(CalleeSubstFnTy, Builder.getModule());



  if (auto *TAI = dyn_cast<TryApplyInst>(AI)) {

    SILBasicBlock *ResultBB = TAI->getNormalBB();

    assert(ResultBB->getSinglePredecessorBlock() == TAI->getParent());

    auto *NewTAI =

        Builder.createTryApply(Loc, Callee, CalleeSILSubstFnTy, Subs, Arguments,

                              ","
    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // The original normal result of the try_apply is an empty tuple.

      assert(ResultBB->getNumArguments() == 1);

      Builder.setInsertionPoint(ResultBB->begin());

      fixUsedVoidType(ResultBB->getArgument(0), Loc, Builder);



      SILArgument *Arg = ResultBB->replacePHIArgument(

          0, StoreResultTo->getType().getObjectType(),

          ValueOwnershipKind::Owned);

      // Store the direct result to the original result address.

      Builder.createStore(Loc, Arg, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    return NewTAI;

  }

  if (auto *A = dyn_cast<ApplyInst>(AI)) {

    auto *NewAI = Builder.createApply(Loc, Callee, CalleeSILSubstFnTy,

                                      substConv.getSILResultType(), Subs,

                                      Arguments, A->isNonThrowing());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // Store the direct result to the original result address.

      fixUsedVoidType(A, Loc, Builder);

      Builder.createStore(Loc, NewAI, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    A->replaceAllUsesWith(NewAI);

    return NewAI;

  }

  if (auto *PAI = dyn_cast<PartialApplyInst>(AI)) {

    CanSILFunctionType NewPAType = ReInfo.createSpecializedType(

        PAI->getFunctionType(), Builder.getModule());

    // SILType PTy =

    // SILType::getPrimitiveObjectType(ReInfo.getSpecializedType());

    SILType PTy = CalleeSILSubstFnTy;

    auto *NewPAI =

        Builder.createPartialApply(Loc, Callee, PTy, Subs, Arguments,

                                   SILType::getPrimitiveObjectType(NewPAType));

    PAI->replaceAllUsesWith(NewPAI);

    return NewPAI;

  }

  llvm_unreachable(""unhandled kind of apply"");

}

"
"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,-,"DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << OrigF->getName()","static bool shouldNotSpecializeCallee(SILFunction *Callee) {

  if (!Callee->shouldOptimize()) {

    DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << Callee->getName()

          << "" marked to be excluded from optimizations.\n"");

    return true;

  }



  if (Callee->hasSemanticsAttr(""optimize.sil.specialize.generic.never""))

    return true;



  return false;

}

","static bool shouldNotSpecializeCallee(SILFunction *Callee) {

  if (!Callee->shouldOptimize()) {

    DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << Callee->getName()
","          << "" marked to be excluded from optimizations.\n"");

    return true;

  }



  if (Callee->hasSemanticsAttr(""optimize.sil.specialize.generic.never""))

    return true;



  return false;

}


"
"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << Callee->getName()","static bool shouldNotSpecializeCallee(SILFunction *Callee) {

  if (!Callee->shouldOptimize()) {

    DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << Callee->getName()

          << "" marked to be excluded from optimizations.\n"");

    return true;

  }



  if (Callee->hasSemanticsAttr(""optimize.sil.specialize.generic.never""))

    return true;



  return false;

}

","static bool shouldNotSpecializeCallee(SILFunction *Callee) {

  if (!Callee->shouldOptimize()) {

   ","
          << "" marked to be excluded from optimizations.\n"");

    return true;

  }



  if (Callee->hasSemanticsAttr(""optimize.sil.specialize.generic.never""))

    return true;



  return false;

}

"
"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(!CalleeSubstFnTy->isPolymorphic() &&,"static CanSILFunctionType

getCalleeSubstFunctionType(SILValue Callee, const ReabstractionInfo &ReInfo) {

  // Create a substituted callee type.

  auto CanFnTy =

      dyn_cast<SILFunctionType>(Callee->getType().getSwiftRValueType());

  auto CalleeSubstFnTy = CanFnTy;



  if (ReInfo.getSpecializedType()->isPolymorphic() &&

      !ReInfo.getCallerParamSubstitutions().empty()) {

    CalleeSubstFnTy = CanFnTy->substGenericArgs(

        ReInfo.getNonSpecializedFunction()->getModule(),

        ReInfo.getCallerParamSubstitutions());

    assert(!CalleeSubstFnTy->isPolymorphic() &&

           ""Substituted callee type should not be polymorphic"");

    assert(!CalleeSubstFnTy->hasTypeParameter() &&

           ""Substituted callee type should not have type parameters"");

  }



  return CalleeSubstFnTy;

}

","static CanSILFunctionType

getCalleeSubstFunctionType(SILValue Callee, const ReabstractionInfo &ReInfo) {

  // Create a substituted callee type.

  auto CanFnTy =

      dyn_cast<SILFunctionType>(Callee->getType().getSwiftRValueType());

  auto CalleeSubstFnTy = CanFnTy;



  if (ReInfo.getSpecializedType()->isPolymorphic() &&

      !ReInfo.getCallerParamSubstitutions().empty()) {

    CalleeSubstFnTy = CanFnTy->substGenericArgs(

        ReInfo.getNonSpecializedFunction()->getModule(),

        ReInfo.getCallerParamSubstitutions());

   ","
           ""Substituted callee type should not be polymorphic"");

    assert(!CalleeSubstFnTy->hasTypeParameter() &&

           ""Substituted callee type should not have type parameters"");

  }



  return CalleeSubstFnTy;

}

"
"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(!CalleeSubstFnTy->hasTypeParameter() &&,"static CanSILFunctionType

getCalleeSubstFunctionType(SILValue Callee, const ReabstractionInfo &ReInfo) {

  // Create a substituted callee type.

  auto CanFnTy =

      dyn_cast<SILFunctionType>(Callee->getType().getSwiftRValueType());

  auto CalleeSubstFnTy = CanFnTy;



  if (ReInfo.getSpecializedType()->isPolymorphic() &&

      !ReInfo.getCallerParamSubstitutions().empty()) {

    CalleeSubstFnTy = CanFnTy->substGenericArgs(

        ReInfo.getNonSpecializedFunction()->getModule(),

        ReInfo.getCallerParamSubstitutions());

    assert(!CalleeSubstFnTy->isPolymorphic() &&

           ""Substituted callee type should not be polymorphic"");

    assert(!CalleeSubstFnTy->hasTypeParameter() &&

           ""Substituted callee type should not have type parameters"");

  }



  return CalleeSubstFnTy;

}

","static CanSILFunctionType

getCalleeSubstFunctionType(SILValue Callee, const ReabstractionInfo &ReInfo) {

  // Create a substituted callee type.

  auto CanFnTy =

      dyn_cast<SILFunctionType>(Callee->getType().getSwiftRValueType());

  auto CalleeSubstFnTy = CanFnTy;



  if (ReInfo.getSpecializedType()->isPolymorphic() &&

      !ReInfo.getCallerParamSubstitutions().empty()) {

    CalleeSubstFnTy = CanFnTy->substGenericArgs(

        ReInfo.getNonSpecializedFunction()->getModule(),

        ReInfo.getCallerParamSubstitutions());

    assert(!CalleeSubstFnTy->isPolymorphic() &&

           ""Substituted callee type should not be polymorphic"");

   ","
           ""Substituted callee type should not have type parameters"");

  }



  return CalleeSubstFnTy;

}

"
"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,-,"Arguments, ResultBB, TAI->getErrorBB());","static ApplySite replaceWithSpecializedCallee(ApplySite AI,

                                              SILValue Callee,

                                              SILBuilder &Builder,

                                              const ReabstractionInfo &ReInfo) {

  SILLocation Loc = AI.getLoc();

  SmallVector<SILValue, 4> Arguments;

  SILValue StoreResultTo;



  prepareCallArguments(AI, Builder, ReInfo, Arguments, StoreResultTo);



  // Create a substituted callee type.

  ArrayRef<Substitution> Subs;

  if (ReInfo.getSpecializedType()->isPolymorphic()) {

    Subs = ReInfo.getCallerParamSubstitutions();

  }



  auto CalleeSubstFnTy = getCalleeSubstFunctionType(Callee, ReInfo);

  auto CalleeSILSubstFnTy = SILType::getPrimitiveObjectType(CalleeSubstFnTy);

  SILFunctionConventions substConv(CalleeSubstFnTy, Builder.getModule());



  if (auto *TAI = dyn_cast<TryApplyInst>(AI)) {

    SILBasicBlock *ResultBB = TAI->getNormalBB();

    assert(ResultBB->getSinglePredecessorBlock() == TAI->getParent());

    auto *NewTAI =

        Builder.createTryApply(Loc, Callee, CalleeSILSubstFnTy, Subs, Arguments,

                               ResultBB, TAI->getErrorBB());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // The original normal result of the try_apply is an empty tuple.

      assert(ResultBB->getNumArguments() == 1);

      Builder.setInsertionPoint(ResultBB->begin());

      fixUsedVoidType(ResultBB->getArgument(0), Loc, Builder);



      SILArgument *Arg = ResultBB->replacePHIArgument(

          0, StoreResultTo->getType().getObjectType(),

          ValueOwnershipKind::Owned);

      // Store the direct result to the original result address.

      Builder.createStore(Loc, Arg, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    return NewTAI;

  }

  if (auto *A = dyn_cast<ApplyInst>(AI)) {

    auto *NewAI = Builder.createApply(Loc, Callee, CalleeSILSubstFnTy,

                                      substConv.getSILResultType(), Subs,

                                      Arguments, A->isNonThrowing());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // Store the direct result to the original result address.

      fixUsedVoidType(A, Loc, Builder);

      Builder.createStore(Loc, NewAI, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    A->replaceAllUsesWith(NewAI);

    return NewAI;

  }

  if (auto *PAI = dyn_cast<PartialApplyInst>(AI)) {

    CanSILFunctionType NewPAType = ReInfo.createSpecializedType(

        PAI->getFunctionType(), Builder.getModule());

    // SILType PTy =

    // SILType::getPrimitiveObjectType(ReInfo.getSpecializedType());

    SILType PTy = CalleeSILSubstFnTy;

    auto *NewPAI =

        Builder.createPartialApply(Loc, Callee, PTy, Subs, Arguments,

                                   SILType::getPrimitiveObjectType(NewPAType));

    PAI->replaceAllUsesWith(NewPAI);

    return NewPAI;

  }

  llvm_unreachable(""unhandled kind of apply"");

}

","static ApplySite replaceWithSpecializedCallee(ApplySite AI,

                                              SILValue Callee,

                                              SILBuilder &Builder,

                                              const ReabstractionInfo &ReInfo) {

  SILLocation Loc = AI.getLoc();

  SmallVector<SILValue, 4> Arguments;

  SILValue StoreResultTo;



  prepareCallArguments(AI, Builder, ReInfo, Arguments, StoreResultTo);



  // Create a substituted callee type.

  ArrayRef<Substitution> Subs;

  if (ReInfo.getSpecializedType()->isPolymorphic()) {
","    Subs = ReInfo.getCallerParamSubstitutions();

  }



  auto CalleeSubstFnTy = getCalleeSubstFunctionType(Callee, ReInfo);

  auto CalleeSILSubstFnTy = SILType::getPrimitiveObjectType(CalleeSubstFnTy);

  SILFunctionConventions substConv(CalleeSubstFnTy, Builder.getModule());



  if (auto *TAI = dyn_cast<TryApplyInst>(AI)) {

    SILBasicBlock *ResultBB = TAI->getNormalBB();

    assert(ResultBB->getSinglePredecessorBlock() == TAI->getParent());

    auto *NewTAI =

        Builder.createTryApply(Loc, Callee, CalleeSILSubstFnTy, Subs, Arguments,

                               ResultBB, TAI->getErrorBB());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // The original normal result of the try_apply is an empty tuple.

      assert(ResultBB->getNumArguments() == 1);

      Builder.setInsertionPoint(ResultBB->begin());

      fixUsedVoidType(ResultBB->getArgument(0), Loc, Builder);



      SILArgument *Arg = ResultBB->replacePHIArgument(

          0, StoreResultTo->getType().getObjectType(),

          ValueOwnershipKind::Owned);

      // Store the direct result to the original result address.

      Builder.createStore(Loc, Arg, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    return NewTAI;

  }

  if (auto *A = dyn_cast<ApplyInst>(AI)) {

    auto *NewAI = Builder.createApply(Loc, Callee, CalleeSILSubstFnTy,

                                      substConv.getSILResultType(), Subs,

                                      Arguments, A->isNonThrowing());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // Store the direct result to the original result address.

      fixUsedVoidType(A, Loc, Builder);

      Builder.createStore(Loc, NewAI, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    A->replaceAllUsesWith(NewAI);

    return NewAI;

  }

  if (auto *PAI = dyn_cast<PartialApplyInst>(AI)) {

    CanSILFunctionType NewPAType = ReInfo.createSpecializedType(

        PAI->getFunctionType(), Builder.getModule());

    // SILType PTy =

    // SILType::getPrimitiveObjectType(ReInfo.getSpecializedType());

    SILType PTy = CalleeSILSubstFnTy;

    auto *NewPAI =

        Builder.createPartialApply(Loc, Callee, PTy, Subs, Arguments,

                                   SILType::getPrimitiveObjectType(NewPAType));

    PAI->replaceAllUsesWith(NewPAI);

    return NewPAI;

  }

  llvm_unreachable(""unhandled kind of apply"");

}


"
"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,"ResultBB, TAI->getErrorBB());","static ApplySite replaceWithSpecializedCallee(ApplySite AI,

                                              SILValue Callee,

                                              SILBuilder &Builder,

                                              const ReabstractionInfo &ReInfo) {

  SILLocation Loc = AI.getLoc();

  SmallVector<SILValue, 4> Arguments;

  SILValue StoreResultTo;



  prepareCallArguments(AI, Builder, ReInfo, Arguments, StoreResultTo);



  // Create a substituted callee type.

  ArrayRef<Substitution> Subs;

  if (ReInfo.getSpecializedType()->isPolymorphic()) {

    Subs = ReInfo.getCallerParamSubstitutions();

  }



  auto CalleeSubstFnTy = getCalleeSubstFunctionType(Callee, ReInfo);

  auto CalleeSILSubstFnTy = SILType::getPrimitiveObjectType(CalleeSubstFnTy);

  SILFunctionConventions substConv(CalleeSubstFnTy, Builder.getModule());



  if (auto *TAI = dyn_cast<TryApplyInst>(AI)) {

    SILBasicBlock *ResultBB = TAI->getNormalBB();

    assert(ResultBB->getSinglePredecessorBlock() == TAI->getParent());

    auto *NewTAI =

        Builder.createTryApply(Loc, Callee, CalleeSILSubstFnTy, Subs, Arguments,

                               ResultBB, TAI->getErrorBB());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // The original normal result of the try_apply is an empty tuple.

      assert(ResultBB->getNumArguments() == 1);

      Builder.setInsertionPoint(ResultBB->begin());

      fixUsedVoidType(ResultBB->getArgument(0), Loc, Builder);



      SILArgument *Arg = ResultBB->replacePHIArgument(

          0, StoreResultTo->getType().getObjectType(),

          ValueOwnershipKind::Owned);

      // Store the direct result to the original result address.

      Builder.createStore(Loc, Arg, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    return NewTAI;

  }

  if (auto *A = dyn_cast<ApplyInst>(AI)) {

    auto *NewAI = Builder.createApply(Loc, Callee, CalleeSILSubstFnTy,

                                      substConv.getSILResultType(), Subs,

                                      Arguments, A->isNonThrowing());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // Store the direct result to the original result address.

      fixUsedVoidType(A, Loc, Builder);

      Builder.createStore(Loc, NewAI, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    A->replaceAllUsesWith(NewAI);

    return NewAI;

  }

  if (auto *PAI = dyn_cast<PartialApplyInst>(AI)) {

    CanSILFunctionType NewPAType = ReInfo.createSpecializedType(

        PAI->getFunctionType(), Builder.getModule());

    // SILType PTy =

    // SILType::getPrimitiveObjectType(ReInfo.getSpecializedType());

    SILType PTy = CalleeSILSubstFnTy;

    auto *NewPAI =

        Builder.createPartialApply(Loc, Callee, PTy, Subs, Arguments,

                                   SILType::getPrimitiveObjectType(NewPAType));

    PAI->replaceAllUsesWith(NewPAI);

    return NewPAI;

  }

  llvm_unreachable(""unhandled kind of apply"");

}

","static ApplySite replaceWithSpecializedCallee(ApplySite AI,

                                              SILValue Callee,

                                              SILBuilder &Builder,

                                              const ReabstractionInfo &ReInfo) {

  SILLocation Loc = AI.getLoc();

  SmallVector<SILValue, 4> Arguments;

  SILValue StoreResultTo;



  prepareCallArguments(AI, Builder, ReInfo, Arguments, StoreResultTo);



  // Create a substituted callee type.

  ArrayRef<Substitution> Subs;

  if (ReInfo.getSpecializedType()->isPolymorphic()) {

    Subs = ReInfo.getCallerParamSubstitutions();

  }



  auto CalleeSubstFnTy = getCalleeSubstFunctionType(Callee, ReInfo);

  auto CalleeSILSubstFnTy = SILType::getPrimitiveObjectType(CalleeSubstFnTy);

  SILFunctionConventions substConv(CalleeSubstFnTy, Builder.getModule());



  if (auto *TAI = dyn_cast<TryApplyInst>(AI)) {

    SILBasicBlock *ResultBB = TAI->getNormalBB();

    assert(ResultBB->getSinglePredecessorBlock() == TAI->getParent());

    auto *NewTAI =

        Builder.createTryApply(Loc, Callee, CalleeSILSubstFnTy, Subs, Arguments,

                              ","
    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // The original normal result of the try_apply is an empty tuple.

      assert(ResultBB->getNumArguments() == 1);

      Builder.setInsertionPoint(ResultBB->begin());

      fixUsedVoidType(ResultBB->getArgument(0), Loc, Builder);



      SILArgument *Arg = ResultBB->replacePHIArgument(

          0, StoreResultTo->getType().getObjectType(),

          ValueOwnershipKind::Owned);

      // Store the direct result to the original result address.

      Builder.createStore(Loc, Arg, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    return NewTAI;

  }

  if (auto *A = dyn_cast<ApplyInst>(AI)) {

    auto *NewAI = Builder.createApply(Loc, Callee, CalleeSILSubstFnTy,

                                      substConv.getSILResultType(), Subs,

                                      Arguments, A->isNonThrowing());

    if (StoreResultTo) {

      assert(substConv.useLoweredAddresses());

      // Store the direct result to the original result address.

      fixUsedVoidType(A, Loc, Builder);

      Builder.createStore(Loc, NewAI, StoreResultTo,

                          StoreOwnershipQualifier::Unqualified);

    }

    A->replaceAllUsesWith(NewAI);

    return NewAI;

  }

  if (auto *PAI = dyn_cast<PartialApplyInst>(AI)) {

    CanSILFunctionType NewPAType = ReInfo.createSpecializedType(

        PAI->getFunctionType(), Builder.getModule());

    // SILType PTy =

    // SILType::getPrimitiveObjectType(ReInfo.getSpecializedType());

    SILType PTy = CalleeSILSubstFnTy;

    auto *NewPAI =

        Builder.createPartialApply(Loc, Callee, PTy, Subs, Arguments,

                                   SILType::getPrimitiveObjectType(NewPAType));

    PAI->replaceAllUsesWith(NewPAI);

    return NewPAI;

  }

  llvm_unreachable(""unhandled kind of apply"");

}

"
"Merge pull request #7881 from eeckstein/thunk-demangling

demangler: add an API function to get the target of a thunk symbol.",tools/swift-demangle/swift-demangle.cpp,+,assert(DCtx.getThunkTarget(name).empty());,"static void demangle(llvm::raw_ostream &os, llvm::StringRef name,

                     swift::Demangle::Context &DCtx,

                     const swift::Demangle::DemangleOptions &options) {

  bool hadLeadingUnderscore = false;

  if (name.startswith(""__"")) {

    hadLeadingUnderscore = true;

    name = name.substr(1);

  }

  swift::Demangle::NodePointer pointer = DCtx.demangleSymbolAsNode(name);

  if (ExpandMode || TreeOnly) {

    llvm::outs() << ""Demangling for "" << name << '\n';

    swift::demangle_wrappers::NodeDumper(pointer).print(llvm::outs());

  }

  if (RemangleMode) {

    std::string remangled;

    if (!pointer) {

      // Just reprint the original mangled name if it didn't demangle.

      // This makes it easier to share the same database between the

      // mangling and demangling tests.

      remangled = name;

    } else {

      // Also accept the future mangling prefix.

      // TODO: remove the ""_S"" as soon as MANGLING_PREFIX_STR gets ""_S"".

      remangled = swift::Demangle::mangleNode(pointer,

                          /*NewMangling*/ name.startswith(MANGLING_PREFIX_STR)

                                          || name.startswith(""_S""));

      if (name.startswith(""_S"")) {

        assert(remangled.find(MANGLING_PREFIX_STR) == 0);

        remangled = ""_S"" + remangled.substr(3);

      }

      if (name != remangled) {

        llvm::errs() << ""\nError: re-mangled name \n  "" << remangled

                     << ""\ndoes not match original name\n  "" << name << '\n';

        exit(1);

      }

    }

    if (hadLeadingUnderscore) llvm::outs() << '_';

    llvm::outs() << remangled;

    return;

  }

  if (!TreeOnly) {

    if (RemangleNew) {

      if (!pointer) {

        llvm::errs() << ""Can't de-mangle "" << name << '\n';

        exit(1);

      }

      std::string remangled = swift::Demangle::mangleNode(pointer);

      llvm::outs() << remangled;

      return;

    }

    std::string string = swift::Demangle::nodeToString(pointer, options);

    if (!CompactMode)

      llvm::outs() << name << "" ---> "";



    if (Classify) {

      std::string Classifications;

      std::string cName = name.str();

      if (!swift::Demangle::isSwiftSymbol(cName.c_str()))

        Classifications += 'N';

      if (DCtx.isThunkSymbol(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += ""T:"";

        Classifications += DCtx.getThunkTarget(name);

      } else {

        assert(DCtx.getThunkTarget(name).empty());

      }

      if (pointer && !DCtx.hasSwiftCallingConvention(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += 'C';

      }

      if (!Classifications.empty())

        llvm::outs() << '{' << Classifications << ""} "";

    }

    llvm::outs() << (string.empty() ? name : llvm::StringRef(string));

  }

  DCtx.clear();

}

","static void demangle(llvm::raw_ostream &os, llvm::StringRef name,

                     swift::Demangle::Context &DCtx,

                     const swift::Demangle::DemangleOptions &options) {

  bool hadLeadingUnderscore = false;

  if (name.startswith(""__"")) {

    hadLeadingUnderscore = true;

    name = name.substr(1);

  }

  swift::Demangle::NodePointer pointer = DCtx.demangleSymbolAsNode(name);

  if (ExpandMode || TreeOnly) {

    llvm::outs() << ""Demangling for "" << name << '\n';

    swift::demangle_wrappers::NodeDumper(pointer).print(llvm::outs());

  }

  if (RemangleMode) {

    std::string remangled;

    if (!pointer) {

      // Just reprint the original mangled name if it didn't demangle.

      // This makes it easier to share the same database between the

      // mangling and demangling tests.

      remangled = name;

    } else {

      // Also accept the future mangling prefix.

      // TODO: remove the ""_S"" as soon as MANGLING_PREFIX_STR gets ""_S"".

      remangled = swift::Demangle::mangleNode(pointer,

                          /*NewMangling*/ name.startswith(MANGLING_PREFIX_STR)

                                          || name.startswith(""_S""));

      if (name.startswith(""_S"")) {

        assert(remangled.find(MANGLING_PREFIX_STR) == 0);

        remangled = ""_S"" + remangled.substr(3);

      }

      if (name != remangled) {

        llvm::errs() << ""\nError: re-mangled name \n  "" << remangled

                     << ""\ndoes not match original name\n  "" << name << '\n';

        exit(1);

      }

    }

    if (hadLeadingUnderscore) llvm::outs() << '_';

    llvm::outs() << remangled;

    return;

  }

  if (!TreeOnly) {

    if (RemangleNew) {

      if (!pointer) {

        llvm::errs() << ""Can't de-mangle "" << name << '\n';

        exit(1);

      }

      std::string remangled = swift::Demangle::mangleNode(pointer);

      llvm::outs() << remangled;

      return;

    }

    std::string string = swift::Demangle::nodeToString(pointer, options);

    if (!CompactMode)

      llvm::outs() << name << "" ---> "";



    if (Classify) {

      std::string Classifications;

      std::string cName = name.str();

      if (!swift::Demangle::isSwiftSymbol(cName.c_str()))

        Classifications += 'N';

      if (DCtx.isThunkSymbol(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += ""T:"";

        Classifications += DCtx.getThunkTarget(name);

      } else {

       ","
      }

      if (pointer && !DCtx.hasSwiftCallingConvention(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += 'C';

      }

      if (!Classifications.empty())

        llvm::outs() << '{' << Classifications << ""} "";

    }

    llvm::outs() << (string.empty() ? name : llvm::StringRef(string));

  }

  DCtx.clear();

}

"
"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeBlankDeclModifier().print(OS);,"TEST(DeclSyntaxTests, DeclModifierMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    getCannedDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), ""private(set)"");

  }

}

","TEST(DeclSyntaxTests, DeclModifierMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    getCannedDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), ""private(set)"");

  }

}

"
"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(DeclSyntaxTests, DeclModifierMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    getCannedDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), ""private(set)"");

  }

}

","TEST(DeclSyntaxTests, DeclModifierMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankDeclModifier().print(OS);

   ","
  }

  {

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    getCannedDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), ""private(set)"");

  }

}

"
"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,getCannedDeclModifier().print(OS);,"TEST(DeclSyntaxTests, DeclModifierMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    getCannedDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), ""private(set)"");

  }

}

","TEST(DeclSyntaxTests, DeclModifierMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), ""private(set)"");

  }

}

"
"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""private(set)"");","TEST(DeclSyntaxTests, DeclModifierMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    getCannedDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), ""private(set)"");

  }

}

","TEST(DeclSyntaxTests, DeclModifierMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    getCannedDeclModifier().print(OS);

   ","
  }

}

"
"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(Empty.empty());,"TEST(SyntaxCollectionTests, empty) {

  auto Empty = SyntaxFactory::makeBlankFunctionCallArgumentList();

  ASSERT_TRUE(Empty.empty());

  ASSERT_FALSE(Empty.appending(getCannedArgument()).empty());

}

","TEST(SyntaxCollectionTests, empty) {

  auto Empty = SyntaxFactory::makeBlankFunctionCallArgumentList();

 ","
  ASSERT_FALSE(Empty.appending(getCannedArgument()).empty());

}

"
"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_FALSE(Empty.appending(getCannedArgument()).empty());,"TEST(SyntaxCollectionTests, empty) {

  auto Empty = SyntaxFactory::makeBlankFunctionCallArgumentList();

  ASSERT_TRUE(Empty.empty());

  ASSERT_FALSE(Empty.appending(getCannedArgument()).empty());

}

","TEST(SyntaxCollectionTests, empty) {

  auto Empty = SyntaxFactory::makeBlankFunctionCallArgumentList();

  ASSERT_TRUE(Empty.empty());

 ","
}

"
"demangler: add an API function to get the target of a thunk symbol.

rdar://problem/30820093",tools/swift-demangle/swift-demangle.cpp,+,assert(DCtx.getThunkTarget(name).empty());,"static void demangle(llvm::raw_ostream &os, llvm::StringRef name,

                     swift::Demangle::Context &DCtx,

                     const swift::Demangle::DemangleOptions &options) {

  bool hadLeadingUnderscore = false;

  if (name.startswith(""__"")) {

    hadLeadingUnderscore = true;

    name = name.substr(1);

  }

  swift::Demangle::NodePointer pointer = DCtx.demangleSymbolAsNode(name);

  if (ExpandMode || TreeOnly) {

    llvm::outs() << ""Demangling for "" << name << '\n';

    swift::demangle_wrappers::NodeDumper(pointer).print(llvm::outs());

  }

  if (RemangleMode) {

    std::string remangled;

    if (!pointer) {

      // Just reprint the original mangled name if it didn't demangle.

      // This makes it easier to share the same database between the

      // mangling and demangling tests.

      remangled = name;

    } else {

      // Also accept the future mangling prefix.

      // TODO: remove the ""_S"" as soon as MANGLING_PREFIX_STR gets ""_S"".

      remangled = swift::Demangle::mangleNode(pointer,

                          /*NewMangling*/ name.startswith(MANGLING_PREFIX_STR)

                                          || name.startswith(""_S""));

      if (name.startswith(""_S"")) {

        assert(remangled.find(MANGLING_PREFIX_STR) == 0);

        remangled = ""_S"" + remangled.substr(3);

      }

      if (name != remangled) {

        llvm::errs() << ""\nError: re-mangled name \n  "" << remangled

                     << ""\ndoes not match original name\n  "" << name << '\n';

        exit(1);

      }

    }

    if (hadLeadingUnderscore) llvm::outs() << '_';

    llvm::outs() << remangled;

    return;

  }

  if (!TreeOnly) {

    if (RemangleNew) {

      if (!pointer) {

        llvm::errs() << ""Can't de-mangle "" << name << '\n';

        exit(1);

      }

      std::string remangled = swift::Demangle::mangleNode(pointer);

      llvm::outs() << remangled;

      return;

    }

    std::string string = swift::Demangle::nodeToString(pointer, options);

    if (!CompactMode)

      llvm::outs() << name << "" ---> "";



    if (Classify) {

      std::string Classifications;

      std::string cName = name.str();

      if (!swift::Demangle::isSwiftSymbol(cName.c_str()))

        Classifications += 'N';

      if (DCtx.isThunkSymbol(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += ""T:"";

        Classifications += DCtx.getThunkTarget(name);

      } else {

        assert(DCtx.getThunkTarget(name).empty());

      }

      if (pointer && !DCtx.hasSwiftCallingConvention(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += 'C';

      }

      if (!Classifications.empty())

        llvm::outs() << '{' << Classifications << ""} "";

    }

    llvm::outs() << (string.empty() ? name : llvm::StringRef(string));

  }

  DCtx.clear();

}

","static void demangle(llvm::raw_ostream &os, llvm::StringRef name,

                     swift::Demangle::Context &DCtx,

                     const swift::Demangle::DemangleOptions &options) {

  bool hadLeadingUnderscore = false;

  if (name.startswith(""__"")) {

    hadLeadingUnderscore = true;

    name = name.substr(1);

  }

  swift::Demangle::NodePointer pointer = DCtx.demangleSymbolAsNode(name);

  if (ExpandMode || TreeOnly) {

    llvm::outs() << ""Demangling for "" << name << '\n';

    swift::demangle_wrappers::NodeDumper(pointer).print(llvm::outs());

  }

  if (RemangleMode) {

    std::string remangled;

    if (!pointer) {

      // Just reprint the original mangled name if it didn't demangle.

      // This makes it easier to share the same database between the

      // mangling and demangling tests.

      remangled = name;

    } else {

      // Also accept the future mangling prefix.

      // TODO: remove the ""_S"" as soon as MANGLING_PREFIX_STR gets ""_S"".

      remangled = swift::Demangle::mangleNode(pointer,

                          /*NewMangling*/ name.startswith(MANGLING_PREFIX_STR)

                                          || name.startswith(""_S""));

      if (name.startswith(""_S"")) {

        assert(remangled.find(MANGLING_PREFIX_STR) == 0);

        remangled = ""_S"" + remangled.substr(3);

      }

      if (name != remangled) {

        llvm::errs() << ""\nError: re-mangled name \n  "" << remangled

                     << ""\ndoes not match original name\n  "" << name << '\n';

        exit(1);

      }

    }

    if (hadLeadingUnderscore) llvm::outs() << '_';

    llvm::outs() << remangled;

    return;

  }

  if (!TreeOnly) {

    if (RemangleNew) {

      if (!pointer) {

        llvm::errs() << ""Can't de-mangle "" << name << '\n';

        exit(1);

      }

      std::string remangled = swift::Demangle::mangleNode(pointer);

      llvm::outs() << remangled;

      return;

    }

    std::string string = swift::Demangle::nodeToString(pointer, options);

    if (!CompactMode)

      llvm::outs() << name << "" ---> "";



    if (Classify) {

      std::string Classifications;

      std::string cName = name.str();

      if (!swift::Demangle::isSwiftSymbol(cName.c_str()))

        Classifications += 'N';

      if (DCtx.isThunkSymbol(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += ""T:"";

        Classifications += DCtx.getThunkTarget(name);

      } else {

       ","
      }

      if (pointer && !DCtx.hasSwiftCallingConvention(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += 'C';

      }

      if (!Classifications.empty())

        llvm::outs() << '{' << Classifications << ""} "";

    }

    llvm::outs() << (string.empty() ? name : llvm::StringRef(string));

  }

  DCtx.clear();

}

"
"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeBlankDeclModifier().print(OS);,"TEST(DeclSyntaxTests, DeclModifierMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    getCannedDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), ""private(set)"");

  }

}

","TEST(DeclSyntaxTests, DeclModifierMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    getCannedDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), ""private(set)"");

  }

}

"
"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(DeclSyntaxTests, DeclModifierMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    getCannedDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), ""private(set)"");

  }

}

","TEST(DeclSyntaxTests, DeclModifierMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankDeclModifier().print(OS);

   ","
  }

  {

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    getCannedDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), ""private(set)"");

  }

}

"
"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",unittests/Syntax/DeclSyntaxTests.cpp,+,getCannedDeclModifier().print(OS);,"TEST(DeclSyntaxTests, DeclModifierMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    getCannedDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), ""private(set)"");

  }

}

","TEST(DeclSyntaxTests, DeclModifierMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), ""private(set)"");

  }

}

"
"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""private(set)"");","TEST(DeclSyntaxTests, DeclModifierMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    getCannedDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), ""private(set)"");

  }

}

","TEST(DeclSyntaxTests, DeclModifierMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankDeclModifier().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    getCannedDeclModifier().print(OS);

   ","
  }

}

"
"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(Empty.empty());,"TEST(SyntaxCollectionTests, empty) {

  auto Empty = SyntaxFactory::makeBlankFunctionCallArgumentList();

  ASSERT_TRUE(Empty.empty());

  ASSERT_FALSE(Empty.appending(getCannedArgument()).empty());

}

","TEST(SyntaxCollectionTests, empty) {

  auto Empty = SyntaxFactory::makeBlankFunctionCallArgumentList();

 ","
  ASSERT_FALSE(Empty.appending(getCannedArgument()).empty());

}

"
"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_FALSE(Empty.appending(getCannedArgument()).empty());,"TEST(SyntaxCollectionTests, empty) {

  auto Empty = SyntaxFactory::makeBlankFunctionCallArgumentList();

  ASSERT_TRUE(Empty.empty());

  ASSERT_FALSE(Empty.appending(getCannedArgument()).empty());

}

","TEST(SyntaxCollectionTests, empty) {

  auto Empty = SyntaxFactory::makeBlankFunctionCallArgumentList();

  ASSERT_TRUE(Empty.empty());

 ","
}

"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,-,assert(baseEntry.isBase());,"    bool findBetterPath(ProtocolDecl *proto, const ProtocolInfo &protoInfo,

                        unsigned lengthSoFar) {

      assert(lengthSoFar < BestPathLength);

      assert(proto != Dest);



      // Keep track of whether we found a better path than the

      // previous best.

      bool foundBetter = false;

      for (auto base : proto->getInheritedProtocols()) {

        // ObjC protocols do not have witnesses.

        if (!Lowering::TypeConverter::protocolRequiresWitnessTable(base))

          continue;



        auto baseIndex = protoInfo.getBaseIndex(base);



        // Compute the length down to this base.

        unsigned lengthToBase = lengthSoFar;

        if (!baseIndex.isPrefix()) {

          lengthToBase++;



          // Don't consider this path if we reach a length that can't

          // possibly be better than the best so far.

          if (lengthToBase == BestPathLength) continue;

        }

        assert(lengthToBase < BestPathLength);



        // If this base *is* the destination, go ahead and start

        // building the path into ReversePath.

        if (base == Dest) {

          // Reset the collected best-path information.

          BestPathLength = lengthToBase;

          ReversePath.clear();



        // Otherwise, if there isn't a better path through this base,

        // don't accumulate anything in the path.

        } else if (!findBetterPath(base, IGM.getProtocolInfo(base),

                                   lengthToBase)) {

          continue;

        }



        // Okay, we've found a better path, and ReversePath contains a

        // path leading from base to Dest.

        assert(BestPathLength >= lengthToBase);

        foundBetter = true;



        // Add the link from proto to base if necessary.

        if (!baseIndex.isPrefix()) {

          ReversePath.push_back(baseIndex);



        // If it isn't necessary, then we might be able to

        // short-circuit considering the bases of this protocol.

        } else {

          if (lengthSoFar == BestPathLength)

            return true;

        }

      }



      return foundBetter;

    }

","    bool findBetterPath(ProtocolDecl *proto, const ProtocolInfo &protoInfo,

                        unsigned lengthSoFar) {

      assert(lengthSoFar < BestPathLength);

      assert(proto != Dest);



      // Keep track of whether we found a better path than the

      // previous best.

","
      for (auto base : proto->getInheritedProtocols()) {

        // ObjC protocols do not have witnesses.

        if (!Lowering::TypeConverter::protocolRequiresWitnessTable(base))

          continue;



        auto baseIndex = protoInfo.getBaseIndex(base);



        // Compute the length down to this base.

        unsigned lengthToBase = lengthSoFar;

        if (!baseIndex.isPrefix()) {

          lengthToBase++;



          // Don't consider this path if we reach a length that can't

          // possibly be better than the best so far.

          if (lengthToBase == BestPathLength) continue;

        }

        assert(lengthToBase < BestPathLength);



        // If this base *is* the destination, go ahead and start

        // building the path into ReversePath.

        if (base == Dest) {

          // Reset the collected best-path information.

          BestPathLength = lengthToBase;

          ReversePath.clear();



        // Otherwise, if there isn't a better path through this base,

        // don't accumulate anything in the path.

        } else if (!findBetterPath(base, IGM.getProtocolInfo(base),

                                   lengthToBase)) {

          continue;

        }



        // Okay, we've found a better path, and ReversePath contains a

        // path leading from base to Dest.

        assert(BestPathLength >= lengthToBase);

        foundBetter = true;



        // Add the link from proto to base if necessary.

        if (!baseIndex.isPrefix()) {

          ReversePath.push_back(baseIndex);



        // If it isn't necessary, then we might be able to

        // short-circuit considering the bases of this protocol.

        } else {

          if (lengthSoFar == BestPathLength)

            return true;

        }

      }



      return foundBetter;

    }


"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,-,assert(piEntry.getOutOfLineBaseIndex().getValue() == Table.size(),"    void addOutOfLineBaseProtocol(ProtocolDecl *baseProto) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::BaseProtocol

             && ""sil witness table does not match protocol"");

      assert(entry.getBaseProtocolWitness().Requirement == baseProto

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getBaseIndex(baseProto);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif

      

      SILEntries = SILEntries.slice(1);



      // TODO: Use the witness entry instead of falling through here.



      // Look for a protocol type info.

      const ProtocolInfo &basePI = IGM.getProtocolInfo(baseProto);

      const ProtocolConformance *astConf

        = Conformance.getInheritedConformance(baseProto);

      const ConformanceInfo &conf =

        basePI.getConformance(IGM, baseProto, astConf);



      // If we can emit the base witness table as a constant, do so.

      llvm::Constant *baseWitness = conf.tryGetConstantTable(IGM, ConcreteType);

      if (baseWitness) {

        Table.push_back(baseWitness);

        return;

      }



      // Otherwise, we'll need to derive it at instantiation time.

      RequiresSpecialization = true;

      SpecializedBaseConformances.push_back({Table.size(), &conf});

      Table.push_back(llvm::ConstantPointerNull::get(IGM.WitnessTablePtrTy));

    }

","    void addOutOfLineBaseProtocol(ProtocolDecl *baseProto) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::BaseProtocol

","
      assert(entry.getBaseProtocolWitness().Requirement == baseProto

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getBaseIndex(baseProto);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif

      

      SILEntries = SILEntries.slice(1);



      // TODO: Use the witness entry instead of falling through here.



      // Look for a protocol type info.

      const ProtocolInfo &basePI = IGM.getProtocolInfo(baseProto);

      const ProtocolConformance *astConf

        = Conformance.getInheritedConformance(baseProto);

      const ConformanceInfo &conf =

        basePI.getConformance(IGM, baseProto, astConf);



      // If we can emit the base witness table as a constant, do so.

      llvm::Constant *baseWitness = conf.tryGetConstantTable(IGM, ConcreteType);

      if (baseWitness) {

        Table.push_back(baseWitness);

        return;

      }



      // Otherwise, we'll need to derive it at instantiation time.

      RequiresSpecialization = true;

      SpecializedBaseConformances.push_back({Table.size(), &conf});

      Table.push_back(llvm::ConstantPointerNull::get(IGM.WitnessTablePtrTy));

    }


"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),"    void addOutOfLineBaseProtocol(ProtocolDecl *baseProto) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::BaseProtocol

             && ""sil witness table does not match protocol"");

      assert(entry.getBaseProtocolWitness().Requirement == baseProto

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getBaseIndex(baseProto);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif

      

      SILEntries = SILEntries.slice(1);



      // TODO: Use the witness entry instead of falling through here.



      // Look for a protocol type info.

      const ProtocolInfo &basePI = IGM.getProtocolInfo(baseProto);

      const ProtocolConformance *astConf

        = Conformance.getInheritedConformance(baseProto);

      const ConformanceInfo &conf =

        basePI.getConformance(IGM, baseProto, astConf);



      // If we can emit the base witness table as a constant, do so.

      llvm::Constant *baseWitness = conf.tryGetConstantTable(IGM, ConcreteType);

      if (baseWitness) {

        Table.push_back(baseWitness);

        return;

      }



      // Otherwise, we'll need to derive it at instantiation time.

      RequiresSpecialization = true;

      SpecializedBaseConformances.push_back({Table.size(), &conf});

      Table.push_back(llvm::ConstantPointerNull::get(IGM.WitnessTablePtrTy));

    }

","    void addOutOfLineBaseProtocol(ProtocolDecl *baseProto) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::BaseProtocol

             && ""sil witness table does not match protocol"");

      assert(entry.getBaseProtocolWitness().Requirement == baseProto

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getBaseIndex(baseProto);

     ","
             && ""offset doesn't match ProtocolInfo layout"");

#endif

      

      SILEntries = SILEntries.slice(1);



      // TODO: Use the witness entry instead of falling through here.



      // Look for a protocol type info.

      const ProtocolInfo &basePI = IGM.getProtocolInfo(baseProto);

      const ProtocolConformance *astConf

        = Conformance.getInheritedConformance(baseProto);

      const ConformanceInfo &conf =

        basePI.getConformance(IGM, baseProto, astConf);



      // If we can emit the base witness table as a constant, do so.

      llvm::Constant *baseWitness = conf.tryGetConstantTable(IGM, ConcreteType);

      if (baseWitness) {

        Table.push_back(baseWitness);

        return;

      }



      // Otherwise, we'll need to derive it at instantiation time.

      RequiresSpecialization = true;

      SpecializedBaseConformances.push_back({Table.size(), &conf});

      Table.push_back(llvm::ConstantPointerNull::get(IGM.WitnessTablePtrTy));

    }

"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,-,assert(piEntry.getFunctionIndex().getValue() == Table.size(),"    void addMethodFromSILWitnessTable(AbstractFunctionDecl *requirement) {

      auto &entry = SILEntries.front();

      SILEntries = SILEntries.slice(1);



      // Handle missing optional requirements.

      if (entry.getKind() == SILWitnessTable::MissingOptional) {

        Table.push_back(llvm::ConstantPointerNull::get(IGM.Int8PtrTy));

        return;

      }



#ifndef NDEBUG

      assert(entry.getKind() == SILWitnessTable::Method

             && ""sil witness table does not match protocol"");

      assert(entry.getMethodWitness().Requirement.getDecl() == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getFunctionIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILFunction *Func = entry.getMethodWitness().Witness;

      llvm::Constant *witness = nullptr;

      if (Func) {

        witness = IGM.getAddrOfSILFunction(Func, NotForDefinition);

      } else {

        // The method is removed by dead method elimination.

        // It should be never called. We add a pointer to an error function.

        witness = IGM.getDeletedMethodErrorFn();

      }

      Table.push_back(witness);

      return;

    }

","    void addMethodFromSILWitnessTable(AbstractFunctionDecl *requirement) {

      auto &entry = SILEntries.front();

      SILEntries = SILEntries.slice(1);



      // Handle missing optional requirements.

      if (entry.getKind() == SILWitnessTable::MissingOptional) {

        Table.push_back(llvm::ConstantPointerNull::get(IGM.Int8PtrTy));

        return;

","


#ifndef NDEBUG

      assert(entry.getKind() == SILWitnessTable::Method

             && ""sil witness table does not match protocol"");

      assert(entry.getMethodWitness().Requirement.getDecl() == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getFunctionIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILFunction *Func = entry.getMethodWitness().Witness;

      llvm::Constant *witness = nullptr;

      if (Func) {

        witness = IGM.getAddrOfSILFunction(Func, NotForDefinition);

      } else {

        // The method is removed by dead method elimination.

        // It should be never called. We add a pointer to an error function.

        witness = IGM.getDeletedMethodErrorFn();

      }

      Table.push_back(witness);

      return;

    }


"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),"    void addMethodFromSILWitnessTable(AbstractFunctionDecl *requirement) {

      auto &entry = SILEntries.front();

      SILEntries = SILEntries.slice(1);



      // Handle missing optional requirements.

      if (entry.getKind() == SILWitnessTable::MissingOptional) {

        Table.push_back(llvm::ConstantPointerNull::get(IGM.Int8PtrTy));

        return;

      }



#ifndef NDEBUG

      assert(entry.getKind() == SILWitnessTable::Method

             && ""sil witness table does not match protocol"");

      assert(entry.getMethodWitness().Requirement.getDecl() == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getFunctionIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILFunction *Func = entry.getMethodWitness().Witness;

      llvm::Constant *witness = nullptr;

      if (Func) {

        witness = IGM.getAddrOfSILFunction(Func, NotForDefinition);

      } else {

        // The method is removed by dead method elimination.

        // It should be never called. We add a pointer to an error function.

        witness = IGM.getDeletedMethodErrorFn();

      }

      Table.push_back(witness);

      return;

    }

","    void addMethodFromSILWitnessTable(AbstractFunctionDecl *requirement) {

      auto &entry = SILEntries.front();

      SILEntries = SILEntries.slice(1);



      // Handle missing optional requirements.

      if (entry.getKind() == SILWitnessTable::MissingOptional) {

        Table.push_back(llvm::ConstantPointerNull::get(IGM.Int8PtrTy));

        return;

      }



#ifndef NDEBUG

      assert(entry.getKind() == SILWitnessTable::Method

             && ""sil witness table does not match protocol"");

      assert(entry.getMethodWitness().Requirement.getDecl() == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getFunctionIndex(requirement);

     ","
             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILFunction *Func = entry.getMethodWitness().Witness;

      llvm::Constant *witness = nullptr;

      if (Func) {

        witness = IGM.getAddrOfSILFunction(Func, NotForDefinition);

      } else {

        // The method is removed by dead method elimination.

        // It should be never called. We add a pointer to an error function.

        witness = IGM.getDeletedMethodErrorFn();

      }

      Table.push_back(witness);

      return;

    }

"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,-,assert(piEntry.getAssociatedTypeIndex().getValue() == Table.size(),"    void addAssociatedType(AssociatedTypeDecl *requirement) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::AssociatedType

             && ""sil witness table does not match protocol"");

      assert(entry.getAssociatedTypeWitness().Requirement == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getAssociatedTypeIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      const Substitution &sub =

        Conformance.getTypeWitness(requirement, nullptr);



      // This type will be expressed in terms of the archetypes

      // of the conforming context.

      CanType associate = sub.getReplacement()->getCanonicalType();

      assert(!associate->hasTypeParameter());



      llvm::Constant *metadataAccessFunction =

        getAssociatedTypeMetadataAccessFunction(requirement, associate);

      Table.push_back(metadataAccessFunction);

    }

","    void addAssociatedType(AssociatedTypeDecl *requirement) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::AssociatedType

             && ""sil witness table does not match protocol"");

","
             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getAssociatedTypeIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      const Substitution &sub =

        Conformance.getTypeWitness(requirement, nullptr);



      // This type will be expressed in terms of the archetypes

      // of the conforming context.

      CanType associate = sub.getReplacement()->getCanonicalType();

      assert(!associate->hasTypeParameter());



      llvm::Constant *metadataAccessFunction =

        getAssociatedTypeMetadataAccessFunction(requirement, associate);

      Table.push_back(metadataAccessFunction);

    }


"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),"    void addAssociatedType(AssociatedTypeDecl *requirement) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::AssociatedType

             && ""sil witness table does not match protocol"");

      assert(entry.getAssociatedTypeWitness().Requirement == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getAssociatedTypeIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      const Substitution &sub =

        Conformance.getTypeWitness(requirement, nullptr);



      // This type will be expressed in terms of the archetypes

      // of the conforming context.

      CanType associate = sub.getReplacement()->getCanonicalType();

      assert(!associate->hasTypeParameter());



      llvm::Constant *metadataAccessFunction =

        getAssociatedTypeMetadataAccessFunction(requirement, associate);

      Table.push_back(metadataAccessFunction);

    }

","    void addAssociatedType(AssociatedTypeDecl *requirement) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::AssociatedType

             && ""sil witness table does not match protocol"");

      assert(entry.getAssociatedTypeWitness().Requirement == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getAssociatedTypeIndex(requirement);

     ","
             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      const Substitution &sub =

        Conformance.getTypeWitness(requirement, nullptr);



      // This type will be expressed in terms of the archetypes

      // of the conforming context.

      CanType associate = sub.getReplacement()->getCanonicalType();

      assert(!associate->hasTypeParameter());



      llvm::Constant *metadataAccessFunction =

        getAssociatedTypeMetadataAccessFunction(requirement, associate);

      Table.push_back(metadataAccessFunction);

    }

"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,-,assert(protos.size() == sub.getConformances().size());,"    void addAssociatedType(AssociatedTypeDecl *requirement) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::AssociatedType

             && ""sil witness table does not match protocol"");

      assert(entry.getAssociatedTypeWitness().Requirement == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getAssociatedTypeIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      const Substitution &sub =

        Conformance.getTypeWitness(requirement, nullptr);



      // This type will be expressed in terms of the archetypes

      // of the conforming context.

      CanType associate = sub.getReplacement()->getCanonicalType();

      assert(!associate->hasTypeParameter());



      llvm::Constant *metadataAccessFunction =

        getAssociatedTypeMetadataAccessFunction(requirement, associate);

      Table.push_back(metadataAccessFunction);

    }

","    void addAssociatedType(AssociatedTypeDecl *requirement) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::AssociatedType

             && ""sil witness table does not match protocol"");

      assert(entry.getAssociatedTypeWitness().Requirement == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getAssociatedTypeIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");
","#endif



      SILEntries = SILEntries.slice(1);



      const Substitution &sub =

        Conformance.getTypeWitness(requirement, nullptr);



      // This type will be expressed in terms of the archetypes

      // of the conforming context.

      CanType associate = sub.getReplacement()->getCanonicalType();

      assert(!associate->hasTypeParameter());



      llvm::Constant *metadataAccessFunction =

        getAssociatedTypeMetadataAccessFunction(requirement, associate);

      Table.push_back(metadataAccessFunction);

    }


"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,+,assert(!associate->hasTypeParameter());,"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

     ","


      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,-,assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol,"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);

","
#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }


"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,-,assert(associatedWitness.Requirement == requirement,"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



","
      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }


"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,-,assert(associatedWitness.Protocol == protocol,"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG
","      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }


"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,+,assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol,"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

     ","
             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,+,assert(associatedWitness.Requirement->isEqual(associatedType),"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

     ","
             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,+,assert(associatedWitness.Protocol == protocol,"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

     ","
             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,+,assert(isa<GenericTypeParamType>(depAssociatedType)); // Self,"static void buildAssociatedTypeValueName(CanType depAssociatedType,

                                         SmallString<128> &name) {

  if (auto memberType = dyn_cast<DependentMemberType>(depAssociatedType)) {

    buildAssociatedTypeValueName(memberType.getBase(), name);

    name += '.';

    name += memberType->getName().str();

  } else {

    assert(isa<GenericTypeParamType>(depAssociatedType)); // Self

  }

}

","static void buildAssociatedTypeValueName(CanType depAssociatedType,

                                         SmallString<128> &name) {

  if (auto memberType = dyn_cast<DependentMemberType>(depAssociatedType)) {

    buildAssociatedTypeValueName(memberType.getBase(), name);

    name += '.';

    name += memberType->getName().str();

  } else {

   ","
  }

}

"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/Linking.cpp,+,assert(isa<GenericTypeParamType>(assocType));,"static void mangleAssociatedTypePath(Mangler &mangler, CanType assocType) {

  if (auto memberType = dyn_cast<DependentMemberType>(assocType)) {

    mangleAssociatedTypePath(mangler, memberType.getBase());

    mangler.mangleIdentifier(memberType->getName().str());

  } else {

    assert(isa<GenericTypeParamType>(assocType));

  }

}

","static void mangleAssociatedTypePath(Mangler &mangler, CanType assocType) {

  if (auto memberType = dyn_cast<DependentMemberType>(assocType)) {

    mangleAssociatedTypePath(mangler, memberType.getBase());

    mangler.mangleIdentifier(memberType->getName().str());

  } else {

   ","
  }

}

"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/SIL/SILPrinter.cpp,+,"static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {","static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {

  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

    if (printAssociatedTypePath(OS, memberType.getBase()))

      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

    assert(isa<GenericTypeParamType>(path));

    return false;

  }

}

","static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {

  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

    if (printAssociatedTypePath(OS, memberType.getBase()))

      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

    assert(isa<GenericTypeParamType>(path));

    return false;

  }

}
","
  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

    if (printAssociatedTypePath(OS, memberType.getBase()))

      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

    assert(isa<GenericTypeParamType>(path));

    return false;

  }

}

"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/SIL/SILPrinter.cpp,+,"if (printAssociatedTypePath(OS, memberType.getBase()))","static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {

  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

    if (printAssociatedTypePath(OS, memberType.getBase()))

      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

    assert(isa<GenericTypeParamType>(path));

    return false;

  }

}

","static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {

  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

   ","
      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

    assert(isa<GenericTypeParamType>(path));

    return false;

  }

}

"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/SIL/SILPrinter.cpp,+,assert(isa<GenericTypeParamType>(path));,"static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {

  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

    if (printAssociatedTypePath(OS, memberType.getBase()))

      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

    assert(isa<GenericTypeParamType>(path));

    return false;

  }

}

","static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {

  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

    if (printAssociatedTypePath(OS, memberType.getBase()))

      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

   ","
    return false;

  }

}

"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/SILGen/SILGenDecl.cpp,-,assert(protos.size() == witness.getConformances().size(),"  void addAssociatedConformance(CanType dependentType, ProtocolDecl *protocol) {

    auto assocConformance =

      Conformance->getAssociatedConformance(dependentType, protocol);



    SGM.useConformance(assocConformance);



    Entries.push_back(SILWitnessTable::AssociatedTypeProtocolWitness{

        dependentType, protocol, assocConformance});

  }

","  void addAssociatedConformance(CanType dependentType, ProtocolDecl *protocol) {

","
      Conformance->getAssociatedConformance(dependentType, protocol);



    SGM.useConformance(assocConformance);



    Entries.push_back(SILWitnessTable::AssociatedTypeProtocolWitness{

        dependentType, protocol, assocConformance});

  }


"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/SILGen/SILGenDecl.cpp,-,assert(witness.getConformances().empty(),"  void addAssociatedConformance(CanType dependentType, ProtocolDecl *protocol) {

    auto assocConformance =

      Conformance->getAssociatedConformance(dependentType, protocol);



    SGM.useConformance(assocConformance);



    Entries.push_back(SILWitnessTable::AssociatedTypeProtocolWitness{

        dependentType, protocol, assocConformance});

  }

","  void addAssociatedConformance(CanType dependentType, ProtocolDecl *protocol) {

    auto assocConformance =

      Conformance->getAssociatedConformance(dependentType, protocol);
","

    SGM.useConformance(assocConformance);



    Entries.push_back(SILWitnessTable::AssociatedTypeProtocolWitness{

        dependentType, protocol, assocConformance});

  }


"
Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/SILGen/SILGenDecl.cpp,-,assert(foundConformance != witness.getConformances().end());,"static SILWitnessTable *

getWitnessTableToInsertAfter(SILGenModule &SGM,

                             NormalProtocolConformance *insertAfter) {

  while (insertAfter) {

    // If the table was emitted, emit after it.

    auto found = SGM.emittedWitnessTables.find(insertAfter);

    if (found != SGM.emittedWitnessTables.end())

      return found->second;



    // Otherwise, try inserting after the table we would transitively be

    // inserted after.

    auto foundDelayed = SGM.delayedConformances.find(insertAfter);

    if (foundDelayed != SGM.delayedConformances.end())

      insertAfter = foundDelayed->second.insertAfter;

    else

      break;

  }



  return nullptr;

}

","static SILWitnessTable *

getWitnessTableToInsertAfter(SILGenModule &SGM,

                             NormalProtocolConformance *insertAfter) {

  while (insertAfter) {

    // If the table was emitted, emit after it.

    auto found = SGM.emittedWitnessTables.find(insertAfter);

    if (found != SGM.emittedWitnessTables.end())
","      return found->second;



    // Otherwise, try inserting after the table we would transitively be

    // inserted after.

    auto foundDelayed = SGM.delayedConformances.find(insertAfter);

    if (foundDelayed != SGM.delayedConformances.end())

      insertAfter = foundDelayed->second.insertAfter;

    else

      break;

  }



  return nullptr;

}


"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,-,assert(baseEntry.isBase());,"    bool findBetterPath(ProtocolDecl *proto, const ProtocolInfo &protoInfo,

                        unsigned lengthSoFar) {

      assert(lengthSoFar < BestPathLength);

      assert(proto != Dest);



      // Keep track of whether we found a better path than the

      // previous best.

      bool foundBetter = false;

      for (auto base : proto->getInheritedProtocols()) {

        // ObjC protocols do not have witnesses.

        if (!Lowering::TypeConverter::protocolRequiresWitnessTable(base))

          continue;



        auto baseIndex = protoInfo.getBaseIndex(base);



        // Compute the length down to this base.

        unsigned lengthToBase = lengthSoFar;

        if (!baseIndex.isPrefix()) {

          lengthToBase++;



          // Don't consider this path if we reach a length that can't

          // possibly be better than the best so far.

          if (lengthToBase == BestPathLength) continue;

        }

        assert(lengthToBase < BestPathLength);



        // If this base *is* the destination, go ahead and start

        // building the path into ReversePath.

        if (base == Dest) {

          // Reset the collected best-path information.

          BestPathLength = lengthToBase;

          ReversePath.clear();



        // Otherwise, if there isn't a better path through this base,

        // don't accumulate anything in the path.

        } else if (!findBetterPath(base, IGM.getProtocolInfo(base),

                                   lengthToBase)) {

          continue;

        }



        // Okay, we've found a better path, and ReversePath contains a

        // path leading from base to Dest.

        assert(BestPathLength >= lengthToBase);

        foundBetter = true;



        // Add the link from proto to base if necessary.

        if (!baseIndex.isPrefix()) {

          ReversePath.push_back(baseIndex);



        // If it isn't necessary, then we might be able to

        // short-circuit considering the bases of this protocol.

        } else {

          if (lengthSoFar == BestPathLength)

            return true;

        }

      }



      return foundBetter;

    }

","    bool findBetterPath(ProtocolDecl *proto, const ProtocolInfo &protoInfo,

                        unsigned lengthSoFar) {

      assert(lengthSoFar < BestPathLength);

      assert(proto != Dest);



      // Keep track of whether we found a better path than the

      // previous best.

","
      for (auto base : proto->getInheritedProtocols()) {

        // ObjC protocols do not have witnesses.

        if (!Lowering::TypeConverter::protocolRequiresWitnessTable(base))

          continue;



        auto baseIndex = protoInfo.getBaseIndex(base);



        // Compute the length down to this base.

        unsigned lengthToBase = lengthSoFar;

        if (!baseIndex.isPrefix()) {

          lengthToBase++;



          // Don't consider this path if we reach a length that can't

          // possibly be better than the best so far.

          if (lengthToBase == BestPathLength) continue;

        }

        assert(lengthToBase < BestPathLength);



        // If this base *is* the destination, go ahead and start

        // building the path into ReversePath.

        if (base == Dest) {

          // Reset the collected best-path information.

          BestPathLength = lengthToBase;

          ReversePath.clear();



        // Otherwise, if there isn't a better path through this base,

        // don't accumulate anything in the path.

        } else if (!findBetterPath(base, IGM.getProtocolInfo(base),

                                   lengthToBase)) {

          continue;

        }



        // Okay, we've found a better path, and ReversePath contains a

        // path leading from base to Dest.

        assert(BestPathLength >= lengthToBase);

        foundBetter = true;



        // Add the link from proto to base if necessary.

        if (!baseIndex.isPrefix()) {

          ReversePath.push_back(baseIndex);



        // If it isn't necessary, then we might be able to

        // short-circuit considering the bases of this protocol.

        } else {

          if (lengthSoFar == BestPathLength)

            return true;

        }

      }



      return foundBetter;

    }


"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,-,assert(piEntry.getOutOfLineBaseIndex().getValue() == Table.size(),"    void addOutOfLineBaseProtocol(ProtocolDecl *baseProto) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::BaseProtocol

             && ""sil witness table does not match protocol"");

      assert(entry.getBaseProtocolWitness().Requirement == baseProto

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getBaseIndex(baseProto);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif

      

      SILEntries = SILEntries.slice(1);



      // TODO: Use the witness entry instead of falling through here.



      // Look for a protocol type info.

      const ProtocolInfo &basePI = IGM.getProtocolInfo(baseProto);

      const ProtocolConformance *astConf

        = Conformance.getInheritedConformance(baseProto);

      const ConformanceInfo &conf =

        basePI.getConformance(IGM, baseProto, astConf);



      // If we can emit the base witness table as a constant, do so.

      llvm::Constant *baseWitness = conf.tryGetConstantTable(IGM, ConcreteType);

      if (baseWitness) {

        Table.push_back(baseWitness);

        return;

      }



      // Otherwise, we'll need to derive it at instantiation time.

      RequiresSpecialization = true;

      SpecializedBaseConformances.push_back({Table.size(), &conf});

      Table.push_back(llvm::ConstantPointerNull::get(IGM.WitnessTablePtrTy));

    }

","    void addOutOfLineBaseProtocol(ProtocolDecl *baseProto) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::BaseProtocol

","
      assert(entry.getBaseProtocolWitness().Requirement == baseProto

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getBaseIndex(baseProto);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif

      

      SILEntries = SILEntries.slice(1);



      // TODO: Use the witness entry instead of falling through here.



      // Look for a protocol type info.

      const ProtocolInfo &basePI = IGM.getProtocolInfo(baseProto);

      const ProtocolConformance *astConf

        = Conformance.getInheritedConformance(baseProto);

      const ConformanceInfo &conf =

        basePI.getConformance(IGM, baseProto, astConf);



      // If we can emit the base witness table as a constant, do so.

      llvm::Constant *baseWitness = conf.tryGetConstantTable(IGM, ConcreteType);

      if (baseWitness) {

        Table.push_back(baseWitness);

        return;

      }



      // Otherwise, we'll need to derive it at instantiation time.

      RequiresSpecialization = true;

      SpecializedBaseConformances.push_back({Table.size(), &conf});

      Table.push_back(llvm::ConstantPointerNull::get(IGM.WitnessTablePtrTy));

    }


"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),"    void addOutOfLineBaseProtocol(ProtocolDecl *baseProto) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::BaseProtocol

             && ""sil witness table does not match protocol"");

      assert(entry.getBaseProtocolWitness().Requirement == baseProto

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getBaseIndex(baseProto);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif

      

      SILEntries = SILEntries.slice(1);



      // TODO: Use the witness entry instead of falling through here.



      // Look for a protocol type info.

      const ProtocolInfo &basePI = IGM.getProtocolInfo(baseProto);

      const ProtocolConformance *astConf

        = Conformance.getInheritedConformance(baseProto);

      const ConformanceInfo &conf =

        basePI.getConformance(IGM, baseProto, astConf);



      // If we can emit the base witness table as a constant, do so.

      llvm::Constant *baseWitness = conf.tryGetConstantTable(IGM, ConcreteType);

      if (baseWitness) {

        Table.push_back(baseWitness);

        return;

      }



      // Otherwise, we'll need to derive it at instantiation time.

      RequiresSpecialization = true;

      SpecializedBaseConformances.push_back({Table.size(), &conf});

      Table.push_back(llvm::ConstantPointerNull::get(IGM.WitnessTablePtrTy));

    }

","    void addOutOfLineBaseProtocol(ProtocolDecl *baseProto) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::BaseProtocol

             && ""sil witness table does not match protocol"");

      assert(entry.getBaseProtocolWitness().Requirement == baseProto

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getBaseIndex(baseProto);

     ","
             && ""offset doesn't match ProtocolInfo layout"");

#endif

      

      SILEntries = SILEntries.slice(1);



      // TODO: Use the witness entry instead of falling through here.



      // Look for a protocol type info.

      const ProtocolInfo &basePI = IGM.getProtocolInfo(baseProto);

      const ProtocolConformance *astConf

        = Conformance.getInheritedConformance(baseProto);

      const ConformanceInfo &conf =

        basePI.getConformance(IGM, baseProto, astConf);



      // If we can emit the base witness table as a constant, do so.

      llvm::Constant *baseWitness = conf.tryGetConstantTable(IGM, ConcreteType);

      if (baseWitness) {

        Table.push_back(baseWitness);

        return;

      }



      // Otherwise, we'll need to derive it at instantiation time.

      RequiresSpecialization = true;

      SpecializedBaseConformances.push_back({Table.size(), &conf});

      Table.push_back(llvm::ConstantPointerNull::get(IGM.WitnessTablePtrTy));

    }

"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,-,assert(piEntry.getFunctionIndex().getValue() == Table.size(),"    void addMethodFromSILWitnessTable(AbstractFunctionDecl *requirement) {

      auto &entry = SILEntries.front();

      SILEntries = SILEntries.slice(1);



      // Handle missing optional requirements.

      if (entry.getKind() == SILWitnessTable::MissingOptional) {

        Table.push_back(llvm::ConstantPointerNull::get(IGM.Int8PtrTy));

        return;

      }



#ifndef NDEBUG

      assert(entry.getKind() == SILWitnessTable::Method

             && ""sil witness table does not match protocol"");

      assert(entry.getMethodWitness().Requirement.getDecl() == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getFunctionIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILFunction *Func = entry.getMethodWitness().Witness;

      llvm::Constant *witness = nullptr;

      if (Func) {

        witness = IGM.getAddrOfSILFunction(Func, NotForDefinition);

      } else {

        // The method is removed by dead method elimination.

        // It should be never called. We add a pointer to an error function.

        witness = IGM.getDeletedMethodErrorFn();

      }

      Table.push_back(witness);

      return;

    }

","    void addMethodFromSILWitnessTable(AbstractFunctionDecl *requirement) {

      auto &entry = SILEntries.front();

      SILEntries = SILEntries.slice(1);



      // Handle missing optional requirements.

      if (entry.getKind() == SILWitnessTable::MissingOptional) {

        Table.push_back(llvm::ConstantPointerNull::get(IGM.Int8PtrTy));

        return;

","


#ifndef NDEBUG

      assert(entry.getKind() == SILWitnessTable::Method

             && ""sil witness table does not match protocol"");

      assert(entry.getMethodWitness().Requirement.getDecl() == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getFunctionIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILFunction *Func = entry.getMethodWitness().Witness;

      llvm::Constant *witness = nullptr;

      if (Func) {

        witness = IGM.getAddrOfSILFunction(Func, NotForDefinition);

      } else {

        // The method is removed by dead method elimination.

        // It should be never called. We add a pointer to an error function.

        witness = IGM.getDeletedMethodErrorFn();

      }

      Table.push_back(witness);

      return;

    }


"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),"    void addMethodFromSILWitnessTable(AbstractFunctionDecl *requirement) {

      auto &entry = SILEntries.front();

      SILEntries = SILEntries.slice(1);



      // Handle missing optional requirements.

      if (entry.getKind() == SILWitnessTable::MissingOptional) {

        Table.push_back(llvm::ConstantPointerNull::get(IGM.Int8PtrTy));

        return;

      }



#ifndef NDEBUG

      assert(entry.getKind() == SILWitnessTable::Method

             && ""sil witness table does not match protocol"");

      assert(entry.getMethodWitness().Requirement.getDecl() == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getFunctionIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILFunction *Func = entry.getMethodWitness().Witness;

      llvm::Constant *witness = nullptr;

      if (Func) {

        witness = IGM.getAddrOfSILFunction(Func, NotForDefinition);

      } else {

        // The method is removed by dead method elimination.

        // It should be never called. We add a pointer to an error function.

        witness = IGM.getDeletedMethodErrorFn();

      }

      Table.push_back(witness);

      return;

    }

","    void addMethodFromSILWitnessTable(AbstractFunctionDecl *requirement) {

      auto &entry = SILEntries.front();

      SILEntries = SILEntries.slice(1);



      // Handle missing optional requirements.

      if (entry.getKind() == SILWitnessTable::MissingOptional) {

        Table.push_back(llvm::ConstantPointerNull::get(IGM.Int8PtrTy));

        return;

      }



#ifndef NDEBUG

      assert(entry.getKind() == SILWitnessTable::Method

             && ""sil witness table does not match protocol"");

      assert(entry.getMethodWitness().Requirement.getDecl() == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getFunctionIndex(requirement);

     ","
             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILFunction *Func = entry.getMethodWitness().Witness;

      llvm::Constant *witness = nullptr;

      if (Func) {

        witness = IGM.getAddrOfSILFunction(Func, NotForDefinition);

      } else {

        // The method is removed by dead method elimination.

        // It should be never called. We add a pointer to an error function.

        witness = IGM.getDeletedMethodErrorFn();

      }

      Table.push_back(witness);

      return;

    }

"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,-,assert(piEntry.getAssociatedTypeIndex().getValue() == Table.size(),"    void addAssociatedType(AssociatedTypeDecl *requirement) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::AssociatedType

             && ""sil witness table does not match protocol"");

      assert(entry.getAssociatedTypeWitness().Requirement == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getAssociatedTypeIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      const Substitution &sub =

        Conformance.getTypeWitness(requirement, nullptr);



      // This type will be expressed in terms of the archetypes

      // of the conforming context.

      CanType associate = sub.getReplacement()->getCanonicalType();

      assert(!associate->hasTypeParameter());



      llvm::Constant *metadataAccessFunction =

        getAssociatedTypeMetadataAccessFunction(requirement, associate);

      Table.push_back(metadataAccessFunction);

    }

","    void addAssociatedType(AssociatedTypeDecl *requirement) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::AssociatedType

             && ""sil witness table does not match protocol"");

","
             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getAssociatedTypeIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      const Substitution &sub =

        Conformance.getTypeWitness(requirement, nullptr);



      // This type will be expressed in terms of the archetypes

      // of the conforming context.

      CanType associate = sub.getReplacement()->getCanonicalType();

      assert(!associate->hasTypeParameter());



      llvm::Constant *metadataAccessFunction =

        getAssociatedTypeMetadataAccessFunction(requirement, associate);

      Table.push_back(metadataAccessFunction);

    }


"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),"    void addAssociatedType(AssociatedTypeDecl *requirement) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::AssociatedType

             && ""sil witness table does not match protocol"");

      assert(entry.getAssociatedTypeWitness().Requirement == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getAssociatedTypeIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      const Substitution &sub =

        Conformance.getTypeWitness(requirement, nullptr);



      // This type will be expressed in terms of the archetypes

      // of the conforming context.

      CanType associate = sub.getReplacement()->getCanonicalType();

      assert(!associate->hasTypeParameter());



      llvm::Constant *metadataAccessFunction =

        getAssociatedTypeMetadataAccessFunction(requirement, associate);

      Table.push_back(metadataAccessFunction);

    }

","    void addAssociatedType(AssociatedTypeDecl *requirement) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::AssociatedType

             && ""sil witness table does not match protocol"");

      assert(entry.getAssociatedTypeWitness().Requirement == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getAssociatedTypeIndex(requirement);

     ","
             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      const Substitution &sub =

        Conformance.getTypeWitness(requirement, nullptr);



      // This type will be expressed in terms of the archetypes

      // of the conforming context.

      CanType associate = sub.getReplacement()->getCanonicalType();

      assert(!associate->hasTypeParameter());



      llvm::Constant *metadataAccessFunction =

        getAssociatedTypeMetadataAccessFunction(requirement, associate);

      Table.push_back(metadataAccessFunction);

    }

"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,-,assert(protos.size() == sub.getConformances().size());,"    void addAssociatedType(AssociatedTypeDecl *requirement) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::AssociatedType

             && ""sil witness table does not match protocol"");

      assert(entry.getAssociatedTypeWitness().Requirement == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getAssociatedTypeIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      const Substitution &sub =

        Conformance.getTypeWitness(requirement, nullptr);



      // This type will be expressed in terms of the archetypes

      // of the conforming context.

      CanType associate = sub.getReplacement()->getCanonicalType();

      assert(!associate->hasTypeParameter());



      llvm::Constant *metadataAccessFunction =

        getAssociatedTypeMetadataAccessFunction(requirement, associate);

      Table.push_back(metadataAccessFunction);

    }

","    void addAssociatedType(AssociatedTypeDecl *requirement) {

#ifndef NDEBUG

      auto &entry = SILEntries.front();

      assert(entry.getKind() == SILWitnessTable::AssociatedType

             && ""sil witness table does not match protocol"");

      assert(entry.getAssociatedTypeWitness().Requirement == requirement

             && ""sil witness table does not match protocol"");

      auto piIndex = PI.getAssociatedTypeIndex(requirement);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");
","#endif



      SILEntries = SILEntries.slice(1);



      const Substitution &sub =

        Conformance.getTypeWitness(requirement, nullptr);



      // This type will be expressed in terms of the archetypes

      // of the conforming context.

      CanType associate = sub.getReplacement()->getCanonicalType();

      assert(!associate->hasTypeParameter());



      llvm::Constant *metadataAccessFunction =

        getAssociatedTypeMetadataAccessFunction(requirement, associate);

      Table.push_back(metadataAccessFunction);

    }


"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,+,assert(!associate->hasTypeParameter());,"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

     ","


      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,-,assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol,"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);

","
#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }


"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,-,assert(associatedWitness.Requirement == requirement,"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



","
      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }


"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,-,assert(associatedWitness.Protocol == protocol,"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG
","      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }


"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,+,assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol,"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

     ","
             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,+,assert(associatedWitness.Requirement->isEqual(associatedType),"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

     ","
             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,+,assert(associatedWitness.Protocol == protocol,"    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

      assert(associatedWitness.Protocol == protocol

             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

","    void addAssociatedConformance(Type associatedType, ProtocolDecl *protocol) {

      // FIXME: Add static witness tables for type conformances.



      CanType associate = Conformance.getAssociatedType(associatedType)

                                    ->getCanonicalType();

      assert(!associate->hasTypeParameter());



      ProtocolConformanceRef associatedConformance =

        Conformance.getAssociatedConformance(associatedType, protocol);



#ifndef NDEBUG

      auto &entry = SILEntries.front();

      (void)entry;

      assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol

             && ""sil witness table does not match protocol"");

      auto associatedWitness = entry.getAssociatedTypeProtocolWitness();

      assert(associatedWitness.Requirement->isEqual(associatedType)

             && ""sil witness table does not match protocol"");

     ","
             && ""sil witness table does not match protocol"");

      auto piIndex =

        PI.getAssociatedConformanceIndex(associatedType->getCanonicalType(),

                                         protocol);

      assert(piIndex.getValue() == Table.size()

             && ""offset doesn't match ProtocolInfo layout"");

#endif



      SILEntries = SILEntries.slice(1);



      llvm::Constant *wtableAccessFunction = 

        getAssociatedTypeWitnessTableAccessFunction(CanType(associatedType),

                                 associate, protocol, associatedConformance);

      Table.push_back(wtableAccessFunction);

    }

"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,+,assert(isa<GenericTypeParamType>(depAssociatedType)); // Self,"static void buildAssociatedTypeValueName(CanType depAssociatedType,

                                         SmallString<128> &name) {

  if (auto memberType = dyn_cast<DependentMemberType>(depAssociatedType)) {

    buildAssociatedTypeValueName(memberType.getBase(), name);

    name += '.';

    name += memberType->getName().str();

  } else {

    assert(isa<GenericTypeParamType>(depAssociatedType)); // Self

  }

}

","static void buildAssociatedTypeValueName(CanType depAssociatedType,

                                         SmallString<128> &name) {

  if (auto memberType = dyn_cast<DependentMemberType>(depAssociatedType)) {

    buildAssociatedTypeValueName(memberType.getBase(), name);

    name += '.';

    name += memberType->getName().str();

  } else {

   ","
  }

}

"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/Linking.cpp,+,assert(isa<GenericTypeParamType>(assocType));,"static void mangleAssociatedTypePath(Mangler &mangler, CanType assocType) {

  if (auto memberType = dyn_cast<DependentMemberType>(assocType)) {

    mangleAssociatedTypePath(mangler, memberType.getBase());

    mangler.mangleIdentifier(memberType->getName().str());

  } else {

    assert(isa<GenericTypeParamType>(assocType));

  }

}

","static void mangleAssociatedTypePath(Mangler &mangler, CanType assocType) {

  if (auto memberType = dyn_cast<DependentMemberType>(assocType)) {

    mangleAssociatedTypePath(mangler, memberType.getBase());

    mangler.mangleIdentifier(memberType->getName().str());

  } else {

   ","
  }

}

"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/SIL/SILPrinter.cpp,+,"static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {","static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {

  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

    if (printAssociatedTypePath(OS, memberType.getBase()))

      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

    assert(isa<GenericTypeParamType>(path));

    return false;

  }

}

","static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {

  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

    if (printAssociatedTypePath(OS, memberType.getBase()))

      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

    assert(isa<GenericTypeParamType>(path));

    return false;

  }

}
","
  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

    if (printAssociatedTypePath(OS, memberType.getBase()))

      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

    assert(isa<GenericTypeParamType>(path));

    return false;

  }

}

"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/SIL/SILPrinter.cpp,+,"if (printAssociatedTypePath(OS, memberType.getBase()))","static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {

  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

    if (printAssociatedTypePath(OS, memberType.getBase()))

      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

    assert(isa<GenericTypeParamType>(path));

    return false;

  }

}

","static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {

  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

   ","
      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

    assert(isa<GenericTypeParamType>(path));

    return false;

  }

}

"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/SIL/SILPrinter.cpp,+,assert(isa<GenericTypeParamType>(path));,"static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {

  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

    if (printAssociatedTypePath(OS, memberType.getBase()))

      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

    assert(isa<GenericTypeParamType>(path));

    return false;

  }

}

","static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {

  if (auto memberType = dyn_cast<DependentMemberType>(path)) {

    if (printAssociatedTypePath(OS, memberType.getBase()))

      OS << '.';

    OS << memberType->getName().str();

    return true;

  } else {

   ","
    return false;

  }

}

"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/SILGen/SILGenDecl.cpp,-,assert(protos.size() == witness.getConformances().size(),"  void addAssociatedConformance(CanType dependentType, ProtocolDecl *protocol) {

    auto assocConformance =

      Conformance->getAssociatedConformance(dependentType, protocol);



    SGM.useConformance(assocConformance);



    Entries.push_back(SILWitnessTable::AssociatedTypeProtocolWitness{

        dependentType, protocol, assocConformance});

  }

","  void addAssociatedConformance(CanType dependentType, ProtocolDecl *protocol) {

","
      Conformance->getAssociatedConformance(dependentType, protocol);



    SGM.useConformance(assocConformance);



    Entries.push_back(SILWitnessTable::AssociatedTypeProtocolWitness{

        dependentType, protocol, assocConformance});

  }


"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/SILGen/SILGenDecl.cpp,-,assert(witness.getConformances().empty(),"  void addAssociatedConformance(CanType dependentType, ProtocolDecl *protocol) {

    auto assocConformance =

      Conformance->getAssociatedConformance(dependentType, protocol);



    SGM.useConformance(assocConformance);



    Entries.push_back(SILWitnessTable::AssociatedTypeProtocolWitness{

        dependentType, protocol, assocConformance});

  }

","  void addAssociatedConformance(CanType dependentType, ProtocolDecl *protocol) {

    auto assocConformance =

      Conformance->getAssociatedConformance(dependentType, protocol);
","

    SGM.useConformance(assocConformance);



    Entries.push_back(SILWitnessTable::AssociatedTypeProtocolWitness{

        dependentType, protocol, assocConformance});

  }


"
"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/SILGen/SILGenDecl.cpp,-,assert(foundConformance != witness.getConformances().end());,"static SILWitnessTable *

getWitnessTableToInsertAfter(SILGenModule &SGM,

                             NormalProtocolConformance *insertAfter) {

  while (insertAfter) {

    // If the table was emitted, emit after it.

    auto found = SGM.emittedWitnessTables.find(insertAfter);

    if (found != SGM.emittedWitnessTables.end())

      return found->second;



    // Otherwise, try inserting after the table we would transitively be

    // inserted after.

    auto foundDelayed = SGM.delayedConformances.find(insertAfter);

    if (foundDelayed != SGM.delayedConformances.end())

      insertAfter = foundDelayed->second.insertAfter;

    else

      break;

  }



  return nullptr;

}

","static SILWitnessTable *

getWitnessTableToInsertAfter(SILGenModule &SGM,

                             NormalProtocolConformance *insertAfter) {

  while (insertAfter) {

    // If the table was emitted, emit after it.

    auto found = SGM.emittedWitnessTables.find(insertAfter);

    if (found != SGM.emittedWitnessTables.end())
","      return found->second;



    // Otherwise, try inserting after the table we would transitively be

    // inserted after.

    auto foundDelayed = SGM.delayedConformances.find(insertAfter);

    if (foundDelayed != SGM.delayedConformances.end())

      insertAfter = foundDelayed->second.insertAfter;

    else

      break;

  }



  return nullptr;

}


"
Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,LogJob(const Job *j) : j(j) {},"  LogJob(const Job *j) : j(j) {}

", ,"
"
Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,LogJobArray(const ArrayRef<const Job *> js) : js(js) {},"  LogJobArray(const ArrayRef<const Job *> js) : js(js) {}

", ,"
"
Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,LogJobSet(const SmallPtrSetImpl<const Job*> &js) : js(js) {},"  LogJobSet(const SmallPtrSetImpl<const Job*> &js) : js(js) {}

", ,"
"
Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,lj.j->printSummary(os);,"llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJob &lj) {

  lj.j->printSummary(os);

  return os;

}

","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJob &lj) {

 ","
  return os;

}

"
Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,"[&](Job const *j) { os << LogJob(j); },","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobArray &ljs) {

  os << ""["";

  interleave(ljs.js,

             [&](Job const *j) { os << LogJob(j); },

             [&]() { os << ' '; });

  os << ""]"";

  return os;

}

","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobArray &ljs) {

  os << ""["";

  interleave(ljs.js,

            ","
             [&]() { os << ' '; });

  os << ""]"";

  return os;

}

"
Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,"[&](Job const *j) { os << LogJob(j); },","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobSet &ljs) {

  os << ""{"";

  interleave(ljs.js,

             [&](Job const *j) { os << LogJob(j); },

             [&]() { os << ' '; });

  os << ""}"";

  return os;

}

","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobSet &ljs) {

  os << ""{"";

  interleave(ljs.js,

            ","
             [&]() { os << ' '; });

  os << ""}"";

  return os;

}

"
Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,-,"static_assert(IsTriviallyCopyable<CompileJobAction::InputInfo>::value,","    void

    dependencyLoadFailed(StringRef DependenciesFile, bool Warn=true) {

      if (Warn && Comp.ShowIncrementalBuildDecisions)

        Comp.Diags.diagnose(SourceLoc(),

                            diag::warn_unable_to_load_dependencies,

                            DependenciesFile);

      Comp.disableIncrementalBuild();

      for (const Job *Cmd : DeferredCommands)

        scheduleCommandIfNecessaryAndPossible(Cmd);

      DeferredCommands.clear();

    }

","    void
","    dependencyLoadFailed(StringRef DependenciesFile, bool Warn=true) {

      if (Warn && Comp.ShowIncrementalBuildDecisions)

        Comp.Diags.diagnose(SourceLoc(),

                            diag::warn_unable_to_load_dependencies,

                            DependenciesFile);

      Comp.disableIncrementalBuild();

      for (const Job *Cmd : DeferredCommands)

        scheduleCommandIfNecessaryAndPossible(Cmd);

      DeferredCommands.clear();

    }


"
Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,assert(FinishedCmd->getCondition() == Job::Condition::Always);,"    void reloadAndRemarkDeps(const Job *FinishedCmd,

                             int ReturnCode,

                             SmallVector<const Job *, N> &Dependents) {

      const CommandOutput &Output = FinishedCmd->getOutput();

      StringRef DependenciesFile =

        Output.getAdditionalOutputForType(types::TY_SwiftDeps);



      if (DependenciesFile.empty()) {

        // If this job doesn't track dependencies, it must always be run.

        // Note: In theory CheckDependencies makes sense as well (for a leaf

        // node in the dependency graph), and maybe even NewlyAdded (for very

        // coarse dependencies that always affect downstream nodes), but we're

        // not using either of those right now, and this logic should probably

        // be revisited when we are.

        assert(FinishedCmd->getCondition() == Job::Condition::Always);

      } else {

        // If we have a dependency file /and/ the frontend task exited normally,

        // we can be discerning about what downstream files to rebuild.

        if (ReturnCode == EXIT_SUCCESS || ReturnCode == EXIT_FAILURE) {

          bool wasCascading = DepGraph.isMarked(FinishedCmd);



          switch (DepGraph.loadFromPath(FinishedCmd, DependenciesFile)) {

          case DependencyGraphImpl::LoadResult::HadError:

            if (ReturnCode == EXIT_SUCCESS) {

              dependencyLoadFailed(DependenciesFile);

              Dependents.clear();

            } // else, let the next build handle it.

            break;

          case DependencyGraphImpl::LoadResult::UpToDate:

            if (!wasCascading)

              break;

            LLVM_FALLTHROUGH;

          case DependencyGraphImpl::LoadResult::AffectsDownstream:

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          }

        } else {

          // If there's an abnormal exit (a crash), assume the worst.

          switch (FinishedCmd->getCondition()) {

          case Job::Condition::NewlyAdded:

            // The job won't be treated as newly added next time. Conservatively

            // mark it as affecting other jobs, because some of them may have

            // completed already.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::Always:

            // Any incremental task that shows up here has already been marked;

            // we didn't need to wait for it to finish to start downstream

            // tasks.

            assert(DepGraph.isMarked(FinishedCmd));

            break;

          case Job::Condition::RunWithoutCascading:

            // If this file changed, it might have been a non-cascading change

            // and it might not. Unfortunately, the interface hash has been

            // updated or compromised, so we don't actually know anymore; we

            // have to conservatively assume the changes could affect other

            // files.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::CheckDependencies:

            // If the only reason we're running this is because something else

            // changed, then we can trust the dependency graph as to whether

            // it's a cascading or non-cascading change. That is, if whatever

            // /caused/ the error isn't supposed to affect other files, and

            // whatever /fixes/ the error isn't supposed to affect other files,

            // then there's no need to recompile any other inputs. If either of

            // those are false, we /do/ need to recompile other inputs.

            break;

          }

        }

      }

    }

","    void reloadAndRemarkDeps(const Job *FinishedCmd,

                             int ReturnCode,

                             SmallVector<const Job *, N> &Dependents) {

      const CommandOutput &Output = FinishedCmd->getOutput();

      StringRef DependenciesFile =

        Output.getAdditionalOutputForType(types::TY_SwiftDeps);



      if (DependenciesFile.empty()) {

        // If this job doesn't track dependencies, it must always be run.

        // Note: In theory CheckDependencies makes sense as well (for a leaf

        // node in the dependency graph), and maybe even NewlyAdded (for very

        // coarse dependencies that always affect downstream nodes), but we're

        // not using either of those right now, and this logic should probably

        // be revisited when we are.

       ","
      } else {

        // If we have a dependency file /and/ the frontend task exited normally,

        // we can be discerning about what downstream files to rebuild.

        if (ReturnCode == EXIT_SUCCESS || ReturnCode == EXIT_FAILURE) {

          bool wasCascading = DepGraph.isMarked(FinishedCmd);



          switch (DepGraph.loadFromPath(FinishedCmd, DependenciesFile)) {

          case DependencyGraphImpl::LoadResult::HadError:

            if (ReturnCode == EXIT_SUCCESS) {

              dependencyLoadFailed(DependenciesFile);

              Dependents.clear();

            } // else, let the next build handle it.

            break;

          case DependencyGraphImpl::LoadResult::UpToDate:

            if (!wasCascading)

              break;

            LLVM_FALLTHROUGH;

          case DependencyGraphImpl::LoadResult::AffectsDownstream:

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          }

        } else {

          // If there's an abnormal exit (a crash), assume the worst.

          switch (FinishedCmd->getCondition()) {

          case Job::Condition::NewlyAdded:

            // The job won't be treated as newly added next time. Conservatively

            // mark it as affecting other jobs, because some of them may have

            // completed already.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::Always:

            // Any incremental task that shows up here has already been marked;

            // we didn't need to wait for it to finish to start downstream

            // tasks.

            assert(DepGraph.isMarked(FinishedCmd));

            break;

          case Job::Condition::RunWithoutCascading:

            // If this file changed, it might have been a non-cascading change

            // and it might not. Unfortunately, the interface hash has been

            // updated or compromised, so we don't actually know anymore; we

            // have to conservatively assume the changes could affect other

            // files.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::CheckDependencies:

            // If the only reason we're running this is because something else

            // changed, then we can trust the dependency graph as to whether

            // it's a cascading or non-cascading change. That is, if whatever

            // /caused/ the error isn't supposed to affect other files, and

            // whatever /fixes/ the error isn't supposed to affect other files,

            // then there's no need to recompile any other inputs. If either of

            // those are false, we /do/ need to recompile other inputs.

            break;

          }

        }

      }

    }

"
Merge branch 'master' into normal-conformance-requirement-signature,tools/swift-demangle/swift-demangle.cpp,+,assert(remangled.find(MANGLING_PREFIX_STR) == 0);,"static void demangle(llvm::raw_ostream &os, llvm::StringRef name,

                     swift::Demangle::Context &DCtx,

                     const swift::Demangle::DemangleOptions &options) {

  bool hadLeadingUnderscore = false;

  if (name.startswith(""__"")) {

    hadLeadingUnderscore = true;

    name = name.substr(1);

  }

  swift::Demangle::NodePointer pointer = DCtx.demangleSymbolAsNode(name);

  if (ExpandMode || TreeOnly) {

    llvm::outs() << ""Demangling for "" << name << '\n';

    swift::demangle_wrappers::NodeDumper(pointer).print(llvm::outs());

  }

  if (RemangleMode) {

    std::string remangled;

    if (!pointer) {

      // Just reprint the original mangled name if it didn't demangle.

      // This makes it easier to share the same database between the

      // mangling and demangling tests.

      remangled = name;

    } else {

      // Also accept the future mangling prefix.

      // TODO: remove the ""_S"" as soon as MANGLING_PREFIX_STR gets ""_S"".

      remangled = swift::Demangle::mangleNode(pointer,

                          /*NewMangling*/ name.startswith(MANGLING_PREFIX_STR)

                                          || name.startswith(""_S""));

      if (name.startswith(""_S"")) {

        assert(remangled.find(MANGLING_PREFIX_STR) == 0);

        remangled = ""_S"" + remangled.substr(3);

      }

      if (name != remangled) {

        llvm::errs() << ""\nError: re-mangled name \n  "" << remangled

                     << ""\ndoes not match original name\n  "" << name << '\n';

        exit(1);

      }

    }

    if (hadLeadingUnderscore) llvm::outs() << '_';

    llvm::outs() << remangled;

    return;

  }

  if (!TreeOnly) {

    if (RemangleNew) {

      if (!pointer) {

        llvm::errs() << ""Can't de-mangle "" << name << '\n';

        exit(1);

      }

      std::string remangled = swift::Demangle::mangleNode(pointer);

      llvm::outs() << remangled;

      return;

    }

    std::string string = swift::Demangle::nodeToString(pointer, options);

    if (!CompactMode)

      llvm::outs() << name << "" ---> "";



    if (Classify) {

      std::string Classifications;

      std::string cName = name.str();

      if (!swift::Demangle::isSwiftSymbol(cName.c_str()))

        Classifications += 'N';

      if (DCtx.isThunkSymbol(name))

        Classifications += 'T';

      if (pointer && !DCtx.hasSwiftCallingConvention(name))

        Classifications += 'C';

      if (!Classifications.empty())

        llvm::outs() << '{' << Classifications << ""} "";

    }

    llvm::outs() << (string.empty() ? name : llvm::StringRef(string));

  }

  DCtx.clear();

}

","static void demangle(llvm::raw_ostream &os, llvm::StringRef name,

                     swift::Demangle::Context &DCtx,

                     const swift::Demangle::DemangleOptions &options) {

  bool hadLeadingUnderscore = false;

  if (name.startswith(""__"")) {

    hadLeadingUnderscore = true;

    name = name.substr(1);

  }

  swift::Demangle::NodePointer pointer = DCtx.demangleSymbolAsNode(name);

  if (ExpandMode || TreeOnly) {

    llvm::outs() << ""Demangling for "" << name << '\n';

    swift::demangle_wrappers::NodeDumper(pointer).print(llvm::outs());

  }

  if (RemangleMode) {

    std::string remangled;

    if (!pointer) {

      // Just reprint the original mangled name if it didn't demangle.

      // This makes it easier to share the same database between the

      // mangling and demangling tests.

      remangled = name;

    } else {

      // Also accept the future mangling prefix.

      // TODO: remove the ""_S"" as soon as MANGLING_PREFIX_STR gets ""_S"".

      remangled = swift::Demangle::mangleNode(pointer,

                          /*NewMangling*/ name.startswith(MANGLING_PREFIX_STR)

                                          || name.startswith(""_S""));

      if (name.startswith(""_S"")) {

       ","
        remangled = ""_S"" + remangled.substr(3);

      }

      if (name != remangled) {

        llvm::errs() << ""\nError: re-mangled name \n  "" << remangled

                     << ""\ndoes not match original name\n  "" << name << '\n';

        exit(1);

      }

    }

    if (hadLeadingUnderscore) llvm::outs() << '_';

    llvm::outs() << remangled;

    return;

  }

  if (!TreeOnly) {

    if (RemangleNew) {

      if (!pointer) {

        llvm::errs() << ""Can't de-mangle "" << name << '\n';

        exit(1);

      }

      std::string remangled = swift::Demangle::mangleNode(pointer);

      llvm::outs() << remangled;

      return;

    }

    std::string string = swift::Demangle::nodeToString(pointer, options);

    if (!CompactMode)

      llvm::outs() << name << "" ---> "";



    if (Classify) {

      std::string Classifications;

      std::string cName = name.str();

      if (!swift::Demangle::isSwiftSymbol(cName.c_str()))

        Classifications += 'N';

      if (DCtx.isThunkSymbol(name))

        Classifications += 'T';

      if (pointer && !DCtx.hasSwiftCallingConvention(name))

        Classifications += 'C';

      if (!Classifications.empty())

        llvm::outs() << '{' << Classifications << ""} "";

    }

    llvm::outs() << (string.empty() ? name : llvm::StringRef(string));

  }

  DCtx.clear();

}

"
"Merge pull request #7850 from eeckstein/demangle-swiftcc

demangler: swiftcc check and support of _S",tools/swift-demangle/swift-demangle.cpp,+,assert(remangled.find(MANGLING_PREFIX_STR) == 0);,"static void demangle(llvm::raw_ostream &os, llvm::StringRef name,

                     swift::Demangle::Context &DCtx,

                     const swift::Demangle::DemangleOptions &options) {

  bool hadLeadingUnderscore = false;

  if (name.startswith(""__"")) {

    hadLeadingUnderscore = true;

    name = name.substr(1);

  }

  swift::Demangle::NodePointer pointer = DCtx.demangleSymbolAsNode(name);

  if (ExpandMode || TreeOnly) {

    llvm::outs() << ""Demangling for "" << name << '\n';

    swift::demangle_wrappers::NodeDumper(pointer).print(llvm::outs());

  }

  if (RemangleMode) {

    std::string remangled;

    if (!pointer) {

      // Just reprint the original mangled name if it didn't demangle.

      // This makes it easier to share the same database between the

      // mangling and demangling tests.

      remangled = name;

    } else {

      // Also accept the future mangling prefix.

      // TODO: remove the ""_S"" as soon as MANGLING_PREFIX_STR gets ""_S"".

      remangled = swift::Demangle::mangleNode(pointer,

                          /*NewMangling*/ name.startswith(MANGLING_PREFIX_STR)

                                          || name.startswith(""_S""));

      if (name.startswith(""_S"")) {

        assert(remangled.find(MANGLING_PREFIX_STR) == 0);

        remangled = ""_S"" + remangled.substr(3);

      }

      if (name != remangled) {

        llvm::errs() << ""\nError: re-mangled name \n  "" << remangled

                     << ""\ndoes not match original name\n  "" << name << '\n';

        exit(1);

      }

    }

    if (hadLeadingUnderscore) llvm::outs() << '_';

    llvm::outs() << remangled;

    return;

  }

  if (!TreeOnly) {

    if (RemangleNew) {

      if (!pointer) {

        llvm::errs() << ""Can't de-mangle "" << name << '\n';

        exit(1);

      }

      std::string remangled = swift::Demangle::mangleNode(pointer);

      llvm::outs() << remangled;

      return;

    }

    std::string string = swift::Demangle::nodeToString(pointer, options);

    if (!CompactMode)

      llvm::outs() << name << "" ---> "";



    if (Classify) {

      std::string Classifications;

      std::string cName = name.str();

      if (!swift::Demangle::isSwiftSymbol(cName.c_str()))

        Classifications += 'N';

      if (DCtx.isThunkSymbol(name))

        Classifications += 'T';

      if (pointer && !DCtx.hasSwiftCallingConvention(name))

        Classifications += 'C';

      if (!Classifications.empty())

        llvm::outs() << '{' << Classifications << ""} "";

    }

    llvm::outs() << (string.empty() ? name : llvm::StringRef(string));

  }

  DCtx.clear();

}

","static void demangle(llvm::raw_ostream &os, llvm::StringRef name,

                     swift::Demangle::Context &DCtx,

                     const swift::Demangle::DemangleOptions &options) {

  bool hadLeadingUnderscore = false;

  if (name.startswith(""__"")) {

    hadLeadingUnderscore = true;

    name = name.substr(1);

  }

  swift::Demangle::NodePointer pointer = DCtx.demangleSymbolAsNode(name);

  if (ExpandMode || TreeOnly) {

    llvm::outs() << ""Demangling for "" << name << '\n';

    swift::demangle_wrappers::NodeDumper(pointer).print(llvm::outs());

  }

  if (RemangleMode) {

    std::string remangled;

    if (!pointer) {

      // Just reprint the original mangled name if it didn't demangle.

      // This makes it easier to share the same database between the

      // mangling and demangling tests.

      remangled = name;

    } else {

      // Also accept the future mangling prefix.

      // TODO: remove the ""_S"" as soon as MANGLING_PREFIX_STR gets ""_S"".

      remangled = swift::Demangle::mangleNode(pointer,

                          /*NewMangling*/ name.startswith(MANGLING_PREFIX_STR)

                                          || name.startswith(""_S""));

      if (name.startswith(""_S"")) {

       ","
        remangled = ""_S"" + remangled.substr(3);

      }

      if (name != remangled) {

        llvm::errs() << ""\nError: re-mangled name \n  "" << remangled

                     << ""\ndoes not match original name\n  "" << name << '\n';

        exit(1);

      }

    }

    if (hadLeadingUnderscore) llvm::outs() << '_';

    llvm::outs() << remangled;

    return;

  }

  if (!TreeOnly) {

    if (RemangleNew) {

      if (!pointer) {

        llvm::errs() << ""Can't de-mangle "" << name << '\n';

        exit(1);

      }

      std::string remangled = swift::Demangle::mangleNode(pointer);

      llvm::outs() << remangled;

      return;

    }

    std::string string = swift::Demangle::nodeToString(pointer, options);

    if (!CompactMode)

      llvm::outs() << name << "" ---> "";



    if (Classify) {

      std::string Classifications;

      std::string cName = name.str();

      if (!swift::Demangle::isSwiftSymbol(cName.c_str()))

        Classifications += 'N';

      if (DCtx.isThunkSymbol(name))

        Classifications += 'T';

      if (pointer && !DCtx.hasSwiftCallingConvention(name))

        Classifications += 'C';

      if (!Classifications.empty())

        llvm::outs() << '{' << Classifications << ""} "";

    }

    llvm::outs() << (string.empty() ? name : llvm::StringRef(string));

  }

  DCtx.clear();

}

"
"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,LogJob(const Job *j) : j(j) {},"  LogJob(const Job *j) : j(j) {}

", ,"
"
"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,LogJobArray(const ArrayRef<const Job *> js) : js(js) {},"  LogJobArray(const ArrayRef<const Job *> js) : js(js) {}

", ,"
"
"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,LogJobSet(const SmallPtrSetImpl<const Job*> &js) : js(js) {},"  LogJobSet(const SmallPtrSetImpl<const Job*> &js) : js(js) {}

", ,"
"
"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,lj.j->printSummary(os);,"llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJob &lj) {

  lj.j->printSummary(os);

  return os;

}

","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJob &lj) {

 ","
  return os;

}

"
"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,"[&](Job const *j) { os << LogJob(j); },","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobArray &ljs) {

  os << ""["";

  interleave(ljs.js,

             [&](Job const *j) { os << LogJob(j); },

             [&]() { os << ' '; });

  os << ""]"";

  return os;

}

","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobArray &ljs) {

  os << ""["";

  interleave(ljs.js,

            ","
             [&]() { os << ' '; });

  os << ""]"";

  return os;

}

"
"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,"[&](Job const *j) { os << LogJob(j); },","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobSet &ljs) {

  os << ""{"";

  interleave(ljs.js,

             [&](Job const *j) { os << LogJob(j); },

             [&]() { os << ' '; });

  os << ""}"";

  return os;

}

","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobSet &ljs) {

  os << ""{"";

  interleave(ljs.js,

            ","
             [&]() { os << ' '; });

  os << ""}"";

  return os;

}

"
"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,-,"static_assert(IsTriviallyCopyable<CompileJobAction::InputInfo>::value,","    void

    dependencyLoadFailed(StringRef DependenciesFile, bool Warn=true) {

      if (Warn && Comp.ShowIncrementalBuildDecisions)

        Comp.Diags.diagnose(SourceLoc(),

                            diag::warn_unable_to_load_dependencies,

                            DependenciesFile);

      Comp.disableIncrementalBuild();

      for (const Job *Cmd : DeferredCommands)

        scheduleCommandIfNecessaryAndPossible(Cmd);

      DeferredCommands.clear();

    }

","    void
","    dependencyLoadFailed(StringRef DependenciesFile, bool Warn=true) {

      if (Warn && Comp.ShowIncrementalBuildDecisions)

        Comp.Diags.diagnose(SourceLoc(),

                            diag::warn_unable_to_load_dependencies,

                            DependenciesFile);

      Comp.disableIncrementalBuild();

      for (const Job *Cmd : DeferredCommands)

        scheduleCommandIfNecessaryAndPossible(Cmd);

      DeferredCommands.clear();

    }


"
"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,assert(FinishedCmd->getCondition() == Job::Condition::Always);,"    void reloadAndRemarkDeps(const Job *FinishedCmd,

                             int ReturnCode,

                             SmallVector<const Job *, N> &Dependents) {

      const CommandOutput &Output = FinishedCmd->getOutput();

      StringRef DependenciesFile =

        Output.getAdditionalOutputForType(types::TY_SwiftDeps);



      if (DependenciesFile.empty()) {

        // If this job doesn't track dependencies, it must always be run.

        // Note: In theory CheckDependencies makes sense as well (for a leaf

        // node in the dependency graph), and maybe even NewlyAdded (for very

        // coarse dependencies that always affect downstream nodes), but we're

        // not using either of those right now, and this logic should probably

        // be revisited when we are.

        assert(FinishedCmd->getCondition() == Job::Condition::Always);

      } else {

        // If we have a dependency file /and/ the frontend task exited normally,

        // we can be discerning about what downstream files to rebuild.

        if (ReturnCode == EXIT_SUCCESS || ReturnCode == EXIT_FAILURE) {

          bool wasCascading = DepGraph.isMarked(FinishedCmd);



          switch (DepGraph.loadFromPath(FinishedCmd, DependenciesFile)) {

          case DependencyGraphImpl::LoadResult::HadError:

            if (ReturnCode == EXIT_SUCCESS) {

              dependencyLoadFailed(DependenciesFile);

              Dependents.clear();

            } // else, let the next build handle it.

            break;

          case DependencyGraphImpl::LoadResult::UpToDate:

            if (!wasCascading)

              break;

            LLVM_FALLTHROUGH;

          case DependencyGraphImpl::LoadResult::AffectsDownstream:

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          }

        } else {

          // If there's an abnormal exit (a crash), assume the worst.

          switch (FinishedCmd->getCondition()) {

          case Job::Condition::NewlyAdded:

            // The job won't be treated as newly added next time. Conservatively

            // mark it as affecting other jobs, because some of them may have

            // completed already.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::Always:

            // Any incremental task that shows up here has already been marked;

            // we didn't need to wait for it to finish to start downstream

            // tasks.

            assert(DepGraph.isMarked(FinishedCmd));

            break;

          case Job::Condition::RunWithoutCascading:

            // If this file changed, it might have been a non-cascading change

            // and it might not. Unfortunately, the interface hash has been

            // updated or compromised, so we don't actually know anymore; we

            // have to conservatively assume the changes could affect other

            // files.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::CheckDependencies:

            // If the only reason we're running this is because something else

            // changed, then we can trust the dependency graph as to whether

            // it's a cascading or non-cascading change. That is, if whatever

            // /caused/ the error isn't supposed to affect other files, and

            // whatever /fixes/ the error isn't supposed to affect other files,

            // then there's no need to recompile any other inputs. If either of

            // those are false, we /do/ need to recompile other inputs.

            break;

          }

        }

      }

    }

","    void reloadAndRemarkDeps(const Job *FinishedCmd,

                             int ReturnCode,

                             SmallVector<const Job *, N> &Dependents) {

      const CommandOutput &Output = FinishedCmd->getOutput();

      StringRef DependenciesFile =

        Output.getAdditionalOutputForType(types::TY_SwiftDeps);



      if (DependenciesFile.empty()) {

        // If this job doesn't track dependencies, it must always be run.

        // Note: In theory CheckDependencies makes sense as well (for a leaf

        // node in the dependency graph), and maybe even NewlyAdded (for very

        // coarse dependencies that always affect downstream nodes), but we're

        // not using either of those right now, and this logic should probably

        // be revisited when we are.

       ","
      } else {

        // If we have a dependency file /and/ the frontend task exited normally,

        // we can be discerning about what downstream files to rebuild.

        if (ReturnCode == EXIT_SUCCESS || ReturnCode == EXIT_FAILURE) {

          bool wasCascading = DepGraph.isMarked(FinishedCmd);



          switch (DepGraph.loadFromPath(FinishedCmd, DependenciesFile)) {

          case DependencyGraphImpl::LoadResult::HadError:

            if (ReturnCode == EXIT_SUCCESS) {

              dependencyLoadFailed(DependenciesFile);

              Dependents.clear();

            } // else, let the next build handle it.

            break;

          case DependencyGraphImpl::LoadResult::UpToDate:

            if (!wasCascading)

              break;

            LLVM_FALLTHROUGH;

          case DependencyGraphImpl::LoadResult::AffectsDownstream:

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          }

        } else {

          // If there's an abnormal exit (a crash), assume the worst.

          switch (FinishedCmd->getCondition()) {

          case Job::Condition::NewlyAdded:

            // The job won't be treated as newly added next time. Conservatively

            // mark it as affecting other jobs, because some of them may have

            // completed already.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::Always:

            // Any incremental task that shows up here has already been marked;

            // we didn't need to wait for it to finish to start downstream

            // tasks.

            assert(DepGraph.isMarked(FinishedCmd));

            break;

          case Job::Condition::RunWithoutCascading:

            // If this file changed, it might have been a non-cascading change

            // and it might not. Unfortunately, the interface hash has been

            // updated or compromised, so we don't actually know anymore; we

            // have to conservatively assume the changes could affect other

            // files.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::CheckDependencies:

            // If the only reason we're running this is because something else

            // changed, then we can trust the dependency graph as to whether

            // it's a cascading or non-cascading change. That is, if whatever

            // /caused/ the error isn't supposed to affect other files, and

            // whatever /fixes/ the error isn't supposed to affect other files,

            // then there's no need to recompile any other inputs. If either of

            // those are false, we /do/ need to recompile other inputs.

            break;

          }

        }

      }

    }

"
demangler: also support the future mangling prefix ‘_S’,tools/swift-demangle/swift-demangle.cpp,+,assert(remangled.find(MANGLING_PREFIX_STR) == 0);,"static void demangle(llvm::raw_ostream &os, llvm::StringRef name,

                     swift::Demangle::Context &DCtx,

                     const swift::Demangle::DemangleOptions &options) {

  bool hadLeadingUnderscore = false;

  if (name.startswith(""__"")) {

    hadLeadingUnderscore = true;

    name = name.substr(1);

  }

  swift::Demangle::NodePointer pointer = DCtx.demangleSymbolAsNode(name);

  if (ExpandMode || TreeOnly) {

    llvm::outs() << ""Demangling for "" << name << '\n';

    swift::demangle_wrappers::NodeDumper(pointer).print(llvm::outs());

  }

  if (RemangleMode) {

    std::string remangled;

    if (!pointer) {

      // Just reprint the original mangled name if it didn't demangle.

      // This makes it easier to share the same database between the

      // mangling and demangling tests.

      remangled = name;

    } else {

      // Also accept the future mangling prefix.

      // TODO: remove the ""_S"" as soon as MANGLING_PREFIX_STR gets ""_S"".

      remangled = swift::Demangle::mangleNode(pointer,

                          /*NewMangling*/ name.startswith(MANGLING_PREFIX_STR)

                                          || name.startswith(""_S""));

      if (name.startswith(""_S"")) {

        assert(remangled.find(MANGLING_PREFIX_STR) == 0);

        remangled = ""_S"" + remangled.substr(3);

      }

      if (name != remangled) {

        llvm::errs() << ""\nError: re-mangled name \n  "" << remangled

                     << ""\ndoes not match original name\n  "" << name << '\n';

        exit(1);

      }

    }

    if (hadLeadingUnderscore) llvm::outs() << '_';

    llvm::outs() << remangled;

    return;

  }

  if (!TreeOnly) {

    if (RemangleNew) {

      if (!pointer) {

        llvm::errs() << ""Can't de-mangle "" << name << '\n';

        exit(1);

      }

      std::string remangled = swift::Demangle::mangleNode(pointer);

      llvm::outs() << remangled;

      return;

    }

    std::string string = swift::Demangle::nodeToString(pointer, options);

    if (!CompactMode)

      llvm::outs() << name << "" ---> "";



    if (Classify) {

      std::string Classifications;

      std::string cName = name.str();

      if (!swift::Demangle::isSwiftSymbol(cName.c_str()))

        Classifications += 'N';

      if (DCtx.isThunkSymbol(name))

        Classifications += 'T';

      if (pointer && !DCtx.hasSwiftCallingConvention(name))

        Classifications += 'C';

      if (!Classifications.empty())

        llvm::outs() << '{' << Classifications << ""} "";

    }

    llvm::outs() << (string.empty() ? name : llvm::StringRef(string));

  }

  DCtx.clear();

}

","static void demangle(llvm::raw_ostream &os, llvm::StringRef name,

                     swift::Demangle::Context &DCtx,

                     const swift::Demangle::DemangleOptions &options) {

  bool hadLeadingUnderscore = false;

  if (name.startswith(""__"")) {

    hadLeadingUnderscore = true;

    name = name.substr(1);

  }

  swift::Demangle::NodePointer pointer = DCtx.demangleSymbolAsNode(name);

  if (ExpandMode || TreeOnly) {

    llvm::outs() << ""Demangling for "" << name << '\n';

    swift::demangle_wrappers::NodeDumper(pointer).print(llvm::outs());

  }

  if (RemangleMode) {

    std::string remangled;

    if (!pointer) {

      // Just reprint the original mangled name if it didn't demangle.

      // This makes it easier to share the same database between the

      // mangling and demangling tests.

      remangled = name;

    } else {

      // Also accept the future mangling prefix.

      // TODO: remove the ""_S"" as soon as MANGLING_PREFIX_STR gets ""_S"".

      remangled = swift::Demangle::mangleNode(pointer,

                          /*NewMangling*/ name.startswith(MANGLING_PREFIX_STR)

                                          || name.startswith(""_S""));

      if (name.startswith(""_S"")) {

       ","
        remangled = ""_S"" + remangled.substr(3);

      }

      if (name != remangled) {

        llvm::errs() << ""\nError: re-mangled name \n  "" << remangled

                     << ""\ndoes not match original name\n  "" << name << '\n';

        exit(1);

      }

    }

    if (hadLeadingUnderscore) llvm::outs() << '_';

    llvm::outs() << remangled;

    return;

  }

  if (!TreeOnly) {

    if (RemangleNew) {

      if (!pointer) {

        llvm::errs() << ""Can't de-mangle "" << name << '\n';

        exit(1);

      }

      std::string remangled = swift::Demangle::mangleNode(pointer);

      llvm::outs() << remangled;

      return;

    }

    std::string string = swift::Demangle::nodeToString(pointer, options);

    if (!CompactMode)

      llvm::outs() << name << "" ---> "";



    if (Classify) {

      std::string Classifications;

      std::string cName = name.str();

      if (!swift::Demangle::isSwiftSymbol(cName.c_str()))

        Classifications += 'N';

      if (DCtx.isThunkSymbol(name))

        Classifications += 'T';

      if (pointer && !DCtx.hasSwiftCallingConvention(name))

        Classifications += 'C';

      if (!Classifications.empty())

        llvm::outs() << '{' << Classifications << ""} "";

    }

    llvm::outs() << (string.empty() ? name : llvm::StringRef(string));

  }

  DCtx.clear();

}

"
[Driver] Clear deferred commands on each task queue iteration.,lib/Driver/Compilation.cpp,-,"llvm::outs() << ""Job finished: "" << LogJob(Cmd) << ""\n"";","    void markFinished(const Job *Cmd, bool Skipped=false) {

      if (Comp.ShowIncrementalBuildDecisions) {

        llvm::outs() << ""Job ""

                     << (Skipped ? ""skipped"" : ""finished"")

                     << "": "" << LogJob(Cmd) << ""\n"";

      }

      FinishedCommands.insert(Cmd);



      auto BlockedIter = BlockingCommands.find(Cmd);

      if (BlockedIter != BlockingCommands.end()) {

        auto AllBlocked = std::move(BlockedIter->second);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Scheduling maybe-unblocked jobs: ""

                       << LogJobArray(AllBlocked) << ""\n"";

        }

        BlockingCommands.erase(BlockedIter);

        for (auto *Blocked : AllBlocked)

          scheduleCommandIfNecessaryAndPossible(Blocked);

      }

    }

","    void markFinished(const Job *Cmd, bool Skipped=false) {

      if (Comp.ShowIncrementalBuildDecisions) {
","        llvm::outs() << ""Job ""

                     << (Skipped ? ""skipped"" : ""finished"")

                     << "": "" << LogJob(Cmd) << ""\n"";

      }

      FinishedCommands.insert(Cmd);



      auto BlockedIter = BlockingCommands.find(Cmd);

      if (BlockedIter != BlockingCommands.end()) {

        auto AllBlocked = std::move(BlockedIter->second);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Scheduling maybe-unblocked jobs: ""

                       << LogJobArray(AllBlocked) << ""\n"";

        }

        BlockingCommands.erase(BlockedIter);

        for (auto *Blocked : AllBlocked)

          scheduleCommandIfNecessaryAndPossible(Blocked);

      }

    }


"
[Driver] Clear deferred commands on each task queue iteration.,lib/Driver/Compilation.cpp,+,"<< "": "" << LogJob(Cmd) << ""\n"";","    void markFinished(const Job *Cmd, bool Skipped=false) {

      if (Comp.ShowIncrementalBuildDecisions) {

        llvm::outs() << ""Job ""

                     << (Skipped ? ""skipped"" : ""finished"")

                     << "": "" << LogJob(Cmd) << ""\n"";

      }

      FinishedCommands.insert(Cmd);



      auto BlockedIter = BlockingCommands.find(Cmd);

      if (BlockedIter != BlockingCommands.end()) {

        auto AllBlocked = std::move(BlockedIter->second);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Scheduling maybe-unblocked jobs: ""

                       << LogJobArray(AllBlocked) << ""\n"";

        }

        BlockingCommands.erase(BlockedIter);

        for (auto *Blocked : AllBlocked)

          scheduleCommandIfNecessaryAndPossible(Blocked);

      }

    }

","    void markFinished(const Job *Cmd, bool Skipped=false) {

      if (Comp.ShowIncrementalBuildDecisions) {

        llvm::outs() << ""Job ""

                     << (Skipped ? ""skipped"" : ""finished"")

                    ","
      }

      FinishedCommands.insert(Cmd);



      auto BlockedIter = BlockingCommands.find(Cmd);

      if (BlockedIter != BlockingCommands.end()) {

        auto AllBlocked = std::move(BlockedIter->second);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Scheduling maybe-unblocked jobs: ""

                       << LogJobArray(AllBlocked) << ""\n"";

        }

        BlockingCommands.erase(BlockedIter);

        for (auto *Blocked : AllBlocked)

          scheduleCommandIfNecessaryAndPossible(Blocked);

      }

    }

"
"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunctionType.cpp,-,= origFnType->getOptionalErrorResult();,"    CanType visitType(CanType origType) {

      assert(!isa<AnyFunctionType>(origType));

      assert(!isa<LValueType>(origType) && !isa<InOutType>(origType));

      auto substType = origType.subst(Subst, Conformances)->getCanonicalType();



      // If the substitution didn't change anything, we know that the

      // original type was a lowered type, so we're good.

      if (origType == substType) {

        return origType;

      }



      AbstractionPattern abstraction(Sig, origType);

      return TheSILModule.Types.getLoweredType(abstraction, substType)

               .getSwiftRValueType();

    }

","    CanType visitType(CanType origType) {

      assert(!isa<AnyFunctionType>(origType));

      assert(!isa<LValueType>(origType) && !isa<InOutType>(origType));

      auto substType = origType.subst(Subst, Conformances)->getCanonicalType();



      // If the substitution didn't change anything, we know that the

","
      if (origType == substType) {

        return origType;

      }



      AbstractionPattern abstraction(Sig, origType);

      return TheSILModule.Types.getLoweredType(abstraction, substType)

               .getSwiftRValueType();

    }


"
"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunctionType.cpp,-,assert(!substErrorResult ||,"    CanType visitType(CanType origType) {

      assert(!isa<AnyFunctionType>(origType));

      assert(!isa<LValueType>(origType) && !isa<InOutType>(origType));

      auto substType = origType.subst(Subst, Conformances)->getCanonicalType();



      // If the substitution didn't change anything, we know that the

      // original type was a lowered type, so we're good.

      if (origType == substType) {

        return origType;

      }



      AbstractionPattern abstraction(Sig, origType);

      return TheSILModule.Types.getLoweredType(abstraction, substType)

               .getSwiftRValueType();

    }

","    CanType visitType(CanType origType) {

      assert(!isa<AnyFunctionType>(origType));

      assert(!isa<LValueType>(origType) && !isa<InOutType>(origType));

      auto substType = origType.subst(Subst, Conformances)->getCanonicalType();



      // If the substitution didn't change anything, we know that the

","
      if (origType == substType) {

        return origType;

      }



      AbstractionPattern abstraction(Sig, origType);

      return TheSILModule.Types.getLoweredType(abstraction, substType)

               .getSwiftRValueType();

    }


"
"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunctionType.cpp,-,"assert(TheSILModule.Types.getLoweredType(abstraction, origType)","    CanType visitType(CanType origType) {

      assert(!isa<AnyFunctionType>(origType));

      assert(!isa<LValueType>(origType) && !isa<InOutType>(origType));

      auto substType = origType.subst(Subst, Conformances)->getCanonicalType();



      // If the substitution didn't change anything, we know that the

      // original type was a lowered type, so we're good.

      if (origType == substType) {

        return origType;

      }



      AbstractionPattern abstraction(Sig, origType);

      return TheSILModule.Types.getLoweredType(abstraction, substType)

               .getSwiftRValueType();

    }

","    CanType visitType(CanType origType) {

      assert(!isa<AnyFunctionType>(origType));

      assert(!isa<LValueType>(origType) && !isa<InOutType>(origType));

      auto substType = origType.subst(Subst, Conformances)->getCanonicalType();

","
      // If the substitution didn't change anything, we know that the

      // original type was a lowered type, so we're good.

      if (origType == substType) {

        return origType;

      }



      AbstractionPattern abstraction(Sig, origType);

      return TheSILModule.Types.getLoweredType(abstraction, substType)

               .getSwiftRValueType();

    }


"
"SIL: SILType::subst() can now take a generic signature

In order to lower replacement types that appear in lowered
position, we need to know the generic signature of the
original type.

Allow this to be passed in explicitly, but fall back to
the push/pop generic context if not present.

This is a first step toward eliminating the push/pop of
the generic context.

Fixes <rdar://problem/29711782>.",lib/SIL/SILFunctionType.cpp,-,"assert(TheSILModule.Types.getLoweredType(abstraction, origType)","    CanType visitType(CanType origType) {

      assert(!isa<AnyFunctionType>(origType));

      assert(!isa<LValueType>(origType) && !isa<InOutType>(origType));

      auto substType = origType.subst(Subst, Conformances)->getCanonicalType();



      // If the substitution didn't change anything, we know that the

      // original type was a lowered type, so we're good.

      if (origType == substType) {

        return origType;

      }



      AbstractionPattern abstraction(Sig, origType);

      return TheSILModule.Types.getLoweredType(abstraction, substType)

               .getSwiftRValueType();

    }

","    CanType visitType(CanType origType) {

      assert(!isa<AnyFunctionType>(origType));

      assert(!isa<LValueType>(origType) && !isa<InOutType>(origType));

      auto substType = origType.subst(Subst, Conformances)->getCanonicalType();

","
      // If the substitution didn't change anything, we know that the

      // original type was a lowered type, so we're good.

      if (origType == substType) {

        return origType;

      }



      AbstractionPattern abstraction(Sig, origType);

      return TheSILModule.Types.getLoweredType(abstraction, substType)

               .getSwiftRValueType();

    }


"
SIL: Remove TypeConverter::substFunctionType(),lib/SIL/SILFunctionType.cpp,-,= origFnType->getOptionalErrorResult();,"    CanType visitType(CanType origType) {

      assert(!isa<AnyFunctionType>(origType));

      assert(!isa<LValueType>(origType) && !isa<InOutType>(origType));



      CanGenericSignature genericSig =

          TheSILModule.Types.getCurGenericContext();

      AbstractionPattern abstraction(genericSig, origType);



      assert(TheSILModule.Types.getLoweredType(abstraction, origType)

               .getSwiftRValueType() == origType);



      CanType substType =

        origType.subst(Subst, Conformances, None)->getCanonicalType();



      // If the substitution didn't change anything, we know that the

      // original type was a lowered type, so we're good.

      if (origType == substType) {

        return origType;

      }



      return TheSILModule.Types.getLoweredType(abstraction, substType)

               .getSwiftRValueType();

    }

","    CanType visitType(CanType origType) {

      assert(!isa<AnyFunctionType>(origType));

      assert(!isa<LValueType>(origType) && !isa<InOutType>(origType));



      CanGenericSignature genericSig =

          TheSILModule.Types.getCurGenericContext();

      AbstractionPattern abstraction(genericSig, origType);



","
               .getSwiftRValueType() == origType);



      CanType substType =

        origType.subst(Subst, Conformances, None)->getCanonicalType();



      // If the substitution didn't change anything, we know that the

      // original type was a lowered type, so we're good.

      if (origType == substType) {

        return origType;

      }



      return TheSILModule.Types.getLoweredType(abstraction, substType)

               .getSwiftRValueType();

    }


"
SIL: Remove TypeConverter::substFunctionType(),lib/SIL/SILFunctionType.cpp,-,assert(!substErrorResult ||,"    CanType visitType(CanType origType) {

      assert(!isa<AnyFunctionType>(origType));

      assert(!isa<LValueType>(origType) && !isa<InOutType>(origType));



      CanGenericSignature genericSig =

          TheSILModule.Types.getCurGenericContext();

      AbstractionPattern abstraction(genericSig, origType);



      assert(TheSILModule.Types.getLoweredType(abstraction, origType)

               .getSwiftRValueType() == origType);



      CanType substType =

        origType.subst(Subst, Conformances, None)->getCanonicalType();



      // If the substitution didn't change anything, we know that the

      // original type was a lowered type, so we're good.

      if (origType == substType) {

        return origType;

      }



      return TheSILModule.Types.getLoweredType(abstraction, substType)

               .getSwiftRValueType();

    }

","    CanType visitType(CanType origType) {

      assert(!isa<AnyFunctionType>(origType));

      assert(!isa<LValueType>(origType) && !isa<InOutType>(origType));



      CanGenericSignature genericSig =

          TheSILModule.Types.getCurGenericContext();

      AbstractionPattern abstraction(genericSig, origType);



","
               .getSwiftRValueType() == origType);



      CanType substType =

        origType.subst(Subst, Conformances, None)->getCanonicalType();



      // If the substitution didn't change anything, we know that the

      // original type was a lowered type, so we're good.

      if (origType == substType) {

        return origType;

      }



      return TheSILModule.Types.getLoweredType(abstraction, substType)

               .getSwiftRValueType();

    }


"
Merge pull request #7829 from gottesmm/checked_cast_br_1,lib/SILGen/SILGenDynamicCast.cpp,+,assert(operand.getType().isAddress());,"    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

        assert(operand.getType().isAddress());

        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

","    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

       ","
        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

"
Merge pull request #7829 from gottesmm/checked_cast_br_1,lib/SILGen/SILGenDynamicCast.cpp,+,"assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");","    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

        assert(operand.getType().isAddress());

        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

","    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

        assert(operand.getType().isAddress());

        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

       ","
      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

"
Merge pull request #7829 from gottesmm/checked_cast_br_1,lib/SILGen/SILGenDynamicCast.cpp,+,assert(!SGF.B.hasValidInsertionPoint() &&,"    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

        assert(operand.getType().isAddress());

        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

","    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

        assert(operand.getType().isAddress());

        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

       ","
      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

"
Merge pull request #7829 from gottesmm/checked_cast_br_1,lib/SILGen/SILGenDynamicCast.cpp,+,assert(!SGF.B.hasValidInsertionPoint() &&,"    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

        assert(operand.getType().isAddress());

        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

","    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

        assert(operand.getType().isAddress());

        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

       ","
      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

"
Merge pull request #7829 from gottesmm/checked_cast_br_1,lib/SILGen/SILGenDynamicCast.cpp,+,"assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");","    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

        assert(operand.getType().isAddress());

        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

","    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

        assert(operand.getType().isAddress());

        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

       ","
      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

"
[Driver] Extract reloadAndRemarkDeps from taskFinished.,lib/Driver/Compilation.cpp,+,assert(FinishedCmd->getCondition() == Job::Condition::Always);,"    void reloadAndRemarkDeps(const Job *FinishedCmd,

                             int ReturnCode,

                             SmallVector<const Job *, N> &Dependents) {

      const CommandOutput &Output = FinishedCmd->getOutput();

      StringRef DependenciesFile =

        Output.getAdditionalOutputForType(types::TY_SwiftDeps);



      if (DependenciesFile.empty()) {

        // If this job doesn't track dependencies, it must always be run.

        // Note: In theory CheckDependencies makes sense as well (for a leaf

        // node in the dependency graph), and maybe even NewlyAdded (for very

        // coarse dependencies that always affect downstream nodes), but we're

        // not using either of those right now, and this logic should probably

        // be revisited when we are.

        assert(FinishedCmd->getCondition() == Job::Condition::Always);

      } else {

        // If we have a dependency file /and/ the frontend task exited normally,

        // we can be discerning about what downstream files to rebuild.

        if (ReturnCode == EXIT_SUCCESS || ReturnCode == EXIT_FAILURE) {

          bool wasCascading = DepGraph.isMarked(FinishedCmd);



          switch (DepGraph.loadFromPath(FinishedCmd, DependenciesFile)) {

          case DependencyGraphImpl::LoadResult::HadError:

            if (ReturnCode == EXIT_SUCCESS) {

              Comp.disableIncrementalBuild();

              for (const Job *Cmd : DeferredCommands)

                scheduleCommandIfNecessaryAndPossible(Cmd);

              DeferredCommands.clear();

              Dependents.clear();

            } // else, let the next build handle it.

            break;

          case DependencyGraphImpl::LoadResult::UpToDate:

            if (!wasCascading)

              break;

            LLVM_FALLTHROUGH;

          case DependencyGraphImpl::LoadResult::AffectsDownstream:

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          }

        } else {

          // If there's an abnormal exit (a crash), assume the worst.

          switch (FinishedCmd->getCondition()) {

          case Job::Condition::NewlyAdded:

            // The job won't be treated as newly added next time. Conservatively

            // mark it as affecting other jobs, because some of them may have

            // completed already.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::Always:

            // Any incremental task that shows up here has already been marked;

            // we didn't need to wait for it to finish to start downstream

            // tasks.

            assert(DepGraph.isMarked(FinishedCmd));

            break;

          case Job::Condition::RunWithoutCascading:

            // If this file changed, it might have been a non-cascading change

            // and it might not. Unfortunately, the interface hash has been

            // updated or compromised, so we don't actually know anymore; we

            // have to conservatively assume the changes could affect other

            // files.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::CheckDependencies:

            // If the only reason we're running this is because something else

            // changed, then we can trust the dependency graph as to whether

            // it's a cascading or non-cascading change. That is, if whatever

            // /caused/ the error isn't supposed to affect other files, and

            // whatever /fixes/ the error isn't supposed to affect other files,

            // then there's no need to recompile any other inputs. If either of

            // those are false, we /do/ need to recompile other inputs.

            break;

          }

        }

      }

    }

","    void reloadAndRemarkDeps(const Job *FinishedCmd,

                             int ReturnCode,

                             SmallVector<const Job *, N> &Dependents) {

      const CommandOutput &Output = FinishedCmd->getOutput();

      StringRef DependenciesFile =

        Output.getAdditionalOutputForType(types::TY_SwiftDeps);



      if (DependenciesFile.empty()) {

        // If this job doesn't track dependencies, it must always be run.

        // Note: In theory CheckDependencies makes sense as well (for a leaf

        // node in the dependency graph), and maybe even NewlyAdded (for very

        // coarse dependencies that always affect downstream nodes), but we're

        // not using either of those right now, and this logic should probably

        // be revisited when we are.

       ","
      } else {

        // If we have a dependency file /and/ the frontend task exited normally,

        // we can be discerning about what downstream files to rebuild.

        if (ReturnCode == EXIT_SUCCESS || ReturnCode == EXIT_FAILURE) {

          bool wasCascading = DepGraph.isMarked(FinishedCmd);



          switch (DepGraph.loadFromPath(FinishedCmd, DependenciesFile)) {

          case DependencyGraphImpl::LoadResult::HadError:

            if (ReturnCode == EXIT_SUCCESS) {

              Comp.disableIncrementalBuild();

              for (const Job *Cmd : DeferredCommands)

                scheduleCommandIfNecessaryAndPossible(Cmd);

              DeferredCommands.clear();

              Dependents.clear();

            } // else, let the next build handle it.

            break;

          case DependencyGraphImpl::LoadResult::UpToDate:

            if (!wasCascading)

              break;

            LLVM_FALLTHROUGH;

          case DependencyGraphImpl::LoadResult::AffectsDownstream:

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          }

        } else {

          // If there's an abnormal exit (a crash), assume the worst.

          switch (FinishedCmd->getCondition()) {

          case Job::Condition::NewlyAdded:

            // The job won't be treated as newly added next time. Conservatively

            // mark it as affecting other jobs, because some of them may have

            // completed already.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::Always:

            // Any incremental task that shows up here has already been marked;

            // we didn't need to wait for it to finish to start downstream

            // tasks.

            assert(DepGraph.isMarked(FinishedCmd));

            break;

          case Job::Condition::RunWithoutCascading:

            // If this file changed, it might have been a non-cascading change

            // and it might not. Unfortunately, the interface hash has been

            // updated or compromised, so we don't actually know anymore; we

            // have to conservatively assume the changes could affect other

            // files.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::CheckDependencies:

            // If the only reason we're running this is because something else

            // changed, then we can trust the dependency graph as to whether

            // it's a cascading or non-cascading change. That is, if whatever

            // /caused/ the error isn't supposed to affect other files, and

            // whatever /fixes/ the error isn't supposed to affect other files,

            // then there's no need to recompile any other inputs. If either of

            // those are false, we /do/ need to recompile other inputs.

            break;

          }

        }

      }

    }

"
[Driver] Extract reloadAndRemarkDeps from taskFinished.,lib/Driver/Compilation.cpp,+,assert(DepGraph.isMarked(FinishedCmd));,"    void reloadAndRemarkDeps(const Job *FinishedCmd,

                             int ReturnCode,

                             SmallVector<const Job *, N> &Dependents) {

      const CommandOutput &Output = FinishedCmd->getOutput();

      StringRef DependenciesFile =

        Output.getAdditionalOutputForType(types::TY_SwiftDeps);



      if (DependenciesFile.empty()) {

        // If this job doesn't track dependencies, it must always be run.

        // Note: In theory CheckDependencies makes sense as well (for a leaf

        // node in the dependency graph), and maybe even NewlyAdded (for very

        // coarse dependencies that always affect downstream nodes), but we're

        // not using either of those right now, and this logic should probably

        // be revisited when we are.

        assert(FinishedCmd->getCondition() == Job::Condition::Always);

      } else {

        // If we have a dependency file /and/ the frontend task exited normally,

        // we can be discerning about what downstream files to rebuild.

        if (ReturnCode == EXIT_SUCCESS || ReturnCode == EXIT_FAILURE) {

          bool wasCascading = DepGraph.isMarked(FinishedCmd);



          switch (DepGraph.loadFromPath(FinishedCmd, DependenciesFile)) {

          case DependencyGraphImpl::LoadResult::HadError:

            if (ReturnCode == EXIT_SUCCESS) {

              Comp.disableIncrementalBuild();

              for (const Job *Cmd : DeferredCommands)

                scheduleCommandIfNecessaryAndPossible(Cmd);

              DeferredCommands.clear();

              Dependents.clear();

            } // else, let the next build handle it.

            break;

          case DependencyGraphImpl::LoadResult::UpToDate:

            if (!wasCascading)

              break;

            LLVM_FALLTHROUGH;

          case DependencyGraphImpl::LoadResult::AffectsDownstream:

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          }

        } else {

          // If there's an abnormal exit (a crash), assume the worst.

          switch (FinishedCmd->getCondition()) {

          case Job::Condition::NewlyAdded:

            // The job won't be treated as newly added next time. Conservatively

            // mark it as affecting other jobs, because some of them may have

            // completed already.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::Always:

            // Any incremental task that shows up here has already been marked;

            // we didn't need to wait for it to finish to start downstream

            // tasks.

            assert(DepGraph.isMarked(FinishedCmd));

            break;

          case Job::Condition::RunWithoutCascading:

            // If this file changed, it might have been a non-cascading change

            // and it might not. Unfortunately, the interface hash has been

            // updated or compromised, so we don't actually know anymore; we

            // have to conservatively assume the changes could affect other

            // files.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::CheckDependencies:

            // If the only reason we're running this is because something else

            // changed, then we can trust the dependency graph as to whether

            // it's a cascading or non-cascading change. That is, if whatever

            // /caused/ the error isn't supposed to affect other files, and

            // whatever /fixes/ the error isn't supposed to affect other files,

            // then there's no need to recompile any other inputs. If either of

            // those are false, we /do/ need to recompile other inputs.

            break;

          }

        }

      }

    }

","    void reloadAndRemarkDeps(const Job *FinishedCmd,

                             int ReturnCode,

                             SmallVector<const Job *, N> &Dependents) {

      const CommandOutput &Output = FinishedCmd->getOutput();

      StringRef DependenciesFile =

        Output.getAdditionalOutputForType(types::TY_SwiftDeps);



      if (DependenciesFile.empty()) {

        // If this job doesn't track dependencies, it must always be run.

        // Note: In theory CheckDependencies makes sense as well (for a leaf

        // node in the dependency graph), and maybe even NewlyAdded (for very

        // coarse dependencies that always affect downstream nodes), but we're

        // not using either of those right now, and this logic should probably

        // be revisited when we are.

        assert(FinishedCmd->getCondition() == Job::Condition::Always);

      } else {

        // If we have a dependency file /and/ the frontend task exited normally,

        // we can be discerning about what downstream files to rebuild.

        if (ReturnCode == EXIT_SUCCESS || ReturnCode == EXIT_FAILURE) {

          bool wasCascading = DepGraph.isMarked(FinishedCmd);



          switch (DepGraph.loadFromPath(FinishedCmd, DependenciesFile)) {

          case DependencyGraphImpl::LoadResult::HadError:

            if (ReturnCode == EXIT_SUCCESS) {

              Comp.disableIncrementalBuild();

              for (const Job *Cmd : DeferredCommands)

                scheduleCommandIfNecessaryAndPossible(Cmd);

              DeferredCommands.clear();

              Dependents.clear();

            } // else, let the next build handle it.

            break;

          case DependencyGraphImpl::LoadResult::UpToDate:

            if (!wasCascading)

              break;

            LLVM_FALLTHROUGH;

          case DependencyGraphImpl::LoadResult::AffectsDownstream:

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          }

        } else {

          // If there's an abnormal exit (a crash), assume the worst.

          switch (FinishedCmd->getCondition()) {

          case Job::Condition::NewlyAdded:

            // The job won't be treated as newly added next time. Conservatively

            // mark it as affecting other jobs, because some of them may have

            // completed already.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::Always:

            // Any incremental task that shows up here has already been marked;

            // we didn't need to wait for it to finish to start downstream

            // tasks.

           ","
            break;

          case Job::Condition::RunWithoutCascading:

            // If this file changed, it might have been a non-cascading change

            // and it might not. Unfortunately, the interface hash has been

            // updated or compromised, so we don't actually know anymore; we

            // have to conservatively assume the changes could affect other

            // files.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::CheckDependencies:

            // If the only reason we're running this is because something else

            // changed, then we can trust the dependency graph as to whether

            // it's a cascading or non-cascading change. That is, if whatever

            // /caused/ the error isn't supposed to affect other files, and

            // whatever /fixes/ the error isn't supposed to affect other files,

            // then there's no need to recompile any other inputs. If either of

            // those are false, we /do/ need to recompile other inputs.

            break;

          }

        }

      }

    }

"
[Driver] Extract reloadAndRemarkDeps from taskFinished.,lib/Driver/Compilation.cpp,-,assert(FinishedCmd->getCondition() == Job::Condition::Always);,"    TaskFinishedResponse

    taskFinished(ProcessId Pid, int ReturnCode, StringRef Output,

                 StringRef Errors, void *Context) {

      const Job *FinishedCmd = (const Job *)Context;



      if (Comp.ShowDriverTimeCompilation) {

        DriverTimers[FinishedCmd]->stopTimer();

      }



      if (Comp.Level == OutputLevel::Parseable) {

        // Parseable output was requested.

        parseable_output::emitFinishedMessage(llvm::errs(), *FinishedCmd, Pid,

                                              ReturnCode, Output);

      } else {

        // Otherwise, send the buffered output to stderr, though only if we

        // support getting buffered output.

        if (TaskQueue::supportsBufferingOutput())

          llvm::errs() << Output;

      }



      // In order to handle both old dependencies that have disappeared and new

      // dependencies that have arisen, we need to reload the dependency file.

      // Do this whether or not the build succeeded.

      SmallVector<const Job *, 16> Dependents;

      if (Comp.getIncrementalBuildEnabled()) {

        reloadAndRemarkDeps(FinishedCmd, ReturnCode, Dependents);

      }



      if (ReturnCode != EXIT_SUCCESS) {

        // The task failed, so return true without performing any further

        // dependency analysis.



        // Store this task's ReturnCode as our Result if we haven't stored

        // anything yet.

        if (Result == EXIT_SUCCESS)

          Result = ReturnCode;



        if (!isa<CompileJobAction>(FinishedCmd->getSource()) ||

            ReturnCode != EXIT_FAILURE) {

          Comp.Diags.diagnose(SourceLoc(), diag::error_command_failed,

                              FinishedCmd->getSource().getClassName(),

                              ReturnCode);

        }



        return Comp.ContinueBuildingAfterErrors ?

          TaskFinishedResponse::ContinueExecution :

          TaskFinishedResponse::StopExecution;

      }



      // When a task finishes, we need to reevaluate the other commands that

      // might have been blocked.

      markFinished(FinishedCmd);



      for (const Job *Cmd : Dependents) {

        DeferredCommands.erase(Cmd);

        noteBuilding(Cmd, ""because of dependencies discovered later"");

        scheduleCommandIfNecessaryAndPossible(Cmd);

      }



      return TaskFinishedResponse::ContinueExecution;

    }

","    TaskFinishedResponse

    taskFinished(ProcessId Pid, int ReturnCode, StringRef Output,

                 StringRef Errors, void *Context) {

      const Job *FinishedCmd = (const Job *)Context;



      if (Comp.ShowDriverTimeCompilation) {

        DriverTimers[FinishedCmd]->stopTimer();

      }



      if (Comp.Level == OutputLevel::Parseable) {

        // Parseable output was requested.

        parseable_output::emitFinishedMessage(llvm::errs(), *FinishedCmd, Pid,

                                              ReturnCode, Output);

      } else {

        // Otherwise, send the buffered output to stderr, though only if we

        // support getting buffered output.

        if (TaskQueue::supportsBufferingOutput())

          llvm::errs() << Output;

","


      // In order to handle both old dependencies that have disappeared and new

      // dependencies that have arisen, we need to reload the dependency file.

      // Do this whether or not the build succeeded.

      SmallVector<const Job *, 16> Dependents;

      if (Comp.getIncrementalBuildEnabled()) {

        reloadAndRemarkDeps(FinishedCmd, ReturnCode, Dependents);

      }



      if (ReturnCode != EXIT_SUCCESS) {

        // The task failed, so return true without performing any further

        // dependency analysis.



        // Store this task's ReturnCode as our Result if we haven't stored

        // anything yet.

        if (Result == EXIT_SUCCESS)

          Result = ReturnCode;



        if (!isa<CompileJobAction>(FinishedCmd->getSource()) ||

            ReturnCode != EXIT_FAILURE) {

          Comp.Diags.diagnose(SourceLoc(), diag::error_command_failed,

                              FinishedCmd->getSource().getClassName(),

                              ReturnCode);

        }



        return Comp.ContinueBuildingAfterErrors ?

          TaskFinishedResponse::ContinueExecution :

          TaskFinishedResponse::StopExecution;

      }



      // When a task finishes, we need to reevaluate the other commands that

      // might have been blocked.

      markFinished(FinishedCmd);



      for (const Job *Cmd : Dependents) {

        DeferredCommands.erase(Cmd);

        noteBuilding(Cmd, ""because of dependencies discovered later"");

        scheduleCommandIfNecessaryAndPossible(Cmd);

      }



      return TaskFinishedResponse::ContinueExecution;

    }


"
[Driver] Extract reloadAndRemarkDeps from taskFinished.,lib/Driver/Compilation.cpp,-,assert(DepGraph.isMarked(FinishedCmd));,"    TaskFinishedResponse

    taskSignalled(ProcessId Pid, StringRef ErrorMsg, StringRef Output,

                  StringRef Errors, void *Context, Optional<int> Signal) {

      const Job *SignalledCmd = (const Job *)Context;



      if (Comp.ShowDriverTimeCompilation) {

        DriverTimers[SignalledCmd]->stopTimer();

      }



      if (Comp.Level == OutputLevel::Parseable) {

        // Parseable output was requested.

        parseable_output::emitSignalledMessage(llvm::errs(), *SignalledCmd,

                                               Pid, ErrorMsg, Output, Signal);

      } else {

        // Otherwise, send the buffered output to stderr, though only if we

        // support getting buffered output.

        if (TaskQueue::supportsBufferingOutput())

          llvm::errs() << Output;

      }



      if (!ErrorMsg.empty())

        Comp.Diags.diagnose(SourceLoc(), diag::error_unable_to_execute_command,

                            ErrorMsg);



      if (Signal.hasValue()) {

        Comp.Diags.diagnose(SourceLoc(), diag::error_command_signalled,

                            SignalledCmd->getSource().getClassName(),

                            Signal.getValue());

      } else {

        Comp.Diags.diagnose(SourceLoc(),

                            diag::error_command_signalled_without_signal_number,

                            SignalledCmd->getSource().getClassName());

      }



      // Since the task signalled, unconditionally set result to -2.

      Result = -2;



      return TaskFinishedResponse::StopExecution;

    }

","    TaskFinishedResponse

    taskSignalled(ProcessId Pid, StringRef ErrorMsg, StringRef Output,

                  StringRef Errors, void *Context, Optional<int> Signal) {

      const Job *SignalledCmd = (const Job *)Context;



      if (Comp.ShowDriverTimeCompilation) {

        DriverTimers[SignalledCmd]->stopTimer();
","      }



      if (Comp.Level == OutputLevel::Parseable) {

        // Parseable output was requested.

        parseable_output::emitSignalledMessage(llvm::errs(), *SignalledCmd,

                                               Pid, ErrorMsg, Output, Signal);

      } else {

        // Otherwise, send the buffered output to stderr, though only if we

        // support getting buffered output.

        if (TaskQueue::supportsBufferingOutput())

          llvm::errs() << Output;

      }



      if (!ErrorMsg.empty())

        Comp.Diags.diagnose(SourceLoc(), diag::error_unable_to_execute_command,

                            ErrorMsg);



      if (Signal.hasValue()) {

        Comp.Diags.diagnose(SourceLoc(), diag::error_command_signalled,

                            SignalledCmd->getSource().getClassName(),

                            Signal.getValue());

      } else {

        Comp.Diags.diagnose(SourceLoc(),

                            diag::error_command_signalled_without_signal_number,

                            SignalledCmd->getSource().getClassName());

      }



      // Since the task signalled, unconditionally set result to -2.

      Result = -2;



      return TaskFinishedResponse::StopExecution;

    }


"
[Driver] Make PerformJobsState a mostly-private class.,lib/Driver/Compilation.cpp,+,Result = Comp.Diags.hadAnyError();,"    int getResult() {

      if (Result == 0)

        Result = Comp.Diags.hadAnyError();

      return Result;

    }

","    int getResult() {

      if (Result == 0)

       ","
      return Result;

    }

"
[Driver] Move populateInputInfoMap into PerformJobsState.,lib/Driver/Compilation.cpp,+,"static_assert(IsTriviallyCopyable<CompileJobAction::InputInfo>::value,","    void populateInputInfoMap(InputInfoMap &inputs) const {

      for (auto &entry : UnfinishedCommands) {

        for (auto *action : entry.first->getSource().getInputs()) {

          auto inputFile = dyn_cast<InputAction>(action);

          if (!inputFile)

            continue;



          CompileJobAction::InputInfo info;

          info.previousModTime = entry.first->getInputModTime();

          info.status = entry.second ?

            CompileJobAction::InputInfo::NeedsCascadingBuild :

            CompileJobAction::InputInfo::NeedsNonCascadingBuild;

          inputs[&inputFile->getInputArg()] = info;

        }

      }



      for (const Job *entry : FinishedCommands) {

        const auto *compileAction = dyn_cast<CompileJobAction>(&entry->getSource());

        if (!compileAction)

          continue;



        for (auto *action : compileAction->getInputs()) {

          auto inputFile = dyn_cast<InputAction>(action);

          if (!inputFile)

            continue;



          CompileJobAction::InputInfo info;

          info.previousModTime = entry->getInputModTime();

          info.status = CompileJobAction::InputInfo::UpToDate;

          inputs[&inputFile->getInputArg()] = info;

        }

      }



      // Sort the entries by input order.

      static_assert(IsTriviallyCopyable<CompileJobAction::InputInfo>::value,

                    ""llvm::array_pod_sort relies on trivially-copyable data"");

      using InputInfoEntry = std::decay<decltype(inputs.front())>::type;

      llvm::array_pod_sort(inputs.begin(), inputs.end(),

                           [](const InputInfoEntry *lhs,

                              const InputInfoEntry *rhs) -> int {

                             auto lhsIndex = lhs->first->getIndex();

                             auto rhsIndex = rhs->first->getIndex();

                             return (lhsIndex < rhsIndex) ? -1 : (lhsIndex > rhsIndex) ? 1 : 0;

                           });

    }

","    void populateInputInfoMap(InputInfoMap &inputs) const {

      for (auto &entry : UnfinishedCommands) {

        for (auto *action : entry.first->getSource().getInputs()) {

          auto inputFile = dyn_cast<InputAction>(action);

          if (!inputFile)

            continue;



          CompileJobAction::InputInfo info;

          info.previousModTime = entry.first->getInputModTime();

          info.status = entry.second ?

            CompileJobAction::InputInfo::NeedsCascadingBuild :

            CompileJobAction::InputInfo::NeedsNonCascadingBuild;

          inputs[&inputFile->getInputArg()] = info;

        }

      }



      for (const Job *entry : FinishedCommands) {

        const auto *compileAction = dyn_cast<CompileJobAction>(&entry->getSource());

        if (!compileAction)

          continue;



        for (auto *action : compileAction->getInputs()) {

          auto inputFile = dyn_cast<InputAction>(action);

          if (!inputFile)

            continue;



          CompileJobAction::InputInfo info;

          info.previousModTime = entry->getInputModTime();

          info.status = CompileJobAction::InputInfo::UpToDate;

          inputs[&inputFile->getInputArg()] = info;

        }

      }



      // Sort the entries by input order.

     ","
                    ""llvm::array_pod_sort relies on trivially-copyable data"");

      using InputInfoEntry = std::decay<decltype(inputs.front())>::type;

      llvm::array_pod_sort(inputs.begin(), inputs.end(),

                           [](const InputInfoEntry *lhs,

                              const InputInfoEntry *rhs) -> int {

                             auto lhsIndex = lhs->first->getIndex();

                             auto rhsIndex = rhs->first->getIndex();

                             return (lhsIndex < rhsIndex) ? -1 : (lhsIndex > rhsIndex) ? 1 : 0;

                           });

    }

"
[Driver] Move populateInputInfoMap into PerformJobsState.,lib/Driver/Compilation.cpp,-,"static_assert(IsTriviallyCopyable<CompileJobAction::InputInfo>::value,","static void writeCompilationRecord(StringRef path, StringRef argsHash,

                                   llvm::sys::TimePoint<> buildTime,

                                   const InputInfoMap &inputs) {

  // Before writing to the dependencies file path, preserve any previous file

  // that may have been there. No error handling -- this is just a nicety, it

  // doesn't matter if it fails.

  llvm::sys::fs::rename(path, path + ""~"");



  std::error_code error;

  llvm::raw_fd_ostream out(path, error, llvm::sys::fs::F_None);

  if (out.has_error()) {

    // FIXME: How should we report this error?

    out.clear_error();

    return;

  }



  auto writeTimeValue = [](llvm::raw_ostream &out,

                           llvm::sys::TimePoint<> time) {

    using namespace std::chrono;

    auto secs = time_point_cast<seconds>(time);

    time -= secs.time_since_epoch(); // remainder in nanoseconds

    out << ""["" << secs.time_since_epoch().count()

        << "", "" << time.time_since_epoch().count() << ""]"";

  };



  using compilation_record::TopLevelKey;

  // NB: We calculate effective version from getCurrentLanguageVersion()

  // here because any -swift-version argument is handled in the

  // argsHash that follows.

  out << compilation_record::getName(TopLevelKey::Version) << "": \""""

      << llvm::yaml::escape(version::getSwiftFullVersion(

                              swift::version::Version::getCurrentLanguageVersion()))

      << ""\""\n"";

  out << compilation_record::getName(TopLevelKey::Options) << "": \""""

      << llvm::yaml::escape(argsHash) << ""\""\n"";

  out << compilation_record::getName(TopLevelKey::BuildTime) << "": "";

  writeTimeValue(out, buildTime);

  out << ""\n"";

  out << compilation_record::getName(TopLevelKey::Inputs) << "":\n"";



  for (auto &entry : inputs) {

    out << ""  \"""" << llvm::yaml::escape(entry.first->getValue()) << ""\"": "";



    using compilation_record::getIdentifierForInputInfoStatus;

    auto Name = getIdentifierForInputInfoStatus(entry.second.status);

    if (!Name.empty()) {

      out << Name << "" "";

    }



    writeTimeValue(out, entry.second.previousModTime);

    out << ""\n"";

  }

}

","static void writeCompilationRecord(StringRef path, StringRef argsHash,

                                   llvm::sys::TimePoint<> buildTime,

                                   const InputInfoMap &inputs) {

  // Before writing to the dependencies file path, preserve any previous file

  // that may have been there. No error handling -- this is just a nicety, it

  // doesn't matter if it fails.

  llvm::sys::fs::rename(path, path + ""~"");

","
  std::error_code error;

  llvm::raw_fd_ostream out(path, error, llvm::sys::fs::F_None);

  if (out.has_error()) {

    // FIXME: How should we report this error?

    out.clear_error();

    return;

  }



  auto writeTimeValue = [](llvm::raw_ostream &out,

                           llvm::sys::TimePoint<> time) {

    using namespace std::chrono;

    auto secs = time_point_cast<seconds>(time);

    time -= secs.time_since_epoch(); // remainder in nanoseconds

    out << ""["" << secs.time_since_epoch().count()

        << "", "" << time.time_since_epoch().count() << ""]"";

  };



  using compilation_record::TopLevelKey;

  // NB: We calculate effective version from getCurrentLanguageVersion()

  // here because any -swift-version argument is handled in the

  // argsHash that follows.

  out << compilation_record::getName(TopLevelKey::Version) << "": \""""

      << llvm::yaml::escape(version::getSwiftFullVersion(

                              swift::version::Version::getCurrentLanguageVersion()))

      << ""\""\n"";

  out << compilation_record::getName(TopLevelKey::Options) << "": \""""

      << llvm::yaml::escape(argsHash) << ""\""\n"";

  out << compilation_record::getName(TopLevelKey::BuildTime) << "": "";

  writeTimeValue(out, buildTime);

  out << ""\n"";

  out << compilation_record::getName(TopLevelKey::Inputs) << "":\n"";



  for (auto &entry : inputs) {

    out << ""  \"""" << llvm::yaml::escape(entry.first->getValue()) << ""\"": "";



    using compilation_record::getIdentifierForInputInfoStatus;

    auto Name = getIdentifierForInputInfoStatus(entry.second.status);

    if (!Name.empty()) {

      out << Name << "" "";

    }



    writeTimeValue(out, entry.second.previousModTime);

    out << ""\n"";

  }

}


"
[Driver] Factor out PerformJobsState::checkUnfinishedJobs.,lib/Driver/Compilation.cpp,+,assert(BlockingCommands.empty() &&,"    void checkUnfinishedJobs() {

      if (Result == 0) {

        assert(BlockingCommands.empty() &&

               ""some blocking commands never finished properly"");

      } else {

        // Make sure we record any files that still need to be rebuilt.

        for (const Job *Cmd : Comp.getJobs()) {

          // Skip files that don't use dependency analysis.

          StringRef DependenciesFile =

            Cmd->getOutput().getAdditionalOutputForType(types::TY_SwiftDeps);

          if (DependenciesFile.empty())

            continue;



          // Don't worry about commands that finished or weren't going to run.

          if (FinishedCommands.count(Cmd))

            continue;

          if (!ScheduledCommands.count(Cmd))

            continue;



          bool isCascading = true;

          if (Comp.getIncrementalBuildEnabled())

            isCascading = DepGraph.isMarked(Cmd);

          UnfinishedCommands.insert({Cmd, isCascading});

        }

      }

    }

","    void checkUnfinishedJobs() {

      if (Result == 0) {

       ","
               ""some blocking commands never finished properly"");

      } else {

        // Make sure we record any files that still need to be rebuilt.

        for (const Job *Cmd : Comp.getJobs()) {

          // Skip files that don't use dependency analysis.

          StringRef DependenciesFile =

            Cmd->getOutput().getAdditionalOutputForType(types::TY_SwiftDeps);

          if (DependenciesFile.empty())

            continue;



          // Don't worry about commands that finished or weren't going to run.

          if (FinishedCommands.count(Cmd))

            continue;

          if (!ScheduledCommands.count(Cmd))

            continue;



          bool isCascading = true;

          if (Comp.getIncrementalBuildEnabled())

            isCascading = DepGraph.isMarked(Cmd);

          UnfinishedCommands.insert({Cmd, isCascading});

        }

      }

    }

"
[Driver] Move TaskQueue callbacks to PerformJobsState.,lib/Driver/Compilation.cpp,+,OS << LogJob(BeganCmd);,"    void taskBegan(ProcessId Pid, void *Context) {

      // TODO: properly handle task began.

      const Job *BeganCmd = (const Job *)Context;



      if (Comp.ShowDriverTimeCompilation) {

        llvm::SmallString<128> TimerName;

        llvm::raw_svector_ostream OS(TimerName);

        OS << LogJob(BeganCmd);

        DriverTimers.insert({

            BeganCmd,

              std::unique_ptr<llvm::Timer>(

                new llvm::Timer(""task"", OS.str(), DriverTimerGroup))

              });

        DriverTimers[BeganCmd]->startTimer();

      }



      // For verbose output, print out each command as it begins execution.

      if (Comp.Level == OutputLevel::Verbose)

        BeganCmd->printCommandLine(llvm::errs());

      else if (Comp.Level == OutputLevel::Parseable)

        parseable_output::emitBeganMessage(llvm::errs(), *BeganCmd, Pid);

    }

","    void taskBegan(ProcessId Pid, void *Context) {

      // TODO: properly handle task began.

      const Job *BeganCmd = (const Job *)Context;



      if (Comp.ShowDriverTimeCompilation) {

        llvm::SmallString<128> TimerName;

        llvm::raw_svector_ostream OS(TimerName);

       ","
        DriverTimers.insert({

            BeganCmd,

              std::unique_ptr<llvm::Timer>(

                new llvm::Timer(""task"", OS.str(), DriverTimerGroup))

              });

        DriverTimers[BeganCmd]->startTimer();

      }



      // For verbose output, print out each command as it begins execution.

      if (Comp.Level == OutputLevel::Verbose)

        BeganCmd->printCommandLine(llvm::errs());

      else if (Comp.Level == OutputLevel::Parseable)

        parseable_output::emitBeganMessage(llvm::errs(), *BeganCmd, Pid);

    }

"
[Driver] Move TaskQueue callbacks to PerformJobsState.,lib/Driver/Compilation.cpp,+,BeganCmd->printCommandLine(llvm::errs());,"    void taskBegan(ProcessId Pid, void *Context) {

      // TODO: properly handle task began.

      const Job *BeganCmd = (const Job *)Context;



      if (Comp.ShowDriverTimeCompilation) {

        llvm::SmallString<128> TimerName;

        llvm::raw_svector_ostream OS(TimerName);

        OS << LogJob(BeganCmd);

        DriverTimers.insert({

            BeganCmd,

              std::unique_ptr<llvm::Timer>(

                new llvm::Timer(""task"", OS.str(), DriverTimerGroup))

              });

        DriverTimers[BeganCmd]->startTimer();

      }



      // For verbose output, print out each command as it begins execution.

      if (Comp.Level == OutputLevel::Verbose)

        BeganCmd->printCommandLine(llvm::errs());

      else if (Comp.Level == OutputLevel::Parseable)

        parseable_output::emitBeganMessage(llvm::errs(), *BeganCmd, Pid);

    }

","    void taskBegan(ProcessId Pid, void *Context) {

      // TODO: properly handle task began.

      const Job *BeganCmd = (const Job *)Context;



      if (Comp.ShowDriverTimeCompilation) {

        llvm::SmallString<128> TimerName;

        llvm::raw_svector_ostream OS(TimerName);

        OS << LogJob(BeganCmd);

        DriverTimers.insert({

            BeganCmd,

              std::unique_ptr<llvm::Timer>(

                new llvm::Timer(""task"", OS.str(), DriverTimerGroup))

              });

        DriverTimers[BeganCmd]->startTimer();

      }



      // For verbose output, print out each command as it begins execution.

      if (Comp.Level == OutputLevel::Verbose)

       ","
      else if (Comp.Level == OutputLevel::Parseable)

        parseable_output::emitBeganMessage(llvm::errs(), *BeganCmd, Pid);

    }

"
[Driver] Move TaskQueue callbacks to PerformJobsState.,lib/Driver/Compilation.cpp,+,assert(FinishedCmd->getCondition() == Job::Condition::Always);,"    TaskFinishedResponse

    taskFinished(ProcessId Pid, int ReturnCode, StringRef Output,

                 StringRef Errors, void *Context) {

      const Job *FinishedCmd = (const Job *)Context;



      if (Comp.ShowDriverTimeCompilation) {

        DriverTimers[FinishedCmd]->stopTimer();

      }



      if (Comp.Level == OutputLevel::Parseable) {

        // Parseable output was requested.

        parseable_output::emitFinishedMessage(llvm::errs(), *FinishedCmd, Pid,

                                              ReturnCode, Output);

      } else {

        // Otherwise, send the buffered output to stderr, though only if we

        // support getting buffered output.

        if (TaskQueue::supportsBufferingOutput())

          llvm::errs() << Output;

      }



      // In order to handle both old dependencies that have disappeared and new

      // dependencies that have arisen, we need to reload the dependency file.

      // Do this whether or not the build succeeded.

      SmallVector<const Job *, 16> Dependents;

      if (Comp.getIncrementalBuildEnabled()) {

        const CommandOutput &Output = FinishedCmd->getOutput();

        StringRef DependenciesFile =

          Output.getAdditionalOutputForType(types::TY_SwiftDeps);



        if (DependenciesFile.empty()) {

          // If this job doesn't track dependencies, it must always be run.

          // Note: In theory CheckDependencies makes sense as well (for a leaf

          // node in the dependency graph), and maybe even NewlyAdded (for very

          // coarse dependencies that always affect downstream nodes), but we're

          // not using either of those right now, and this logic should probably

          // be revisited when we are.

          assert(FinishedCmd->getCondition() == Job::Condition::Always);

        } else {

          // If we have a dependency file /and/ the frontend task exited normally,

          // we can be discerning about what downstream files to rebuild.

          if (ReturnCode == EXIT_SUCCESS || ReturnCode == EXIT_FAILURE) {

            bool wasCascading = DepGraph.isMarked(FinishedCmd);



            switch (DepGraph.loadFromPath(FinishedCmd, DependenciesFile)) {

            case DependencyGraphImpl::LoadResult::HadError:

              if (ReturnCode == EXIT_SUCCESS) {

                Comp.disableIncrementalBuild();

                for (const Job *Cmd : DeferredCommands)

                  scheduleCommandIfNecessaryAndPossible(Cmd);

                DeferredCommands.clear();

                Dependents.clear();

              } // else, let the next build handle it.

              break;

            case DependencyGraphImpl::LoadResult::UpToDate:

              if (!wasCascading)

                break;

              LLVM_FALLTHROUGH;

            case DependencyGraphImpl::LoadResult::AffectsDownstream:

              DepGraph.markTransitive(Dependents, FinishedCmd,

                                      IncrementalTracer);

              break;

            }

          } else {

            // If there's an abnormal exit (a crash), assume the worst.

            switch (FinishedCmd->getCondition()) {

            case Job::Condition::NewlyAdded:

              // The job won't be treated as newly added next time. Conservatively

              // mark it as affecting other jobs, because some of them may have

              // completed already.

              DepGraph.markTransitive(Dependents, FinishedCmd,

                                      IncrementalTracer);

              break;

            case Job::Condition::Always:

              // Any incremental task that shows up here has already been marked;

              // we didn't need to wait for it to finish to start downstream

              // tasks.

              assert(DepGraph.isMarked(FinishedCmd));

              break;

            case Job::Condition::RunWithoutCascading:

              // If this file changed, it might have been a non-cascading change

              // and it might not. Unfortunately, the interface hash has been

              // updated or compromised, so we don't actually know anymore; we

              // have to conservatively assume the changes could affect other

              // files.

              DepGraph.markTransitive(Dependents, FinishedCmd,

                                      IncrementalTracer);

              break;

            case Job::Condition::CheckDependencies:

              // If the only reason we're running this is because something else

              // changed, then we can trust the dependency graph as to whether

              // it's a cascading or non-cascading change. That is, if whatever

              // /caused/ the error isn't supposed to affect other files, and

              // whatever /fixes/ the error isn't supposed to affect other files,

              // then there's no need to recompile any other inputs. If either of

              // those are false, we /do/ need to recompile other inputs.

              break;

            }

          }

        }

      }



      if (ReturnCode != EXIT_SUCCESS) {

        // The task failed, so return true without performing any further

        // dependency analysis.



        // Store this task's ReturnCode as our Result if we haven't stored

        // anything yet.

        if (Result == EXIT_SUCCESS)

          Result = ReturnCode;



        if (!isa<CompileJobAction>(FinishedCmd->getSource()) ||

            ReturnCode != EXIT_FAILURE) {

          Comp.Diags.diagnose(SourceLoc(), diag::error_command_failed,

                              FinishedCmd->getSource().getClassName(),

                              ReturnCode);

        }



        return Comp.ContinueBuildingAfterErrors ?

          TaskFinishedResponse::ContinueExecution :

          TaskFinishedResponse::StopExecution;

      }



      // When a task finishes, we need to reevaluate the other commands that

      // might have been blocked.

      markFinished(FinishedCmd);



      for (const Job *Cmd : Dependents) {

        DeferredCommands.erase(Cmd);

        noteBuilding(Cmd, ""because of dependencies discovered later"");

        scheduleCommandIfNecessaryAndPossible(Cmd);

      }



      return TaskFinishedResponse::ContinueExecution;

    }

","    TaskFinishedResponse

    taskFinished(ProcessId Pid, int ReturnCode, StringRef Output,

                 StringRef Errors, void *Context) {

      const Job *FinishedCmd = (const Job *)Context;



      if (Comp.ShowDriverTimeCompilation) {

        DriverTimers[FinishedCmd]->stopTimer();

      }



      if (Comp.Level == OutputLevel::Parseable) {

        // Parseable output was requested.

        parseable_output::emitFinishedMessage(llvm::errs(), *FinishedCmd, Pid,

                                              ReturnCode, Output);

      } else {

        // Otherwise, send the buffered output to stderr, though only if we

        // support getting buffered output.

        if (TaskQueue::supportsBufferingOutput())

          llvm::errs() << Output;

      }



      // In order to handle both old dependencies that have disappeared and new

      // dependencies that have arisen, we need to reload the dependency file.

      // Do this whether or not the build succeeded.

      SmallVector<const Job *, 16> Dependents;

      if (Comp.getIncrementalBuildEnabled()) {

        const CommandOutput &Output = FinishedCmd->getOutput();

        StringRef DependenciesFile =

          Output.getAdditionalOutputForType(types::TY_SwiftDeps);



        if (DependenciesFile.empty()) {

          // If this job doesn't track dependencies, it must always be run.

          // Note: In theory CheckDependencies makes sense as well (for a leaf

          // node in the dependency graph), and maybe even NewlyAdded (for very

          // coarse dependencies that always affect downstream nodes), but we're

          // not using either of those right now, and this logic should probably

          // be revisited when we are.

         ","
        } else {

          // If we have a dependency file /and/ the frontend task exited normally,

          // we can be discerning about what downstream files to rebuild.

          if (ReturnCode == EXIT_SUCCESS || ReturnCode == EXIT_FAILURE) {

            bool wasCascading = DepGraph.isMarked(FinishedCmd);



            switch (DepGraph.loadFromPath(FinishedCmd, DependenciesFile)) {

            case DependencyGraphImpl::LoadResult::HadError:

              if (ReturnCode == EXIT_SUCCESS) {

                Comp.disableIncrementalBuild();

                for (const Job *Cmd : DeferredCommands)

                  scheduleCommandIfNecessaryAndPossible(Cmd);

                DeferredCommands.clear();

                Dependents.clear();

              } // else, let the next build handle it.

              break;

            case DependencyGraphImpl::LoadResult::UpToDate:

              if (!wasCascading)

                break;

              LLVM_FALLTHROUGH;

            case DependencyGraphImpl::LoadResult::AffectsDownstream:

              DepGraph.markTransitive(Dependents, FinishedCmd,

                                      IncrementalTracer);

              break;

            }

          } else {

            // If there's an abnormal exit (a crash), assume the worst.

            switch (FinishedCmd->getCondition()) {

            case Job::Condition::NewlyAdded:

              // The job won't be treated as newly added next time. Conservatively

              // mark it as affecting other jobs, because some of them may have

              // completed already.

              DepGraph.markTransitive(Dependents, FinishedCmd,

                                      IncrementalTracer);

              break;

            case Job::Condition::Always:

              // Any incremental task that shows up here has already been marked;

              // we didn't need to wait for it to finish to start downstream

              // tasks.

              assert(DepGraph.isMarked(FinishedCmd));

              break;

            case Job::Condition::RunWithoutCascading:

              // If this file changed, it might have been a non-cascading change

              // and it might not. Unfortunately, the interface hash has been

              // updated or compromised, so we don't actually know anymore; we

              // have to conservatively assume the changes could affect other

              // files.

              DepGraph.markTransitive(Dependents, FinishedCmd,

                                      IncrementalTracer);

              break;

            case Job::Condition::CheckDependencies:

              // If the only reason we're running this is because something else

              // changed, then we can trust the dependency graph as to whether

              // it's a cascading or non-cascading change. That is, if whatever

              // /caused/ the error isn't supposed to affect other files, and

              // whatever /fixes/ the error isn't supposed to affect other files,

              // then there's no need to recompile any other inputs. If either of

              // those are false, we /do/ need to recompile other inputs.

              break;

            }

          }

        }

      }



      if (ReturnCode != EXIT_SUCCESS) {

        // The task failed, so return true without performing any further

        // dependency analysis.



        // Store this task's ReturnCode as our Result if we haven't stored

        // anything yet.

        if (Result == EXIT_SUCCESS)

          Result = ReturnCode;



        if (!isa<CompileJobAction>(FinishedCmd->getSource()) ||

            ReturnCode != EXIT_FAILURE) {

          Comp.Diags.diagnose(SourceLoc(), diag::error_command_failed,

                              FinishedCmd->getSource().getClassName(),

                              ReturnCode);

        }



        return Comp.ContinueBuildingAfterErrors ?

          TaskFinishedResponse::ContinueExecution :

          TaskFinishedResponse::StopExecution;

      }



      // When a task finishes, we need to reevaluate the other commands that

      // might have been blocked.

      markFinished(FinishedCmd);



      for (const Job *Cmd : Dependents) {

        DeferredCommands.erase(Cmd);

        noteBuilding(Cmd, ""because of dependencies discovered later"");

        scheduleCommandIfNecessaryAndPossible(Cmd);

      }



      return TaskFinishedResponse::ContinueExecution;

    }

"
[Driver] Move TaskQueue callbacks to PerformJobsState.,lib/Driver/Compilation.cpp,+,assert(DepGraph.isMarked(FinishedCmd));,"    TaskFinishedResponse

    taskFinished(ProcessId Pid, int ReturnCode, StringRef Output,

                 StringRef Errors, void *Context) {

      const Job *FinishedCmd = (const Job *)Context;



      if (Comp.ShowDriverTimeCompilation) {

        DriverTimers[FinishedCmd]->stopTimer();

      }



      if (Comp.Level == OutputLevel::Parseable) {

        // Parseable output was requested.

        parseable_output::emitFinishedMessage(llvm::errs(), *FinishedCmd, Pid,

                                              ReturnCode, Output);

      } else {

        // Otherwise, send the buffered output to stderr, though only if we

        // support getting buffered output.

        if (TaskQueue::supportsBufferingOutput())

          llvm::errs() << Output;

      }



      // In order to handle both old dependencies that have disappeared and new

      // dependencies that have arisen, we need to reload the dependency file.

      // Do this whether or not the build succeeded.

      SmallVector<const Job *, 16> Dependents;

      if (Comp.getIncrementalBuildEnabled()) {

        const CommandOutput &Output = FinishedCmd->getOutput();

        StringRef DependenciesFile =

          Output.getAdditionalOutputForType(types::TY_SwiftDeps);



        if (DependenciesFile.empty()) {

          // If this job doesn't track dependencies, it must always be run.

          // Note: In theory CheckDependencies makes sense as well (for a leaf

          // node in the dependency graph), and maybe even NewlyAdded (for very

          // coarse dependencies that always affect downstream nodes), but we're

          // not using either of those right now, and this logic should probably

          // be revisited when we are.

          assert(FinishedCmd->getCondition() == Job::Condition::Always);

        } else {

          // If we have a dependency file /and/ the frontend task exited normally,

          // we can be discerning about what downstream files to rebuild.

          if (ReturnCode == EXIT_SUCCESS || ReturnCode == EXIT_FAILURE) {

            bool wasCascading = DepGraph.isMarked(FinishedCmd);



            switch (DepGraph.loadFromPath(FinishedCmd, DependenciesFile)) {

            case DependencyGraphImpl::LoadResult::HadError:

              if (ReturnCode == EXIT_SUCCESS) {

                Comp.disableIncrementalBuild();

                for (const Job *Cmd : DeferredCommands)

                  scheduleCommandIfNecessaryAndPossible(Cmd);

                DeferredCommands.clear();

                Dependents.clear();

              } // else, let the next build handle it.

              break;

            case DependencyGraphImpl::LoadResult::UpToDate:

              if (!wasCascading)

                break;

              LLVM_FALLTHROUGH;

            case DependencyGraphImpl::LoadResult::AffectsDownstream:

              DepGraph.markTransitive(Dependents, FinishedCmd,

                                      IncrementalTracer);

              break;

            }

          } else {

            // If there's an abnormal exit (a crash), assume the worst.

            switch (FinishedCmd->getCondition()) {

            case Job::Condition::NewlyAdded:

              // The job won't be treated as newly added next time. Conservatively

              // mark it as affecting other jobs, because some of them may have

              // completed already.

              DepGraph.markTransitive(Dependents, FinishedCmd,

                                      IncrementalTracer);

              break;

            case Job::Condition::Always:

              // Any incremental task that shows up here has already been marked;

              // we didn't need to wait for it to finish to start downstream

              // tasks.

              assert(DepGraph.isMarked(FinishedCmd));

              break;

            case Job::Condition::RunWithoutCascading:

              // If this file changed, it might have been a non-cascading change

              // and it might not. Unfortunately, the interface hash has been

              // updated or compromised, so we don't actually know anymore; we

              // have to conservatively assume the changes could affect other

              // files.

              DepGraph.markTransitive(Dependents, FinishedCmd,

                                      IncrementalTracer);

              break;

            case Job::Condition::CheckDependencies:

              // If the only reason we're running this is because something else

              // changed, then we can trust the dependency graph as to whether

              // it's a cascading or non-cascading change. That is, if whatever

              // /caused/ the error isn't supposed to affect other files, and

              // whatever /fixes/ the error isn't supposed to affect other files,

              // then there's no need to recompile any other inputs. If either of

              // those are false, we /do/ need to recompile other inputs.

              break;

            }

          }

        }

      }



      if (ReturnCode != EXIT_SUCCESS) {

        // The task failed, so return true without performing any further

        // dependency analysis.



        // Store this task's ReturnCode as our Result if we haven't stored

        // anything yet.

        if (Result == EXIT_SUCCESS)

          Result = ReturnCode;



        if (!isa<CompileJobAction>(FinishedCmd->getSource()) ||

            ReturnCode != EXIT_FAILURE) {

          Comp.Diags.diagnose(SourceLoc(), diag::error_command_failed,

                              FinishedCmd->getSource().getClassName(),

                              ReturnCode);

        }



        return Comp.ContinueBuildingAfterErrors ?

          TaskFinishedResponse::ContinueExecution :

          TaskFinishedResponse::StopExecution;

      }



      // When a task finishes, we need to reevaluate the other commands that

      // might have been blocked.

      markFinished(FinishedCmd);



      for (const Job *Cmd : Dependents) {

        DeferredCommands.erase(Cmd);

        noteBuilding(Cmd, ""because of dependencies discovered later"");

        scheduleCommandIfNecessaryAndPossible(Cmd);

      }



      return TaskFinishedResponse::ContinueExecution;

    }

","    TaskFinishedResponse

    taskFinished(ProcessId Pid, int ReturnCode, StringRef Output,

                 StringRef Errors, void *Context) {

      const Job *FinishedCmd = (const Job *)Context;



      if (Comp.ShowDriverTimeCompilation) {

        DriverTimers[FinishedCmd]->stopTimer();

      }



      if (Comp.Level == OutputLevel::Parseable) {

        // Parseable output was requested.

        parseable_output::emitFinishedMessage(llvm::errs(), *FinishedCmd, Pid,

                                              ReturnCode, Output);

      } else {

        // Otherwise, send the buffered output to stderr, though only if we

        // support getting buffered output.

        if (TaskQueue::supportsBufferingOutput())

          llvm::errs() << Output;

      }



      // In order to handle both old dependencies that have disappeared and new

      // dependencies that have arisen, we need to reload the dependency file.

      // Do this whether or not the build succeeded.

      SmallVector<const Job *, 16> Dependents;

      if (Comp.getIncrementalBuildEnabled()) {

        const CommandOutput &Output = FinishedCmd->getOutput();

        StringRef DependenciesFile =

          Output.getAdditionalOutputForType(types::TY_SwiftDeps);



        if (DependenciesFile.empty()) {

          // If this job doesn't track dependencies, it must always be run.

          // Note: In theory CheckDependencies makes sense as well (for a leaf

          // node in the dependency graph), and maybe even NewlyAdded (for very

          // coarse dependencies that always affect downstream nodes), but we're

          // not using either of those right now, and this logic should probably

          // be revisited when we are.

          assert(FinishedCmd->getCondition() == Job::Condition::Always);

        } else {

          // If we have a dependency file /and/ the frontend task exited normally,

          // we can be discerning about what downstream files to rebuild.

          if (ReturnCode == EXIT_SUCCESS || ReturnCode == EXIT_FAILURE) {

            bool wasCascading = DepGraph.isMarked(FinishedCmd);



            switch (DepGraph.loadFromPath(FinishedCmd, DependenciesFile)) {

            case DependencyGraphImpl::LoadResult::HadError:

              if (ReturnCode == EXIT_SUCCESS) {

                Comp.disableIncrementalBuild();

                for (const Job *Cmd : DeferredCommands)

                  scheduleCommandIfNecessaryAndPossible(Cmd);

                DeferredCommands.clear();

                Dependents.clear();

              } // else, let the next build handle it.

              break;

            case DependencyGraphImpl::LoadResult::UpToDate:

              if (!wasCascading)

                break;

              LLVM_FALLTHROUGH;

            case DependencyGraphImpl::LoadResult::AffectsDownstream:

              DepGraph.markTransitive(Dependents, FinishedCmd,

                                      IncrementalTracer);

              break;

            }

          } else {

            // If there's an abnormal exit (a crash), assume the worst.

            switch (FinishedCmd->getCondition()) {

            case Job::Condition::NewlyAdded:

              // The job won't be treated as newly added next time. Conservatively

              // mark it as affecting other jobs, because some of them may have

              // completed already.

              DepGraph.markTransitive(Dependents, FinishedCmd,

                                      IncrementalTracer);

              break;

            case Job::Condition::Always:

              // Any incremental task that shows up here has already been marked;

              // we didn't need to wait for it to finish to start downstream

              // tasks.

             ","
              break;

            case Job::Condition::RunWithoutCascading:

              // If this file changed, it might have been a non-cascading change

              // and it might not. Unfortunately, the interface hash has been

              // updated or compromised, so we don't actually know anymore; we

              // have to conservatively assume the changes could affect other

              // files.

              DepGraph.markTransitive(Dependents, FinishedCmd,

                                      IncrementalTracer);

              break;

            case Job::Condition::CheckDependencies:

              // If the only reason we're running this is because something else

              // changed, then we can trust the dependency graph as to whether

              // it's a cascading or non-cascading change. That is, if whatever

              // /caused/ the error isn't supposed to affect other files, and

              // whatever /fixes/ the error isn't supposed to affect other files,

              // then there's no need to recompile any other inputs. If either of

              // those are false, we /do/ need to recompile other inputs.

              break;

            }

          }

        }

      }



      if (ReturnCode != EXIT_SUCCESS) {

        // The task failed, so return true without performing any further

        // dependency analysis.



        // Store this task's ReturnCode as our Result if we haven't stored

        // anything yet.

        if (Result == EXIT_SUCCESS)

          Result = ReturnCode;



        if (!isa<CompileJobAction>(FinishedCmd->getSource()) ||

            ReturnCode != EXIT_FAILURE) {

          Comp.Diags.diagnose(SourceLoc(), diag::error_command_failed,

                              FinishedCmd->getSource().getClassName(),

                              ReturnCode);

        }



        return Comp.ContinueBuildingAfterErrors ?

          TaskFinishedResponse::ContinueExecution :

          TaskFinishedResponse::StopExecution;

      }



      // When a task finishes, we need to reevaluate the other commands that

      // might have been blocked.

      markFinished(FinishedCmd);



      for (const Job *Cmd : Dependents) {

        DeferredCommands.erase(Cmd);

        noteBuilding(Cmd, ""because of dependencies discovered later"");

        scheduleCommandIfNecessaryAndPossible(Cmd);

      }



      return TaskFinishedResponse::ContinueExecution;

    }

"
[Driver] Move TaskQueue callbacks to PerformJobsState.,lib/Driver/Compilation.cpp,-,assert(State.DepGraph.isMarked(FinishedCmd));,"static bool writeAllSourcesFile(DiagnosticEngine &diags, StringRef path,

                                ArrayRef<InputPair> inputFiles) {

  std::error_code error;

  llvm::raw_fd_ostream out(path, error, llvm::sys::fs::F_None);

  if (out.has_error()) {

    out.clear_error();

    diags.diagnose(SourceLoc(), diag::error_unable_to_make_temporary_file,

                   error.message());

    return false;

  }



  for (auto inputPair : inputFiles) {

    if (!types::isPartOfSwiftCompilation(inputPair.first))

      continue;

    out << inputPair.second->getValue() << ""\n"";

  }



  return true;

}

","static bool writeAllSourcesFile(DiagnosticEngine &diags, StringRef path,

","
  std::error_code error;

  llvm::raw_fd_ostream out(path, error, llvm::sys::fs::F_None);

  if (out.has_error()) {

    out.clear_error();

    diags.diagnose(SourceLoc(), diag::error_unable_to_make_temporary_file,

                   error.message());

    return false;

  }



  for (auto inputPair : inputFiles) {

    if (!types::isPartOfSwiftCompilation(inputPair.first))

      continue;

    out << inputPair.second->getValue() << ""\n"";

  }



  return true;

}


"
[Driver] Move DepGraph and MarkTracer to PerformJobsState.,lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Queuing "" << reason << "": "" << LogJob(cmd) << ""\n"";","    void noteBuilding(const Job *cmd, StringRef reason) {

      if (!Comp.ShowIncrementalBuildDecisions)

        return;

      if (ScheduledCommands.count(cmd))

        return;

      llvm::outs() << ""Queuing "" << reason << "": "" << LogJob(cmd) << ""\n"";

      IncrementalTracer->printPath(

        llvm::outs(), cmd, [](raw_ostream &out, const Job *base) {

          out << llvm::sys::path::filename(base->getOutput().getBaseInput(0));

        });

    }

","    void noteBuilding(const Job *cmd, StringRef reason) {

      if (!Comp.ShowIncrementalBuildDecisions)

        return;

      if (ScheduledCommands.count(cmd))

        return;

     ","
      IncrementalTracer->printPath(

        llvm::outs(), cmd, [](raw_ostream &out, const Job *base) {

          out << llvm::sys::path::filename(base->getOutput().getBaseInput(0));

        });

    }

"
[Driver] Move DepGraph and MarkTracer to PerformJobsState.,lib/Driver/Compilation.cpp,+,IncrementalTracer->printPath(,"    void noteBuilding(const Job *cmd, StringRef reason) {

      if (!Comp.ShowIncrementalBuildDecisions)

        return;

      if (ScheduledCommands.count(cmd))

        return;

      llvm::outs() << ""Queuing "" << reason << "": "" << LogJob(cmd) << ""\n"";

      IncrementalTracer->printPath(

        llvm::outs(), cmd, [](raw_ostream &out, const Job *base) {

          out << llvm::sys::path::filename(base->getOutput().getBaseInput(0));

        });

    }

","    void noteBuilding(const Job *cmd, StringRef reason) {

      if (!Comp.ShowIncrementalBuildDecisions)

        return;

      if (ScheduledCommands.count(cmd))

        return;

      llvm::outs() << ""Queuing "" << reason << "": "" << LogJob(cmd) << ""\n"";

     ","
        llvm::outs(), cmd, [](raw_ostream &out, const Job *base) {

          out << llvm::sys::path::filename(base->getOutput().getBaseInput(0));

        });

    }

"
"[Driver] Move markFinished to PerformJobsState, add logging.",lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Job finished: "" << LogJob(Cmd) << ""\n"";","    void markFinished(const Job *Cmd) {

      if (Comp.ShowIncrementalBuildDecisions) {

        llvm::outs() << ""Job finished: "" << LogJob(Cmd) << ""\n"";

      }

      FinishedCommands.insert(Cmd);



      auto BlockedIter = BlockingCommands.find(Cmd);

      if (BlockedIter != BlockingCommands.end()) {

        auto AllBlocked = std::move(BlockedIter->second);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Scheduling maybe-unblocked jobs: ""

                       << LogJobArray(AllBlocked) << ""\n"";

        }

        BlockingCommands.erase(BlockedIter);

        for (auto *Blocked : AllBlocked)

          scheduleCommandIfNecessaryAndPossible(Blocked);

    }

  }

","    void markFinished(const Job *Cmd) {

      if (Comp.ShowIncrementalBuildDecisions) {

       ","
      }

      FinishedCommands.insert(Cmd);



      auto BlockedIter = BlockingCommands.find(Cmd);

      if (BlockedIter != BlockingCommands.end()) {

        auto AllBlocked = std::move(BlockedIter->second);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Scheduling maybe-unblocked jobs: ""

                       << LogJobArray(AllBlocked) << ""\n"";

        }

        BlockingCommands.erase(BlockedIter);

        for (auto *Blocked : AllBlocked)

          scheduleCommandIfNecessaryAndPossible(Blocked);

    }

  }

"
"[Driver] Move markFinished to PerformJobsState, add logging.",lib/Driver/Compilation.cpp,+,"<< LogJobArray(AllBlocked) << ""\n"";","    void markFinished(const Job *Cmd) {

      if (Comp.ShowIncrementalBuildDecisions) {

        llvm::outs() << ""Job finished: "" << LogJob(Cmd) << ""\n"";

      }

      FinishedCommands.insert(Cmd);



      auto BlockedIter = BlockingCommands.find(Cmd);

      if (BlockedIter != BlockingCommands.end()) {

        auto AllBlocked = std::move(BlockedIter->second);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Scheduling maybe-unblocked jobs: ""

                       << LogJobArray(AllBlocked) << ""\n"";

        }

        BlockingCommands.erase(BlockedIter);

        for (auto *Blocked : AllBlocked)

          scheduleCommandIfNecessaryAndPossible(Blocked);

    }

  }

","    void markFinished(const Job *Cmd) {

      if (Comp.ShowIncrementalBuildDecisions) {

        llvm::outs() << ""Job finished: "" << LogJob(Cmd) << ""\n"";

      }

      FinishedCommands.insert(Cmd);



      auto BlockedIter = BlockingCommands.find(Cmd);

      if (BlockedIter != BlockingCommands.end()) {

        auto AllBlocked = std::move(BlockedIter->second);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Scheduling maybe-unblocked jobs: ""

                      ","
        }

        BlockingCommands.erase(BlockedIter);

        for (auto *Blocked : AllBlocked)

          scheduleCommandIfNecessaryAndPossible(Blocked);

    }

  }

"
[Driver] Extract scheduleCommandIfNecessary and add logging.,lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Already scheduled: "" << LogJob(Cmd) << ""\n"";","    void scheduleCommandIfNecessaryAndPossible(const Job *Cmd) {

      if (ScheduledCommands.count(Cmd)) {

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Already scheduled: "" << LogJob(Cmd) << ""\n"";

        }

        return;

      }



      if (auto Blocking = findUnfinishedJob(Cmd->getInputs())) {

        BlockingCommands[Blocking].push_back(Cmd);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Blocked by: "" << LogJob(Blocking)

                       << "", now blocking jobs: ""

                       << LogJobArray(BlockingCommands[Blocking]) << ""\n"";

        }

        return;

      }



      // FIXME: Failing here should not take down the whole process.

      bool success = writeFilelistIfNecessary(Cmd, Comp.Diags);

      assert(success && ""failed to write filelist"");

      (void)success;



      assert(Cmd->getExtraEnvironment().empty() &&

             ""not implemented for compilations with multiple jobs"");

      ScheduledCommands.insert(Cmd);

      if (Comp.ShowIncrementalBuildDecisions)

        llvm::outs() << ""Added to TaskQueue: "" << LogJob(Cmd) << ""\n"";

      TQ->addTask(Cmd->getExecutable(), Cmd->getArguments(), llvm::None,

                  (void *)Cmd);

    }

","    void scheduleCommandIfNecessaryAndPossible(const Job *Cmd) {

      if (ScheduledCommands.count(Cmd)) {

        if (Comp.ShowIncrementalBuildDecisions) {

         ","
        }

        return;

      }



      if (auto Blocking = findUnfinishedJob(Cmd->getInputs())) {

        BlockingCommands[Blocking].push_back(Cmd);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Blocked by: "" << LogJob(Blocking)

                       << "", now blocking jobs: ""

                       << LogJobArray(BlockingCommands[Blocking]) << ""\n"";

        }

        return;

      }



      // FIXME: Failing here should not take down the whole process.

      bool success = writeFilelistIfNecessary(Cmd, Comp.Diags);

      assert(success && ""failed to write filelist"");

      (void)success;



      assert(Cmd->getExtraEnvironment().empty() &&

             ""not implemented for compilations with multiple jobs"");

      ScheduledCommands.insert(Cmd);

      if (Comp.ShowIncrementalBuildDecisions)

        llvm::outs() << ""Added to TaskQueue: "" << LogJob(Cmd) << ""\n"";

      TQ->addTask(Cmd->getExecutable(), Cmd->getArguments(), llvm::None,

                  (void *)Cmd);

    }

"
[Driver] Extract scheduleCommandIfNecessary and add logging.,lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Blocked by: "" << LogJob(Blocking)","    void scheduleCommandIfNecessaryAndPossible(const Job *Cmd) {

      if (ScheduledCommands.count(Cmd)) {

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Already scheduled: "" << LogJob(Cmd) << ""\n"";

        }

        return;

      }



      if (auto Blocking = findUnfinishedJob(Cmd->getInputs())) {

        BlockingCommands[Blocking].push_back(Cmd);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Blocked by: "" << LogJob(Blocking)

                       << "", now blocking jobs: ""

                       << LogJobArray(BlockingCommands[Blocking]) << ""\n"";

        }

        return;

      }



      // FIXME: Failing here should not take down the whole process.

      bool success = writeFilelistIfNecessary(Cmd, Comp.Diags);

      assert(success && ""failed to write filelist"");

      (void)success;



      assert(Cmd->getExtraEnvironment().empty() &&

             ""not implemented for compilations with multiple jobs"");

      ScheduledCommands.insert(Cmd);

      if (Comp.ShowIncrementalBuildDecisions)

        llvm::outs() << ""Added to TaskQueue: "" << LogJob(Cmd) << ""\n"";

      TQ->addTask(Cmd->getExecutable(), Cmd->getArguments(), llvm::None,

                  (void *)Cmd);

    }

","    void scheduleCommandIfNecessaryAndPossible(const Job *Cmd) {

      if (ScheduledCommands.count(Cmd)) {

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Already scheduled: "" << LogJob(Cmd) << ""\n"";

        }

        return;

      }



      if (auto Blocking = findUnfinishedJob(Cmd->getInputs())) {

        BlockingCommands[Blocking].push_back(Cmd);

        if (Comp.ShowIncrementalBuildDecisions) {

         ","
                       << "", now blocking jobs: ""

                       << LogJobArray(BlockingCommands[Blocking]) << ""\n"";

        }

        return;

      }



      // FIXME: Failing here should not take down the whole process.

      bool success = writeFilelistIfNecessary(Cmd, Comp.Diags);

      assert(success && ""failed to write filelist"");

      (void)success;



      assert(Cmd->getExtraEnvironment().empty() &&

             ""not implemented for compilations with multiple jobs"");

      ScheduledCommands.insert(Cmd);

      if (Comp.ShowIncrementalBuildDecisions)

        llvm::outs() << ""Added to TaskQueue: "" << LogJob(Cmd) << ""\n"";

      TQ->addTask(Cmd->getExecutable(), Cmd->getArguments(), llvm::None,

                  (void *)Cmd);

    }

"
[Driver] Extract scheduleCommandIfNecessary and add logging.,lib/Driver/Compilation.cpp,+,"<< LogJobArray(BlockingCommands[Blocking]) << ""\n"";","    void scheduleCommandIfNecessaryAndPossible(const Job *Cmd) {

      if (ScheduledCommands.count(Cmd)) {

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Already scheduled: "" << LogJob(Cmd) << ""\n"";

        }

        return;

      }



      if (auto Blocking = findUnfinishedJob(Cmd->getInputs())) {

        BlockingCommands[Blocking].push_back(Cmd);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Blocked by: "" << LogJob(Blocking)

                       << "", now blocking jobs: ""

                       << LogJobArray(BlockingCommands[Blocking]) << ""\n"";

        }

        return;

      }



      // FIXME: Failing here should not take down the whole process.

      bool success = writeFilelistIfNecessary(Cmd, Comp.Diags);

      assert(success && ""failed to write filelist"");

      (void)success;



      assert(Cmd->getExtraEnvironment().empty() &&

             ""not implemented for compilations with multiple jobs"");

      ScheduledCommands.insert(Cmd);

      if (Comp.ShowIncrementalBuildDecisions)

        llvm::outs() << ""Added to TaskQueue: "" << LogJob(Cmd) << ""\n"";

      TQ->addTask(Cmd->getExecutable(), Cmd->getArguments(), llvm::None,

                  (void *)Cmd);

    }

","    void scheduleCommandIfNecessaryAndPossible(const Job *Cmd) {

      if (ScheduledCommands.count(Cmd)) {

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Already scheduled: "" << LogJob(Cmd) << ""\n"";

        }

        return;

      }



      if (auto Blocking = findUnfinishedJob(Cmd->getInputs())) {

        BlockingCommands[Blocking].push_back(Cmd);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Blocked by: "" << LogJob(Blocking)

                       << "", now blocking jobs: ""

                      ","
        }

        return;

      }



      // FIXME: Failing here should not take down the whole process.

      bool success = writeFilelistIfNecessary(Cmd, Comp.Diags);

      assert(success && ""failed to write filelist"");

      (void)success;



      assert(Cmd->getExtraEnvironment().empty() &&

             ""not implemented for compilations with multiple jobs"");

      ScheduledCommands.insert(Cmd);

      if (Comp.ShowIncrementalBuildDecisions)

        llvm::outs() << ""Added to TaskQueue: "" << LogJob(Cmd) << ""\n"";

      TQ->addTask(Cmd->getExecutable(), Cmd->getArguments(), llvm::None,

                  (void *)Cmd);

    }

"
[Driver] Extract scheduleCommandIfNecessary and add logging.,lib/Driver/Compilation.cpp,+,"bool success = writeFilelistIfNecessary(Cmd, Comp.Diags);","    void scheduleCommandIfNecessaryAndPossible(const Job *Cmd) {

      if (ScheduledCommands.count(Cmd)) {

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Already scheduled: "" << LogJob(Cmd) << ""\n"";

        }

        return;

      }



      if (auto Blocking = findUnfinishedJob(Cmd->getInputs())) {

        BlockingCommands[Blocking].push_back(Cmd);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Blocked by: "" << LogJob(Blocking)

                       << "", now blocking jobs: ""

                       << LogJobArray(BlockingCommands[Blocking]) << ""\n"";

        }

        return;

      }



      // FIXME: Failing here should not take down the whole process.

      bool success = writeFilelistIfNecessary(Cmd, Comp.Diags);

      assert(success && ""failed to write filelist"");

      (void)success;



      assert(Cmd->getExtraEnvironment().empty() &&

             ""not implemented for compilations with multiple jobs"");

      ScheduledCommands.insert(Cmd);

      if (Comp.ShowIncrementalBuildDecisions)

        llvm::outs() << ""Added to TaskQueue: "" << LogJob(Cmd) << ""\n"";

      TQ->addTask(Cmd->getExecutable(), Cmd->getArguments(), llvm::None,

                  (void *)Cmd);

    }

","    void scheduleCommandIfNecessaryAndPossible(const Job *Cmd) {

      if (ScheduledCommands.count(Cmd)) {

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Already scheduled: "" << LogJob(Cmd) << ""\n"";

        }

        return;

      }



      if (auto Blocking = findUnfinishedJob(Cmd->getInputs())) {

        BlockingCommands[Blocking].push_back(Cmd);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Blocked by: "" << LogJob(Blocking)

                       << "", now blocking jobs: ""

                       << LogJobArray(BlockingCommands[Blocking]) << ""\n"";

        }

        return;

      }



      // FIXME: Failing here should not take down the whole process.

     ","
      assert(success && ""failed to write filelist"");

      (void)success;



      assert(Cmd->getExtraEnvironment().empty() &&

             ""not implemented for compilations with multiple jobs"");

      ScheduledCommands.insert(Cmd);

      if (Comp.ShowIncrementalBuildDecisions)

        llvm::outs() << ""Added to TaskQueue: "" << LogJob(Cmd) << ""\n"";

      TQ->addTask(Cmd->getExecutable(), Cmd->getArguments(), llvm::None,

                  (void *)Cmd);

    }

"
[Driver] Extract scheduleCommandIfNecessary and add logging.,lib/Driver/Compilation.cpp,+,"assert(success && ""failed to write filelist"");","    void scheduleCommandIfNecessaryAndPossible(const Job *Cmd) {

      if (ScheduledCommands.count(Cmd)) {

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Already scheduled: "" << LogJob(Cmd) << ""\n"";

        }

        return;

      }



      if (auto Blocking = findUnfinishedJob(Cmd->getInputs())) {

        BlockingCommands[Blocking].push_back(Cmd);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Blocked by: "" << LogJob(Blocking)

                       << "", now blocking jobs: ""

                       << LogJobArray(BlockingCommands[Blocking]) << ""\n"";

        }

        return;

      }



      // FIXME: Failing here should not take down the whole process.

      bool success = writeFilelistIfNecessary(Cmd, Comp.Diags);

      assert(success && ""failed to write filelist"");

      (void)success;



      assert(Cmd->getExtraEnvironment().empty() &&

             ""not implemented for compilations with multiple jobs"");

      ScheduledCommands.insert(Cmd);

      if (Comp.ShowIncrementalBuildDecisions)

        llvm::outs() << ""Added to TaskQueue: "" << LogJob(Cmd) << ""\n"";

      TQ->addTask(Cmd->getExecutable(), Cmd->getArguments(), llvm::None,

                  (void *)Cmd);

    }

","    void scheduleCommandIfNecessaryAndPossible(const Job *Cmd) {

      if (ScheduledCommands.count(Cmd)) {

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Already scheduled: "" << LogJob(Cmd) << ""\n"";

        }

        return;

      }



      if (auto Blocking = findUnfinishedJob(Cmd->getInputs())) {

        BlockingCommands[Blocking].push_back(Cmd);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Blocked by: "" << LogJob(Blocking)

                       << "", now blocking jobs: ""

                       << LogJobArray(BlockingCommands[Blocking]) << ""\n"";

        }

        return;

      }



      // FIXME: Failing here should not take down the whole process.

      bool success = writeFilelistIfNecessary(Cmd, Comp.Diags);

     ","
      (void)success;



      assert(Cmd->getExtraEnvironment().empty() &&

             ""not implemented for compilations with multiple jobs"");

      ScheduledCommands.insert(Cmd);

      if (Comp.ShowIncrementalBuildDecisions)

        llvm::outs() << ""Added to TaskQueue: "" << LogJob(Cmd) << ""\n"";

      TQ->addTask(Cmd->getExecutable(), Cmd->getArguments(), llvm::None,

                  (void *)Cmd);

    }

"
[Driver] Extract scheduleCommandIfNecessary and add logging.,lib/Driver/Compilation.cpp,+,assert(Cmd->getExtraEnvironment().empty() &&,"    void scheduleCommandIfNecessaryAndPossible(const Job *Cmd) {

      if (ScheduledCommands.count(Cmd)) {

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Already scheduled: "" << LogJob(Cmd) << ""\n"";

        }

        return;

      }



      if (auto Blocking = findUnfinishedJob(Cmd->getInputs())) {

        BlockingCommands[Blocking].push_back(Cmd);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Blocked by: "" << LogJob(Blocking)

                       << "", now blocking jobs: ""

                       << LogJobArray(BlockingCommands[Blocking]) << ""\n"";

        }

        return;

      }



      // FIXME: Failing here should not take down the whole process.

      bool success = writeFilelistIfNecessary(Cmd, Comp.Diags);

      assert(success && ""failed to write filelist"");

      (void)success;



      assert(Cmd->getExtraEnvironment().empty() &&

             ""not implemented for compilations with multiple jobs"");

      ScheduledCommands.insert(Cmd);

      if (Comp.ShowIncrementalBuildDecisions)

        llvm::outs() << ""Added to TaskQueue: "" << LogJob(Cmd) << ""\n"";

      TQ->addTask(Cmd->getExecutable(), Cmd->getArguments(), llvm::None,

                  (void *)Cmd);

    }

","    void scheduleCommandIfNecessaryAndPossible(const Job *Cmd) {

      if (ScheduledCommands.count(Cmd)) {

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Already scheduled: "" << LogJob(Cmd) << ""\n"";

        }

        return;

      }



      if (auto Blocking = findUnfinishedJob(Cmd->getInputs())) {

        BlockingCommands[Blocking].push_back(Cmd);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Blocked by: "" << LogJob(Blocking)

                       << "", now blocking jobs: ""

                       << LogJobArray(BlockingCommands[Blocking]) << ""\n"";

        }

        return;

      }



      // FIXME: Failing here should not take down the whole process.

      bool success = writeFilelistIfNecessary(Cmd, Comp.Diags);

      assert(success && ""failed to write filelist"");

      (void)success;



     ","
             ""not implemented for compilations with multiple jobs"");

      ScheduledCommands.insert(Cmd);

      if (Comp.ShowIncrementalBuildDecisions)

        llvm::outs() << ""Added to TaskQueue: "" << LogJob(Cmd) << ""\n"";

      TQ->addTask(Cmd->getExecutable(), Cmd->getArguments(), llvm::None,

                  (void *)Cmd);

    }

"
[Driver] Extract scheduleCommandIfNecessary and add logging.,lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Added to TaskQueue: "" << LogJob(Cmd) << ""\n"";","    void scheduleCommandIfNecessaryAndPossible(const Job *Cmd) {

      if (ScheduledCommands.count(Cmd)) {

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Already scheduled: "" << LogJob(Cmd) << ""\n"";

        }

        return;

      }



      if (auto Blocking = findUnfinishedJob(Cmd->getInputs())) {

        BlockingCommands[Blocking].push_back(Cmd);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Blocked by: "" << LogJob(Blocking)

                       << "", now blocking jobs: ""

                       << LogJobArray(BlockingCommands[Blocking]) << ""\n"";

        }

        return;

      }



      // FIXME: Failing here should not take down the whole process.

      bool success = writeFilelistIfNecessary(Cmd, Comp.Diags);

      assert(success && ""failed to write filelist"");

      (void)success;



      assert(Cmd->getExtraEnvironment().empty() &&

             ""not implemented for compilations with multiple jobs"");

      ScheduledCommands.insert(Cmd);

      if (Comp.ShowIncrementalBuildDecisions)

        llvm::outs() << ""Added to TaskQueue: "" << LogJob(Cmd) << ""\n"";

      TQ->addTask(Cmd->getExecutable(), Cmd->getArguments(), llvm::None,

                  (void *)Cmd);

    }

","    void scheduleCommandIfNecessaryAndPossible(const Job *Cmd) {

      if (ScheduledCommands.count(Cmd)) {

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Already scheduled: "" << LogJob(Cmd) << ""\n"";

        }

        return;

      }



      if (auto Blocking = findUnfinishedJob(Cmd->getInputs())) {

        BlockingCommands[Blocking].push_back(Cmd);

        if (Comp.ShowIncrementalBuildDecisions) {

          llvm::outs() << ""Blocked by: "" << LogJob(Blocking)

                       << "", now blocking jobs: ""

                       << LogJobArray(BlockingCommands[Blocking]) << ""\n"";

        }

        return;

      }



      // FIXME: Failing here should not take down the whole process.

      bool success = writeFilelistIfNecessary(Cmd, Comp.Diags);

      assert(success && ""failed to write filelist"");

      (void)success;



      assert(Cmd->getExtraEnvironment().empty() &&

             ""not implemented for compilations with multiple jobs"");

      ScheduledCommands.insert(Cmd);

      if (Comp.ShowIncrementalBuildDecisions)

       ","
      TQ->addTask(Cmd->getExecutable(), Cmd->getArguments(), llvm::None,

                  (void *)Cmd);

    }

"
[Driver] Factor out some Job-logging support.,lib/Driver/Compilation.cpp,+,LogJob(const Job *j) : j(j) {},"  LogJob(const Job *j) : j(j) {}

", ,"
"
[Driver] Factor out some Job-logging support.,lib/Driver/Compilation.cpp,+,LogJobArray(const ArrayRef<const Job *> js) : js(js) {},"  LogJobArray(const ArrayRef<const Job *> js) : js(js) {}

", ,"
"
[Driver] Factor out some Job-logging support.,lib/Driver/Compilation.cpp,+,LogJobSet(const SmallPtrSetImpl<const Job*> &js) : js(js) {},"  LogJobSet(const SmallPtrSetImpl<const Job*> &js) : js(js) {}

", ,"
"
[Driver] Factor out some Job-logging support.,lib/Driver/Compilation.cpp,+,lj.j->printSummary(os);,"llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJob &lj) {

  lj.j->printSummary(os);

  return os;

}

","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJob &lj) {

 ","
  return os;

}

"
[Driver] Factor out some Job-logging support.,lib/Driver/Compilation.cpp,+,"[&](Job const *j) { os << LogJob(j); },","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobArray &ljs) {

  os << ""["";

  interleave(ljs.js,

             [&](Job const *j) { os << LogJob(j); },

             [&]() { os << ' '; });

  os << ""]"";

  return os;

}

","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobArray &ljs) {

  os << ""["";

  interleave(ljs.js,

            ","
             [&]() { os << ' '; });

  os << ""]"";

  return os;

}

"
[Driver] Factor out some Job-logging support.,lib/Driver/Compilation.cpp,+,"[&](Job const *j) { os << LogJob(j); },","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobSet &ljs) {

  os << ""{"";

  interleave(ljs.js,

             [&](Job const *j) { os << LogJob(j); },

             [&]() { os << ' '; });

  os << ""}"";

  return os;

}

","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobSet &ljs) {

  os << ""{"";

  interleave(ljs.js,

            ","
             [&]() { os << ' '; });

  os << ""}"";

  return os;

}

"
"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,SymbolicRef.print(KnownOS);,"TEST(UnknownSyntaxTests, UnknownSyntaxMakeAPIs) {

  {

    auto SymbolicRef = getCannedSymbolicRef();



    // Print the known symbolic reference. It should print as ""Array<Int>"".

    SmallString<48> KnownScratch;

    llvm::raw_svector_ostream KnownOS(KnownScratch);

    SymbolicRef.print(KnownOS);

    ASSERT_EQ(KnownOS.str().str(), ""Array<Int>"");



    // Wrap that symbolic reference as an UnknownSyntax. This has the same

    // RawSyntax layout but with the Unknown Kind.

    auto UnknownSymbolicRefData = UnknownSyntaxData::make(SymbolicRef.getRaw());



    auto Unknown = UnknownSyntax {

      UnknownSymbolicRefData,

      UnknownSymbolicRefData.get()

    };



    // Print the unknown syntax. It should also print as ""Array<Int>"".

    SmallString<48> UnknownScratch;

    llvm::raw_svector_ostream UnknownOS(UnknownScratch);

    Unknown.print(UnknownOS);



    ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());

  }

}

","TEST(UnknownSyntaxTests, UnknownSyntaxMakeAPIs) {

  {

    auto SymbolicRef = getCannedSymbolicRef();



    // Print the known symbolic reference. It should print as ""Array<Int>"".

    SmallString<48> KnownScratch;

    llvm::raw_svector_ostream KnownOS(KnownScratch);

   ","
    ASSERT_EQ(KnownOS.str().str(), ""Array<Int>"");



    // Wrap that symbolic reference as an UnknownSyntax. This has the same

    // RawSyntax layout but with the Unknown Kind.

    auto UnknownSymbolicRefData = UnknownSyntaxData::make(SymbolicRef.getRaw());



    auto Unknown = UnknownSyntax {

      UnknownSymbolicRefData,

      UnknownSymbolicRefData.get()

    };



    // Print the unknown syntax. It should also print as ""Array<Int>"".

    SmallString<48> UnknownScratch;

    llvm::raw_svector_ostream UnknownOS(UnknownScratch);

    Unknown.print(UnknownOS);



    ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());

  }

}

"
"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,"ASSERT_EQ(KnownOS.str().str(), ""Array<Int>"");","TEST(UnknownSyntaxTests, UnknownSyntaxMakeAPIs) {

  {

    auto SymbolicRef = getCannedSymbolicRef();



    // Print the known symbolic reference. It should print as ""Array<Int>"".

    SmallString<48> KnownScratch;

    llvm::raw_svector_ostream KnownOS(KnownScratch);

    SymbolicRef.print(KnownOS);

    ASSERT_EQ(KnownOS.str().str(), ""Array<Int>"");



    // Wrap that symbolic reference as an UnknownSyntax. This has the same

    // RawSyntax layout but with the Unknown Kind.

    auto UnknownSymbolicRefData = UnknownSyntaxData::make(SymbolicRef.getRaw());



    auto Unknown = UnknownSyntax {

      UnknownSymbolicRefData,

      UnknownSymbolicRefData.get()

    };



    // Print the unknown syntax. It should also print as ""Array<Int>"".

    SmallString<48> UnknownScratch;

    llvm::raw_svector_ostream UnknownOS(UnknownScratch);

    Unknown.print(UnknownOS);



    ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());

  }

}

","TEST(UnknownSyntaxTests, UnknownSyntaxMakeAPIs) {

  {

    auto SymbolicRef = getCannedSymbolicRef();



    // Print the known symbolic reference. It should print as ""Array<Int>"".

    SmallString<48> KnownScratch;

    llvm::raw_svector_ostream KnownOS(KnownScratch);

    SymbolicRef.print(KnownOS);

   ","


    // Wrap that symbolic reference as an UnknownSyntax. This has the same

    // RawSyntax layout but with the Unknown Kind.

    auto UnknownSymbolicRefData = UnknownSyntaxData::make(SymbolicRef.getRaw());



    auto Unknown = UnknownSyntax {

      UnknownSymbolicRefData,

      UnknownSymbolicRefData.get()

    };



    // Print the unknown syntax. It should also print as ""Array<Int>"".

    SmallString<48> UnknownScratch;

    llvm::raw_svector_ostream UnknownOS(UnknownScratch);

    Unknown.print(UnknownOS);



    ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());

  }

}

"
"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,Unknown.print(UnknownOS);,"TEST(UnknownSyntaxTests, UnknownSyntaxMakeAPIs) {

  {

    auto SymbolicRef = getCannedSymbolicRef();



    // Print the known symbolic reference. It should print as ""Array<Int>"".

    SmallString<48> KnownScratch;

    llvm::raw_svector_ostream KnownOS(KnownScratch);

    SymbolicRef.print(KnownOS);

    ASSERT_EQ(KnownOS.str().str(), ""Array<Int>"");



    // Wrap that symbolic reference as an UnknownSyntax. This has the same

    // RawSyntax layout but with the Unknown Kind.

    auto UnknownSymbolicRefData = UnknownSyntaxData::make(SymbolicRef.getRaw());



    auto Unknown = UnknownSyntax {

      UnknownSymbolicRefData,

      UnknownSymbolicRefData.get()

    };



    // Print the unknown syntax. It should also print as ""Array<Int>"".

    SmallString<48> UnknownScratch;

    llvm::raw_svector_ostream UnknownOS(UnknownScratch);

    Unknown.print(UnknownOS);



    ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());

  }

}

","TEST(UnknownSyntaxTests, UnknownSyntaxMakeAPIs) {

  {

    auto SymbolicRef = getCannedSymbolicRef();



    // Print the known symbolic reference. It should print as ""Array<Int>"".

    SmallString<48> KnownScratch;

    llvm::raw_svector_ostream KnownOS(KnownScratch);

    SymbolicRef.print(KnownOS);

    ASSERT_EQ(KnownOS.str().str(), ""Array<Int>"");



    // Wrap that symbolic reference as an UnknownSyntax. This has the same

    // RawSyntax layout but with the Unknown Kind.

    auto UnknownSymbolicRefData = UnknownSyntaxData::make(SymbolicRef.getRaw());



    auto Unknown = UnknownSyntax {

      UnknownSymbolicRefData,

      UnknownSymbolicRefData.get()

    };



    // Print the unknown syntax. It should also print as ""Array<Int>"".

    SmallString<48> UnknownScratch;

    llvm::raw_svector_ostream UnknownOS(UnknownScratch);

   ","


    ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());

  }

}

"
"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,"ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());","TEST(UnknownSyntaxTests, UnknownSyntaxMakeAPIs) {

  {

    auto SymbolicRef = getCannedSymbolicRef();



    // Print the known symbolic reference. It should print as ""Array<Int>"".

    SmallString<48> KnownScratch;

    llvm::raw_svector_ostream KnownOS(KnownScratch);

    SymbolicRef.print(KnownOS);

    ASSERT_EQ(KnownOS.str().str(), ""Array<Int>"");



    // Wrap that symbolic reference as an UnknownSyntax. This has the same

    // RawSyntax layout but with the Unknown Kind.

    auto UnknownSymbolicRefData = UnknownSyntaxData::make(SymbolicRef.getRaw());



    auto Unknown = UnknownSyntax {

      UnknownSymbolicRefData,

      UnknownSymbolicRefData.get()

    };



    // Print the unknown syntax. It should also print as ""Array<Int>"".

    SmallString<48> UnknownScratch;

    llvm::raw_svector_ostream UnknownOS(UnknownScratch);

    Unknown.print(UnknownOS);



    ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());

  }

}

","TEST(UnknownSyntaxTests, UnknownSyntaxMakeAPIs) {

  {

    auto SymbolicRef = getCannedSymbolicRef();



    // Print the known symbolic reference. It should print as ""Array<Int>"".

    SmallString<48> KnownScratch;

    llvm::raw_svector_ostream KnownOS(KnownScratch);

    SymbolicRef.print(KnownOS);

    ASSERT_EQ(KnownOS.str().str(), ""Array<Int>"");



    // Wrap that symbolic reference as an UnknownSyntax. This has the same

    // RawSyntax layout but with the Unknown Kind.

    auto UnknownSymbolicRefData = UnknownSyntaxData::make(SymbolicRef.getRaw());



    auto Unknown = UnknownSyntax {

      UnknownSymbolicRefData,

      UnknownSymbolicRefData.get()

    };



    // Print the unknown syntax. It should also print as ""Array<Int>"".

    SmallString<48> UnknownScratch;

    llvm::raw_svector_ostream UnknownOS(UnknownScratch);

    Unknown.print(UnknownOS);



   ","
  }

}

"
"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,SymbolicRef.print(KnownOS);,"TEST(UnknownSyntaxTests, UnknownSyntaxMakeAPIs) {

  {

    auto SymbolicRef = getCannedSymbolicRef();



    // Print the known symbolic reference. It should print as ""Array<Int>"".

    SmallString<48> KnownScratch;

    llvm::raw_svector_ostream KnownOS(KnownScratch);

    SymbolicRef.print(KnownOS);

    ASSERT_EQ(KnownOS.str().str(), ""Array<Int>"");



    // Wrap that symbolic reference as an UnknownSyntax. This has the same

    // RawSyntax layout but with the Unknown Kind.

    auto UnknownSymbolicRefData = UnknownSyntaxData::make(SymbolicRef.getRaw());



    auto Unknown = UnknownSyntax {

      UnknownSymbolicRefData,

      UnknownSymbolicRefData.get()

    };



    // Print the unknown syntax. It should also print as ""Array<Int>"".

    SmallString<48> UnknownScratch;

    llvm::raw_svector_ostream UnknownOS(UnknownScratch);

    Unknown.print(UnknownOS);



    ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());

  }

}

","TEST(UnknownSyntaxTests, UnknownSyntaxMakeAPIs) {

  {

    auto SymbolicRef = getCannedSymbolicRef();



    // Print the known symbolic reference. It should print as ""Array<Int>"".

    SmallString<48> KnownScratch;

    llvm::raw_svector_ostream KnownOS(KnownScratch);

   ","
    ASSERT_EQ(KnownOS.str().str(), ""Array<Int>"");



    // Wrap that symbolic reference as an UnknownSyntax. This has the same

    // RawSyntax layout but with the Unknown Kind.

    auto UnknownSymbolicRefData = UnknownSyntaxData::make(SymbolicRef.getRaw());



    auto Unknown = UnknownSyntax {

      UnknownSymbolicRefData,

      UnknownSymbolicRefData.get()

    };



    // Print the unknown syntax. It should also print as ""Array<Int>"".

    SmallString<48> UnknownScratch;

    llvm::raw_svector_ostream UnknownOS(UnknownScratch);

    Unknown.print(UnknownOS);



    ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());

  }

}

"
"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,"ASSERT_EQ(KnownOS.str().str(), ""Array<Int>"");","TEST(UnknownSyntaxTests, UnknownSyntaxMakeAPIs) {

  {

    auto SymbolicRef = getCannedSymbolicRef();



    // Print the known symbolic reference. It should print as ""Array<Int>"".

    SmallString<48> KnownScratch;

    llvm::raw_svector_ostream KnownOS(KnownScratch);

    SymbolicRef.print(KnownOS);

    ASSERT_EQ(KnownOS.str().str(), ""Array<Int>"");



    // Wrap that symbolic reference as an UnknownSyntax. This has the same

    // RawSyntax layout but with the Unknown Kind.

    auto UnknownSymbolicRefData = UnknownSyntaxData::make(SymbolicRef.getRaw());



    auto Unknown = UnknownSyntax {

      UnknownSymbolicRefData,

      UnknownSymbolicRefData.get()

    };



    // Print the unknown syntax. It should also print as ""Array<Int>"".

    SmallString<48> UnknownScratch;

    llvm::raw_svector_ostream UnknownOS(UnknownScratch);

    Unknown.print(UnknownOS);



    ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());

  }

}

","TEST(UnknownSyntaxTests, UnknownSyntaxMakeAPIs) {

  {

    auto SymbolicRef = getCannedSymbolicRef();



    // Print the known symbolic reference. It should print as ""Array<Int>"".

    SmallString<48> KnownScratch;

    llvm::raw_svector_ostream KnownOS(KnownScratch);

    SymbolicRef.print(KnownOS);

   ","


    // Wrap that symbolic reference as an UnknownSyntax. This has the same

    // RawSyntax layout but with the Unknown Kind.

    auto UnknownSymbolicRefData = UnknownSyntaxData::make(SymbolicRef.getRaw());



    auto Unknown = UnknownSyntax {

      UnknownSymbolicRefData,

      UnknownSymbolicRefData.get()

    };



    // Print the unknown syntax. It should also print as ""Array<Int>"".

    SmallString<48> UnknownScratch;

    llvm::raw_svector_ostream UnknownOS(UnknownScratch);

    Unknown.print(UnknownOS);



    ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());

  }

}

"
"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,Unknown.print(UnknownOS);,"TEST(UnknownSyntaxTests, UnknownSyntaxMakeAPIs) {

  {

    auto SymbolicRef = getCannedSymbolicRef();



    // Print the known symbolic reference. It should print as ""Array<Int>"".

    SmallString<48> KnownScratch;

    llvm::raw_svector_ostream KnownOS(KnownScratch);

    SymbolicRef.print(KnownOS);

    ASSERT_EQ(KnownOS.str().str(), ""Array<Int>"");



    // Wrap that symbolic reference as an UnknownSyntax. This has the same

    // RawSyntax layout but with the Unknown Kind.

    auto UnknownSymbolicRefData = UnknownSyntaxData::make(SymbolicRef.getRaw());



    auto Unknown = UnknownSyntax {

      UnknownSymbolicRefData,

      UnknownSymbolicRefData.get()

    };



    // Print the unknown syntax. It should also print as ""Array<Int>"".

    SmallString<48> UnknownScratch;

    llvm::raw_svector_ostream UnknownOS(UnknownScratch);

    Unknown.print(UnknownOS);



    ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());

  }

}

","TEST(UnknownSyntaxTests, UnknownSyntaxMakeAPIs) {

  {

    auto SymbolicRef = getCannedSymbolicRef();



    // Print the known symbolic reference. It should print as ""Array<Int>"".

    SmallString<48> KnownScratch;

    llvm::raw_svector_ostream KnownOS(KnownScratch);

    SymbolicRef.print(KnownOS);

    ASSERT_EQ(KnownOS.str().str(), ""Array<Int>"");



    // Wrap that symbolic reference as an UnknownSyntax. This has the same

    // RawSyntax layout but with the Unknown Kind.

    auto UnknownSymbolicRefData = UnknownSyntaxData::make(SymbolicRef.getRaw());



    auto Unknown = UnknownSyntax {

      UnknownSymbolicRefData,

      UnknownSymbolicRefData.get()

    };



    // Print the unknown syntax. It should also print as ""Array<Int>"".

    SmallString<48> UnknownScratch;

    llvm::raw_svector_ostream UnknownOS(UnknownScratch);

   ","


    ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());

  }

}

"
"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,"ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());","TEST(UnknownSyntaxTests, UnknownSyntaxMakeAPIs) {

  {

    auto SymbolicRef = getCannedSymbolicRef();



    // Print the known symbolic reference. It should print as ""Array<Int>"".

    SmallString<48> KnownScratch;

    llvm::raw_svector_ostream KnownOS(KnownScratch);

    SymbolicRef.print(KnownOS);

    ASSERT_EQ(KnownOS.str().str(), ""Array<Int>"");



    // Wrap that symbolic reference as an UnknownSyntax. This has the same

    // RawSyntax layout but with the Unknown Kind.

    auto UnknownSymbolicRefData = UnknownSyntaxData::make(SymbolicRef.getRaw());



    auto Unknown = UnknownSyntax {

      UnknownSymbolicRefData,

      UnknownSymbolicRefData.get()

    };



    // Print the unknown syntax. It should also print as ""Array<Int>"".

    SmallString<48> UnknownScratch;

    llvm::raw_svector_ostream UnknownOS(UnknownScratch);

    Unknown.print(UnknownOS);



    ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());

  }

}

","TEST(UnknownSyntaxTests, UnknownSyntaxMakeAPIs) {

  {

    auto SymbolicRef = getCannedSymbolicRef();



    // Print the known symbolic reference. It should print as ""Array<Int>"".

    SmallString<48> KnownScratch;

    llvm::raw_svector_ostream KnownOS(KnownScratch);

    SymbolicRef.print(KnownOS);

    ASSERT_EQ(KnownOS.str().str(), ""Array<Int>"");



    // Wrap that symbolic reference as an UnknownSyntax. This has the same

    // RawSyntax layout but with the Unknown Kind.

    auto UnknownSymbolicRefData = UnknownSyntaxData::make(SymbolicRef.getRaw());



    auto Unknown = UnknownSyntax {

      UnknownSymbolicRefData,

      UnknownSymbolicRefData.get()

    };



    // Print the unknown syntax. It should also print as ""Array<Int>"".

    SmallString<48> UnknownScratch;

    llvm::raw_svector_ostream UnknownOS(UnknownScratch);

    Unknown.print(UnknownOS);



   ","
  }

}

"
"[semantic-sil] Pass the uncasted argument as an @owned arg in the failed checked_cast_br cast.

Previously, we would put a destroy_value directly on the value that we tried to
cast. Since checked_cast_br is consuming, this would cause the destroy_value on
the failure path to be flagged as a double consume.

This commit causes SILGen to emit the value consumed by checked_cast_br as an
@owned argument to the failure BB, allowing semantic arc rules to be respected.

As an additional benefit, I also upgraded the ownership_model_eliminator test to
use semantic sil verification.

One issue that did come up though is that I was unable to use the new code in
all locations in the compiler. Specifically, there is one location in
SILGenPattern that uses argument unforwarding. I am going to need to undo
argument unforwarding in SILGenPattern in order to completely eliminate the old
code path.",lib/SILGen/SILGenDynamicCast.cpp,+,assert(operand.getType().isAddress());,"    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

        assert(operand.getType().isAddress());

        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

","    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

       ","
        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

"
"[semantic-sil] Pass the uncasted argument as an @owned arg in the failed checked_cast_br cast.

Previously, we would put a destroy_value directly on the value that we tried to
cast. Since checked_cast_br is consuming, this would cause the destroy_value on
the failure path to be flagged as a double consume.

This commit causes SILGen to emit the value consumed by checked_cast_br as an
@owned argument to the failure BB, allowing semantic arc rules to be respected.

As an additional benefit, I also upgraded the ownership_model_eliminator test to
use semantic sil verification.

One issue that did come up though is that I was unable to use the new code in
all locations in the compiler. Specifically, there is one location in
SILGenPattern that uses argument unforwarding. I am going to need to undo
argument unforwarding in SILGenPattern in order to completely eliminate the old
code path.",lib/SILGen/SILGenDynamicCast.cpp,+,"assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");","    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

        assert(operand.getType().isAddress());

        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

","    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

        assert(operand.getType().isAddress());

        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

       ","
      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

"
"[semantic-sil] Pass the uncasted argument as an @owned arg in the failed checked_cast_br cast.

Previously, we would put a destroy_value directly on the value that we tried to
cast. Since checked_cast_br is consuming, this would cause the destroy_value on
the failure path to be flagged as a double consume.

This commit causes SILGen to emit the value consumed by checked_cast_br as an
@owned argument to the failure BB, allowing semantic arc rules to be respected.

As an additional benefit, I also upgraded the ownership_model_eliminator test to
use semantic sil verification.

One issue that did come up though is that I was unable to use the new code in
all locations in the compiler. Specifically, there is one location in
SILGenPattern that uses argument unforwarding. I am going to need to undo
argument unforwarding in SILGenPattern in order to completely eliminate the old
code path.",lib/SILGen/SILGenDynamicCast.cpp,+,assert(!SGF.B.hasValidInsertionPoint() &&,"    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

        assert(operand.getType().isAddress());

        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

","    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

        assert(operand.getType().isAddress());

        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

       ","
      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

"
"[semantic-sil] Pass the uncasted argument as an @owned arg in the failed checked_cast_br cast.

Previously, we would put a destroy_value directly on the value that we tried to
cast. Since checked_cast_br is consuming, this would cause the destroy_value on
the failure path to be flagged as a double consume.

This commit causes SILGen to emit the value consumed by checked_cast_br as an
@owned argument to the failure BB, allowing semantic arc rules to be respected.

As an additional benefit, I also upgraded the ownership_model_eliminator test to
use semantic sil verification.

One issue that did come up though is that I was unable to use the new code in
all locations in the compiler. Specifically, there is one location in
SILGenPattern that uses argument unforwarding. I am going to need to undo
argument unforwarding in SILGenPattern in order to completely eliminate the old
code path.",lib/SILGen/SILGenDynamicCast.cpp,+,assert(!SGF.B.hasValidInsertionPoint() &&,"    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

        assert(operand.getType().isAddress());

        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

","    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

        assert(operand.getType().isAddress());

        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

       ","
      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

"
"[semantic-sil] Pass the uncasted argument as an @owned arg in the failed checked_cast_br cast.

Previously, we would put a destroy_value directly on the value that we tried to
cast. Since checked_cast_br is consuming, this would cause the destroy_value on
the failure path to be flagged as a double consume.

This commit causes SILGen to emit the value consumed by checked_cast_br as an
@owned argument to the failure BB, allowing semantic arc rules to be respected.

As an additional benefit, I also upgraded the ownership_model_eliminator test to
use semantic sil verification.

One issue that did come up though is that I was unable to use the new code in
all locations in the compiler. Specifically, there is one location in
SILGenPattern that uses argument unforwarding. I am going to need to undo
argument unforwarding in SILGenPattern in order to completely eliminate the old
code path.",lib/SILGen/SILGenDynamicCast.cpp,+,"assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");","    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

        assert(operand.getType().isAddress());

        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

","    void emitConditional(

        ManagedValue operand, CastConsumptionKind consumption, SGFContext ctx,

        const std::function<void(ManagedValue)> &handleTrue,

        const std::function<void(Optional<ManagedValue>)> &handleFalse) {

      // The cast instructions don't know how to work with anything

      // but the most general possible abstraction level.

      AbstractionPattern abstraction =

          SGF.SGM.Types.getMostGeneralAbstraction();

      auto &origTargetTL = SGF.getTypeLowering(abstraction, TargetType);

      auto &substTargetTL = SGF.getTypeLowering(TargetType);

      bool hasAbstraction =

          (origTargetTL.getLoweredType() != substTargetTL.getLoweredType());



      SILBasicBlock *falseBB = SGF.B.splitBlockForFallthrough();

      SILBasicBlock *trueBB = SGF.B.splitBlockForFallthrough();



      // Emit the branch.

      ManagedValue scalarOperandValue;

      SILValue resultBuffer;

      if (Strategy == CastStrategy::Address) {

        assert(operand.getType().isAddress());

        resultBuffer =

            createAbstractResultBuffer(hasAbstraction, origTargetTL, ctx);

        SGF.B.createCheckedCastAddrBranch(

            Loc, consumption, operand.forward(SGF), SourceType, resultBuffer,

            TargetType, trueBB, falseBB);

      } else {

        // Tolerate being passed an address here.  It comes up during switch

        // emission.

        scalarOperandValue = std::move(operand);

        if (scalarOperandValue.getType().isAddress()) {

          scalarOperandValue = SGF.B.createLoadTake(Loc, scalarOperandValue);

        }

        SGF.B.createCheckedCastBranch(Loc, /*exact*/ false, scalarOperandValue,

                                      origTargetTL.getLoweredType(), trueBB,

                                      falseBB);

      }



      // Emit the success block.

      SGF.B.setInsertionPoint(trueBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        ManagedValue result;

        if (Strategy == CastStrategy::Address) {

          result = finishFromResultBuffer(hasAbstraction, resultBuffer,

                                          abstraction, origTargetTL, ctx);

        } else {

          ManagedValue argument =

              SGF.B.createOwnedPHIArgument(origTargetTL.getLoweredType());

          result = finishFromResultScalar(hasAbstraction, argument, consumption,

                                          abstraction, origTargetTL, ctx);

        }



        handleTrue(result);

       ","
      }



      // Emit the failure block.

      SGF.B.setInsertionPoint(falseBB);

      {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(Loc));



        // If we have an address only type, do not handle the consumption

        // rules. These are handled for us by the user.

        if (Strategy == CastStrategy::Address) {

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        // Otherwise, we use the following strategy:

        //

        // 1. If we have a take_always, we create a phi node argument for the

        // failure case and a scope for that so that it is immediately

        // destroyed.

        //

        // 2. If we have a take_on_success or copy_on_success, then on failure,

        // we propagate through the default argument, but do not clean it up. On

        // the false case, our user must treat the taken value as a new value.

        if (shouldDestroyOnFailure(consumption)) {

          {

            FullExpr argScope(SGF.Cleanups, CleanupLocation::get(Loc));

            SGF.B.createOwnedPHIArgument(scalarOperandValue.getType());

          }

          handleFalse(None);

          assert(!SGF.B.hasValidInsertionPoint() &&

                 ""handler did not end block"");

          return;

        }



        handleFalse(SGF.B.createOwnedPHIArgument(scalarOperandValue.getType()));

        assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");

      }

    }

"
Improve how DeclContext chains are printed in AST dumps. (#7786),lib/AST/ASTDumper.cpp,-,"static void printName(raw_ostream &os, Identifier name) {","static void printName(raw_ostream &os, DeclName name) {

  if (!name)

    os << ""<anonymous>"";

  else

    os << name;

}

",,"
  if (!name)

    os << ""<anonymous>"";

  else

    os << name;

}


"
Improve how DeclContext chains are printed in AST dumps. (#7786),lib/AST/ASTDumper.cpp,+,"static void printName(raw_ostream &os, DeclName name) {","static void printName(raw_ostream &os, DeclName name) {

  if (!name)

    os << ""<anonymous>"";

  else

    os << name;

}

","static void printName(raw_ostream &os, DeclName name) {

  if (!name)

    os << ""<anonymous>"";

  else

    os << name;

}
","
  if (!name)

    os << ""<anonymous>"";

  else

    os << name;

}

"
"Merge pull request #7798 from slavapestov/spring-cleaning

Spring cleaning",lib/SILGen/SILGenMaterializeForSet.cpp,-,assert(selfTuple->getNumElements() == 1);,"  LValue buildSelfLValue(SILGenFunction &gen, SILLocation loc,

                         ManagedValue self) {

    // All of the complexity here is tied up with class types.  If the

    // substituted type isn't a reference type, then we can't have a

    // class-bounded protocol or inheritance, and the simple case just

    // works.

    AbstractionPattern selfPattern(SubstSelfType);



    // Metatypes and bases of non-mutating setters on value types

    //  are always rvalues.

    if (!SubstSelfType->getRValueInstanceType()->mayHaveSuperclass()) {

      if (self.getType().isObject())

        return LValue::forValue(self, SubstSelfType);

      else {

        if (!self.isLValue())

          self = ManagedValue::forLValue(self.getValue());

        return LValue::forAddress(self, selfPattern, SubstSelfType);

      }

    }



    CanType witnessSelfType =

      Witness->computeInterfaceSelfType()->getCanonicalType();

    witnessSelfType = getSubstWitnessInterfaceType(witnessSelfType);

    witnessSelfType = witnessSelfType->getInOutObjectType()

      ->getCanonicalType();



    // Eagerly loading here could cause an unnecessary

    // load+materialize in some cases, but it's not really important.

    SILValue selfValue = self.getValue();

    if (selfValue->getType().isAddress()) {

      // SEMANTIC ARC TODO: We are returning self as a borrowed value. Is this

      // correct?

      selfValue = gen.B.createLoadBorrow(loc, selfValue);

    }



    // Do a derived-to-base conversion if necessary.

    if (witnessSelfType != SubstSelfType) {

      auto selfSILType = gen.getLoweredType(witnessSelfType);

      selfValue = gen.B.createUpcast(loc, selfValue, selfSILType);

    }



    // Recreate as a borrowed value.

    self = ManagedValue::forUnmanaged(selfValue);

    return LValue::forValue(self, witnessSelfType);

  }

","  LValue buildSelfLValue(SILGenFunction &gen, SILLocation loc,

                         ManagedValue self) {

    // All of the complexity here is tied up with class types.  If the

    // substituted type isn't a reference type, then we can't have a

    // class-bounded protocol or inheritance, and the simple case just

    // works.

    AbstractionPattern selfPattern(SubstSelfType);



    // Metatypes and bases of non-mutating setters on value types

    //  are always rvalues.

    if (!SubstSelfType->getRValueInstanceType()->mayHaveSuperclass()) {

      if (self.getType().isObject())

","
      else {

        if (!self.isLValue())

          self = ManagedValue::forLValue(self.getValue());

        return LValue::forAddress(self, selfPattern, SubstSelfType);

      }

    }



    CanType witnessSelfType =

      Witness->computeInterfaceSelfType()->getCanonicalType();

    witnessSelfType = getSubstWitnessInterfaceType(witnessSelfType);

    witnessSelfType = witnessSelfType->getInOutObjectType()

      ->getCanonicalType();



    // Eagerly loading here could cause an unnecessary

    // load+materialize in some cases, but it's not really important.

    SILValue selfValue = self.getValue();

    if (selfValue->getType().isAddress()) {

      // SEMANTIC ARC TODO: We are returning self as a borrowed value. Is this

      // correct?

      selfValue = gen.B.createLoadBorrow(loc, selfValue);

    }



    // Do a derived-to-base conversion if necessary.

    if (witnessSelfType != SubstSelfType) {

      auto selfSILType = gen.getLoweredType(witnessSelfType);

      selfValue = gen.B.createUpcast(loc, selfValue, selfSILType);

    }



    // Recreate as a borrowed value.

    self = ManagedValue::forUnmanaged(selfValue);

    return LValue::forValue(self, witnessSelfType);

  }


"
"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(Ref.getIdentifier(), Array);","TEST(ExprSyntaxTests, SymbolicReferenceExprGetAPIs) {

  {

    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto IntType = SyntaxFactory::makeTypeIdentifier(""Int"", {}, {});

    GenericArgumentClauseBuilder ArgBuilder;

    ArgBuilder

      .useLeftAngleBracket(SyntaxFactory::makeLeftAngleToken({}, {}))

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(llvm::None, IntType);



    auto GenericArgs = ArgBuilder.build();



    auto Ref = SyntaxFactory::makeSymbolicReferenceExpr(Array, GenericArgs);



    ASSERT_EQ(Ref.getIdentifier(), Array);



    auto GottenArgs = Ref.getGenericArgumentClause().getValue();

    auto GottenArgs2 = Ref.getGenericArgumentClause().getValue();

    ASSERT_TRUE(GottenArgs.hasSameIdentityAs(GottenArgs2));



    {

      llvm::SmallString<48> Scratch;

      llvm::raw_svector_ostream OS(Scratch);

      GottenArgs.print(OS);

      ASSERT_EQ(OS.str().str(), ""<Int>"");

    }

  }

}

","TEST(ExprSyntaxTests, SymbolicReferenceExprGetAPIs) {

  {

    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto IntType = SyntaxFactory::makeTypeIdentifier(""Int"", {}, {});

    GenericArgumentClauseBuilder ArgBuilder;

    ArgBuilder

      .useLeftAngleBracket(SyntaxFactory::makeLeftAngleToken({}, {}))

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(llvm::None, IntType);



    auto GenericArgs = ArgBuilder.build();



    auto Ref = SyntaxFactory::makeSymbolicReferenceExpr(Array, GenericArgs);



   ","


    auto GottenArgs = Ref.getGenericArgumentClause().getValue();

    auto GottenArgs2 = Ref.getGenericArgumentClause().getValue();

    ASSERT_TRUE(GottenArgs.hasSameIdentityAs(GottenArgs2));



    {

      llvm::SmallString<48> Scratch;

      llvm::raw_svector_ostream OS(Scratch);

      GottenArgs.print(OS);

      ASSERT_EQ(OS.str().str(), ""<Int>"");

    }

  }

}

"
"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,ASSERT_TRUE(GottenArgs.hasSameIdentityAs(GottenArgs2));,"TEST(ExprSyntaxTests, SymbolicReferenceExprGetAPIs) {

  {

    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto IntType = SyntaxFactory::makeTypeIdentifier(""Int"", {}, {});

    GenericArgumentClauseBuilder ArgBuilder;

    ArgBuilder

      .useLeftAngleBracket(SyntaxFactory::makeLeftAngleToken({}, {}))

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(llvm::None, IntType);



    auto GenericArgs = ArgBuilder.build();



    auto Ref = SyntaxFactory::makeSymbolicReferenceExpr(Array, GenericArgs);



    ASSERT_EQ(Ref.getIdentifier(), Array);



    auto GottenArgs = Ref.getGenericArgumentClause().getValue();

    auto GottenArgs2 = Ref.getGenericArgumentClause().getValue();

    ASSERT_TRUE(GottenArgs.hasSameIdentityAs(GottenArgs2));



    {

      llvm::SmallString<48> Scratch;

      llvm::raw_svector_ostream OS(Scratch);

      GottenArgs.print(OS);

      ASSERT_EQ(OS.str().str(), ""<Int>"");

    }

  }

}

","TEST(ExprSyntaxTests, SymbolicReferenceExprGetAPIs) {

  {

    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto IntType = SyntaxFactory::makeTypeIdentifier(""Int"", {}, {});

    GenericArgumentClauseBuilder ArgBuilder;

    ArgBuilder

      .useLeftAngleBracket(SyntaxFactory::makeLeftAngleToken({}, {}))

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(llvm::None, IntType);



    auto GenericArgs = ArgBuilder.build();



    auto Ref = SyntaxFactory::makeSymbolicReferenceExpr(Array, GenericArgs);



    ASSERT_EQ(Ref.getIdentifier(), Array);



    auto GottenArgs = Ref.getGenericArgumentClause().getValue();

    auto GottenArgs2 = Ref.getGenericArgumentClause().getValue();

   ","


    {

      llvm::SmallString<48> Scratch;

      llvm::raw_svector_ostream OS(Scratch);

      GottenArgs.print(OS);

      ASSERT_EQ(OS.str().str(), ""<Int>"");

    }

  }

}

"
"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,GottenArgs.print(OS);,"TEST(ExprSyntaxTests, SymbolicReferenceExprGetAPIs) {

  {

    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto IntType = SyntaxFactory::makeTypeIdentifier(""Int"", {}, {});

    GenericArgumentClauseBuilder ArgBuilder;

    ArgBuilder

      .useLeftAngleBracket(SyntaxFactory::makeLeftAngleToken({}, {}))

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(llvm::None, IntType);



    auto GenericArgs = ArgBuilder.build();



    auto Ref = SyntaxFactory::makeSymbolicReferenceExpr(Array, GenericArgs);



    ASSERT_EQ(Ref.getIdentifier(), Array);



    auto GottenArgs = Ref.getGenericArgumentClause().getValue();

    auto GottenArgs2 = Ref.getGenericArgumentClause().getValue();

    ASSERT_TRUE(GottenArgs.hasSameIdentityAs(GottenArgs2));



    {

      llvm::SmallString<48> Scratch;

      llvm::raw_svector_ostream OS(Scratch);

      GottenArgs.print(OS);

      ASSERT_EQ(OS.str().str(), ""<Int>"");

    }

  }

}

","TEST(ExprSyntaxTests, SymbolicReferenceExprGetAPIs) {

  {

    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto IntType = SyntaxFactory::makeTypeIdentifier(""Int"", {}, {});

    GenericArgumentClauseBuilder ArgBuilder;

    ArgBuilder

      .useLeftAngleBracket(SyntaxFactory::makeLeftAngleToken({}, {}))

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(llvm::None, IntType);



    auto GenericArgs = ArgBuilder.build();



    auto Ref = SyntaxFactory::makeSymbolicReferenceExpr(Array, GenericArgs);



    ASSERT_EQ(Ref.getIdentifier(), Array);



    auto GottenArgs = Ref.getGenericArgumentClause().getValue();

    auto GottenArgs2 = Ref.getGenericArgumentClause().getValue();

    ASSERT_TRUE(GottenArgs.hasSameIdentityAs(GottenArgs2));



    {

      llvm::SmallString<48> Scratch;

      llvm::raw_svector_ostream OS(Scratch);

     ","
      ASSERT_EQ(OS.str().str(), ""<Int>"");

    }

  }

}

"
"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""<Int>"");","TEST(ExprSyntaxTests, SymbolicReferenceExprGetAPIs) {

  {

    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto IntType = SyntaxFactory::makeTypeIdentifier(""Int"", {}, {});

    GenericArgumentClauseBuilder ArgBuilder;

    ArgBuilder

      .useLeftAngleBracket(SyntaxFactory::makeLeftAngleToken({}, {}))

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(llvm::None, IntType);



    auto GenericArgs = ArgBuilder.build();



    auto Ref = SyntaxFactory::makeSymbolicReferenceExpr(Array, GenericArgs);



    ASSERT_EQ(Ref.getIdentifier(), Array);



    auto GottenArgs = Ref.getGenericArgumentClause().getValue();

    auto GottenArgs2 = Ref.getGenericArgumentClause().getValue();

    ASSERT_TRUE(GottenArgs.hasSameIdentityAs(GottenArgs2));



    {

      llvm::SmallString<48> Scratch;

      llvm::raw_svector_ostream OS(Scratch);

      GottenArgs.print(OS);

      ASSERT_EQ(OS.str().str(), ""<Int>"");

    }

  }

}

","TEST(ExprSyntaxTests, SymbolicReferenceExprGetAPIs) {

  {

    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto IntType = SyntaxFactory::makeTypeIdentifier(""Int"", {}, {});

    GenericArgumentClauseBuilder ArgBuilder;

    ArgBuilder

      .useLeftAngleBracket(SyntaxFactory::makeLeftAngleToken({}, {}))

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(llvm::None, IntType);



    auto GenericArgs = ArgBuilder.build();



    auto Ref = SyntaxFactory::makeSymbolicReferenceExpr(Array, GenericArgs);



    ASSERT_EQ(Ref.getIdentifier(), Array);



    auto GottenArgs = Ref.getGenericArgumentClause().getValue();

    auto GottenArgs2 = Ref.getGenericArgumentClause().getValue();

    ASSERT_TRUE(GottenArgs.hasSameIdentityAs(GottenArgs2));



    {

      llvm::SmallString<48> Scratch;

      llvm::raw_svector_ostream OS(Scratch);

      GottenArgs.print(OS);

     ","
    }

  }

}

"
SILGen: Remove sillyness from materializeForSet emission,lib/SILGen/SILGenMaterializeForSet.cpp,-,assert(selfTuple->getNumElements() == 1);,"  LValue buildSelfLValue(SILGenFunction &gen, SILLocation loc,

                         ManagedValue self) {

    // All of the complexity here is tied up with class types.  If the

    // substituted type isn't a reference type, then we can't have a

    // class-bounded protocol or inheritance, and the simple case just

    // works.

    AbstractionPattern selfPattern(SubstSelfType);



    // Metatypes and bases of non-mutating setters on value types

    //  are always rvalues.

    if (!SubstSelfType->getRValueInstanceType()->mayHaveSuperclass()) {

      if (self.getType().isObject())

        return LValue::forValue(self, SubstSelfType);

      else {

        if (!self.isLValue())

          self = ManagedValue::forLValue(self.getValue());

        return LValue::forAddress(self, selfPattern, SubstSelfType);

      }

    }



    CanType witnessSelfType =

      Witness->computeInterfaceSelfType()->getCanonicalType();

    witnessSelfType = getSubstWitnessInterfaceType(witnessSelfType);

    witnessSelfType = witnessSelfType->getInOutObjectType()

      ->getCanonicalType();



    // Eagerly loading here could cause an unnecessary

    // load+materialize in some cases, but it's not really important.

    SILValue selfValue = self.getValue();

    if (selfValue->getType().isAddress()) {

      // SEMANTIC ARC TODO: We are returning self as a borrowed value. Is this

      // correct?

      selfValue = gen.B.createLoadBorrow(loc, selfValue);

    }



    // Do a derived-to-base conversion if necessary.

    if (witnessSelfType != SubstSelfType) {

      auto selfSILType = gen.getLoweredType(witnessSelfType);

      selfValue = gen.B.createUpcast(loc, selfValue, selfSILType);

    }



    // Recreate as a borrowed value.

    self = ManagedValue::forUnmanaged(selfValue);

    return LValue::forValue(self, witnessSelfType);

  }

","  LValue buildSelfLValue(SILGenFunction &gen, SILLocation loc,

                         ManagedValue self) {

    // All of the complexity here is tied up with class types.  If the

    // substituted type isn't a reference type, then we can't have a

    // class-bounded protocol or inheritance, and the simple case just

    // works.

    AbstractionPattern selfPattern(SubstSelfType);



    // Metatypes and bases of non-mutating setters on value types

    //  are always rvalues.

    if (!SubstSelfType->getRValueInstanceType()->mayHaveSuperclass()) {

      if (self.getType().isObject())

","
      else {

        if (!self.isLValue())

          self = ManagedValue::forLValue(self.getValue());

        return LValue::forAddress(self, selfPattern, SubstSelfType);

      }

    }



    CanType witnessSelfType =

      Witness->computeInterfaceSelfType()->getCanonicalType();

    witnessSelfType = getSubstWitnessInterfaceType(witnessSelfType);

    witnessSelfType = witnessSelfType->getInOutObjectType()

      ->getCanonicalType();



    // Eagerly loading here could cause an unnecessary

    // load+materialize in some cases, but it's not really important.

    SILValue selfValue = self.getValue();

    if (selfValue->getType().isAddress()) {

      // SEMANTIC ARC TODO: We are returning self as a borrowed value. Is this

      // correct?

      selfValue = gen.B.createLoadBorrow(loc, selfValue);

    }



    // Do a derived-to-base conversion if necessary.

    if (witnessSelfType != SubstSelfType) {

      auto selfSILType = gen.getLoweredType(witnessSelfType);

      selfValue = gen.B.createUpcast(loc, selfValue, selfSILType);

    }



    // Recreate as a borrowed value.

    self = ManagedValue::forUnmanaged(selfValue);

    return LValue::forValue(self, witnessSelfType);

  }


"
"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(Ref.getIdentifier(), Array);","TEST(ExprSyntaxTests, SymbolicReferenceExprGetAPIs) {

  {

    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto IntType = SyntaxFactory::makeTypeIdentifier(""Int"", {}, {});

    GenericArgumentClauseBuilder ArgBuilder;

    ArgBuilder

      .useLeftAngleBracket(SyntaxFactory::makeLeftAngleToken({}, {}))

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(llvm::None, IntType);



    auto GenericArgs = ArgBuilder.build();



    auto Ref = SyntaxFactory::makeSymbolicReferenceExpr(Array, GenericArgs);



    ASSERT_EQ(Ref.getIdentifier(), Array);



    auto GottenArgs = Ref.getGenericArgumentClause().getValue();

    auto GottenArgs2 = Ref.getGenericArgumentClause().getValue();

    ASSERT_TRUE(GottenArgs.hasSameIdentityAs(GottenArgs2));



    {

      llvm::SmallString<48> Scratch;

      llvm::raw_svector_ostream OS(Scratch);

      GottenArgs.print(OS);

      ASSERT_EQ(OS.str().str(), ""<Int>"");

    }

  }

}

","TEST(ExprSyntaxTests, SymbolicReferenceExprGetAPIs) {

  {

    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto IntType = SyntaxFactory::makeTypeIdentifier(""Int"", {}, {});

    GenericArgumentClauseBuilder ArgBuilder;

    ArgBuilder

      .useLeftAngleBracket(SyntaxFactory::makeLeftAngleToken({}, {}))

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(llvm::None, IntType);



    auto GenericArgs = ArgBuilder.build();



    auto Ref = SyntaxFactory::makeSymbolicReferenceExpr(Array, GenericArgs);



   ","


    auto GottenArgs = Ref.getGenericArgumentClause().getValue();

    auto GottenArgs2 = Ref.getGenericArgumentClause().getValue();

    ASSERT_TRUE(GottenArgs.hasSameIdentityAs(GottenArgs2));



    {

      llvm::SmallString<48> Scratch;

      llvm::raw_svector_ostream OS(Scratch);

      GottenArgs.print(OS);

      ASSERT_EQ(OS.str().str(), ""<Int>"");

    }

  }

}

"
"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,ASSERT_TRUE(GottenArgs.hasSameIdentityAs(GottenArgs2));,"TEST(ExprSyntaxTests, SymbolicReferenceExprGetAPIs) {

  {

    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto IntType = SyntaxFactory::makeTypeIdentifier(""Int"", {}, {});

    GenericArgumentClauseBuilder ArgBuilder;

    ArgBuilder

      .useLeftAngleBracket(SyntaxFactory::makeLeftAngleToken({}, {}))

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(llvm::None, IntType);



    auto GenericArgs = ArgBuilder.build();



    auto Ref = SyntaxFactory::makeSymbolicReferenceExpr(Array, GenericArgs);



    ASSERT_EQ(Ref.getIdentifier(), Array);



    auto GottenArgs = Ref.getGenericArgumentClause().getValue();

    auto GottenArgs2 = Ref.getGenericArgumentClause().getValue();

    ASSERT_TRUE(GottenArgs.hasSameIdentityAs(GottenArgs2));



    {

      llvm::SmallString<48> Scratch;

      llvm::raw_svector_ostream OS(Scratch);

      GottenArgs.print(OS);

      ASSERT_EQ(OS.str().str(), ""<Int>"");

    }

  }

}

","TEST(ExprSyntaxTests, SymbolicReferenceExprGetAPIs) {

  {

    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto IntType = SyntaxFactory::makeTypeIdentifier(""Int"", {}, {});

    GenericArgumentClauseBuilder ArgBuilder;

    ArgBuilder

      .useLeftAngleBracket(SyntaxFactory::makeLeftAngleToken({}, {}))

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(llvm::None, IntType);



    auto GenericArgs = ArgBuilder.build();



    auto Ref = SyntaxFactory::makeSymbolicReferenceExpr(Array, GenericArgs);



    ASSERT_EQ(Ref.getIdentifier(), Array);



    auto GottenArgs = Ref.getGenericArgumentClause().getValue();

    auto GottenArgs2 = Ref.getGenericArgumentClause().getValue();

   ","


    {

      llvm::SmallString<48> Scratch;

      llvm::raw_svector_ostream OS(Scratch);

      GottenArgs.print(OS);

      ASSERT_EQ(OS.str().str(), ""<Int>"");

    }

  }

}

"
"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,GottenArgs.print(OS);,"TEST(ExprSyntaxTests, SymbolicReferenceExprGetAPIs) {

  {

    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto IntType = SyntaxFactory::makeTypeIdentifier(""Int"", {}, {});

    GenericArgumentClauseBuilder ArgBuilder;

    ArgBuilder

      .useLeftAngleBracket(SyntaxFactory::makeLeftAngleToken({}, {}))

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(llvm::None, IntType);



    auto GenericArgs = ArgBuilder.build();



    auto Ref = SyntaxFactory::makeSymbolicReferenceExpr(Array, GenericArgs);



    ASSERT_EQ(Ref.getIdentifier(), Array);



    auto GottenArgs = Ref.getGenericArgumentClause().getValue();

    auto GottenArgs2 = Ref.getGenericArgumentClause().getValue();

    ASSERT_TRUE(GottenArgs.hasSameIdentityAs(GottenArgs2));



    {

      llvm::SmallString<48> Scratch;

      llvm::raw_svector_ostream OS(Scratch);

      GottenArgs.print(OS);

      ASSERT_EQ(OS.str().str(), ""<Int>"");

    }

  }

}

","TEST(ExprSyntaxTests, SymbolicReferenceExprGetAPIs) {

  {

    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto IntType = SyntaxFactory::makeTypeIdentifier(""Int"", {}, {});

    GenericArgumentClauseBuilder ArgBuilder;

    ArgBuilder

      .useLeftAngleBracket(SyntaxFactory::makeLeftAngleToken({}, {}))

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(llvm::None, IntType);



    auto GenericArgs = ArgBuilder.build();



    auto Ref = SyntaxFactory::makeSymbolicReferenceExpr(Array, GenericArgs);



    ASSERT_EQ(Ref.getIdentifier(), Array);



    auto GottenArgs = Ref.getGenericArgumentClause().getValue();

    auto GottenArgs2 = Ref.getGenericArgumentClause().getValue();

    ASSERT_TRUE(GottenArgs.hasSameIdentityAs(GottenArgs2));



    {

      llvm::SmallString<48> Scratch;

      llvm::raw_svector_ostream OS(Scratch);

     ","
      ASSERT_EQ(OS.str().str(), ""<Int>"");

    }

  }

}

"
"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""<Int>"");","TEST(ExprSyntaxTests, SymbolicReferenceExprGetAPIs) {

  {

    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto IntType = SyntaxFactory::makeTypeIdentifier(""Int"", {}, {});

    GenericArgumentClauseBuilder ArgBuilder;

    ArgBuilder

      .useLeftAngleBracket(SyntaxFactory::makeLeftAngleToken({}, {}))

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(llvm::None, IntType);



    auto GenericArgs = ArgBuilder.build();



    auto Ref = SyntaxFactory::makeSymbolicReferenceExpr(Array, GenericArgs);



    ASSERT_EQ(Ref.getIdentifier(), Array);



    auto GottenArgs = Ref.getGenericArgumentClause().getValue();

    auto GottenArgs2 = Ref.getGenericArgumentClause().getValue();

    ASSERT_TRUE(GottenArgs.hasSameIdentityAs(GottenArgs2));



    {

      llvm::SmallString<48> Scratch;

      llvm::raw_svector_ostream OS(Scratch);

      GottenArgs.print(OS);

      ASSERT_EQ(OS.str().str(), ""<Int>"");

    }

  }

}

","TEST(ExprSyntaxTests, SymbolicReferenceExprGetAPIs) {

  {

    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto IntType = SyntaxFactory::makeTypeIdentifier(""Int"", {}, {});

    GenericArgumentClauseBuilder ArgBuilder;

    ArgBuilder

      .useLeftAngleBracket(SyntaxFactory::makeLeftAngleToken({}, {}))

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(llvm::None, IntType);



    auto GenericArgs = ArgBuilder.build();



    auto Ref = SyntaxFactory::makeSymbolicReferenceExpr(Array, GenericArgs);



    ASSERT_EQ(Ref.getIdentifier(), Array);



    auto GottenArgs = Ref.getGenericArgumentClause().getValue();

    auto GottenArgs2 = Ref.getGenericArgumentClause().getValue();

    ASSERT_TRUE(GottenArgs.hasSameIdentityAs(GottenArgs2));



    {

      llvm::SmallString<48> Scratch;

      llvm::raw_svector_ostream OS(Scratch);

      GottenArgs.print(OS);

     ","
    }

  }

}

"
Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"assert(hashIter != valueHashMap.end() && ""Missing SILValue"");","  ValueStorage &getStorage(SILValue value) {

    auto hashIter = valueHashMap.find(value);

    assert(hashIter != valueHashMap.end() && ""Missing SILValue"");

    return valueVector[hashIter->second].second;

  }

","  ValueStorage &getStorage(SILValue value) {

    auto hashIter = valueHashMap.find(value);

   ","
    return valueVector[hashIter->second].second;

  }

"
Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(onlyHaveDebugUses(inst));,"  void markDeadInst(SILInstruction *inst) {

#ifndef NDEBUG

    for (Operand *use : inst->getUses())

      assert(instsToDelete.count(use->getUser()));

#endif

    instsToDelete.insert(inst);

  }

","  void markDeadInst(SILInstruction *inst) {
","#ifndef NDEBUG

    for (Operand *use : inst->getUses())

      assert(instsToDelete.count(use->getUser()));

#endif

    instsToDelete.insert(inst);

  }


"
Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(instsToDelete.count(use->getUser()));,"  void markDeadInst(SILInstruction *inst) {

#ifndef NDEBUG

    for (Operand *use : inst->getUses())

      assert(instsToDelete.count(use->getUser()));

#endif

    instsToDelete.insert(inst);

  }

","  void markDeadInst(SILInstruction *inst) {

#ifndef NDEBUG

    for (Operand *use : inst->getUses())

     ","
#endif

    instsToDelete.insert(inst);

  }

"
"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"assert(hashIter != valueHashMap.end() && ""Missing SILValue"");","  ValueStorage &getStorage(SILValue value) {

    auto hashIter = valueHashMap.find(value);

    assert(hashIter != valueHashMap.end() && ""Missing SILValue"");

    return valueVector[hashIter->second].second;

  }

","  ValueStorage &getStorage(SILValue value) {

    auto hashIter = valueHashMap.find(value);

   ","
    return valueVector[hashIter->second].second;

  }

"
"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(onlyHaveDebugUses(inst));,"  void markDeadInst(SILInstruction *inst) {

#ifndef NDEBUG

    for (Operand *use : inst->getUses())

      assert(instsToDelete.count(use->getUser()));

#endif

    instsToDelete.insert(inst);

  }

","  void markDeadInst(SILInstruction *inst) {
","#ifndef NDEBUG

    for (Operand *use : inst->getUses())

      assert(instsToDelete.count(use->getUser()));

#endif

    instsToDelete.insert(inst);

  }


"
"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(instsToDelete.count(use->getUser()));,"  void markDeadInst(SILInstruction *inst) {

#ifndef NDEBUG

    for (Operand *use : inst->getUses())

      assert(instsToDelete.count(use->getUser()));

#endif

    instsToDelete.insert(inst);

  }

","  void markDeadInst(SILInstruction *inst) {

#ifndef NDEBUG

    for (Operand *use : inst->getUses())

     ","
#endif

    instsToDelete.insert(inst);

  }

"
"Merge pull request #7771 from jckarter/bogus-noescape-error

Sema: Don't raise bogus escape diagnostics about captures in closures with errors.",lib/Sema/TypeCheckCaptures.cpp,+,!AFR.getType()->hasError() &&,"  void addCapture(CapturedValue capture, SourceLoc Loc) {

    auto VD = capture.getDecl();



    // Check to see if we already have an entry for this decl.

    unsigned &entryNumber = captureEntryNumber[VD];

    if (entryNumber == 0) {

      Captures.push_back(capture);

      entryNumber = Captures.size();

    } else {

      // If this already had an entry in the capture list, make sure to merge

      // the information together.  If one is noescape but the other isn't,

      // then the result is escaping.

      unsigned Flags =

        Captures[entryNumber-1].getFlags() & capture.getFlags();

      capture = CapturedValue(VD, Flags);

      Captures[entryNumber-1] = capture;

    }



    // Visit the type of the capture, if it isn't a class reference, since

    // we'd need the metadata to do so.

    if (VD->hasInterfaceType()

        && (!AFR.isObjC()

            || !isa<VarDecl>(VD)

            || !cast<VarDecl>(VD)->getType()->hasRetainablePointerRepresentation()))

      checkType(VD->getInterfaceType(), VD->getLoc());



    // If VD is a noescape decl, then the closure we're computing this for

    // must also be noescape.

    if (AFR.hasType() &&

        !AFR.getType()->hasError() &&

        VD->hasInterfaceType() &&

        VD->getInterfaceType()->is<AnyFunctionType>() &&

        VD->getInterfaceType()->castTo<AnyFunctionType>()->isNoEscape() &&

        !capture.isNoEscape() &&

        // Don't repeatedly diagnose the same thing.

        Diagnosed.insert(VD).second) {



      // Otherwise, diagnose this as an invalid capture.

      bool isDecl = AFR.getAbstractFunctionDecl() != nullptr;



      TC.diagnose(Loc, isDecl ? diag::decl_closure_noescape_use

                              : diag::closure_noescape_use,

                  VD->getName());



      // If we're a parameter, emit a helpful fixit to add @escaping

      auto paramDecl = dyn_cast<ParamDecl>(VD);

      bool isAutoClosure =

          VD->getInterfaceType()->castTo<AnyFunctionType>()->isAutoClosure();

      if (paramDecl && !isAutoClosure) {

        TC.diagnose(paramDecl->getStartLoc(), diag::noescape_parameter,

                    paramDecl->getName())

            .fixItInsert(paramDecl->getTypeLoc().getSourceRange().Start,

                         ""@escaping "");

      } else if (isAutoClosure) {

        // TODO: add in a fixit for autoclosure

        TC.diagnose(VD->getLoc(), diag::noescape_autoclosure, VD->getName());

      }

    }

  }

","  void addCapture(CapturedValue capture, SourceLoc Loc) {

    auto VD = capture.getDecl();



    // Check to see if we already have an entry for this decl.

    unsigned &entryNumber = captureEntryNumber[VD];

    if (entryNumber == 0) {

      Captures.push_back(capture);

      entryNumber = Captures.size();

    } else {

      // If this already had an entry in the capture list, make sure to merge

      // the information together.  If one is noescape but the other isn't,

      // then the result is escaping.

      unsigned Flags =

        Captures[entryNumber-1].getFlags() & capture.getFlags();

      capture = CapturedValue(VD, Flags);

      Captures[entryNumber-1] = capture;

    }



    // Visit the type of the capture, if it isn't a class reference, since

    // we'd need the metadata to do so.

    if (VD->hasInterfaceType()

        && (!AFR.isObjC()

            || !isa<VarDecl>(VD)

            || !cast<VarDecl>(VD)->getType()->hasRetainablePointerRepresentation()))

      checkType(VD->getInterfaceType(), VD->getLoc());



    // If VD is a noescape decl, then the closure we're computing this for

    // must also be noescape.

    if (AFR.hasType() &&

       ","
        VD->hasInterfaceType() &&

        VD->getInterfaceType()->is<AnyFunctionType>() &&

        VD->getInterfaceType()->castTo<AnyFunctionType>()->isNoEscape() &&

        !capture.isNoEscape() &&

        // Don't repeatedly diagnose the same thing.

        Diagnosed.insert(VD).second) {



      // Otherwise, diagnose this as an invalid capture.

      bool isDecl = AFR.getAbstractFunctionDecl() != nullptr;



      TC.diagnose(Loc, isDecl ? diag::decl_closure_noescape_use

                              : diag::closure_noescape_use,

                  VD->getName());



      // If we're a parameter, emit a helpful fixit to add @escaping

      auto paramDecl = dyn_cast<ParamDecl>(VD);

      bool isAutoClosure =

          VD->getInterfaceType()->castTo<AnyFunctionType>()->isAutoClosure();

      if (paramDecl && !isAutoClosure) {

        TC.diagnose(paramDecl->getStartLoc(), diag::noescape_parameter,

                    paramDecl->getName())

            .fixItInsert(paramDecl->getTypeLoc().getSourceRange().Start,

                         ""@escaping "");

      } else if (isAutoClosure) {

        // TODO: add in a fixit for autoclosure

        TC.diagnose(VD->getLoc(), diag::noescape_autoclosure, VD->getName());

      }

    }

  }

"
Sema: Don't raise bogus escape diagnostics about captures in closures with errors.,lib/Sema/TypeCheckCaptures.cpp,+,!AFR.getType()->hasError() &&,"  void addCapture(CapturedValue capture, SourceLoc Loc) {

    auto VD = capture.getDecl();



    // Check to see if we already have an entry for this decl.

    unsigned &entryNumber = captureEntryNumber[VD];

    if (entryNumber == 0) {

      Captures.push_back(capture);

      entryNumber = Captures.size();

    } else {

      // If this already had an entry in the capture list, make sure to merge

      // the information together.  If one is noescape but the other isn't,

      // then the result is escaping.

      unsigned Flags =

        Captures[entryNumber-1].getFlags() & capture.getFlags();

      capture = CapturedValue(VD, Flags);

      Captures[entryNumber-1] = capture;

    }



    // Visit the type of the capture, if it isn't a class reference, since

    // we'd need the metadata to do so.

    if (VD->hasInterfaceType()

        && (!AFR.isObjC()

            || !isa<VarDecl>(VD)

            || !cast<VarDecl>(VD)->getType()->hasRetainablePointerRepresentation()))

      checkType(VD->getInterfaceType(), VD->getLoc());



    // If VD is a noescape decl, then the closure we're computing this for

    // must also be noescape.

    if (AFR.hasType() &&

        !AFR.getType()->hasError() &&

        VD->hasInterfaceType() &&

        VD->getInterfaceType()->is<AnyFunctionType>() &&

        VD->getInterfaceType()->castTo<AnyFunctionType>()->isNoEscape() &&

        !capture.isNoEscape() &&

        // Don't repeatedly diagnose the same thing.

        Diagnosed.insert(VD).second) {



      // Otherwise, diagnose this as an invalid capture.

      bool isDecl = AFR.getAbstractFunctionDecl() != nullptr;



      TC.diagnose(Loc, isDecl ? diag::decl_closure_noescape_use

                              : diag::closure_noescape_use,

                  VD->getName());



      // If we're a parameter, emit a helpful fixit to add @escaping

      auto paramDecl = dyn_cast<ParamDecl>(VD);

      bool isAutoClosure =

          VD->getInterfaceType()->castTo<AnyFunctionType>()->isAutoClosure();

      if (paramDecl && !isAutoClosure) {

        TC.diagnose(paramDecl->getStartLoc(), diag::noescape_parameter,

                    paramDecl->getName())

            .fixItInsert(paramDecl->getTypeLoc().getSourceRange().Start,

                         ""@escaping "");

      } else if (isAutoClosure) {

        // TODO: add in a fixit for autoclosure

        TC.diagnose(VD->getLoc(), diag::noescape_autoclosure, VD->getName());

      }

    }

  }

","  void addCapture(CapturedValue capture, SourceLoc Loc) {

    auto VD = capture.getDecl();



    // Check to see if we already have an entry for this decl.

    unsigned &entryNumber = captureEntryNumber[VD];

    if (entryNumber == 0) {

      Captures.push_back(capture);

      entryNumber = Captures.size();

    } else {

      // If this already had an entry in the capture list, make sure to merge

      // the information together.  If one is noescape but the other isn't,

      // then the result is escaping.

      unsigned Flags =

        Captures[entryNumber-1].getFlags() & capture.getFlags();

      capture = CapturedValue(VD, Flags);

      Captures[entryNumber-1] = capture;

    }



    // Visit the type of the capture, if it isn't a class reference, since

    // we'd need the metadata to do so.

    if (VD->hasInterfaceType()

        && (!AFR.isObjC()

            || !isa<VarDecl>(VD)

            || !cast<VarDecl>(VD)->getType()->hasRetainablePointerRepresentation()))

      checkType(VD->getInterfaceType(), VD->getLoc());



    // If VD is a noescape decl, then the closure we're computing this for

    // must also be noescape.

    if (AFR.hasType() &&

       ","
        VD->hasInterfaceType() &&

        VD->getInterfaceType()->is<AnyFunctionType>() &&

        VD->getInterfaceType()->castTo<AnyFunctionType>()->isNoEscape() &&

        !capture.isNoEscape() &&

        // Don't repeatedly diagnose the same thing.

        Diagnosed.insert(VD).second) {



      // Otherwise, diagnose this as an invalid capture.

      bool isDecl = AFR.getAbstractFunctionDecl() != nullptr;



      TC.diagnose(Loc, isDecl ? diag::decl_closure_noescape_use

                              : diag::closure_noescape_use,

                  VD->getName());



      // If we're a parameter, emit a helpful fixit to add @escaping

      auto paramDecl = dyn_cast<ParamDecl>(VD);

      bool isAutoClosure =

          VD->getInterfaceType()->castTo<AnyFunctionType>()->isAutoClosure();

      if (paramDecl && !isAutoClosure) {

        TC.diagnose(paramDecl->getStartLoc(), diag::noescape_parameter,

                    paramDecl->getName())

            .fixItInsert(paramDecl->getTypeLoc().getSourceRange().Start,

                         ""@escaping "");

      } else if (isAutoClosure) {

        // TODO: add in a fixit for autoclosure

        TC.diagnose(VD->getLoc(), diag::noescape_autoclosure, VD->getName());

      }

    }

  }

"
Merge pull request #7758 from eeckstein/bumpptr-allocation,lib/Basic/DemangleWrappers.cpp,-,"printNode(Out, child.get(), depth + 1);","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());
","  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}


"
Merge pull request #7758 from eeckstein/bumpptr-allocation,lib/Basic/DemangleWrappers.cpp,+,"printNode(Out, child, depth + 1);","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

   ","
  }

}

"
"Demangler: Use a bump-pointer allocator for node allocation.

This makes the demangler about 10 times faster.
It also changes the lifetimes of nodes. Previously nodes were reference-counted.
Now the returned demangle  node-tree is owned by the Demangler class and it’s lifetime ends with the lifetime of the Demangler.

Therefore the old (and already deprecated) global functions demangleSymbolAsNode and demangleTypeAsNode are no longer available.

Another change is that the demangling for reflection now only supports the new mangling (which should be no problem because
we are generating only new mangled names for reflection).",lib/Basic/DemangleWrappers.cpp,-,"printNode(Out, child.get(), depth + 1);","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());
","  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}


"
"Demangler: Use a bump-pointer allocator for node allocation.

This makes the demangler about 10 times faster.
It also changes the lifetimes of nodes. Previously nodes were reference-counted.
Now the returned demangle  node-tree is owned by the Demangler class and it’s lifetime ends with the lifetime of the Demangler.

Therefore the old (and already deprecated) global functions demangleSymbolAsNode and demangleTypeAsNode are no longer available.

Another change is that the demangling for reflection now only supports the new mangling (which should be no problem because
we are generating only new mangled names for reflection).",lib/Basic/DemangleWrappers.cpp,+,"printNode(Out, child, depth + 1);","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

   ","
  }

}

"
"Merge pull request #7750 from jckarter/static-stored-vars-in-concrete-extensions

SILGen: Allow static stored properties in fully-concrete extensions of generic types.",lib/SILGen/SILGenType.cpp,-,"assert(!generics && ""generic static properties not implemented"");","static void emitTypeMemberGlobalVariable(SILGenModule &SGM,

                                         VarDecl *var) {

  if (var->getDeclContext()->isGenericContext()) {

    assert(var->getDeclContext()->getGenericSignatureOfContext()

              ->areAllParamsConcrete()

           && ""generic static vars are not implemented yet"");

  }



  if (var->getDeclContext()->getAsClassOrClassExtensionContext()) {

    assert(var->isFinal() && ""only 'static' ('class final') stored properties are implemented in classes"");

  }



  SGM.addGlobalVariable(var);

}

","static void emitTypeMemberGlobalVariable(SILGenModule &SGM,

                                         VarDecl *var) {

","
    assert(var->getDeclContext()->getGenericSignatureOfContext()

              ->areAllParamsConcrete()

           && ""generic static vars are not implemented yet"");

  }



  if (var->getDeclContext()->getAsClassOrClassExtensionContext()) {

    assert(var->isFinal() && ""only 'static' ('class final') stored properties are implemented in classes"");

  }



  SGM.addGlobalVariable(var);

}


"
"Merge pull request #7750 from jckarter/static-stored-vars-in-concrete-extensions

SILGen: Allow static stored properties in fully-concrete extensions of generic types.",lib/SILGen/SILGenType.cpp,+,assert(var->getDeclContext()->getGenericSignatureOfContext(),"static void emitTypeMemberGlobalVariable(SILGenModule &SGM,

                                         VarDecl *var) {

  if (var->getDeclContext()->isGenericContext()) {

    assert(var->getDeclContext()->getGenericSignatureOfContext()

              ->areAllParamsConcrete()

           && ""generic static vars are not implemented yet"");

  }



  if (var->getDeclContext()->getAsClassOrClassExtensionContext()) {

    assert(var->isFinal() && ""only 'static' ('class final') stored properties are implemented in classes"");

  }



  SGM.addGlobalVariable(var);

}

","static void emitTypeMemberGlobalVariable(SILGenModule &SGM,

                                         VarDecl *var) {

  if (var->getDeclContext()->isGenericContext()) {

   ","
              ->areAllParamsConcrete()

           && ""generic static vars are not implemented yet"");

  }



  if (var->getDeclContext()->getAsClassOrClassExtensionContext()) {

    assert(var->isFinal() && ""only 'static' ('class final') stored properties are implemented in classes"");

  }



  SGM.addGlobalVariable(var);

}

"
"SILGen: Allow static stored properties in fully-concrete extensions of generic types.

There's no need for per-instantiation storage in this case, so we can relax the implementation limitation for them.",lib/SILGen/SILGenType.cpp,-,"assert(!generics && ""generic static properties not implemented"");","static void emitTypeMemberGlobalVariable(SILGenModule &SGM,

                                         VarDecl *var) {

  if (var->getDeclContext()->isGenericContext()) {

    assert(var->getDeclContext()->getGenericSignatureOfContext()

              ->areAllParamsConcrete()

           && ""generic static vars are not implemented yet"");

  }



  if (var->getDeclContext()->getAsClassOrClassExtensionContext()) {

    assert(var->isFinal() && ""only 'static' ('class final') stored properties are implemented in classes"");

  }



  SGM.addGlobalVariable(var);

}

","static void emitTypeMemberGlobalVariable(SILGenModule &SGM,

                                         VarDecl *var) {

","
    assert(var->getDeclContext()->getGenericSignatureOfContext()

              ->areAllParamsConcrete()

           && ""generic static vars are not implemented yet"");

  }



  if (var->getDeclContext()->getAsClassOrClassExtensionContext()) {

    assert(var->isFinal() && ""only 'static' ('class final') stored properties are implemented in classes"");

  }



  SGM.addGlobalVariable(var);

}


"
"SILGen: Allow static stored properties in fully-concrete extensions of generic types.

There's no need for per-instantiation storage in this case, so we can relax the implementation limitation for them.",lib/SILGen/SILGenType.cpp,+,assert(var->getDeclContext()->getGenericSignatureOfContext(),"static void emitTypeMemberGlobalVariable(SILGenModule &SGM,

                                         VarDecl *var) {

  if (var->getDeclContext()->isGenericContext()) {

    assert(var->getDeclContext()->getGenericSignatureOfContext()

              ->areAllParamsConcrete()

           && ""generic static vars are not implemented yet"");

  }



  if (var->getDeclContext()->getAsClassOrClassExtensionContext()) {

    assert(var->isFinal() && ""only 'static' ('class final') stored properties are implemented in classes"");

  }



  SGM.addGlobalVariable(var);

}

","static void emitTypeMemberGlobalVariable(SILGenModule &SGM,

                                         VarDecl *var) {

  if (var->getDeclContext()->isGenericContext()) {

   ","
              ->areAllParamsConcrete()

           && ""generic static vars are not implemented yet"");

  }



  if (var->getDeclContext()->getAsClassOrClassExtensionContext()) {

    assert(var->isFinal() && ""only 'static' ('class final') stored properties are implemented in classes"");

  }



  SGM.addGlobalVariable(var);

}

"
"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",unittests/runtime/LongTests/LongRefcounting.cpp,+,"ASSERT_DEATH(swift_unownedCheck(object),","static SWIFT_CC(swift) void deinitTestObject(SWIFT_CONTEXT HeapObject *_object) {

  auto object = static_cast<TestObject*>(_object);

  assert(object->Addr && ""object already deallocated"");



  if (object->CheckLifecycle) {

    // RC ok

    swift_retain(object);

    swift_retain(object);

    swift_release(object);

    swift_release(object);

    // FIXME: RC underflow during deinit?



    // URC load crashes

    // URC increment OK

    // URC decrement OK

    ASSERT_DEATH(swift_unownedCheck(object),

                 ""attempted to read an unowned reference"");

    swift_unownedRetain(object);

    swift_unownedRetain(object);

    swift_unownedRelease(object);

    swift_unownedRelease(object);

    

    if (object->WeakRef) {

      // WRC load is nil

      // WRC increment is nil

      // WRC decrement OK



      // WRC -1

      auto weak_value = swift_weakLoadStrong(object->WeakRef);

      EXPECT_EQ(nullptr, weak_value);

      swift_weakDestroy(object->WeakRef);



      // WRC no change

      swift_weakInit(object->WeakRef, object);

      weak_value = swift_weakLoadStrong(object->WeakRef);

      EXPECT_EQ(nullptr, weak_value);



      // WRC no change

      swift_weakInit(object->WeakRef, object);

      weak_value = swift_weakLoadStrong(object->WeakRef);

      EXPECT_EQ(nullptr, weak_value);

    }

  }



  *object->Addr = object->Value;

  object->Addr = nullptr;

  swift_deallocObject(object, sizeof(TestObject), alignof(TestObject) - 1);

}

","static SWIFT_CC(swift) void deinitTestObject(SWIFT_CONTEXT HeapObject *_object) {

  auto object = static_cast<TestObject*>(_object);

  assert(object->Addr && ""object already deallocated"");



  if (object->CheckLifecycle) {

    // RC ok

    swift_retain(object);

    swift_retain(object);

    swift_release(object);

    swift_release(object);

    // FIXME: RC underflow during deinit?



    // URC load crashes

    // URC increment OK

    // URC decrement OK

   ","
                 ""attempted to read an unowned reference"");

    swift_unownedRetain(object);

    swift_unownedRetain(object);

    swift_unownedRelease(object);

    swift_unownedRelease(object);

    

    if (object->WeakRef) {

      // WRC load is nil

      // WRC increment is nil

      // WRC decrement OK



      // WRC -1

      auto weak_value = swift_weakLoadStrong(object->WeakRef);

      EXPECT_EQ(nullptr, weak_value);

      swift_weakDestroy(object->WeakRef);



      // WRC no change

      swift_weakInit(object->WeakRef, object);

      weak_value = swift_weakLoadStrong(object->WeakRef);

      EXPECT_EQ(nullptr, weak_value);



      // WRC no change

      swift_weakInit(object->WeakRef, object);

      weak_value = swift_weakLoadStrong(object->WeakRef);

      EXPECT_EQ(nullptr, weak_value);

    }

  }



  *object->Addr = object->Value;

  object->Addr = nullptr;

  swift_deallocObject(object, sizeof(TestObject), alignof(TestObject) - 1);

}

"
"Merge pull request #7727 from practicalswift/typos-20170223

[gardening] Fix typos",lib/IRGen/GenCall.cpp,-,"assert(CanUseError && ""Mulitple error parameters?!"");","    bool claimError() {

      auto Ret = CanUseError;

      assert(CanUseError && ""Multiple error parameters?!"");

      CanUseError = false;

      return Ret;

    }

","    bool claimError() {

","
      assert(CanUseError && ""Multiple error parameters?!"");

      CanUseError = false;

      return Ret;

    }


"
"Merge pull request #7727 from practicalswift/typos-20170223

[gardening] Fix typos",lib/IRGen/GenCall.cpp,+,"assert(CanUseError && ""Multiple error parameters?!"");","    bool claimError() {

      auto Ret = CanUseError;

      assert(CanUseError && ""Multiple error parameters?!"");

      CanUseError = false;

      return Ret;

    }

","    bool claimError() {

      auto Ret = CanUseError;

     ","
      CanUseError = false;

      return Ret;

    }

"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,getForeignErrorConventionKindString(ForeignErrorConvention::Kind value) {,"static StringRef

getForeignErrorConventionKindString(ForeignErrorConvention::Kind value) {

  switch (value) {

  case ForeignErrorConvention::ZeroResult: return ""ZeroResult"";

  case ForeignErrorConvention::NonZeroResult: return ""NonZeroResult"";

  case ForeignErrorConvention::ZeroPreservedResult: return ""ZeroPreservedResult"";

  case ForeignErrorConvention::NilResult: return ""NilResult"";

  case ForeignErrorConvention::NonNilError: return ""NonNilError"";

  }

}

","static StringRef
","
  switch (value) {

  case ForeignErrorConvention::ZeroResult: return ""ZeroResult"";

  case ForeignErrorConvention::NonZeroResult: return ""NonZeroResult"";

  case ForeignErrorConvention::ZeroPreservedResult: return ""ZeroPreservedResult"";

  case ForeignErrorConvention::NilResult: return ""NilResult"";

  case ForeignErrorConvention::NonNilError: return ""NonNilError"";

  }

}

"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#column"");","    void printParameter(const ParamDecl *P) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter "";

      printDeclName(P);

      if (!P->getArgumentName().empty())

        PrintWithColorRAII(OS, IdentifierColor)

          << "" apiName="" << P->getArgumentName();



      if (P->hasType()) {

        PrintWithColorRAII(OS, TypeColor) << "" type='"";

        P->getType().print(PrintWithColorRAII(OS, TypeColor).getOS());

        PrintWithColorRAII(OS, TypeColor) << ""'"";

      }



      if (P->hasInterfaceType()) {

        PrintWithColorRAII(OS, InterfaceTypeColor) << "" interface type='"";

        P->getInterfaceType().print(

            PrintWithColorRAII(OS, InterfaceTypeColor).getOS());

        PrintWithColorRAII(OS, InterfaceTypeColor) << ""'"";

      }



      if (!P->isLet())

        OS << "" mutable"";



      if (P->isVariadic())

        OS << "" variadic"";



      if (P->getDefaultArgumentKind() != DefaultArgumentKind::None)

        printField(""default_arg"",

                   getDefaultArgumentKindString(P->getDefaultArgumentKind()));



      if (auto init = P->getDefaultValue()) {

        OS << "" expression=\n"";

        printRec(init);

      }



      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }

","    void printParameter(const ParamDecl *P) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter "";

      printDeclName(P);

      if (!P->getArgumentName().empty())

        PrintWithColorRAII(OS, IdentifierColor)

          << "" apiName="" << P->getArgumentName();



      if (P->hasType()) {

        PrintWithColorRAII(OS, TypeColor) << "" type='"";

        P->getType().print(PrintWithColorRAII(OS, TypeColor).getOS());

        PrintWithColorRAII(OS, TypeColor) << ""'"";

      }



      if (P->hasInterfaceType()) {
","        PrintWithColorRAII(OS, InterfaceTypeColor) << "" interface type='"";

        P->getInterfaceType().print(

            PrintWithColorRAII(OS, InterfaceTypeColor).getOS());

        PrintWithColorRAII(OS, InterfaceTypeColor) << ""'"";

      }



      if (!P->isLet())

        OS << "" mutable"";



      if (P->isVariadic())

        OS << "" variadic"";



      if (P->getDefaultArgumentKind() != DefaultArgumentKind::None)

        printField(""default_arg"",

                   getDefaultArgumentKindString(P->getDefaultArgumentKind()));



      if (auto init = P->getDefaultValue()) {

        OS << "" expression=\n"";

        printRec(init);

      }



      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#dsohandle"");","    void printParameter(const ParamDecl *P) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter "";

      printDeclName(P);

      if (!P->getArgumentName().empty())

        PrintWithColorRAII(OS, IdentifierColor)

          << "" apiName="" << P->getArgumentName();



      if (P->hasType()) {

        PrintWithColorRAII(OS, TypeColor) << "" type='"";

        P->getType().print(PrintWithColorRAII(OS, TypeColor).getOS());

        PrintWithColorRAII(OS, TypeColor) << ""'"";

      }



      if (P->hasInterfaceType()) {

        PrintWithColorRAII(OS, InterfaceTypeColor) << "" interface type='"";

        P->getInterfaceType().print(

            PrintWithColorRAII(OS, InterfaceTypeColor).getOS());

        PrintWithColorRAII(OS, InterfaceTypeColor) << ""'"";

      }



      if (!P->isLet())

        OS << "" mutable"";



      if (P->isVariadic())

        OS << "" variadic"";



      if (P->getDefaultArgumentKind() != DefaultArgumentKind::None)

        printField(""default_arg"",

                   getDefaultArgumentKindString(P->getDefaultArgumentKind()));



      if (auto init = P->getDefaultValue()) {

        OS << "" expression=\n"";

        printRec(init);

      }



      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }

","    void printParameter(const ParamDecl *P) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter "";

      printDeclName(P);

      if (!P->getArgumentName().empty())

        PrintWithColorRAII(OS, IdentifierColor)

          << "" apiName="" << P->getArgumentName();



      if (P->hasType()) {

        PrintWithColorRAII(OS, TypeColor) << "" type='"";

        P->getType().print(PrintWithColorRAII(OS, TypeColor).getOS());

        PrintWithColorRAII(OS, TypeColor) << ""'"";

      }



      if (P->hasInterfaceType()) {

        PrintWithColorRAII(OS, InterfaceTypeColor) << "" interface type='"";
","        P->getInterfaceType().print(

            PrintWithColorRAII(OS, InterfaceTypeColor).getOS());

        PrintWithColorRAII(OS, InterfaceTypeColor) << ""'"";

      }



      if (!P->isLet())

        OS << "" mutable"";



      if (P->isVariadic())

        OS << "" variadic"";



      if (P->getDefaultArgumentKind() != DefaultArgumentKind::None)

        printField(""default_arg"",

                   getDefaultArgumentKindString(P->getDefaultArgumentKind()));



      if (auto init = P->getDefaultValue()) {

        OS << "" expression=\n"";

        printRec(init);

      }



      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#file"");","    void printParameter(const ParamDecl *P) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter "";

      printDeclName(P);

      if (!P->getArgumentName().empty())

        PrintWithColorRAII(OS, IdentifierColor)

          << "" apiName="" << P->getArgumentName();



      if (P->hasType()) {

        PrintWithColorRAII(OS, TypeColor) << "" type='"";

        P->getType().print(PrintWithColorRAII(OS, TypeColor).getOS());

        PrintWithColorRAII(OS, TypeColor) << ""'"";

      }



      if (P->hasInterfaceType()) {

        PrintWithColorRAII(OS, InterfaceTypeColor) << "" interface type='"";

        P->getInterfaceType().print(

            PrintWithColorRAII(OS, InterfaceTypeColor).getOS());

        PrintWithColorRAII(OS, InterfaceTypeColor) << ""'"";

      }



      if (!P->isLet())

        OS << "" mutable"";



      if (P->isVariadic())

        OS << "" variadic"";



      if (P->getDefaultArgumentKind() != DefaultArgumentKind::None)

        printField(""default_arg"",

                   getDefaultArgumentKindString(P->getDefaultArgumentKind()));



      if (auto init = P->getDefaultValue()) {

        OS << "" expression=\n"";

        printRec(init);

      }



      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }

","    void printParameter(const ParamDecl *P) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter "";

      printDeclName(P);

      if (!P->getArgumentName().empty())

        PrintWithColorRAII(OS, IdentifierColor)

          << "" apiName="" << P->getArgumentName();



      if (P->hasType()) {

        PrintWithColorRAII(OS, TypeColor) << "" type='"";

        P->getType().print(PrintWithColorRAII(OS, TypeColor).getOS());

        PrintWithColorRAII(OS, TypeColor) << ""'"";

      }



      if (P->hasInterfaceType()) {

        PrintWithColorRAII(OS, InterfaceTypeColor) << "" interface type='"";

        P->getInterfaceType().print(
","            PrintWithColorRAII(OS, InterfaceTypeColor).getOS());

        PrintWithColorRAII(OS, InterfaceTypeColor) << ""'"";

      }



      if (!P->isLet())

        OS << "" mutable"";



      if (P->isVariadic())

        OS << "" variadic"";



      if (P->getDefaultArgumentKind() != DefaultArgumentKind::None)

        printField(""default_arg"",

                   getDefaultArgumentKindString(P->getDefaultArgumentKind()));



      if (auto init = P->getDefaultValue()) {

        OS << "" expression=\n"";

        printRec(init);

      }



      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#function"");","    void printParameter(const ParamDecl *P) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter "";

      printDeclName(P);

      if (!P->getArgumentName().empty())

        PrintWithColorRAII(OS, IdentifierColor)

          << "" apiName="" << P->getArgumentName();



      if (P->hasType()) {

        PrintWithColorRAII(OS, TypeColor) << "" type='"";

        P->getType().print(PrintWithColorRAII(OS, TypeColor).getOS());

        PrintWithColorRAII(OS, TypeColor) << ""'"";

      }



      if (P->hasInterfaceType()) {

        PrintWithColorRAII(OS, InterfaceTypeColor) << "" interface type='"";

        P->getInterfaceType().print(

            PrintWithColorRAII(OS, InterfaceTypeColor).getOS());

        PrintWithColorRAII(OS, InterfaceTypeColor) << ""'"";

      }



      if (!P->isLet())

        OS << "" mutable"";



      if (P->isVariadic())

        OS << "" variadic"";



      if (P->getDefaultArgumentKind() != DefaultArgumentKind::None)

        printField(""default_arg"",

                   getDefaultArgumentKindString(P->getDefaultArgumentKind()));



      if (auto init = P->getDefaultValue()) {

        OS << "" expression=\n"";

        printRec(init);

      }



      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }

","    void printParameter(const ParamDecl *P) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter "";

      printDeclName(P);

      if (!P->getArgumentName().empty())

        PrintWithColorRAII(OS, IdentifierColor)

          << "" apiName="" << P->getArgumentName();



      if (P->hasType()) {

        PrintWithColorRAII(OS, TypeColor) << "" type='"";

        P->getType().print(PrintWithColorRAII(OS, TypeColor).getOS());

        PrintWithColorRAII(OS, TypeColor) << ""'"";

      }



      if (P->hasInterfaceType()) {

        PrintWithColorRAII(OS, InterfaceTypeColor) << "" interface type='"";

        P->getInterfaceType().print(

            PrintWithColorRAII(OS, InterfaceTypeColor).getOS());
","        PrintWithColorRAII(OS, InterfaceTypeColor) << ""'"";

      }



      if (!P->isLet())

        OS << "" mutable"";



      if (P->isVariadic())

        OS << "" variadic"";



      if (P->getDefaultArgumentKind() != DefaultArgumentKind::None)

        printField(""default_arg"",

                   getDefaultArgumentKindString(P->getDefaultArgumentKind()));



      if (auto init = P->getDefaultValue()) {

        OS << "" expression=\n"";

        printRec(init);

      }



      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#line"");","    void printParameterList(const ParameterList *params) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";

      Indent += 2;

      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }

","    void printParameterList(const ParameterList *params) {
","      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";

      Indent += 2;

      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""nil"");","    void printParameterList(const ParameterList *params) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";

      Indent += 2;

      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }

","    void printParameterList(const ParameterList *params) {

      OS.indent(Indent);
","      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";

      Indent += 2;

      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""[]"");","    void printParameterList(const ParameterList *params) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";

      Indent += 2;

      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }

","    void printParameterList(const ParameterList *params) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';
","      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";

      Indent += 2;

      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""[:]"");","    void printParameterList(const ParameterList *params) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";

      Indent += 2;

      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }

","    void printParameterList(const ParameterList *params) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";
","      Indent += 2;

      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""normal"");","    void printParameterList(const ParameterList *params) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";

      Indent += 2;

      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }

","    void printParameterList(const ParameterList *params) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";

      Indent += 2;
","      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor) << "" designated"";","    void visitConstructorDecl(ConstructorDecl *CD) {

      printCommonAFD(CD, ""constructor_decl"");

      if (CD->isRequired())

        PrintWithColorRAII(OS, DeclModifierColor) << "" required"";

      PrintWithColorRAII(OS, DeclModifierColor) << "" ""

        << getCtorInitializerKindString(CD->getInitKind());

      if (CD->getFailability() != OTK_None)

        PrintWithColorRAII(OS, DeclModifierColor) << "" failable=""

          << getOptionalTypeKindString(CD->getFailability());

      printAbstractFunctionDecl(CD);

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }

","    void visitConstructorDecl(ConstructorDecl *CD) {

      printCommonAFD(CD, ""constructor_decl"");

      if (CD->isRequired())

","
      PrintWithColorRAII(OS, DeclModifierColor) << "" ""

        << getCtorInitializerKindString(CD->getInitKind());

      if (CD->getFailability() != OTK_None)

        PrintWithColorRAII(OS, DeclModifierColor) << "" failable=""

          << getOptionalTypeKindString(CD->getFailability());

      printAbstractFunctionDecl(CD);

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor) << "" convenience"";","    void visitConstructorDecl(ConstructorDecl *CD) {

      printCommonAFD(CD, ""constructor_decl"");

      if (CD->isRequired())

        PrintWithColorRAII(OS, DeclModifierColor) << "" required"";

      PrintWithColorRAII(OS, DeclModifierColor) << "" ""

        << getCtorInitializerKindString(CD->getInitKind());

      if (CD->getFailability() != OTK_None)

        PrintWithColorRAII(OS, DeclModifierColor) << "" failable=""

          << getOptionalTypeKindString(CD->getFailability());

      printAbstractFunctionDecl(CD);

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }

","    void visitConstructorDecl(ConstructorDecl *CD) {

      printCommonAFD(CD, ""constructor_decl"");

      if (CD->isRequired())

        PrintWithColorRAII(OS, DeclModifierColor) << "" required"";

      PrintWithColorRAII(OS, DeclModifierColor) << "" ""
","        << getCtorInitializerKindString(CD->getInitKind());

      if (CD->getFailability() != OTK_None)

        PrintWithColorRAII(OS, DeclModifierColor) << "" failable=""

          << getOptionalTypeKindString(CD->getFailability());

      printAbstractFunctionDecl(CD);

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor) << "" factory"";","    void visitDestructorDecl(DestructorDecl *DD) {

      printCommonAFD(DD, ""destructor_decl"");

      printAbstractFunctionDecl(DD);

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }

","    void visitDestructorDecl(DestructorDecl *DD) {

","
      printAbstractFunctionDecl(DD);

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor) << "" failable=Optional"";","    void visitTopLevelCodeDecl(TopLevelCodeDecl *TLCD) {

      printCommon(TLCD, ""top_level_code_decl"");

      if (TLCD->getBody()) {

        OS << ""\n"";

        printRec(TLCD->getBody());

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }

","    void visitTopLevelCodeDecl(TopLevelCodeDecl *TLCD) {

      printCommon(TLCD, ""top_level_code_decl"");

","
        OS << ""\n"";

        printRec(TLCD->getBody());

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor)","    void visitTopLevelCodeDecl(TopLevelCodeDecl *TLCD) {

      printCommon(TLCD, ""top_level_code_decl"");

      if (TLCD->getBody()) {

        OS << ""\n"";

        printRec(TLCD->getBody());

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }

","    void visitTopLevelCodeDecl(TopLevelCodeDecl *TLCD) {

      printCommon(TLCD, ""top_level_code_decl"");

      if (TLCD->getBody()) {

        OS << ""\n"";
","        printRec(TLCD->getBody());

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,void printStringEncoding(StringLiteralExpr::Encoding encoding) {,"  void visitStringLiteralExpr(StringLiteralExpr *E) {

    printCommon(E, ""string_literal_expr"");

    PrintWithColorRAII(OS, LiteralValueColor) << "" encoding=""

      << getStringLiteralExprEncodingString(E->getEncoding())

      << "" value="" << QuotedString(E->getValue())

      << "" builtin_initializer="";

    E->getBuiltinInitializer().dump(

      PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, LiteralValueColor) << "" initializer="";

    E->getInitializer().dump(PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

",,"
    printCommon(E, ""string_literal_expr"");

    PrintWithColorRAII(OS, LiteralValueColor) << "" encoding=""

      << getStringLiteralExprEncodingString(E->getEncoding())

      << "" value="" << QuotedString(E->getValue())

      << "" builtin_initializer="";

    E->getBuiltinInitializer().dump(

      PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, LiteralValueColor) << "" initializer="";

    E->getInitializer().dump(PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor) << ""utf8"";","  void visitStringLiteralExpr(StringLiteralExpr *E) {

    printCommon(E, ""string_literal_expr"");

    PrintWithColorRAII(OS, LiteralValueColor) << "" encoding=""

      << getStringLiteralExprEncodingString(E->getEncoding())

      << "" value="" << QuotedString(E->getValue())

      << "" builtin_initializer="";

    E->getBuiltinInitializer().dump(

      PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, LiteralValueColor) << "" initializer="";

    E->getInitializer().dump(PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitStringLiteralExpr(StringLiteralExpr *E) {

","
    PrintWithColorRAII(OS, LiteralValueColor) << "" encoding=""

      << getStringLiteralExprEncodingString(E->getEncoding())

      << "" value="" << QuotedString(E->getValue())

      << "" builtin_initializer="";

    E->getBuiltinInitializer().dump(

      PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, LiteralValueColor) << "" initializer="";

    E->getInitializer().dump(PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor) << ""utf16"";","  void visitStringLiteralExpr(StringLiteralExpr *E) {

    printCommon(E, ""string_literal_expr"");

    PrintWithColorRAII(OS, LiteralValueColor) << "" encoding=""

      << getStringLiteralExprEncodingString(E->getEncoding())

      << "" value="" << QuotedString(E->getValue())

      << "" builtin_initializer="";

    E->getBuiltinInitializer().dump(

      PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, LiteralValueColor) << "" initializer="";

    E->getInitializer().dump(PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitStringLiteralExpr(StringLiteralExpr *E) {

    printCommon(E, ""string_literal_expr"");

","
      << getStringLiteralExprEncodingString(E->getEncoding())

      << "" value="" << QuotedString(E->getValue())

      << "" builtin_initializer="";

    E->getBuiltinInitializer().dump(

      PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, LiteralValueColor) << "" initializer="";

    E->getInitializer().dump(PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor) << ""unicodeScalar"";","  void visitStringLiteralExpr(StringLiteralExpr *E) {

    printCommon(E, ""string_literal_expr"");

    PrintWithColorRAII(OS, LiteralValueColor) << "" encoding=""

      << getStringLiteralExprEncodingString(E->getEncoding())

      << "" value="" << QuotedString(E->getValue())

      << "" builtin_initializer="";

    E->getBuiltinInitializer().dump(

      PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, LiteralValueColor) << "" initializer="";

    E->getInitializer().dump(PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitStringLiteralExpr(StringLiteralExpr *E) {

    printCommon(E, ""string_literal_expr"");

    PrintWithColorRAII(OS, LiteralValueColor) << "" encoding=""

","
      << "" value="" << QuotedString(E->getValue())

      << "" builtin_initializer="";

    E->getBuiltinInitializer().dump(

      PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, LiteralValueColor) << "" initializer="";

    E->getInitializer().dump(PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor) << "" encoding="";","  void visitInterpolatedStringLiteralExpr(InterpolatedStringLiteralExpr *E) {

    printCommon(E, ""interpolated_string_literal_expr"");

    for (auto Segment : E->getSegments()) {

      OS << '\n';

      printRec(Segment);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

",,"
    printCommon(E, ""interpolated_string_literal_expr"");

    for (auto Segment : E->getSegments()) {

      OS << '\n';

      printRec(Segment);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,printStringEncoding(E->getEncoding());,"  void visitInterpolatedStringLiteralExpr(InterpolatedStringLiteralExpr *E) {

    printCommon(E, ""interpolated_string_literal_expr"");

    for (auto Segment : E->getSegments()) {

      OS << '\n';

      printRec(Segment);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

",,"
    printCommon(E, ""interpolated_string_literal_expr"");

    for (auto Segment : E->getSegments()) {

      OS << '\n';

      printRec(Segment);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor)","  void visitInterpolatedStringLiteralExpr(InterpolatedStringLiteralExpr *E) {

    printCommon(E, ""interpolated_string_literal_expr"");

    for (auto Segment : E->getSegments()) {

      OS << '\n';

      printRec(Segment);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

",,"
    printCommon(E, ""interpolated_string_literal_expr"");

    for (auto Segment : E->getSegments()) {

      OS << '\n';

      printRec(Segment);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printCommon(E, ""magic_identifier_literal_expr"") << "" kind="";","  void visitMagicIdentifierLiteralExpr(MagicIdentifierLiteralExpr *E) {

    printCommon(E, ""magic_identifier_literal_expr"")

      << "" kind="" << getMagicIdentifierLiteralExprKindString(E->getKind());



    if (E->isString()) {

      OS << "" encoding=""

         << getStringLiteralExprEncodingString(E->getStringEncoding())

         << "" builtin_initializer="";

      E->getBuiltinInitializer().dump(OS);

      OS << "" initializer="";

      E->getInitializer().dump(OS);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitMagicIdentifierLiteralExpr(MagicIdentifierLiteralExpr *E) {
","    printCommon(E, ""magic_identifier_literal_expr"")

      << "" kind="" << getMagicIdentifierLiteralExprKindString(E->getKind());



    if (E->isString()) {

      OS << "" encoding=""

         << getStringLiteralExprEncodingString(E->getStringEncoding())

         << "" builtin_initializer="";

      E->getBuiltinInitializer().dump(OS);

      OS << "" initializer="";

      E->getInitializer().dump(OS);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,printStringEncoding(E->getStringEncoding());,"  void visitMagicIdentifierLiteralExpr(MagicIdentifierLiteralExpr *E) {

    printCommon(E, ""magic_identifier_literal_expr"")

      << "" kind="" << getMagicIdentifierLiteralExprKindString(E->getKind());



    if (E->isString()) {

      OS << "" encoding=""

         << getStringLiteralExprEncodingString(E->getStringEncoding())

         << "" builtin_initializer="";

      E->getBuiltinInitializer().dump(OS);

      OS << "" initializer="";

      E->getInitializer().dump(OS);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitMagicIdentifierLiteralExpr(MagicIdentifierLiteralExpr *E) {

    printCommon(E, ""magic_identifier_literal_expr"")

","


    if (E->isString()) {

      OS << "" encoding=""

         << getStringLiteralExprEncodingString(E->getStringEncoding())

         << "" builtin_initializer="";

      E->getBuiltinInitializer().dump(OS);

      OS << "" initializer="";

      E->getInitializer().dump(OS);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,printStringEncoding(E->getStringEncoding());,"  void visitMagicIdentifierLiteralExpr(MagicIdentifierLiteralExpr *E) {

    printCommon(E, ""magic_identifier_literal_expr"")

      << "" kind="" << getMagicIdentifierLiteralExprKindString(E->getKind());



    if (E->isString()) {

      OS << "" encoding=""

         << getStringLiteralExprEncodingString(E->getStringEncoding())

         << "" builtin_initializer="";

      E->getBuiltinInitializer().dump(OS);

      OS << "" initializer="";

      E->getInitializer().dump(OS);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitMagicIdentifierLiteralExpr(MagicIdentifierLiteralExpr *E) {

    printCommon(E, ""magic_identifier_literal_expr"")

      << "" kind="" << getMagicIdentifierLiteralExprKindString(E->getKind());



","
      OS << "" encoding=""

         << getStringLiteralExprEncodingString(E->getStringEncoding())

         << "" builtin_initializer="";

      E->getBuiltinInitializer().dump(OS);

      OS << "" initializer="";

      E->getInitializer().dump(OS);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << E->getAccessSemantics();","  void visitDeclRefExpr(DeclRefExpr *E) {

    printCommon(E, ""declref_expr"");

    PrintWithColorRAII(OS, DeclColor) << "" decl="";

    E->getDeclRef().dump(PrintWithColorRAII(OS, DeclColor).getOS());

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

      PrintWithColorRAII(OS, AccessibilityColor)

        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    PrintWithColorRAII(OS, ExprModifierColor)

      << "" function_ref="" << getFunctionRefKindStr(E->getFunctionRefKind())

      << "" specialized="" << (E->isSpecialized()? ""yes"" : ""no"");



    for (auto TR : E->getGenericArgs()) {

      OS << '\n';

      printRec(TR);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitDeclRefExpr(DeclRefExpr *E) {

    printCommon(E, ""declref_expr"");

","
    E->getDeclRef().dump(PrintWithColorRAII(OS, DeclColor).getOS());

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

      PrintWithColorRAII(OS, AccessibilityColor)

        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    PrintWithColorRAII(OS, ExprModifierColor)

      << "" function_ref="" << getFunctionRefKindStr(E->getFunctionRefKind())

      << "" specialized="" << (E->isSpecialized()? ""yes"" : ""no"");



    for (auto TR : E->getGenericArgs()) {

      OS << '\n';

      printRec(TR);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, AccessibilityColor)","  void visitDeclRefExpr(DeclRefExpr *E) {

    printCommon(E, ""declref_expr"");

    PrintWithColorRAII(OS, DeclColor) << "" decl="";

    E->getDeclRef().dump(PrintWithColorRAII(OS, DeclColor).getOS());

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

      PrintWithColorRAII(OS, AccessibilityColor)

        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    PrintWithColorRAII(OS, ExprModifierColor)

      << "" function_ref="" << getFunctionRefKindStr(E->getFunctionRefKind())

      << "" specialized="" << (E->isSpecialized()? ""yes"" : ""no"");



    for (auto TR : E->getGenericArgs()) {

      OS << '\n';

      printRec(TR);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitDeclRefExpr(DeclRefExpr *E) {

    printCommon(E, ""declref_expr"");

    PrintWithColorRAII(OS, DeclColor) << "" decl="";

    E->getDeclRef().dump(PrintWithColorRAII(OS, DeclColor).getOS());

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

     ","
        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    PrintWithColorRAII(OS, ExprModifierColor)

      << "" function_ref="" << getFunctionRefKindStr(E->getFunctionRefKind())

      << "" specialized="" << (E->isSpecialized()? ""yes"" : ""no"");



    for (auto TR : E->getGenericArgs()) {

      OS << '\n';

      printRec(TR);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << E->getAccessSemantics();","  void visitMemberRefExpr(MemberRefExpr *E) {

    printCommon(E, ""member_ref_expr"")

      << "" decl="";

    E->getMember().dump(OS);

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

      PrintWithColorRAII(OS, AccessibilityColor)

        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    if (E->isSuper())

      OS << "" super"";



    OS << '\n';

    printRec(E->getBase());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitMemberRefExpr(MemberRefExpr *E) {

    printCommon(E, ""member_ref_expr"")

      << "" decl="";
","    E->getMember().dump(OS);

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

      PrintWithColorRAII(OS, AccessibilityColor)

        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    if (E->isSuper())

      OS << "" super"";



    OS << '\n';

    printRec(E->getBase());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, AccessibilityColor)","  void visitMemberRefExpr(MemberRefExpr *E) {

    printCommon(E, ""member_ref_expr"")

      << "" decl="";

    E->getMember().dump(OS);

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

      PrintWithColorRAII(OS, AccessibilityColor)

        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    if (E->isSuper())

      OS << "" super"";



    OS << '\n';

    printRec(E->getBase());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitMemberRefExpr(MemberRefExpr *E) {

    printCommon(E, ""member_ref_expr"")

      << "" decl="";

    E->getMember().dump(OS);

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

     ","
        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    if (E->isSuper())

      OS << "" super"";



    OS << '\n';

    printRec(E->getBase());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << E->getAccessSemantics();","  void visitSubscriptExpr(SubscriptExpr *E) {

    printCommon(E, ""subscript_expr"");

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

      PrintWithColorRAII(OS, AccessibilityColor)

        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    if (E->isSuper())

      OS << "" super"";

    if (E->hasDecl()) {

      OS << ""  decl="";

      E->getDecl().dump(OS);

    }

    printArgumentLabels(E->getArgumentLabels());

    OS << '\n';

    printRec(E->getBase());

    OS << '\n';

    printRec(E->getIndex());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitSubscriptExpr(SubscriptExpr *E) {

","
    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

      PrintWithColorRAII(OS, AccessibilityColor)

        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    if (E->isSuper())

      OS << "" super"";

    if (E->hasDecl()) {

      OS << ""  decl="";

      E->getDecl().dump(OS);

    }

    printArgumentLabels(E->getArgumentLabels());

    OS << '\n';

    printRec(E->getBase());

    OS << '\n';

    printRec(E->getIndex());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, AccessibilityColor)","  void visitSubscriptExpr(SubscriptExpr *E) {

    printCommon(E, ""subscript_expr"");

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

      PrintWithColorRAII(OS, AccessibilityColor)

        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    if (E->isSuper())

      OS << "" super"";

    if (E->hasDecl()) {

      OS << ""  decl="";

      E->getDecl().dump(OS);

    }

    printArgumentLabels(E->getArgumentLabels());

    OS << '\n';

    printRec(E->getBase());

    OS << '\n';

    printRec(E->getIndex());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitSubscriptExpr(SubscriptExpr *E) {

    printCommon(E, ""subscript_expr"");

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

     ","
        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    if (E->isSuper())

      OS << "" super"";

    if (E->hasDecl()) {

      OS << ""  decl="";

      E->getDecl().dump(OS);

    }

    printArgumentLabels(E->getArgumentLabels());

    OS << '\n';

    printRec(E->getBase());

    OS << '\n';

    printRec(E->getIndex());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printFlag(""vararg"");","    void dumpParameterFlags(ParameterTypeFlags paramFlags) {

      printFlag(paramFlags.isVariadic(), ""vararg"");

      printFlag(paramFlags.isAutoClosure(), ""autoclosure"");

      printFlag(paramFlags.isEscaping(), ""escaping"");

    }

","    void dumpParameterFlags(ParameterTypeFlags paramFlags) {

","
      printFlag(paramFlags.isAutoClosure(), ""autoclosure"");

      printFlag(paramFlags.isEscaping(), ""escaping"");

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printFlag(""autoclosure"");","    void dumpParameterFlags(ParameterTypeFlags paramFlags) {

      printFlag(paramFlags.isVariadic(), ""vararg"");

      printFlag(paramFlags.isAutoClosure(), ""autoclosure"");

      printFlag(paramFlags.isEscaping(), ""escaping"");

    }

","    void dumpParameterFlags(ParameterTypeFlags paramFlags) {

      printFlag(paramFlags.isVariadic(), ""vararg"");
","      printFlag(paramFlags.isAutoClosure(), ""autoclosure"");

      printFlag(paramFlags.isEscaping(), ""escaping"");

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printFlag(""escaping"");","    void dumpParameterFlags(ParameterTypeFlags paramFlags) {

      printFlag(paramFlags.isVariadic(), ""vararg"");

      printFlag(paramFlags.isAutoClosure(), ""autoclosure"");

      printFlag(paramFlags.isEscaping(), ""escaping"");

    }

","    void dumpParameterFlags(ParameterTypeFlags paramFlags) {

      printFlag(paramFlags.isVariadic(), ""vararg"");

","
      printFlag(paramFlags.isEscaping(), ""escaping"");

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,"printFlag(paramFlags.isVariadic(), ""vararg"");","    void dumpParameterFlags(ParameterTypeFlags paramFlags) {

      printFlag(paramFlags.isVariadic(), ""vararg"");

      printFlag(paramFlags.isAutoClosure(), ""autoclosure"");

      printFlag(paramFlags.isEscaping(), ""escaping"");

    }

","    void dumpParameterFlags(ParameterTypeFlags paramFlags) {

     ","
      printFlag(paramFlags.isAutoClosure(), ""autoclosure"");

      printFlag(paramFlags.isEscaping(), ""escaping"");

    }

"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,void printMetatypeRepresentation(MetatypeRepresentation representation) {,"    void visitMetatypeType(MetatypeType *T, StringRef label) {

      printCommon(T, label, ""metatype_type"");

      if (T->hasRepresentation())

        OS << "" "" << getMetatypeRepresentationString(T->getRepresentation());

      printRec(T->getInstanceType());

      OS << "")"";

    }

",,"
      printCommon(T, label, ""metatype_type"");

      if (T->hasRepresentation())

        OS << "" "" << getMetatypeRepresentationString(T->getRepresentation());

      printRec(T->getInstanceType());

      OS << "")"";

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,printMetatypeRepresentation(T->getRepresentation());,"    void visitModuleType(ModuleType *T, StringRef label) {

      printCommon(T, label, ""module_type"");

      printField(""module"", T->getModule()->getName());

      OS << "")"";

    }

",,"
      printCommon(T, label, ""module_type"");

      printField(""module"", T->getModule()->getName());

      OS << "")"";

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,printMetatypeRepresentation(T->getRepresentation());,"    void visitExistentialMetatypeType(ExistentialMetatypeType *T,

                                      StringRef label) {

      printCommon(T, label, ""existential_metatype_type"");

      if (T->hasRepresentation())

        OS << "" "" << getMetatypeRepresentationString(T->getRepresentation());

      printRec(T->getInstanceType());

      OS << "")"";

    }

","    void visitExistentialMetatypeType(ExistentialMetatypeType *T,

                                      StringRef label) {

","
      if (T->hasRepresentation())

        OS << "" "" << getMetatypeRepresentationString(T->getRepresentation());

      printRec(T->getInstanceType());

      OS << "")"";

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""block"");","    void printAnyFunctionTypeCommon(AnyFunctionType *T, StringRef label,

                                    StringRef name) {

      printCommon(T, label, name);

      SILFunctionType::Representation representation =

        T->getExtInfo().getSILRepresentation();



      if (representation != SILFunctionType::Representation::Thick)

        printField(""representation"",

                   getSILFunctionTypeRepresentationString(representation));



      printFlag(T->isAutoClosure(), ""autoclosure"");

      printFlag(!T->isNoEscape(), ""escaping"");

      printFlag(T->throws(), ""throws"");



      printRec(""input"", T->getInput());

      printRec(""output"", T->getResult());

    }

","    void printAnyFunctionTypeCommon(AnyFunctionType *T, StringRef label,

                                    StringRef name) {

      printCommon(T, label, name);

      SILFunctionType::Representation representation =

        T->getExtInfo().getSILRepresentation();


","      if (representation != SILFunctionType::Representation::Thick)

        printField(""representation"",

                   getSILFunctionTypeRepresentationString(representation));



      printFlag(T->isAutoClosure(), ""autoclosure"");

      printFlag(!T->isNoEscape(), ""escaping"");

      printFlag(T->throws(), ""throws"");



      printRec(""input"", T->getInput());

      printRec(""output"", T->getResult());

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""c"");","    void printAnyFunctionTypeCommon(AnyFunctionType *T, StringRef label,

                                    StringRef name) {

      printCommon(T, label, name);

      SILFunctionType::Representation representation =

        T->getExtInfo().getSILRepresentation();



      if (representation != SILFunctionType::Representation::Thick)

        printField(""representation"",

                   getSILFunctionTypeRepresentationString(representation));



      printFlag(T->isAutoClosure(), ""autoclosure"");

      printFlag(!T->isNoEscape(), ""escaping"");

      printFlag(T->throws(), ""throws"");



      printRec(""input"", T->getInput());

      printRec(""output"", T->getResult());

    }

","    void printAnyFunctionTypeCommon(AnyFunctionType *T, StringRef label,

                                    StringRef name) {

      printCommon(T, label, name);

      SILFunctionType::Representation representation =

        T->getExtInfo().getSILRepresentation();



      if (representation != SILFunctionType::Representation::Thick)

","
                   getSILFunctionTypeRepresentationString(representation));



      printFlag(T->isAutoClosure(), ""autoclosure"");

      printFlag(!T->isNoEscape(), ""escaping"");

      printFlag(T->throws(), ""throws"");



      printRec(""input"", T->getInput());

      printRec(""output"", T->getResult());

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""method"");","    void visitFunctionType(FunctionType *T, StringRef label) {

      printAnyFunctionTypeCommon(T, label, ""function_type"");

      OS << "")"";

    }

","    void visitFunctionType(FunctionType *T, StringRef label) {

","
      OS << "")"";

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""objc_method"");","    void visitGenericFunctionType(GenericFunctionType *T, StringRef label) {

      printAnyFunctionTypeCommon(T, label, ""generic_function_type"");

      // FIXME: generic signature dumping needs improvement

      OS << ""\n"";

      OS.indent(Indent + 2) << ""("";

      printField(""generic_sig"", T->getGenericSignature()->getAsString());

      OS << "")"";

      OS << "")"";

    }

",,"
      printAnyFunctionTypeCommon(T, label, ""generic_function_type"");

      // FIXME: generic signature dumping needs improvement

      OS << ""\n"";

      OS.indent(Indent + 2) << ""("";

      printField(""generic_sig"", T->getGenericSignature()->getAsString());

      OS << "")"";

      OS << "")"";

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""witness_method"");","    void visitGenericFunctionType(GenericFunctionType *T, StringRef label) {

      printAnyFunctionTypeCommon(T, label, ""generic_function_type"");

      // FIXME: generic signature dumping needs improvement

      OS << ""\n"";

      OS.indent(Indent + 2) << ""("";

      printField(""generic_sig"", T->getGenericSignature()->getAsString());

      OS << "")"";

      OS << "")"";

    }

","    void visitGenericFunctionType(GenericFunctionType *T, StringRef label) {

      printAnyFunctionTypeCommon(T, label, ""generic_function_type"");
","      // FIXME: generic signature dumping needs improvement

      OS << ""\n"";

      OS.indent(Indent + 2) << ""("";

      printField(""generic_sig"", T->getGenericSignature()->getAsString());

      OS << "")"";

      OS << "")"";

    }


"
"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""closure"");","    void visitGenericFunctionType(GenericFunctionType *T, StringRef label) {

      printAnyFunctionTypeCommon(T, label, ""generic_function_type"");

      // FIXME: generic signature dumping needs improvement

      OS << ""\n"";

      OS.indent(Indent + 2) << ""("";

      printField(""generic_sig"", T->getGenericSignature()->getAsString());

      OS << "")"";

      OS << "")"";

    }

","    void visitGenericFunctionType(GenericFunctionType *T, StringRef label) {

      printAnyFunctionTypeCommon(T, label, ""generic_function_type"");

      // FIXME: generic signature dumping needs improvement

","
      OS.indent(Indent + 2) << ""("";

      printField(""generic_sig"", T->getGenericSignature()->getAsString());

      OS << "")"";

      OS << "")"";

    }


"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,Trivia::spaces(0).print(OS);,"TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

   ","
  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,Trivia::tabs(0).print(OS);,"TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

   ","
  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,Trivia::newlines(0).print(OS);,"TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

   ","
  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,"TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

 ","
    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"Trivia::lineComment("""").print(OS);","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

   ","
  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,"TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

 ","
    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"Trivia::blockComment("""").print(OS);","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

   ","
  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,"TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

 ","
    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"Trivia::docLineComment("""").print(OS);","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

   ","
  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,"TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

 ","
    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"Trivia::docBlockComment("""").print(OS);","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

   ","
  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,Trivia().print(OS);,"TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

   ","
  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
[gardening] Fix typos,lib/IRGen/GenCall.cpp,-,"assert(CanUseError && ""Mulitple error parameters?!"");","    bool claimError() {

      auto Ret = CanUseError;

      assert(CanUseError && ""Multiple error parameters?!"");

      CanUseError = false;

      return Ret;

    }

","    bool claimError() {

","
      assert(CanUseError && ""Multiple error parameters?!"");

      CanUseError = false;

      return Ret;

    }


"
[gardening] Fix typos,lib/IRGen/GenCall.cpp,+,"assert(CanUseError && ""Multiple error parameters?!"");","    bool claimError() {

      auto Ret = CanUseError;

      assert(CanUseError && ""Multiple error parameters?!"");

      CanUseError = false;

      return Ret;

    }

","    bool claimError() {

      auto Ret = CanUseError;

     ","
      CanUseError = false;

      return Ret;

    }

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,Trivia::spaces(0).print(OS);,"TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

   ","
  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,Trivia::tabs(0).print(OS);,"TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

   ","
  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,Trivia::newlines(0).print(OS);,"TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

   ","
  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,"TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

 ","
    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"Trivia::lineComment("""").print(OS);","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

   ","
  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,"TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

 ","
    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"Trivia::blockComment("""").print(OS);","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

   ","
  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,"TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

 ","
    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"Trivia::docLineComment("""").print(OS);","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

   ","
  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,"TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

 ","
    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"Trivia::docBlockComment("""").print(OS);","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

   ","
  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,Trivia().print(OS);,"TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

","TEST(TriviaTests, Empty) {

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::spaces(0).print(OS);

   ","
  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::tabs(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::newlines(0).print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

#ifndef NDEBUG

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::lineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::blockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docLineComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

  ASSERT_DEATH({

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia::docBlockComment("""").print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }, """");

#endif

  {

    llvm::SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    Trivia().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

}

"
"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",unittests/Syntax/ThreadSafeCachingTests.cpp,+,"ASSERT_EQ(FirstDataPointer, SecondDataPointer);","TEST(ThreadSafeCachingTests, ReturnGetExpression) {

  auto ReturnKW = SyntaxFactory::makeReturnKeyword({}, Trivia::spaces(1));

  auto Minus = SyntaxFactory::makePrefixOpereator(""-"", {});

  auto One = SyntaxFactory::makeIntegerLiteralToken(""1"", {}, {});

  auto MinusOne = SyntaxFactory::makeIntegerLiteralExpr(Minus, One);



  for (unsigned i = 0; i < 10000; ++i) {

    llvm::SmallString<48> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Return = SyntaxFactory::makeReturnStmt(ReturnKW, MinusOne);



    uintptr_t FirstDataPointer;

    uintptr_t SecondDataPointer;



    std::thread first(getExpressionFrom, Return, &FirstDataPointer);

    std::thread second(getExpressionFrom, Return, &SecondDataPointer);

    first.join();

    second.join();



    auto DataPointer = reinterpret_cast<uintptr_t>(

      Return.getExpression().getValue().getDataPointer());



    ASSERT_EQ(FirstDataPointer, SecondDataPointer);

    ASSERT_EQ(FirstDataPointer, DataPointer);



    if (FirstDataPointer != SecondDataPointer ||

        FirstDataPointer != DataPointer) {

      break;

    }

  }

}

","TEST(ThreadSafeCachingTests, ReturnGetExpression) {

  auto ReturnKW = SyntaxFactory::makeReturnKeyword({}, Trivia::spaces(1));

  auto Minus = SyntaxFactory::makePrefixOpereator(""-"", {});

  auto One = SyntaxFactory::makeIntegerLiteralToken(""1"", {}, {});

  auto MinusOne = SyntaxFactory::makeIntegerLiteralExpr(Minus, One);



  for (unsigned i = 0; i < 10000; ++i) {

    llvm::SmallString<48> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Return = SyntaxFactory::makeReturnStmt(ReturnKW, MinusOne);



    uintptr_t FirstDataPointer;

    uintptr_t SecondDataPointer;



    std::thread first(getExpressionFrom, Return, &FirstDataPointer);

    std::thread second(getExpressionFrom, Return, &SecondDataPointer);

    first.join();

    second.join();



    auto DataPointer = reinterpret_cast<uintptr_t>(

      Return.getExpression().getValue().getDataPointer());



   ","
    ASSERT_EQ(FirstDataPointer, DataPointer);



    if (FirstDataPointer != SecondDataPointer ||

        FirstDataPointer != DataPointer) {

      break;

    }

  }

}

"
"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",unittests/Syntax/ThreadSafeCachingTests.cpp,+,"ASSERT_EQ(FirstDataPointer, DataPointer);","TEST(ThreadSafeCachingTests, ReturnGetExpression) {

  auto ReturnKW = SyntaxFactory::makeReturnKeyword({}, Trivia::spaces(1));

  auto Minus = SyntaxFactory::makePrefixOpereator(""-"", {});

  auto One = SyntaxFactory::makeIntegerLiteralToken(""1"", {}, {});

  auto MinusOne = SyntaxFactory::makeIntegerLiteralExpr(Minus, One);



  for (unsigned i = 0; i < 10000; ++i) {

    llvm::SmallString<48> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Return = SyntaxFactory::makeReturnStmt(ReturnKW, MinusOne);



    uintptr_t FirstDataPointer;

    uintptr_t SecondDataPointer;



    std::thread first(getExpressionFrom, Return, &FirstDataPointer);

    std::thread second(getExpressionFrom, Return, &SecondDataPointer);

    first.join();

    second.join();



    auto DataPointer = reinterpret_cast<uintptr_t>(

      Return.getExpression().getValue().getDataPointer());



    ASSERT_EQ(FirstDataPointer, SecondDataPointer);

    ASSERT_EQ(FirstDataPointer, DataPointer);



    if (FirstDataPointer != SecondDataPointer ||

        FirstDataPointer != DataPointer) {

      break;

    }

  }

}

","TEST(ThreadSafeCachingTests, ReturnGetExpression) {

  auto ReturnKW = SyntaxFactory::makeReturnKeyword({}, Trivia::spaces(1));

  auto Minus = SyntaxFactory::makePrefixOpereator(""-"", {});

  auto One = SyntaxFactory::makeIntegerLiteralToken(""1"", {}, {});

  auto MinusOne = SyntaxFactory::makeIntegerLiteralExpr(Minus, One);



  for (unsigned i = 0; i < 10000; ++i) {

    llvm::SmallString<48> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Return = SyntaxFactory::makeReturnStmt(ReturnKW, MinusOne);



    uintptr_t FirstDataPointer;

    uintptr_t SecondDataPointer;



    std::thread first(getExpressionFrom, Return, &FirstDataPointer);

    std::thread second(getExpressionFrom, Return, &SecondDataPointer);

    first.join();

    second.join();



    auto DataPointer = reinterpret_cast<uintptr_t>(

      Return.getExpression().getValue().getDataPointer());



    ASSERT_EQ(FirstDataPointer, SecondDataPointer);

   ","


    if (FirstDataPointer != SecondDataPointer ||

        FirstDataPointer != DataPointer) {

      break;

    }

  }

}

"
"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",unittests/Syntax/ThreadSafeCachingTests.cpp,+,"ASSERT_EQ(FirstDataPointer, SecondDataPointer);","TEST(ThreadSafeCachingTests, ReturnGetExpression) {

  auto ReturnKW = SyntaxFactory::makeReturnKeyword({}, Trivia::spaces(1));

  auto Minus = SyntaxFactory::makePrefixOpereator(""-"", {});

  auto One = SyntaxFactory::makeIntegerLiteralToken(""1"", {}, {});

  auto MinusOne = SyntaxFactory::makeIntegerLiteralExpr(Minus, One);



  for (unsigned i = 0; i < 10000; ++i) {

    llvm::SmallString<48> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Return = SyntaxFactory::makeReturnStmt(ReturnKW, MinusOne);



    uintptr_t FirstDataPointer;

    uintptr_t SecondDataPointer;



    std::thread first(getExpressionFrom, Return, &FirstDataPointer);

    std::thread second(getExpressionFrom, Return, &SecondDataPointer);

    first.join();

    second.join();



    auto DataPointer = reinterpret_cast<uintptr_t>(

      Return.getExpression().getValue().getDataPointer());



    ASSERT_EQ(FirstDataPointer, SecondDataPointer);

    ASSERT_EQ(FirstDataPointer, DataPointer);



    if (FirstDataPointer != SecondDataPointer ||

        FirstDataPointer != DataPointer) {

      break;

    }

  }

}

","TEST(ThreadSafeCachingTests, ReturnGetExpression) {

  auto ReturnKW = SyntaxFactory::makeReturnKeyword({}, Trivia::spaces(1));

  auto Minus = SyntaxFactory::makePrefixOpereator(""-"", {});

  auto One = SyntaxFactory::makeIntegerLiteralToken(""1"", {}, {});

  auto MinusOne = SyntaxFactory::makeIntegerLiteralExpr(Minus, One);



  for (unsigned i = 0; i < 10000; ++i) {

    llvm::SmallString<48> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Return = SyntaxFactory::makeReturnStmt(ReturnKW, MinusOne);



    uintptr_t FirstDataPointer;

    uintptr_t SecondDataPointer;



    std::thread first(getExpressionFrom, Return, &FirstDataPointer);

    std::thread second(getExpressionFrom, Return, &SecondDataPointer);

    first.join();

    second.join();



    auto DataPointer = reinterpret_cast<uintptr_t>(

      Return.getExpression().getValue().getDataPointer());



   ","
    ASSERT_EQ(FirstDataPointer, DataPointer);



    if (FirstDataPointer != SecondDataPointer ||

        FirstDataPointer != DataPointer) {

      break;

    }

  }

}

"
"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",unittests/Syntax/ThreadSafeCachingTests.cpp,+,"ASSERT_EQ(FirstDataPointer, DataPointer);","TEST(ThreadSafeCachingTests, ReturnGetExpression) {

  auto ReturnKW = SyntaxFactory::makeReturnKeyword({}, Trivia::spaces(1));

  auto Minus = SyntaxFactory::makePrefixOpereator(""-"", {});

  auto One = SyntaxFactory::makeIntegerLiteralToken(""1"", {}, {});

  auto MinusOne = SyntaxFactory::makeIntegerLiteralExpr(Minus, One);



  for (unsigned i = 0; i < 10000; ++i) {

    llvm::SmallString<48> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Return = SyntaxFactory::makeReturnStmt(ReturnKW, MinusOne);



    uintptr_t FirstDataPointer;

    uintptr_t SecondDataPointer;



    std::thread first(getExpressionFrom, Return, &FirstDataPointer);

    std::thread second(getExpressionFrom, Return, &SecondDataPointer);

    first.join();

    second.join();



    auto DataPointer = reinterpret_cast<uintptr_t>(

      Return.getExpression().getValue().getDataPointer());



    ASSERT_EQ(FirstDataPointer, SecondDataPointer);

    ASSERT_EQ(FirstDataPointer, DataPointer);



    if (FirstDataPointer != SecondDataPointer ||

        FirstDataPointer != DataPointer) {

      break;

    }

  }

}

","TEST(ThreadSafeCachingTests, ReturnGetExpression) {

  auto ReturnKW = SyntaxFactory::makeReturnKeyword({}, Trivia::spaces(1));

  auto Minus = SyntaxFactory::makePrefixOpereator(""-"", {});

  auto One = SyntaxFactory::makeIntegerLiteralToken(""1"", {}, {});

  auto MinusOne = SyntaxFactory::makeIntegerLiteralExpr(Minus, One);



  for (unsigned i = 0; i < 10000; ++i) {

    llvm::SmallString<48> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Return = SyntaxFactory::makeReturnStmt(ReturnKW, MinusOne);



    uintptr_t FirstDataPointer;

    uintptr_t SecondDataPointer;



    std::thread first(getExpressionFrom, Return, &FirstDataPointer);

    std::thread second(getExpressionFrom, Return, &SecondDataPointer);

    first.join();

    second.join();



    auto DataPointer = reinterpret_cast<uintptr_t>(

      Return.getExpression().getValue().getDataPointer());



    ASSERT_EQ(FirstDataPointer, SecondDataPointer);

   ","


    if (FirstDataPointer != SecondDataPointer ||

        FirstDataPointer != DataPointer) {

      break;

    }

  }

}

"
"Merge pull request #7683 from slavapestov/sema-generic-subscripts

Preliminary Sema support for generic subscripts",lib/Sema/CSRanking.cpp,-,"assert(!type1->is<GenericFunctionType>() && ""Odd generic function type?"");","static bool isDeclAsSpecializedAs(TypeChecker &tc, DeclContext *dc,

                                  ValueDecl *decl1, ValueDecl *decl2) {



  if (tc.getLangOpts().DebugConstraintSolver) {

    auto &log = tc.Context.TypeCheckerDebug->getStream();

    log << ""Comparing declarations\n"";

    decl1->print(log); 

    log << ""\nand\n"";

    decl2->print(log);

    log << ""\n"";

  }



  if (!tc.specializedOverloadComparisonCache.count({decl1, decl2})) {



    auto compareSpecializations = [&] () -> bool {

      // If the kinds are different, there's nothing we can do.

      // FIXME: This is wrong for type declarations, which we're skipping

      // entirely.

      if (decl1->getKind() != decl2->getKind() || isa<TypeDecl>(decl1))

        return false;



      // A non-generic declaration is more specialized than a generic declaration.

      if (auto func1 = dyn_cast<AbstractFunctionDecl>(decl1)) {

        auto func2 = cast<AbstractFunctionDecl>(decl2);

        if (func1->isGeneric() != func2->isGeneric())

          return func2->isGeneric();

      }



      if (auto subscript1 = dyn_cast<SubscriptDecl>(decl1)) {

        auto subscript2 = cast<SubscriptDecl>(decl2);

        if (subscript1->isGeneric() != subscript2->isGeneric())

          return subscript2->isGeneric();

      }



      // A witness is always more specialized than the requirement it satisfies.

      switch (compareWitnessAndRequirement(tc, dc, decl1, decl2)) {

      case Comparison::Unordered:

        break;



      case Comparison::Better:

        return true;



      case Comparison::Worse:

        return false;

      }



      // Members of protocol extensions have special overloading rules.

      ProtocolDecl *inProtocolExtension1 = decl1->getDeclContext()

                                             ->getAsProtocolExtensionContext();

      ProtocolDecl *inProtocolExtension2 = decl2->getDeclContext()

                                             ->getAsProtocolExtensionContext();

      if (inProtocolExtension1 && inProtocolExtension2) {

        // Both members are in protocol extensions.

        // Determine whether the 'Self' type from the first protocol extension

        // satisfies all of the requirements of the second protocol extension.

        DeclContext *dc1 = decl1->getDeclContext();

        DeclContext *dc2 = decl2->getDeclContext();

        bool better1 = isProtocolExtensionAsSpecializedAs(tc, dc1, dc2);

        bool better2 = isProtocolExtensionAsSpecializedAs(tc, dc2, dc1);

        if (better1 != better2) {

          return better1;

        }

      } else if (inProtocolExtension1 || inProtocolExtension2) {

        // One member is in a protocol extension, the other is in a concrete type.

        // Prefer the member in the concrete type.

        return inProtocolExtension2;

      }



      Type type1 = decl1->getInterfaceType();

      Type type2 = decl2->getInterfaceType();



      /// What part of the type should we check?

      enum {

        CheckAll,

        CheckInput,

      } checkKind;

      if (isa<AbstractFunctionDecl>(decl1) || isa<EnumElementDecl>(decl1)) {

        // Nothing to do: these have the curried 'self' already.

        if (auto elt = dyn_cast<EnumElementDecl>(decl1)) {

          checkKind = elt->getArgumentInterfaceType() ? CheckInput : CheckAll;

        } else {

          checkKind = CheckInput;

        }

      } else {

        // Add a curried 'self' type.

        type1 = addCurriedSelfType(tc.Context, type1, decl1->getDeclContext());

        type2 = addCurriedSelfType(tc.Context, type2, decl2->getDeclContext());



        // For a subscript declaration, only look at the input type (i.e., the

        // indices).

        if (isa<SubscriptDecl>(decl1))

          checkKind = CheckInput;

        else

          checkKind = CheckAll;

      }



      // Construct a constraint system to compare the two declarations.

      ConstraintSystem cs(tc, dc, ConstraintSystemOptions());



      auto locator = cs.getConstraintLocator(nullptr);

      // FIXME: Locator when anchored on a declaration.

      // Get the type of a reference to the second declaration.

      llvm::DenseMap<CanType, TypeVariableType *> unused;

      Type openedType2;

      if (auto *funcType = type2->getAs<AnyFunctionType>()) {

        openedType2 = cs.openFunctionType(

            funcType, /*numArgumentLabelsToRemove=*/0, locator,

            /*replacements=*/unused,

            decl2->getInnermostDeclContext(),

            decl2->getDeclContext(),

            /*skipProtocolSelfConstraint=*/false);

      } else {

        openedType2 = cs.openType(type2, locator, unused);

      }



      // Get the type of a reference to the first declaration, swapping in

      // archetypes for the dependent types.

      llvm::DenseMap<CanType, TypeVariableType *> replacements;

      auto dc1 = decl1->getInnermostDeclContext();

      Type openedType1;

      if (auto *funcType = type1->getAs<AnyFunctionType>()) {

        openedType1 = cs.openFunctionType(

            funcType, /*numArgumentLabelsToRemove=*/0, locator,

            replacements,

            dc1,

            decl1->getDeclContext(),

            /*skipProtocolSelfConstraint=*/false);

      } else {

        openedType1 = cs.openType(type1, locator, replacements);

      }



      for (const auto &replacement : replacements) {

        if (auto mapped = dc1->mapTypeIntoContext(replacement.first)) {

          cs.addConstraint(ConstraintKind::Bind, replacement.second, mapped,

                           locator);

        }

      }



      // Extract the self types from the declarations, if they have them.

      Type selfTy1;

      Type selfTy2;

      if (decl1->getDeclContext()->isTypeContext()) {

        auto funcTy1 = openedType1->castTo<FunctionType>();

        selfTy1 = funcTy1->getInput()->getRValueInstanceType();

        openedType1 = funcTy1->getResult();

      }

      if (decl2->getDeclContext()->isTypeContext()) {

        auto funcTy2 = openedType2->castTo<FunctionType>();

        selfTy2 = funcTy2->getInput()->getRValueInstanceType();

        openedType2 = funcTy2->getResult();

      }

      

      // Determine the relationship between the 'self' types and add the

      // appropriate constraints. The constraints themselves never fail, but

      // they help deduce type variables that were opened.

      switch (computeSelfTypeRelationship(tc, dc, decl1->getDeclContext(),

                                          decl2->getDeclContext())) {

      case SelfTypeRelationship::Unrelated:

        // Skip the self types parameter entirely.

        break;



      case SelfTypeRelationship::Equivalent:

        cs.addConstraint(ConstraintKind::Equal, selfTy1, selfTy2, locator);

        break;



      case SelfTypeRelationship::Subclass:

        cs.addConstraint(ConstraintKind::Subtype, selfTy1, selfTy2, locator);

        break;



      case SelfTypeRelationship::Superclass:

        cs.addConstraint(ConstraintKind::Subtype, selfTy2, selfTy1, locator);

        break;



      case SelfTypeRelationship::ConformsTo:

        cs.addConstraint(ConstraintKind::ConformsTo, selfTy1,

                         cast<ProtocolDecl>(decl2->getDeclContext())

                           ->getDeclaredType(),

                         locator);

        break;



      case SelfTypeRelationship::ConformedToBy:

        cs.addConstraint(ConstraintKind::ConformsTo, selfTy2,

                         cast<ProtocolDecl>(decl1->getDeclContext())

                           ->getDeclaredType(),

                         locator);

        break;

      }



      bool fewerEffectiveParameters = false;

      switch (checkKind) {

      case CheckAll:

        // Check whether the first type is a subtype of the second.

        cs.addConstraint(ConstraintKind::Subtype,

                         openedType1,

                         openedType2,

                         locator);

        break;



      case CheckInput: {

        // Check whether the first function type's input is a subtype of the

        // second type's inputs, i.e., can we forward the arguments?

        auto funcTy1 = openedType1->castTo<FunctionType>();

        auto funcTy2 = openedType2->castTo<FunctionType>();

        SmallVector<CallArgParam, 4> params1 =

          decomposeParamType(funcTy1->getInput(), decl1,

                             decl1->getDeclContext()->isTypeContext());

        SmallVector<CallArgParam, 4> params2 =

          decomposeParamType(funcTy2->getInput(), decl2,

                             decl2->getDeclContext()->isTypeContext());



        unsigned numParams1 = params1.size();

        unsigned numParams2 = params2.size();

        if (numParams1 > numParams2) return false;



        for (unsigned i = 0; i != numParams2; ++i) {

          // If there is no corresponding argument in the first

          // parameter list...

          if (i >= numParams1) {

            // We need either a default argument or a variadic

            // argument for the first declaration to be more

            // specialized.

            if (!params2[i].HasDefaultArgument &&

                !params2[i].isVariadic())

              return false;



            fewerEffectiveParameters = true;

            continue;

          }



          // If one parameter is variadic and the other is not...

          if (params1[i].isVariadic() != params2[i].isVariadic()) {

            // If the first parameter is the variadic one, it's not

            // more specialized.

            if (params1[i].isVariadic()) return false;



            fewerEffectiveParameters = true;

          }



          // Check whether the first parameter is a subtype of the second.

          cs.addConstraint(ConstraintKind::Subtype,

                           params1[i].Ty, params2[i].Ty, locator);

        }



        break;

      }

      }



      // Solve the system.

      auto solution = cs.solveSingle(FreeTypeVariableBinding::Allow);



      // Ban value-to-optional conversions.

      if (solution && solution->getFixedScore().Data[SK_ValueToOptional] == 0)

        return true;



      // If the first function has fewer effective parameters than the

      // second, it is more specialized.

      if (fewerEffectiveParameters) return true;



      return false;

    };



    tc.specializedOverloadComparisonCache[{decl1, decl2}] = 

        compareSpecializations();

  } else if (tc.getLangOpts().DebugConstraintSolver) {

    auto &log = tc.Context.TypeCheckerDebug->getStream();

    log << ""Found cached comparison: "" 

        << tc.specializedOverloadComparisonCache[{decl1, decl2}] << ""\n"";

  }



  return tc.specializedOverloadComparisonCache[{decl1, decl2}];

}

","static bool isDeclAsSpecializedAs(TypeChecker &tc, DeclContext *dc,

                                  ValueDecl *decl1, ValueDecl *decl2) {



  if (tc.getLangOpts().DebugConstraintSolver) {

    auto &log = tc.Context.TypeCheckerDebug->getStream();

    log << ""Comparing declarations\n"";

    decl1->print(log); 

    log << ""\nand\n"";

    decl2->print(log);

    log << ""\n"";

  }



  if (!tc.specializedOverloadComparisonCache.count({decl1, decl2})) {



    auto compareSpecializations = [&] () -> bool {

      // If the kinds are different, there's nothing we can do.

      // FIXME: This is wrong for type declarations, which we're skipping

      // entirely.

      if (decl1->getKind() != decl2->getKind() || isa<TypeDecl>(decl1))

        return false;



      // A non-generic declaration is more specialized than a generic declaration.

      if (auto func1 = dyn_cast<AbstractFunctionDecl>(decl1)) {

        auto func2 = cast<AbstractFunctionDecl>(decl2);

        if (func1->isGeneric() != func2->isGeneric())

          return func2->isGeneric();

      }



      if (auto subscript1 = dyn_cast<SubscriptDecl>(decl1)) {

        auto subscript2 = cast<SubscriptDecl>(decl2);

        if (subscript1->isGeneric() != subscript2->isGeneric())

          return subscript2->isGeneric();

      }



      // A witness is always more specialized than the requirement it satisfies.

      switch (compareWitnessAndRequirement(tc, dc, decl1, decl2)) {

      case Comparison::Unordered:

        break;



      case Comparison::Better:

        return true;



      case Comparison::Worse:
","        return false;

      }



      // Members of protocol extensions have special overloading rules.

      ProtocolDecl *inProtocolExtension1 = decl1->getDeclContext()

                                             ->getAsProtocolExtensionContext();

      ProtocolDecl *inProtocolExtension2 = decl2->getDeclContext()

                                             ->getAsProtocolExtensionContext();

      if (inProtocolExtension1 && inProtocolExtension2) {

        // Both members are in protocol extensions.

        // Determine whether the 'Self' type from the first protocol extension

        // satisfies all of the requirements of the second protocol extension.

        DeclContext *dc1 = decl1->getDeclContext();

        DeclContext *dc2 = decl2->getDeclContext();

        bool better1 = isProtocolExtensionAsSpecializedAs(tc, dc1, dc2);

        bool better2 = isProtocolExtensionAsSpecializedAs(tc, dc2, dc1);

        if (better1 != better2) {

          return better1;

        }

      } else if (inProtocolExtension1 || inProtocolExtension2) {

        // One member is in a protocol extension, the other is in a concrete type.

        // Prefer the member in the concrete type.

        return inProtocolExtension2;

      }



      Type type1 = decl1->getInterfaceType();

      Type type2 = decl2->getInterfaceType();



      /// What part of the type should we check?

      enum {

        CheckAll,

        CheckInput,

      } checkKind;

      if (isa<AbstractFunctionDecl>(decl1) || isa<EnumElementDecl>(decl1)) {

        // Nothing to do: these have the curried 'self' already.

        if (auto elt = dyn_cast<EnumElementDecl>(decl1)) {

          checkKind = elt->getArgumentInterfaceType() ? CheckInput : CheckAll;

        } else {

          checkKind = CheckInput;

        }

      } else {

        // Add a curried 'self' type.

        type1 = addCurriedSelfType(tc.Context, type1, decl1->getDeclContext());

        type2 = addCurriedSelfType(tc.Context, type2, decl2->getDeclContext());



        // For a subscript declaration, only look at the input type (i.e., the

        // indices).

        if (isa<SubscriptDecl>(decl1))

          checkKind = CheckInput;

        else

          checkKind = CheckAll;

      }



      // Construct a constraint system to compare the two declarations.

      ConstraintSystem cs(tc, dc, ConstraintSystemOptions());



      auto locator = cs.getConstraintLocator(nullptr);

      // FIXME: Locator when anchored on a declaration.

      // Get the type of a reference to the second declaration.

      llvm::DenseMap<CanType, TypeVariableType *> unused;

      Type openedType2;

      if (auto *funcType = type2->getAs<AnyFunctionType>()) {

        openedType2 = cs.openFunctionType(

            funcType, /*numArgumentLabelsToRemove=*/0, locator,

            /*replacements=*/unused,

            decl2->getInnermostDeclContext(),

            decl2->getDeclContext(),

            /*skipProtocolSelfConstraint=*/false);

      } else {

        openedType2 = cs.openType(type2, locator, unused);

      }



      // Get the type of a reference to the first declaration, swapping in

      // archetypes for the dependent types.

      llvm::DenseMap<CanType, TypeVariableType *> replacements;

      auto dc1 = decl1->getInnermostDeclContext();

      Type openedType1;

      if (auto *funcType = type1->getAs<AnyFunctionType>()) {

        openedType1 = cs.openFunctionType(

            funcType, /*numArgumentLabelsToRemove=*/0, locator,

            replacements,

            dc1,

            decl1->getDeclContext(),

            /*skipProtocolSelfConstraint=*/false);

      } else {

        openedType1 = cs.openType(type1, locator, replacements);

      }



      for (const auto &replacement : replacements) {

        if (auto mapped = dc1->mapTypeIntoContext(replacement.first)) {

          cs.addConstraint(ConstraintKind::Bind, replacement.second, mapped,

                           locator);

        }

      }



      // Extract the self types from the declarations, if they have them.

      Type selfTy1;

      Type selfTy2;

      if (decl1->getDeclContext()->isTypeContext()) {

        auto funcTy1 = openedType1->castTo<FunctionType>();

        selfTy1 = funcTy1->getInput()->getRValueInstanceType();

        openedType1 = funcTy1->getResult();

      }

      if (decl2->getDeclContext()->isTypeContext()) {

        auto funcTy2 = openedType2->castTo<FunctionType>();

        selfTy2 = funcTy2->getInput()->getRValueInstanceType();

        openedType2 = funcTy2->getResult();

      }

      

      // Determine the relationship between the 'self' types and add the

      // appropriate constraints. The constraints themselves never fail, but

      // they help deduce type variables that were opened.

      switch (computeSelfTypeRelationship(tc, dc, decl1->getDeclContext(),

                                          decl2->getDeclContext())) {

      case SelfTypeRelationship::Unrelated:

        // Skip the self types parameter entirely.

        break;



      case SelfTypeRelationship::Equivalent:

        cs.addConstraint(ConstraintKind::Equal, selfTy1, selfTy2, locator);

        break;



      case SelfTypeRelationship::Subclass:

        cs.addConstraint(ConstraintKind::Subtype, selfTy1, selfTy2, locator);

        break;



      case SelfTypeRelationship::Superclass:

        cs.addConstraint(ConstraintKind::Subtype, selfTy2, selfTy1, locator);

        break;



      case SelfTypeRelationship::ConformsTo:

        cs.addConstraint(ConstraintKind::ConformsTo, selfTy1,

                         cast<ProtocolDecl>(decl2->getDeclContext())

                           ->getDeclaredType(),

                         locator);

        break;



      case SelfTypeRelationship::ConformedToBy:

        cs.addConstraint(ConstraintKind::ConformsTo, selfTy2,

                         cast<ProtocolDecl>(decl1->getDeclContext())

                           ->getDeclaredType(),

                         locator);

        break;

      }



      bool fewerEffectiveParameters = false;

      switch (checkKind) {

      case CheckAll:

        // Check whether the first type is a subtype of the second.

        cs.addConstraint(ConstraintKind::Subtype,

                         openedType1,

                         openedType2,

                         locator);

        break;



      case CheckInput: {

        // Check whether the first function type's input is a subtype of the

        // second type's inputs, i.e., can we forward the arguments?

        auto funcTy1 = openedType1->castTo<FunctionType>();

        auto funcTy2 = openedType2->castTo<FunctionType>();

        SmallVector<CallArgParam, 4> params1 =

          decomposeParamType(funcTy1->getInput(), decl1,

                             decl1->getDeclContext()->isTypeContext());

        SmallVector<CallArgParam, 4> params2 =

          decomposeParamType(funcTy2->getInput(), decl2,

                             decl2->getDeclContext()->isTypeContext());



        unsigned numParams1 = params1.size();

        unsigned numParams2 = params2.size();

        if (numParams1 > numParams2) return false;



        for (unsigned i = 0; i != numParams2; ++i) {

          // If there is no corresponding argument in the first

          // parameter list...

          if (i >= numParams1) {

            // We need either a default argument or a variadic

            // argument for the first declaration to be more

            // specialized.

            if (!params2[i].HasDefaultArgument &&

                !params2[i].isVariadic())

              return false;



            fewerEffectiveParameters = true;

            continue;

          }



          // If one parameter is variadic and the other is not...

          if (params1[i].isVariadic() != params2[i].isVariadic()) {

            // If the first parameter is the variadic one, it's not

            // more specialized.

            if (params1[i].isVariadic()) return false;



            fewerEffectiveParameters = true;

          }



          // Check whether the first parameter is a subtype of the second.

          cs.addConstraint(ConstraintKind::Subtype,

                           params1[i].Ty, params2[i].Ty, locator);

        }



        break;

      }

      }



      // Solve the system.

      auto solution = cs.solveSingle(FreeTypeVariableBinding::Allow);



      // Ban value-to-optional conversions.

      if (solution && solution->getFixedScore().Data[SK_ValueToOptional] == 0)

        return true;



      // If the first function has fewer effective parameters than the

      // second, it is more specialized.

      if (fewerEffectiveParameters) return true;



      return false;

    };



    tc.specializedOverloadComparisonCache[{decl1, decl2}] = 

        compareSpecializations();

  } else if (tc.getLangOpts().DebugConstraintSolver) {

    auto &log = tc.Context.TypeCheckerDebug->getStream();

    log << ""Found cached comparison: "" 

        << tc.specializedOverloadComparisonCache[{decl1, decl2}] << ""\n"";

  }



  return tc.specializedOverloadComparisonCache[{decl1, decl2}];

}


"
"Merge pull request #7683 from slavapestov/sema-generic-subscripts

Preliminary Sema support for generic subscripts",lib/Sema/CSRanking.cpp,-,"assert(!type2->is<GenericFunctionType>() && ""Odd generic function type?"");","static bool isDeclAsSpecializedAs(TypeChecker &tc, DeclContext *dc,

                                  ValueDecl *decl1, ValueDecl *decl2) {



  if (tc.getLangOpts().DebugConstraintSolver) {

    auto &log = tc.Context.TypeCheckerDebug->getStream();

    log << ""Comparing declarations\n"";

    decl1->print(log); 

    log << ""\nand\n"";

    decl2->print(log);

    log << ""\n"";

  }



  if (!tc.specializedOverloadComparisonCache.count({decl1, decl2})) {



    auto compareSpecializations = [&] () -> bool {

      // If the kinds are different, there's nothing we can do.

      // FIXME: This is wrong for type declarations, which we're skipping

      // entirely.

      if (decl1->getKind() != decl2->getKind() || isa<TypeDecl>(decl1))

        return false;



      // A non-generic declaration is more specialized than a generic declaration.

      if (auto func1 = dyn_cast<AbstractFunctionDecl>(decl1)) {

        auto func2 = cast<AbstractFunctionDecl>(decl2);

        if (func1->isGeneric() != func2->isGeneric())

          return func2->isGeneric();

      }



      if (auto subscript1 = dyn_cast<SubscriptDecl>(decl1)) {

        auto subscript2 = cast<SubscriptDecl>(decl2);

        if (subscript1->isGeneric() != subscript2->isGeneric())

          return subscript2->isGeneric();

      }



      // A witness is always more specialized than the requirement it satisfies.

      switch (compareWitnessAndRequirement(tc, dc, decl1, decl2)) {

      case Comparison::Unordered:

        break;



      case Comparison::Better:

        return true;



      case Comparison::Worse:

        return false;

      }



      // Members of protocol extensions have special overloading rules.

      ProtocolDecl *inProtocolExtension1 = decl1->getDeclContext()

                                             ->getAsProtocolExtensionContext();

      ProtocolDecl *inProtocolExtension2 = decl2->getDeclContext()

                                             ->getAsProtocolExtensionContext();

      if (inProtocolExtension1 && inProtocolExtension2) {

        // Both members are in protocol extensions.

        // Determine whether the 'Self' type from the first protocol extension

        // satisfies all of the requirements of the second protocol extension.

        DeclContext *dc1 = decl1->getDeclContext();

        DeclContext *dc2 = decl2->getDeclContext();

        bool better1 = isProtocolExtensionAsSpecializedAs(tc, dc1, dc2);

        bool better2 = isProtocolExtensionAsSpecializedAs(tc, dc2, dc1);

        if (better1 != better2) {

          return better1;

        }

      } else if (inProtocolExtension1 || inProtocolExtension2) {

        // One member is in a protocol extension, the other is in a concrete type.

        // Prefer the member in the concrete type.

        return inProtocolExtension2;

      }



      Type type1 = decl1->getInterfaceType();

      Type type2 = decl2->getInterfaceType();



      /// What part of the type should we check?

      enum {

        CheckAll,

        CheckInput,

      } checkKind;

      if (isa<AbstractFunctionDecl>(decl1) || isa<EnumElementDecl>(decl1)) {

        // Nothing to do: these have the curried 'self' already.

        if (auto elt = dyn_cast<EnumElementDecl>(decl1)) {

          checkKind = elt->getArgumentInterfaceType() ? CheckInput : CheckAll;

        } else {

          checkKind = CheckInput;

        }

      } else {

        // Add a curried 'self' type.

        type1 = addCurriedSelfType(tc.Context, type1, decl1->getDeclContext());

        type2 = addCurriedSelfType(tc.Context, type2, decl2->getDeclContext());



        // For a subscript declaration, only look at the input type (i.e., the

        // indices).

        if (isa<SubscriptDecl>(decl1))

          checkKind = CheckInput;

        else

          checkKind = CheckAll;

      }



      // Construct a constraint system to compare the two declarations.

      ConstraintSystem cs(tc, dc, ConstraintSystemOptions());



      auto locator = cs.getConstraintLocator(nullptr);

      // FIXME: Locator when anchored on a declaration.

      // Get the type of a reference to the second declaration.

      llvm::DenseMap<CanType, TypeVariableType *> unused;

      Type openedType2;

      if (auto *funcType = type2->getAs<AnyFunctionType>()) {

        openedType2 = cs.openFunctionType(

            funcType, /*numArgumentLabelsToRemove=*/0, locator,

            /*replacements=*/unused,

            decl2->getInnermostDeclContext(),

            decl2->getDeclContext(),

            /*skipProtocolSelfConstraint=*/false);

      } else {

        openedType2 = cs.openType(type2, locator, unused);

      }



      // Get the type of a reference to the first declaration, swapping in

      // archetypes for the dependent types.

      llvm::DenseMap<CanType, TypeVariableType *> replacements;

      auto dc1 = decl1->getInnermostDeclContext();

      Type openedType1;

      if (auto *funcType = type1->getAs<AnyFunctionType>()) {

        openedType1 = cs.openFunctionType(

            funcType, /*numArgumentLabelsToRemove=*/0, locator,

            replacements,

            dc1,

            decl1->getDeclContext(),

            /*skipProtocolSelfConstraint=*/false);

      } else {

        openedType1 = cs.openType(type1, locator, replacements);

      }



      for (const auto &replacement : replacements) {

        if (auto mapped = dc1->mapTypeIntoContext(replacement.first)) {

          cs.addConstraint(ConstraintKind::Bind, replacement.second, mapped,

                           locator);

        }

      }



      // Extract the self types from the declarations, if they have them.

      Type selfTy1;

      Type selfTy2;

      if (decl1->getDeclContext()->isTypeContext()) {

        auto funcTy1 = openedType1->castTo<FunctionType>();

        selfTy1 = funcTy1->getInput()->getRValueInstanceType();

        openedType1 = funcTy1->getResult();

      }

      if (decl2->getDeclContext()->isTypeContext()) {

        auto funcTy2 = openedType2->castTo<FunctionType>();

        selfTy2 = funcTy2->getInput()->getRValueInstanceType();

        openedType2 = funcTy2->getResult();

      }

      

      // Determine the relationship between the 'self' types and add the

      // appropriate constraints. The constraints themselves never fail, but

      // they help deduce type variables that were opened.

      switch (computeSelfTypeRelationship(tc, dc, decl1->getDeclContext(),

                                          decl2->getDeclContext())) {

      case SelfTypeRelationship::Unrelated:

        // Skip the self types parameter entirely.

        break;



      case SelfTypeRelationship::Equivalent:

        cs.addConstraint(ConstraintKind::Equal, selfTy1, selfTy2, locator);

        break;



      case SelfTypeRelationship::Subclass:

        cs.addConstraint(ConstraintKind::Subtype, selfTy1, selfTy2, locator);

        break;



      case SelfTypeRelationship::Superclass:

        cs.addConstraint(ConstraintKind::Subtype, selfTy2, selfTy1, locator);

        break;



      case SelfTypeRelationship::ConformsTo:

        cs.addConstraint(ConstraintKind::ConformsTo, selfTy1,

                         cast<ProtocolDecl>(decl2->getDeclContext())

                           ->getDeclaredType(),

                         locator);

        break;



      case SelfTypeRelationship::ConformedToBy:

        cs.addConstraint(ConstraintKind::ConformsTo, selfTy2,

                         cast<ProtocolDecl>(decl1->getDeclContext())

                           ->getDeclaredType(),

                         locator);

        break;

      }



      bool fewerEffectiveParameters = false;

      switch (checkKind) {

      case CheckAll:

        // Check whether the first type is a subtype of the second.

        cs.addConstraint(ConstraintKind::Subtype,

                         openedType1,

                         openedType2,

                         locator);

        break;



      case CheckInput: {

        // Check whether the first function type's input is a subtype of the

        // second type's inputs, i.e., can we forward the arguments?

        auto funcTy1 = openedType1->castTo<FunctionType>();

        auto funcTy2 = openedType2->castTo<FunctionType>();

        SmallVector<CallArgParam, 4> params1 =

          decomposeParamType(funcTy1->getInput(), decl1,

                             decl1->getDeclContext()->isTypeContext());

        SmallVector<CallArgParam, 4> params2 =

          decomposeParamType(funcTy2->getInput(), decl2,

                             decl2->getDeclContext()->isTypeContext());



        unsigned numParams1 = params1.size();

        unsigned numParams2 = params2.size();

        if (numParams1 > numParams2) return false;



        for (unsigned i = 0; i != numParams2; ++i) {

          // If there is no corresponding argument in the first

          // parameter list...

          if (i >= numParams1) {

            // We need either a default argument or a variadic

            // argument for the first declaration to be more

            // specialized.

            if (!params2[i].HasDefaultArgument &&

                !params2[i].isVariadic())

              return false;



            fewerEffectiveParameters = true;

            continue;

          }



          // If one parameter is variadic and the other is not...

          if (params1[i].isVariadic() != params2[i].isVariadic()) {

            // If the first parameter is the variadic one, it's not

            // more specialized.

            if (params1[i].isVariadic()) return false;



            fewerEffectiveParameters = true;

          }



          // Check whether the first parameter is a subtype of the second.

          cs.addConstraint(ConstraintKind::Subtype,

                           params1[i].Ty, params2[i].Ty, locator);

        }



        break;

      }

      }



      // Solve the system.

      auto solution = cs.solveSingle(FreeTypeVariableBinding::Allow);



      // Ban value-to-optional conversions.

      if (solution && solution->getFixedScore().Data[SK_ValueToOptional] == 0)

        return true;



      // If the first function has fewer effective parameters than the

      // second, it is more specialized.

      if (fewerEffectiveParameters) return true;



      return false;

    };



    tc.specializedOverloadComparisonCache[{decl1, decl2}] = 

        compareSpecializations();

  } else if (tc.getLangOpts().DebugConstraintSolver) {

    auto &log = tc.Context.TypeCheckerDebug->getStream();

    log << ""Found cached comparison: "" 

        << tc.specializedOverloadComparisonCache[{decl1, decl2}] << ""\n"";

  }



  return tc.specializedOverloadComparisonCache[{decl1, decl2}];

}

","static bool isDeclAsSpecializedAs(TypeChecker &tc, DeclContext *dc,

                                  ValueDecl *decl1, ValueDecl *decl2) {



  if (tc.getLangOpts().DebugConstraintSolver) {

    auto &log = tc.Context.TypeCheckerDebug->getStream();

    log << ""Comparing declarations\n"";

    decl1->print(log); 

    log << ""\nand\n"";

    decl2->print(log);

    log << ""\n"";

  }



  if (!tc.specializedOverloadComparisonCache.count({decl1, decl2})) {



    auto compareSpecializations = [&] () -> bool {

      // If the kinds are different, there's nothing we can do.

      // FIXME: This is wrong for type declarations, which we're skipping

      // entirely.

      if (decl1->getKind() != decl2->getKind() || isa<TypeDecl>(decl1))

        return false;



      // A non-generic declaration is more specialized than a generic declaration.

      if (auto func1 = dyn_cast<AbstractFunctionDecl>(decl1)) {

        auto func2 = cast<AbstractFunctionDecl>(decl2);

        if (func1->isGeneric() != func2->isGeneric())

          return func2->isGeneric();

      }



      if (auto subscript1 = dyn_cast<SubscriptDecl>(decl1)) {

        auto subscript2 = cast<SubscriptDecl>(decl2);

        if (subscript1->isGeneric() != subscript2->isGeneric())

          return subscript2->isGeneric();

      }



      // A witness is always more specialized than the requirement it satisfies.

      switch (compareWitnessAndRequirement(tc, dc, decl1, decl2)) {

      case Comparison::Unordered:

        break;



      case Comparison::Better:

        return true;



      case Comparison::Worse:
","        return false;

      }



      // Members of protocol extensions have special overloading rules.

      ProtocolDecl *inProtocolExtension1 = decl1->getDeclContext()

                                             ->getAsProtocolExtensionContext();

      ProtocolDecl *inProtocolExtension2 = decl2->getDeclContext()

                                             ->getAsProtocolExtensionContext();

      if (inProtocolExtension1 && inProtocolExtension2) {

        // Both members are in protocol extensions.

        // Determine whether the 'Self' type from the first protocol extension

        // satisfies all of the requirements of the second protocol extension.

        DeclContext *dc1 = decl1->getDeclContext();

        DeclContext *dc2 = decl2->getDeclContext();

        bool better1 = isProtocolExtensionAsSpecializedAs(tc, dc1, dc2);

        bool better2 = isProtocolExtensionAsSpecializedAs(tc, dc2, dc1);

        if (better1 != better2) {

          return better1;

        }

      } else if (inProtocolExtension1 || inProtocolExtension2) {

        // One member is in a protocol extension, the other is in a concrete type.

        // Prefer the member in the concrete type.

        return inProtocolExtension2;

      }



      Type type1 = decl1->getInterfaceType();

      Type type2 = decl2->getInterfaceType();



      /// What part of the type should we check?

      enum {

        CheckAll,

        CheckInput,

      } checkKind;

      if (isa<AbstractFunctionDecl>(decl1) || isa<EnumElementDecl>(decl1)) {

        // Nothing to do: these have the curried 'self' already.

        if (auto elt = dyn_cast<EnumElementDecl>(decl1)) {

          checkKind = elt->getArgumentInterfaceType() ? CheckInput : CheckAll;

        } else {

          checkKind = CheckInput;

        }

      } else {

        // Add a curried 'self' type.

        type1 = addCurriedSelfType(tc.Context, type1, decl1->getDeclContext());

        type2 = addCurriedSelfType(tc.Context, type2, decl2->getDeclContext());



        // For a subscript declaration, only look at the input type (i.e., the

        // indices).

        if (isa<SubscriptDecl>(decl1))

          checkKind = CheckInput;

        else

          checkKind = CheckAll;

      }



      // Construct a constraint system to compare the two declarations.

      ConstraintSystem cs(tc, dc, ConstraintSystemOptions());



      auto locator = cs.getConstraintLocator(nullptr);

      // FIXME: Locator when anchored on a declaration.

      // Get the type of a reference to the second declaration.

      llvm::DenseMap<CanType, TypeVariableType *> unused;

      Type openedType2;

      if (auto *funcType = type2->getAs<AnyFunctionType>()) {

        openedType2 = cs.openFunctionType(

            funcType, /*numArgumentLabelsToRemove=*/0, locator,

            /*replacements=*/unused,

            decl2->getInnermostDeclContext(),

            decl2->getDeclContext(),

            /*skipProtocolSelfConstraint=*/false);

      } else {

        openedType2 = cs.openType(type2, locator, unused);

      }



      // Get the type of a reference to the first declaration, swapping in

      // archetypes for the dependent types.

      llvm::DenseMap<CanType, TypeVariableType *> replacements;

      auto dc1 = decl1->getInnermostDeclContext();

      Type openedType1;

      if (auto *funcType = type1->getAs<AnyFunctionType>()) {

        openedType1 = cs.openFunctionType(

            funcType, /*numArgumentLabelsToRemove=*/0, locator,

            replacements,

            dc1,

            decl1->getDeclContext(),

            /*skipProtocolSelfConstraint=*/false);

      } else {

        openedType1 = cs.openType(type1, locator, replacements);

      }



      for (const auto &replacement : replacements) {

        if (auto mapped = dc1->mapTypeIntoContext(replacement.first)) {

          cs.addConstraint(ConstraintKind::Bind, replacement.second, mapped,

                           locator);

        }

      }



      // Extract the self types from the declarations, if they have them.

      Type selfTy1;

      Type selfTy2;

      if (decl1->getDeclContext()->isTypeContext()) {

        auto funcTy1 = openedType1->castTo<FunctionType>();

        selfTy1 = funcTy1->getInput()->getRValueInstanceType();

        openedType1 = funcTy1->getResult();

      }

      if (decl2->getDeclContext()->isTypeContext()) {

        auto funcTy2 = openedType2->castTo<FunctionType>();

        selfTy2 = funcTy2->getInput()->getRValueInstanceType();

        openedType2 = funcTy2->getResult();

      }

      

      // Determine the relationship between the 'self' types and add the

      // appropriate constraints. The constraints themselves never fail, but

      // they help deduce type variables that were opened.

      switch (computeSelfTypeRelationship(tc, dc, decl1->getDeclContext(),

                                          decl2->getDeclContext())) {

      case SelfTypeRelationship::Unrelated:

        // Skip the self types parameter entirely.

        break;



      case SelfTypeRelationship::Equivalent:

        cs.addConstraint(ConstraintKind::Equal, selfTy1, selfTy2, locator);

        break;



      case SelfTypeRelationship::Subclass:

        cs.addConstraint(ConstraintKind::Subtype, selfTy1, selfTy2, locator);

        break;



      case SelfTypeRelationship::Superclass:

        cs.addConstraint(ConstraintKind::Subtype, selfTy2, selfTy1, locator);

        break;



      case SelfTypeRelationship::ConformsTo:

        cs.addConstraint(ConstraintKind::ConformsTo, selfTy1,

                         cast<ProtocolDecl>(decl2->getDeclContext())

                           ->getDeclaredType(),

                         locator);

        break;



      case SelfTypeRelationship::ConformedToBy:

        cs.addConstraint(ConstraintKind::ConformsTo, selfTy2,

                         cast<ProtocolDecl>(decl1->getDeclContext())

                           ->getDeclaredType(),

                         locator);

        break;

      }



      bool fewerEffectiveParameters = false;

      switch (checkKind) {

      case CheckAll:

        // Check whether the first type is a subtype of the second.

        cs.addConstraint(ConstraintKind::Subtype,

                         openedType1,

                         openedType2,

                         locator);

        break;



      case CheckInput: {

        // Check whether the first function type's input is a subtype of the

        // second type's inputs, i.e., can we forward the arguments?

        auto funcTy1 = openedType1->castTo<FunctionType>();

        auto funcTy2 = openedType2->castTo<FunctionType>();

        SmallVector<CallArgParam, 4> params1 =

          decomposeParamType(funcTy1->getInput(), decl1,

                             decl1->getDeclContext()->isTypeContext());

        SmallVector<CallArgParam, 4> params2 =

          decomposeParamType(funcTy2->getInput(), decl2,

                             decl2->getDeclContext()->isTypeContext());



        unsigned numParams1 = params1.size();

        unsigned numParams2 = params2.size();

        if (numParams1 > numParams2) return false;



        for (unsigned i = 0; i != numParams2; ++i) {

          // If there is no corresponding argument in the first

          // parameter list...

          if (i >= numParams1) {

            // We need either a default argument or a variadic

            // argument for the first declaration to be more

            // specialized.

            if (!params2[i].HasDefaultArgument &&

                !params2[i].isVariadic())

              return false;



            fewerEffectiveParameters = true;

            continue;

          }



          // If one parameter is variadic and the other is not...

          if (params1[i].isVariadic() != params2[i].isVariadic()) {

            // If the first parameter is the variadic one, it's not

            // more specialized.

            if (params1[i].isVariadic()) return false;



            fewerEffectiveParameters = true;

          }



          // Check whether the first parameter is a subtype of the second.

          cs.addConstraint(ConstraintKind::Subtype,

                           params1[i].Ty, params2[i].Ty, locator);

        }



        break;

      }

      }



      // Solve the system.

      auto solution = cs.solveSingle(FreeTypeVariableBinding::Allow);



      // Ban value-to-optional conversions.

      if (solution && solution->getFixedScore().Data[SK_ValueToOptional] == 0)

        return true;



      // If the first function has fewer effective parameters than the

      // second, it is more specialized.

      if (fewerEffectiveParameters) return true;



      return false;

    };



    tc.specializedOverloadComparisonCache[{decl1, decl2}] = 

        compareSpecializations();

  } else if (tc.getLangOpts().DebugConstraintSolver) {

    auto &log = tc.Context.TypeCheckerDebug->getStream();

    log << ""Found cached comparison: "" 

        << tc.specializedOverloadComparisonCache[{decl1, decl2}] << ""\n"";

  }



  return tc.specializedOverloadComparisonCache[{decl1, decl2}];

}


"
"Sema: Fix CSRanking in preparation for generic subscripts

Subscripts in generic context will soon have a
GenericFunctionType, so get ready to handle that.",lib/Sema/CSRanking.cpp,-,"assert(!type1->is<GenericFunctionType>() && ""Odd generic function type?"");","static bool isDeclAsSpecializedAs(TypeChecker &tc, DeclContext *dc,

                                  ValueDecl *decl1, ValueDecl *decl2) {



  if (tc.getLangOpts().DebugConstraintSolver) {

    auto &log = tc.Context.TypeCheckerDebug->getStream();

    log << ""Comparing declarations\n"";

    decl1->print(log); 

    log << ""\nand\n"";

    decl2->print(log);

    log << ""\n"";

  }



  if (!tc.specializedOverloadComparisonCache.count({decl1, decl2})) {



    auto compareSpecializations = [&] () -> bool {

      // If the kinds are different, there's nothing we can do.

      // FIXME: This is wrong for type declarations, which we're skipping

      // entirely.

      if (decl1->getKind() != decl2->getKind() || isa<TypeDecl>(decl1))

        return false;



      // A non-generic declaration is more specialized than a generic declaration.

      if (auto func1 = dyn_cast<AbstractFunctionDecl>(decl1)) {

        auto func2 = cast<AbstractFunctionDecl>(decl2);

        if (func1->isGeneric() != func2->isGeneric())

          return func2->isGeneric();

      }



      if (auto subscript1 = dyn_cast<SubscriptDecl>(decl1)) {

        auto subscript2 = cast<SubscriptDecl>(decl2);

        if (subscript1->isGeneric() != subscript2->isGeneric())

          return subscript2->isGeneric();

      }



      // A witness is always more specialized than the requirement it satisfies.

      switch (compareWitnessAndRequirement(tc, dc, decl1, decl2)) {

      case Comparison::Unordered:

        break;



      case Comparison::Better:

        return true;



      case Comparison::Worse:

        return false;

      }



      // Members of protocol extensions have special overloading rules.

      ProtocolDecl *inProtocolExtension1 = decl1->getDeclContext()

                                             ->getAsProtocolExtensionContext();

      ProtocolDecl *inProtocolExtension2 = decl2->getDeclContext()

                                             ->getAsProtocolExtensionContext();

      if (inProtocolExtension1 && inProtocolExtension2) {

        // Both members are in protocol extensions.

        // Determine whether the 'Self' type from the first protocol extension

        // satisfies all of the requirements of the second protocol extension.

        DeclContext *dc1 = decl1->getDeclContext();

        DeclContext *dc2 = decl2->getDeclContext();

        bool better1 = isProtocolExtensionAsSpecializedAs(tc, dc1, dc2);

        bool better2 = isProtocolExtensionAsSpecializedAs(tc, dc2, dc1);

        if (better1 != better2) {

          return better1;

        }

      } else if (inProtocolExtension1 || inProtocolExtension2) {

        // One member is in a protocol extension, the other is in a concrete type.

        // Prefer the member in the concrete type.

        return inProtocolExtension2;

      }



      Type type1 = decl1->getInterfaceType();

      Type type2 = decl2->getInterfaceType();



      /// What part of the type should we check?

      enum {

        CheckAll,

        CheckInput,

      } checkKind;

      if (isa<AbstractFunctionDecl>(decl1) || isa<EnumElementDecl>(decl1)) {

        // Nothing to do: these have the curried 'self' already.

        if (auto elt = dyn_cast<EnumElementDecl>(decl1)) {

          checkKind = elt->getArgumentInterfaceType() ? CheckInput : CheckAll;

        } else {

          checkKind = CheckInput;

        }

      } else {

        // Add a curried 'self' type.

        type1 = addCurriedSelfType(tc.Context, type1, decl1->getDeclContext());

        type2 = addCurriedSelfType(tc.Context, type2, decl2->getDeclContext());



        // For a subscript declaration, only look at the input type (i.e., the

        // indices).

        if (isa<SubscriptDecl>(decl1))

          checkKind = CheckInput;

        else

          checkKind = CheckAll;

      }



      // Construct a constraint system to compare the two declarations.

      ConstraintSystem cs(tc, dc, ConstraintSystemOptions());



      auto locator = cs.getConstraintLocator(nullptr);

      // FIXME: Locator when anchored on a declaration.

      // Get the type of a reference to the second declaration.

      llvm::DenseMap<CanType, TypeVariableType *> unused;

      Type openedType2;

      if (auto *funcType = type2->getAs<AnyFunctionType>()) {

        openedType2 = cs.openFunctionType(

            funcType, /*numArgumentLabelsToRemove=*/0, locator,

            /*replacements=*/unused,

            decl2->getInnermostDeclContext(),

            decl2->getDeclContext(),

            /*skipProtocolSelfConstraint=*/false);

      } else {

        openedType2 = cs.openType(type2, locator, unused);

      }



      // Get the type of a reference to the first declaration, swapping in

      // archetypes for the dependent types.

      llvm::DenseMap<CanType, TypeVariableType *> replacements;

      auto dc1 = decl1->getInnermostDeclContext();

      Type openedType1;

      if (auto *funcType = type1->getAs<AnyFunctionType>()) {

        openedType1 = cs.openFunctionType(

            funcType, /*numArgumentLabelsToRemove=*/0, locator,

            replacements,

            dc1,

            decl1->getDeclContext(),

            /*skipProtocolSelfConstraint=*/false);

      } else {

        openedType1 = cs.openType(type1, locator, replacements);

      }



      for (const auto &replacement : replacements) {

        if (auto mapped = dc1->mapTypeIntoContext(replacement.first)) {

          cs.addConstraint(ConstraintKind::Bind, replacement.second, mapped,

                           locator);

        }

      }



      // Extract the self types from the declarations, if they have them.

      Type selfTy1;

      Type selfTy2;

      if (decl1->getDeclContext()->isTypeContext()) {

        auto funcTy1 = openedType1->castTo<FunctionType>();

        selfTy1 = funcTy1->getInput()->getRValueInstanceType();

        openedType1 = funcTy1->getResult();

      }

      if (decl2->getDeclContext()->isTypeContext()) {

        auto funcTy2 = openedType2->castTo<FunctionType>();

        selfTy2 = funcTy2->getInput()->getRValueInstanceType();

        openedType2 = funcTy2->getResult();

      }

      

      // Determine the relationship between the 'self' types and add the

      // appropriate constraints. The constraints themselves never fail, but

      // they help deduce type variables that were opened.

      switch (computeSelfTypeRelationship(tc, dc, decl1->getDeclContext(),

                                          decl2->getDeclContext())) {

      case SelfTypeRelationship::Unrelated:

        // Skip the self types parameter entirely.

        break;



      case SelfTypeRelationship::Equivalent:

        cs.addConstraint(ConstraintKind::Equal, selfTy1, selfTy2, locator);

        break;



      case SelfTypeRelationship::Subclass:

        cs.addConstraint(ConstraintKind::Subtype, selfTy1, selfTy2, locator);

        break;



      case SelfTypeRelationship::Superclass:

        cs.addConstraint(ConstraintKind::Subtype, selfTy2, selfTy1, locator);

        break;



      case SelfTypeRelationship::ConformsTo:

        cs.addConstraint(ConstraintKind::ConformsTo, selfTy1,

                         cast<ProtocolDecl>(decl2->getDeclContext())

                           ->getDeclaredType(),

                         locator);

        break;



      case SelfTypeRelationship::ConformedToBy:

        cs.addConstraint(ConstraintKind::ConformsTo, selfTy2,

                         cast<ProtocolDecl>(decl1->getDeclContext())

                           ->getDeclaredType(),

                         locator);

        break;

      }



      bool fewerEffectiveParameters = false;

      switch (checkKind) {

      case CheckAll:

        // Check whether the first type is a subtype of the second.

        cs.addConstraint(ConstraintKind::Subtype,

                         openedType1,

                         openedType2,

                         locator);

        break;



      case CheckInput: {

        // Check whether the first function type's input is a subtype of the

        // second type's inputs, i.e., can we forward the arguments?

        auto funcTy1 = openedType1->castTo<FunctionType>();

        auto funcTy2 = openedType2->castTo<FunctionType>();

        SmallVector<CallArgParam, 4> params1 =

          decomposeParamType(funcTy1->getInput(), decl1,

                             decl1->getDeclContext()->isTypeContext());

        SmallVector<CallArgParam, 4> params2 =

          decomposeParamType(funcTy2->getInput(), decl2,

                             decl2->getDeclContext()->isTypeContext());



        unsigned numParams1 = params1.size();

        unsigned numParams2 = params2.size();

        if (numParams1 > numParams2) return false;



        for (unsigned i = 0; i != numParams2; ++i) {

          // If there is no corresponding argument in the first

          // parameter list...

          if (i >= numParams1) {

            // We need either a default argument or a variadic

            // argument for the first declaration to be more

            // specialized.

            if (!params2[i].HasDefaultArgument &&

                !params2[i].isVariadic())

              return false;



            fewerEffectiveParameters = true;

            continue;

          }



          // If one parameter is variadic and the other is not...

          if (params1[i].isVariadic() != params2[i].isVariadic()) {

            // If the first parameter is the variadic one, it's not

            // more specialized.

            if (params1[i].isVariadic()) return false;



            fewerEffectiveParameters = true;

          }



          // Check whether the first parameter is a subtype of the second.

          cs.addConstraint(ConstraintKind::Subtype,

                           params1[i].Ty, params2[i].Ty, locator);

        }



        break;

      }

      }



      // Solve the system.

      auto solution = cs.solveSingle(FreeTypeVariableBinding::Allow);



      // Ban value-to-optional conversions.

      if (solution && solution->getFixedScore().Data[SK_ValueToOptional] == 0)

        return true;



      // If the first function has fewer effective parameters than the

      // second, it is more specialized.

      if (fewerEffectiveParameters) return true;



      return false;

    };



    tc.specializedOverloadComparisonCache[{decl1, decl2}] = 

        compareSpecializations();

  } else if (tc.getLangOpts().DebugConstraintSolver) {

    auto &log = tc.Context.TypeCheckerDebug->getStream();

    log << ""Found cached comparison: "" 

        << tc.specializedOverloadComparisonCache[{decl1, decl2}] << ""\n"";

  }



  return tc.specializedOverloadComparisonCache[{decl1, decl2}];

}

","static bool isDeclAsSpecializedAs(TypeChecker &tc, DeclContext *dc,

                                  ValueDecl *decl1, ValueDecl *decl2) {



  if (tc.getLangOpts().DebugConstraintSolver) {

    auto &log = tc.Context.TypeCheckerDebug->getStream();

    log << ""Comparing declarations\n"";

    decl1->print(log); 

    log << ""\nand\n"";

    decl2->print(log);

    log << ""\n"";

  }



  if (!tc.specializedOverloadComparisonCache.count({decl1, decl2})) {



    auto compareSpecializations = [&] () -> bool {

      // If the kinds are different, there's nothing we can do.

      // FIXME: This is wrong for type declarations, which we're skipping

      // entirely.

      if (decl1->getKind() != decl2->getKind() || isa<TypeDecl>(decl1))

        return false;



      // A non-generic declaration is more specialized than a generic declaration.

      if (auto func1 = dyn_cast<AbstractFunctionDecl>(decl1)) {

        auto func2 = cast<AbstractFunctionDecl>(decl2);

        if (func1->isGeneric() != func2->isGeneric())

          return func2->isGeneric();

      }



      if (auto subscript1 = dyn_cast<SubscriptDecl>(decl1)) {

        auto subscript2 = cast<SubscriptDecl>(decl2);

        if (subscript1->isGeneric() != subscript2->isGeneric())

          return subscript2->isGeneric();

      }



      // A witness is always more specialized than the requirement it satisfies.

      switch (compareWitnessAndRequirement(tc, dc, decl1, decl2)) {

      case Comparison::Unordered:

        break;



      case Comparison::Better:

        return true;



      case Comparison::Worse:
","        return false;

      }



      // Members of protocol extensions have special overloading rules.

      ProtocolDecl *inProtocolExtension1 = decl1->getDeclContext()

                                             ->getAsProtocolExtensionContext();

      ProtocolDecl *inProtocolExtension2 = decl2->getDeclContext()

                                             ->getAsProtocolExtensionContext();

      if (inProtocolExtension1 && inProtocolExtension2) {

        // Both members are in protocol extensions.

        // Determine whether the 'Self' type from the first protocol extension

        // satisfies all of the requirements of the second protocol extension.

        DeclContext *dc1 = decl1->getDeclContext();

        DeclContext *dc2 = decl2->getDeclContext();

        bool better1 = isProtocolExtensionAsSpecializedAs(tc, dc1, dc2);

        bool better2 = isProtocolExtensionAsSpecializedAs(tc, dc2, dc1);

        if (better1 != better2) {

          return better1;

        }

      } else if (inProtocolExtension1 || inProtocolExtension2) {

        // One member is in a protocol extension, the other is in a concrete type.

        // Prefer the member in the concrete type.

        return inProtocolExtension2;

      }



      Type type1 = decl1->getInterfaceType();

      Type type2 = decl2->getInterfaceType();



      /// What part of the type should we check?

      enum {

        CheckAll,

        CheckInput,

      } checkKind;

      if (isa<AbstractFunctionDecl>(decl1) || isa<EnumElementDecl>(decl1)) {

        // Nothing to do: these have the curried 'self' already.

        if (auto elt = dyn_cast<EnumElementDecl>(decl1)) {

          checkKind = elt->getArgumentInterfaceType() ? CheckInput : CheckAll;

        } else {

          checkKind = CheckInput;

        }

      } else {

        // Add a curried 'self' type.

        type1 = addCurriedSelfType(tc.Context, type1, decl1->getDeclContext());

        type2 = addCurriedSelfType(tc.Context, type2, decl2->getDeclContext());



        // For a subscript declaration, only look at the input type (i.e., the

        // indices).

        if (isa<SubscriptDecl>(decl1))

          checkKind = CheckInput;

        else

          checkKind = CheckAll;

      }



      // Construct a constraint system to compare the two declarations.

      ConstraintSystem cs(tc, dc, ConstraintSystemOptions());



      auto locator = cs.getConstraintLocator(nullptr);

      // FIXME: Locator when anchored on a declaration.

      // Get the type of a reference to the second declaration.

      llvm::DenseMap<CanType, TypeVariableType *> unused;

      Type openedType2;

      if (auto *funcType = type2->getAs<AnyFunctionType>()) {

        openedType2 = cs.openFunctionType(

            funcType, /*numArgumentLabelsToRemove=*/0, locator,

            /*replacements=*/unused,

            decl2->getInnermostDeclContext(),

            decl2->getDeclContext(),

            /*skipProtocolSelfConstraint=*/false);

      } else {

        openedType2 = cs.openType(type2, locator, unused);

      }



      // Get the type of a reference to the first declaration, swapping in

      // archetypes for the dependent types.

      llvm::DenseMap<CanType, TypeVariableType *> replacements;

      auto dc1 = decl1->getInnermostDeclContext();

      Type openedType1;

      if (auto *funcType = type1->getAs<AnyFunctionType>()) {

        openedType1 = cs.openFunctionType(

            funcType, /*numArgumentLabelsToRemove=*/0, locator,

            replacements,

            dc1,

            decl1->getDeclContext(),

            /*skipProtocolSelfConstraint=*/false);

      } else {

        openedType1 = cs.openType(type1, locator, replacements);

      }



      for (const auto &replacement : replacements) {

        if (auto mapped = dc1->mapTypeIntoContext(replacement.first)) {

          cs.addConstraint(ConstraintKind::Bind, replacement.second, mapped,

                           locator);

        }

      }



      // Extract the self types from the declarations, if they have them.

      Type selfTy1;

      Type selfTy2;

      if (decl1->getDeclContext()->isTypeContext()) {

        auto funcTy1 = openedType1->castTo<FunctionType>();

        selfTy1 = funcTy1->getInput()->getRValueInstanceType();

        openedType1 = funcTy1->getResult();

      }

      if (decl2->getDeclContext()->isTypeContext()) {

        auto funcTy2 = openedType2->castTo<FunctionType>();

        selfTy2 = funcTy2->getInput()->getRValueInstanceType();

        openedType2 = funcTy2->getResult();

      }

      

      // Determine the relationship between the 'self' types and add the

      // appropriate constraints. The constraints themselves never fail, but

      // they help deduce type variables that were opened.

      switch (computeSelfTypeRelationship(tc, dc, decl1->getDeclContext(),

                                          decl2->getDeclContext())) {

      case SelfTypeRelationship::Unrelated:

        // Skip the self types parameter entirely.

        break;



      case SelfTypeRelationship::Equivalent:

        cs.addConstraint(ConstraintKind::Equal, selfTy1, selfTy2, locator);

        break;



      case SelfTypeRelationship::Subclass:

        cs.addConstraint(ConstraintKind::Subtype, selfTy1, selfTy2, locator);

        break;



      case SelfTypeRelationship::Superclass:

        cs.addConstraint(ConstraintKind::Subtype, selfTy2, selfTy1, locator);

        break;



      case SelfTypeRelationship::ConformsTo:

        cs.addConstraint(ConstraintKind::ConformsTo, selfTy1,

                         cast<ProtocolDecl>(decl2->getDeclContext())

                           ->getDeclaredType(),

                         locator);

        break;



      case SelfTypeRelationship::ConformedToBy:

        cs.addConstraint(ConstraintKind::ConformsTo, selfTy2,

                         cast<ProtocolDecl>(decl1->getDeclContext())

                           ->getDeclaredType(),

                         locator);

        break;

      }



      bool fewerEffectiveParameters = false;

      switch (checkKind) {

      case CheckAll:

        // Check whether the first type is a subtype of the second.

        cs.addConstraint(ConstraintKind::Subtype,

                         openedType1,

                         openedType2,

                         locator);

        break;



      case CheckInput: {

        // Check whether the first function type's input is a subtype of the

        // second type's inputs, i.e., can we forward the arguments?

        auto funcTy1 = openedType1->castTo<FunctionType>();

        auto funcTy2 = openedType2->castTo<FunctionType>();

        SmallVector<CallArgParam, 4> params1 =

          decomposeParamType(funcTy1->getInput(), decl1,

                             decl1->getDeclContext()->isTypeContext());

        SmallVector<CallArgParam, 4> params2 =

          decomposeParamType(funcTy2->getInput(), decl2,

                             decl2->getDeclContext()->isTypeContext());



        unsigned numParams1 = params1.size();

        unsigned numParams2 = params2.size();

        if (numParams1 > numParams2) return false;



        for (unsigned i = 0; i != numParams2; ++i) {

          // If there is no corresponding argument in the first

          // parameter list...

          if (i >= numParams1) {

            // We need either a default argument or a variadic

            // argument for the first declaration to be more

            // specialized.

            if (!params2[i].HasDefaultArgument &&

                !params2[i].isVariadic())

              return false;



            fewerEffectiveParameters = true;

            continue;

          }



          // If one parameter is variadic and the other is not...

          if (params1[i].isVariadic() != params2[i].isVariadic()) {

            // If the first parameter is the variadic one, it's not

            // more specialized.

            if (params1[i].isVariadic()) return false;



            fewerEffectiveParameters = true;

          }



          // Check whether the first parameter is a subtype of the second.

          cs.addConstraint(ConstraintKind::Subtype,

                           params1[i].Ty, params2[i].Ty, locator);

        }



        break;

      }

      }



      // Solve the system.

      auto solution = cs.solveSingle(FreeTypeVariableBinding::Allow);



      // Ban value-to-optional conversions.

      if (solution && solution->getFixedScore().Data[SK_ValueToOptional] == 0)

        return true;



      // If the first function has fewer effective parameters than the

      // second, it is more specialized.

      if (fewerEffectiveParameters) return true;



      return false;

    };



    tc.specializedOverloadComparisonCache[{decl1, decl2}] = 

        compareSpecializations();

  } else if (tc.getLangOpts().DebugConstraintSolver) {

    auto &log = tc.Context.TypeCheckerDebug->getStream();

    log << ""Found cached comparison: "" 

        << tc.specializedOverloadComparisonCache[{decl1, decl2}] << ""\n"";

  }



  return tc.specializedOverloadComparisonCache[{decl1, decl2}];

}


"
"Sema: Fix CSRanking in preparation for generic subscripts

Subscripts in generic context will soon have a
GenericFunctionType, so get ready to handle that.",lib/Sema/CSRanking.cpp,-,"assert(!type2->is<GenericFunctionType>() && ""Odd generic function type?"");","static bool isDeclAsSpecializedAs(TypeChecker &tc, DeclContext *dc,

                                  ValueDecl *decl1, ValueDecl *decl2) {



  if (tc.getLangOpts().DebugConstraintSolver) {

    auto &log = tc.Context.TypeCheckerDebug->getStream();

    log << ""Comparing declarations\n"";

    decl1->print(log); 

    log << ""\nand\n"";

    decl2->print(log);

    log << ""\n"";

  }



  if (!tc.specializedOverloadComparisonCache.count({decl1, decl2})) {



    auto compareSpecializations = [&] () -> bool {

      // If the kinds are different, there's nothing we can do.

      // FIXME: This is wrong for type declarations, which we're skipping

      // entirely.

      if (decl1->getKind() != decl2->getKind() || isa<TypeDecl>(decl1))

        return false;



      // A non-generic declaration is more specialized than a generic declaration.

      if (auto func1 = dyn_cast<AbstractFunctionDecl>(decl1)) {

        auto func2 = cast<AbstractFunctionDecl>(decl2);

        if (func1->isGeneric() != func2->isGeneric())

          return func2->isGeneric();

      }



      if (auto subscript1 = dyn_cast<SubscriptDecl>(decl1)) {

        auto subscript2 = cast<SubscriptDecl>(decl2);

        if (subscript1->isGeneric() != subscript2->isGeneric())

          return subscript2->isGeneric();

      }



      // A witness is always more specialized than the requirement it satisfies.

      switch (compareWitnessAndRequirement(tc, dc, decl1, decl2)) {

      case Comparison::Unordered:

        break;



      case Comparison::Better:

        return true;



      case Comparison::Worse:

        return false;

      }



      // Members of protocol extensions have special overloading rules.

      ProtocolDecl *inProtocolExtension1 = decl1->getDeclContext()

                                             ->getAsProtocolExtensionContext();

      ProtocolDecl *inProtocolExtension2 = decl2->getDeclContext()

                                             ->getAsProtocolExtensionContext();

      if (inProtocolExtension1 && inProtocolExtension2) {

        // Both members are in protocol extensions.

        // Determine whether the 'Self' type from the first protocol extension

        // satisfies all of the requirements of the second protocol extension.

        DeclContext *dc1 = decl1->getDeclContext();

        DeclContext *dc2 = decl2->getDeclContext();

        bool better1 = isProtocolExtensionAsSpecializedAs(tc, dc1, dc2);

        bool better2 = isProtocolExtensionAsSpecializedAs(tc, dc2, dc1);

        if (better1 != better2) {

          return better1;

        }

      } else if (inProtocolExtension1 || inProtocolExtension2) {

        // One member is in a protocol extension, the other is in a concrete type.

        // Prefer the member in the concrete type.

        return inProtocolExtension2;

      }



      Type type1 = decl1->getInterfaceType();

      Type type2 = decl2->getInterfaceType();



      /// What part of the type should we check?

      enum {

        CheckAll,

        CheckInput,

      } checkKind;

      if (isa<AbstractFunctionDecl>(decl1) || isa<EnumElementDecl>(decl1)) {

        // Nothing to do: these have the curried 'self' already.

        if (auto elt = dyn_cast<EnumElementDecl>(decl1)) {

          checkKind = elt->getArgumentInterfaceType() ? CheckInput : CheckAll;

        } else {

          checkKind = CheckInput;

        }

      } else {

        // Add a curried 'self' type.

        type1 = addCurriedSelfType(tc.Context, type1, decl1->getDeclContext());

        type2 = addCurriedSelfType(tc.Context, type2, decl2->getDeclContext());



        // For a subscript declaration, only look at the input type (i.e., the

        // indices).

        if (isa<SubscriptDecl>(decl1))

          checkKind = CheckInput;

        else

          checkKind = CheckAll;

      }



      // Construct a constraint system to compare the two declarations.

      ConstraintSystem cs(tc, dc, ConstraintSystemOptions());



      auto locator = cs.getConstraintLocator(nullptr);

      // FIXME: Locator when anchored on a declaration.

      // Get the type of a reference to the second declaration.

      llvm::DenseMap<CanType, TypeVariableType *> unused;

      Type openedType2;

      if (auto *funcType = type2->getAs<AnyFunctionType>()) {

        openedType2 = cs.openFunctionType(

            funcType, /*numArgumentLabelsToRemove=*/0, locator,

            /*replacements=*/unused,

            decl2->getInnermostDeclContext(),

            decl2->getDeclContext(),

            /*skipProtocolSelfConstraint=*/false);

      } else {

        openedType2 = cs.openType(type2, locator, unused);

      }



      // Get the type of a reference to the first declaration, swapping in

      // archetypes for the dependent types.

      llvm::DenseMap<CanType, TypeVariableType *> replacements;

      auto dc1 = decl1->getInnermostDeclContext();

      Type openedType1;

      if (auto *funcType = type1->getAs<AnyFunctionType>()) {

        openedType1 = cs.openFunctionType(

            funcType, /*numArgumentLabelsToRemove=*/0, locator,

            replacements,

            dc1,

            decl1->getDeclContext(),

            /*skipProtocolSelfConstraint=*/false);

      } else {

        openedType1 = cs.openType(type1, locator, replacements);

      }



      for (const auto &replacement : replacements) {

        if (auto mapped = dc1->mapTypeIntoContext(replacement.first)) {

          cs.addConstraint(ConstraintKind::Bind, replacement.second, mapped,

                           locator);

        }

      }



      // Extract the self types from the declarations, if they have them.

      Type selfTy1;

      Type selfTy2;

      if (decl1->getDeclContext()->isTypeContext()) {

        auto funcTy1 = openedType1->castTo<FunctionType>();

        selfTy1 = funcTy1->getInput()->getRValueInstanceType();

        openedType1 = funcTy1->getResult();

      }

      if (decl2->getDeclContext()->isTypeContext()) {

        auto funcTy2 = openedType2->castTo<FunctionType>();

        selfTy2 = funcTy2->getInput()->getRValueInstanceType();

        openedType2 = funcTy2->getResult();

      }

      

      // Determine the relationship between the 'self' types and add the

      // appropriate constraints. The constraints themselves never fail, but

      // they help deduce type variables that were opened.

      switch (computeSelfTypeRelationship(tc, dc, decl1->getDeclContext(),

                                          decl2->getDeclContext())) {

      case SelfTypeRelationship::Unrelated:

        // Skip the self types parameter entirely.

        break;



      case SelfTypeRelationship::Equivalent:

        cs.addConstraint(ConstraintKind::Equal, selfTy1, selfTy2, locator);

        break;



      case SelfTypeRelationship::Subclass:

        cs.addConstraint(ConstraintKind::Subtype, selfTy1, selfTy2, locator);

        break;



      case SelfTypeRelationship::Superclass:

        cs.addConstraint(ConstraintKind::Subtype, selfTy2, selfTy1, locator);

        break;



      case SelfTypeRelationship::ConformsTo:

        cs.addConstraint(ConstraintKind::ConformsTo, selfTy1,

                         cast<ProtocolDecl>(decl2->getDeclContext())

                           ->getDeclaredType(),

                         locator);

        break;



      case SelfTypeRelationship::ConformedToBy:

        cs.addConstraint(ConstraintKind::ConformsTo, selfTy2,

                         cast<ProtocolDecl>(decl1->getDeclContext())

                           ->getDeclaredType(),

                         locator);

        break;

      }



      bool fewerEffectiveParameters = false;

      switch (checkKind) {

      case CheckAll:

        // Check whether the first type is a subtype of the second.

        cs.addConstraint(ConstraintKind::Subtype,

                         openedType1,

                         openedType2,

                         locator);

        break;



      case CheckInput: {

        // Check whether the first function type's input is a subtype of the

        // second type's inputs, i.e., can we forward the arguments?

        auto funcTy1 = openedType1->castTo<FunctionType>();

        auto funcTy2 = openedType2->castTo<FunctionType>();

        SmallVector<CallArgParam, 4> params1 =

          decomposeParamType(funcTy1->getInput(), decl1,

                             decl1->getDeclContext()->isTypeContext());

        SmallVector<CallArgParam, 4> params2 =

          decomposeParamType(funcTy2->getInput(), decl2,

                             decl2->getDeclContext()->isTypeContext());



        unsigned numParams1 = params1.size();

        unsigned numParams2 = params2.size();

        if (numParams1 > numParams2) return false;



        for (unsigned i = 0; i != numParams2; ++i) {

          // If there is no corresponding argument in the first

          // parameter list...

          if (i >= numParams1) {

            // We need either a default argument or a variadic

            // argument for the first declaration to be more

            // specialized.

            if (!params2[i].HasDefaultArgument &&

                !params2[i].isVariadic())

              return false;



            fewerEffectiveParameters = true;

            continue;

          }



          // If one parameter is variadic and the other is not...

          if (params1[i].isVariadic() != params2[i].isVariadic()) {

            // If the first parameter is the variadic one, it's not

            // more specialized.

            if (params1[i].isVariadic()) return false;



            fewerEffectiveParameters = true;

          }



          // Check whether the first parameter is a subtype of the second.

          cs.addConstraint(ConstraintKind::Subtype,

                           params1[i].Ty, params2[i].Ty, locator);

        }



        break;

      }

      }



      // Solve the system.

      auto solution = cs.solveSingle(FreeTypeVariableBinding::Allow);



      // Ban value-to-optional conversions.

      if (solution && solution->getFixedScore().Data[SK_ValueToOptional] == 0)

        return true;



      // If the first function has fewer effective parameters than the

      // second, it is more specialized.

      if (fewerEffectiveParameters) return true;



      return false;

    };



    tc.specializedOverloadComparisonCache[{decl1, decl2}] = 

        compareSpecializations();

  } else if (tc.getLangOpts().DebugConstraintSolver) {

    auto &log = tc.Context.TypeCheckerDebug->getStream();

    log << ""Found cached comparison: "" 

        << tc.specializedOverloadComparisonCache[{decl1, decl2}] << ""\n"";

  }



  return tc.specializedOverloadComparisonCache[{decl1, decl2}];

}

","static bool isDeclAsSpecializedAs(TypeChecker &tc, DeclContext *dc,

                                  ValueDecl *decl1, ValueDecl *decl2) {



  if (tc.getLangOpts().DebugConstraintSolver) {

    auto &log = tc.Context.TypeCheckerDebug->getStream();

    log << ""Comparing declarations\n"";

    decl1->print(log); 

    log << ""\nand\n"";

    decl2->print(log);

    log << ""\n"";

  }



  if (!tc.specializedOverloadComparisonCache.count({decl1, decl2})) {



    auto compareSpecializations = [&] () -> bool {

      // If the kinds are different, there's nothing we can do.

      // FIXME: This is wrong for type declarations, which we're skipping

      // entirely.

      if (decl1->getKind() != decl2->getKind() || isa<TypeDecl>(decl1))

        return false;



      // A non-generic declaration is more specialized than a generic declaration.

      if (auto func1 = dyn_cast<AbstractFunctionDecl>(decl1)) {

        auto func2 = cast<AbstractFunctionDecl>(decl2);

        if (func1->isGeneric() != func2->isGeneric())

          return func2->isGeneric();

      }



      if (auto subscript1 = dyn_cast<SubscriptDecl>(decl1)) {

        auto subscript2 = cast<SubscriptDecl>(decl2);

        if (subscript1->isGeneric() != subscript2->isGeneric())

          return subscript2->isGeneric();

      }



      // A witness is always more specialized than the requirement it satisfies.

      switch (compareWitnessAndRequirement(tc, dc, decl1, decl2)) {

      case Comparison::Unordered:

        break;



      case Comparison::Better:

        return true;



      case Comparison::Worse:
","        return false;

      }



      // Members of protocol extensions have special overloading rules.

      ProtocolDecl *inProtocolExtension1 = decl1->getDeclContext()

                                             ->getAsProtocolExtensionContext();

      ProtocolDecl *inProtocolExtension2 = decl2->getDeclContext()

                                             ->getAsProtocolExtensionContext();

      if (inProtocolExtension1 && inProtocolExtension2) {

        // Both members are in protocol extensions.

        // Determine whether the 'Self' type from the first protocol extension

        // satisfies all of the requirements of the second protocol extension.

        DeclContext *dc1 = decl1->getDeclContext();

        DeclContext *dc2 = decl2->getDeclContext();

        bool better1 = isProtocolExtensionAsSpecializedAs(tc, dc1, dc2);

        bool better2 = isProtocolExtensionAsSpecializedAs(tc, dc2, dc1);

        if (better1 != better2) {

          return better1;

        }

      } else if (inProtocolExtension1 || inProtocolExtension2) {

        // One member is in a protocol extension, the other is in a concrete type.

        // Prefer the member in the concrete type.

        return inProtocolExtension2;

      }



      Type type1 = decl1->getInterfaceType();

      Type type2 = decl2->getInterfaceType();



      /// What part of the type should we check?

      enum {

        CheckAll,

        CheckInput,

      } checkKind;

      if (isa<AbstractFunctionDecl>(decl1) || isa<EnumElementDecl>(decl1)) {

        // Nothing to do: these have the curried 'self' already.

        if (auto elt = dyn_cast<EnumElementDecl>(decl1)) {

          checkKind = elt->getArgumentInterfaceType() ? CheckInput : CheckAll;

        } else {

          checkKind = CheckInput;

        }

      } else {

        // Add a curried 'self' type.

        type1 = addCurriedSelfType(tc.Context, type1, decl1->getDeclContext());

        type2 = addCurriedSelfType(tc.Context, type2, decl2->getDeclContext());



        // For a subscript declaration, only look at the input type (i.e., the

        // indices).

        if (isa<SubscriptDecl>(decl1))

          checkKind = CheckInput;

        else

          checkKind = CheckAll;

      }



      // Construct a constraint system to compare the two declarations.

      ConstraintSystem cs(tc, dc, ConstraintSystemOptions());



      auto locator = cs.getConstraintLocator(nullptr);

      // FIXME: Locator when anchored on a declaration.

      // Get the type of a reference to the second declaration.

      llvm::DenseMap<CanType, TypeVariableType *> unused;

      Type openedType2;

      if (auto *funcType = type2->getAs<AnyFunctionType>()) {

        openedType2 = cs.openFunctionType(

            funcType, /*numArgumentLabelsToRemove=*/0, locator,

            /*replacements=*/unused,

            decl2->getInnermostDeclContext(),

            decl2->getDeclContext(),

            /*skipProtocolSelfConstraint=*/false);

      } else {

        openedType2 = cs.openType(type2, locator, unused);

      }



      // Get the type of a reference to the first declaration, swapping in

      // archetypes for the dependent types.

      llvm::DenseMap<CanType, TypeVariableType *> replacements;

      auto dc1 = decl1->getInnermostDeclContext();

      Type openedType1;

      if (auto *funcType = type1->getAs<AnyFunctionType>()) {

        openedType1 = cs.openFunctionType(

            funcType, /*numArgumentLabelsToRemove=*/0, locator,

            replacements,

            dc1,

            decl1->getDeclContext(),

            /*skipProtocolSelfConstraint=*/false);

      } else {

        openedType1 = cs.openType(type1, locator, replacements);

      }



      for (const auto &replacement : replacements) {

        if (auto mapped = dc1->mapTypeIntoContext(replacement.first)) {

          cs.addConstraint(ConstraintKind::Bind, replacement.second, mapped,

                           locator);

        }

      }



      // Extract the self types from the declarations, if they have them.

      Type selfTy1;

      Type selfTy2;

      if (decl1->getDeclContext()->isTypeContext()) {

        auto funcTy1 = openedType1->castTo<FunctionType>();

        selfTy1 = funcTy1->getInput()->getRValueInstanceType();

        openedType1 = funcTy1->getResult();

      }

      if (decl2->getDeclContext()->isTypeContext()) {

        auto funcTy2 = openedType2->castTo<FunctionType>();

        selfTy2 = funcTy2->getInput()->getRValueInstanceType();

        openedType2 = funcTy2->getResult();

      }

      

      // Determine the relationship between the 'self' types and add the

      // appropriate constraints. The constraints themselves never fail, but

      // they help deduce type variables that were opened.

      switch (computeSelfTypeRelationship(tc, dc, decl1->getDeclContext(),

                                          decl2->getDeclContext())) {

      case SelfTypeRelationship::Unrelated:

        // Skip the self types parameter entirely.

        break;



      case SelfTypeRelationship::Equivalent:

        cs.addConstraint(ConstraintKind::Equal, selfTy1, selfTy2, locator);

        break;



      case SelfTypeRelationship::Subclass:

        cs.addConstraint(ConstraintKind::Subtype, selfTy1, selfTy2, locator);

        break;



      case SelfTypeRelationship::Superclass:

        cs.addConstraint(ConstraintKind::Subtype, selfTy2, selfTy1, locator);

        break;



      case SelfTypeRelationship::ConformsTo:

        cs.addConstraint(ConstraintKind::ConformsTo, selfTy1,

                         cast<ProtocolDecl>(decl2->getDeclContext())

                           ->getDeclaredType(),

                         locator);

        break;



      case SelfTypeRelationship::ConformedToBy:

        cs.addConstraint(ConstraintKind::ConformsTo, selfTy2,

                         cast<ProtocolDecl>(decl1->getDeclContext())

                           ->getDeclaredType(),

                         locator);

        break;

      }



      bool fewerEffectiveParameters = false;

      switch (checkKind) {

      case CheckAll:

        // Check whether the first type is a subtype of the second.

        cs.addConstraint(ConstraintKind::Subtype,

                         openedType1,

                         openedType2,

                         locator);

        break;



      case CheckInput: {

        // Check whether the first function type's input is a subtype of the

        // second type's inputs, i.e., can we forward the arguments?

        auto funcTy1 = openedType1->castTo<FunctionType>();

        auto funcTy2 = openedType2->castTo<FunctionType>();

        SmallVector<CallArgParam, 4> params1 =

          decomposeParamType(funcTy1->getInput(), decl1,

                             decl1->getDeclContext()->isTypeContext());

        SmallVector<CallArgParam, 4> params2 =

          decomposeParamType(funcTy2->getInput(), decl2,

                             decl2->getDeclContext()->isTypeContext());



        unsigned numParams1 = params1.size();

        unsigned numParams2 = params2.size();

        if (numParams1 > numParams2) return false;



        for (unsigned i = 0; i != numParams2; ++i) {

          // If there is no corresponding argument in the first

          // parameter list...

          if (i >= numParams1) {

            // We need either a default argument or a variadic

            // argument for the first declaration to be more

            // specialized.

            if (!params2[i].HasDefaultArgument &&

                !params2[i].isVariadic())

              return false;



            fewerEffectiveParameters = true;

            continue;

          }



          // If one parameter is variadic and the other is not...

          if (params1[i].isVariadic() != params2[i].isVariadic()) {

            // If the first parameter is the variadic one, it's not

            // more specialized.

            if (params1[i].isVariadic()) return false;



            fewerEffectiveParameters = true;

          }



          // Check whether the first parameter is a subtype of the second.

          cs.addConstraint(ConstraintKind::Subtype,

                           params1[i].Ty, params2[i].Ty, locator);

        }



        break;

      }

      }



      // Solve the system.

      auto solution = cs.solveSingle(FreeTypeVariableBinding::Allow);



      // Ban value-to-optional conversions.

      if (solution && solution->getFixedScore().Data[SK_ValueToOptional] == 0)

        return true;



      // If the first function has fewer effective parameters than the

      // second, it is more specialized.

      if (fewerEffectiveParameters) return true;



      return false;

    };



    tc.specializedOverloadComparisonCache[{decl1, decl2}] = 

        compareSpecializations();

  } else if (tc.getLangOpts().DebugConstraintSolver) {

    auto &log = tc.Context.TypeCheckerDebug->getStream();

    log << ""Found cached comparison: "" 

        << tc.specializedOverloadComparisonCache[{decl1, decl2}] << ""\n"";

  }



  return tc.specializedOverloadComparisonCache[{decl1, decl2}];

}


"
"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/USRGeneration.cpp,+,"static bool printObjCUSRFragment(const ValueDecl *D, StringRef ObjCName,","static bool printObjCUSRFragment(const ValueDecl *D, StringRef ObjCName,

                                  raw_ostream &OS) {

  if (!D)

    return true;



  if (isa<ClassDecl>(D)) {

    clang::index::generateUSRForObjCClass(ObjCName, OS);

  } else if (isa<ProtocolDecl>(D)) {

    clang::index::generateUSRForObjCProtocol(ObjCName, OS);

  } else if (isa<VarDecl>(D)) {

    clang::index::generateUSRForObjCProperty(ObjCName, D->isStatic(), OS);

  } else if (isa<AbstractFunctionDecl>(D)) {

    clang::index::generateUSRForObjCMethod(ObjCName, D->isInstanceMember(), OS);

  } else if (isa<EnumDecl>(D)) {

    OS << ""@E@"" << ObjCName; // FIXME: expose clang API to handle enum names

  } else if (isa<EnumElementDecl>(D)) {

    OS << ""@"" << ObjCName;

  } else {

    llvm_unreachable(""Unexpected value decl"");

  }

  return false;

}

","static bool printObjCUSRFragment(const ValueDecl *D, StringRef ObjCName,

                                  raw_ostream &OS) {

  if (!D)

    return true;



  if (isa<ClassDecl>(D)) {

    clang::index::generateUSRForObjCClass(ObjCName, OS);

  } else if (isa<ProtocolDecl>(D)) {

    clang::index::generateUSRForObjCProtocol(ObjCName, OS);

  } else if (isa<VarDecl>(D)) {

    clang::index::generateUSRForObjCProperty(ObjCName, D->isStatic(), OS);

  } else if (isa<AbstractFunctionDecl>(D)) {

    clang::index::generateUSRForObjCMethod(ObjCName, D->isInstanceMember(), OS);

  } else if (isa<EnumDecl>(D)) {

    OS << ""@E@"" << ObjCName; // FIXME: expose clang API to handle enum names

  } else if (isa<EnumElementDecl>(D)) {

    OS << ""@"" << ObjCName;

  } else {

    llvm_unreachable(""Unexpected value decl"");

  }

  return false;

}
","
                                  raw_ostream &OS) {

  if (!D)

    return true;



  if (isa<ClassDecl>(D)) {

    clang::index::generateUSRForObjCClass(ObjCName, OS);

  } else if (isa<ProtocolDecl>(D)) {

    clang::index::generateUSRForObjCProtocol(ObjCName, OS);

  } else if (isa<VarDecl>(D)) {

    clang::index::generateUSRForObjCProperty(ObjCName, D->isStatic(), OS);

  } else if (isa<AbstractFunctionDecl>(D)) {

    clang::index::generateUSRForObjCMethod(ObjCName, D->isInstanceMember(), OS);

  } else if (isa<EnumDecl>(D)) {

    OS << ""@E@"" << ObjCName; // FIXME: expose clang API to handle enum names

  } else if (isa<EnumElementDecl>(D)) {

    OS << ""@"" << ObjCName;

  } else {

    llvm_unreachable(""Unexpected value decl"");

  }

  return false;

}

"
"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/USRGeneration.cpp,+,"static bool printObjCUSRForAccessor(const AbstractStorageDecl *ASD,","static bool printObjCUSRForAccessor(const AbstractStorageDecl *ASD,

                                    AccessorKind Kind,

                                    raw_ostream &OS) {

  ObjCSelector Selector;

  switch (Kind) {

    case swift::AccessorKind::IsGetter:

      Selector = ASD->getObjCGetterSelector();

      break;

    case swift::AccessorKind::IsSetter:

      Selector = ASD->getObjCSetterSelector();

      break;

    default:

      llvm_unreachable(""invalid accessor kind"");

  }

  assert(Selector);

  llvm::SmallString<128> Buf;

  clang::index::generateUSRForObjCMethod(Selector.getString(Buf),

                                         ASD->isInstanceMember(), OS);

  return false;

}

","static bool printObjCUSRForAccessor(const AbstractStorageDecl *ASD,

                                    AccessorKind Kind,

                                    raw_ostream &OS) {

  ObjCSelector Selector;

  switch (Kind) {

    case swift::AccessorKind::IsGetter:

      Selector = ASD->getObjCGetterSelector();

      break;

    case swift::AccessorKind::IsSetter:

      Selector = ASD->getObjCSetterSelector();

      break;

    default:

      llvm_unreachable(""invalid accessor kind"");

  }

  assert(Selector);

  llvm::SmallString<128> Buf;

  clang::index::generateUSRForObjCMethod(Selector.getString(Buf),

                                         ASD->isInstanceMember(), OS);

  return false;

}
","
                                    AccessorKind Kind,

                                    raw_ostream &OS) {

  ObjCSelector Selector;

  switch (Kind) {

    case swift::AccessorKind::IsGetter:

      Selector = ASD->getObjCGetterSelector();

      break;

    case swift::AccessorKind::IsSetter:

      Selector = ASD->getObjCSetterSelector();

      break;

    default:

      llvm_unreachable(""invalid accessor kind"");

  }

  assert(Selector);

  llvm::SmallString<128> Buf;

  clang::index::generateUSRForObjCMethod(Selector.getString(Buf),

                                         ASD->isInstanceMember(), OS);

  return false;

}

"
"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/USRGeneration.cpp,+,assert(Selector);,"static bool printObjCUSRForAccessor(const AbstractStorageDecl *ASD,

                                    AccessorKind Kind,

                                    raw_ostream &OS) {

  ObjCSelector Selector;

  switch (Kind) {

    case swift::AccessorKind::IsGetter:

      Selector = ASD->getObjCGetterSelector();

      break;

    case swift::AccessorKind::IsSetter:

      Selector = ASD->getObjCSetterSelector();

      break;

    default:

      llvm_unreachable(""invalid accessor kind"");

  }

  assert(Selector);

  llvm::SmallString<128> Buf;

  clang::index::generateUSRForObjCMethod(Selector.getString(Buf),

                                         ASD->isInstanceMember(), OS);

  return false;

}

","static bool printObjCUSRForAccessor(const AbstractStorageDecl *ASD,

                                    AccessorKind Kind,

                                    raw_ostream &OS) {

  ObjCSelector Selector;

  switch (Kind) {

    case swift::AccessorKind::IsGetter:

      Selector = ASD->getObjCGetterSelector();

      break;

    case swift::AccessorKind::IsSetter:

      Selector = ASD->getObjCSetterSelector();

      break;

    default:

      llvm_unreachable(""invalid accessor kind"");

  }

 ","
  llvm::SmallString<128> Buf;

  clang::index::generateUSRForObjCMethod(Selector.getString(Buf),

                                         ASD->isInstanceMember(), OS);

  return false;

}

"
"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/USRGeneration.cpp,+,"static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}

","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}
","
  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}

"
"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/USRGeneration.cpp,+,"if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}

","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

   ","
      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}

"
"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/USRGeneration.cpp,+,"return printObjCUSRFragment(D, ObjCName.first.str(), OS);","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}

","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

   ","


  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}

"
"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/USRGeneration.cpp,+,assert(ObjCName.second);,"static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}

","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



 ","
  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}

"
"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/USRGeneration.cpp,+,"return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}

","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

 ","
}

"
"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,-,"static bool printObjCNameFragment(const ValueDecl *D, StringRef ObjCName,","static bool printObjCUSRFragment(const ValueDecl *D, StringRef ObjCName,

                                  raw_ostream &OS) {

  if (!D)

    return true;



  if (isa<ClassDecl>(D)) {

    clang::index::generateUSRForObjCClass(ObjCName, OS);

  } else if (isa<ProtocolDecl>(D)) {

    clang::index::generateUSRForObjCProtocol(ObjCName, OS);

  } else if (isa<VarDecl>(D)) {

    clang::index::generateUSRForObjCProperty(ObjCName, D->isStatic(), OS);

  } else if (isa<AbstractFunctionDecl>(D)) {

    clang::index::generateUSRForObjCMethod(ObjCName, D->isInstanceMember(), OS);

  } else if (isa<EnumDecl>(D)) {

    OS << ""@E@"" << ObjCName; // FIXME: expose clang API to handle enum names

  } else if (isa<EnumElementDecl>(D)) {

    OS << ""@"" << ObjCName;

  } else {

    llvm_unreachable(""Unexpected value decl"");

  }

  return false;

}

",,"
                                  raw_ostream &OS) {

  if (!D)

    return true;



  if (isa<ClassDecl>(D)) {

    clang::index::generateUSRForObjCClass(ObjCName, OS);

  } else if (isa<ProtocolDecl>(D)) {

    clang::index::generateUSRForObjCProtocol(ObjCName, OS);

  } else if (isa<VarDecl>(D)) {

    clang::index::generateUSRForObjCProperty(ObjCName, D->isStatic(), OS);

  } else if (isa<AbstractFunctionDecl>(D)) {

    clang::index::generateUSRForObjCMethod(ObjCName, D->isInstanceMember(), OS);

  } else if (isa<EnumDecl>(D)) {

    OS << ""@E@"" << ObjCName; // FIXME: expose clang API to handle enum names

  } else if (isa<EnumElementDecl>(D)) {

    OS << ""@"" << ObjCName;

  } else {

    llvm_unreachable(""Unexpected value decl"");

  }

  return false;

}


"
"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,+,"static bool printObjCUSRFragment(const ValueDecl *D, StringRef ObjCName,","static bool printObjCUSRFragment(const ValueDecl *D, StringRef ObjCName,

                                  raw_ostream &OS) {

  if (!D)

    return true;



  if (isa<ClassDecl>(D)) {

    clang::index::generateUSRForObjCClass(ObjCName, OS);

  } else if (isa<ProtocolDecl>(D)) {

    clang::index::generateUSRForObjCProtocol(ObjCName, OS);

  } else if (isa<VarDecl>(D)) {

    clang::index::generateUSRForObjCProperty(ObjCName, D->isStatic(), OS);

  } else if (isa<AbstractFunctionDecl>(D)) {

    clang::index::generateUSRForObjCMethod(ObjCName, D->isInstanceMember(), OS);

  } else if (isa<EnumDecl>(D)) {

    OS << ""@E@"" << ObjCName; // FIXME: expose clang API to handle enum names

  } else if (isa<EnumElementDecl>(D)) {

    OS << ""@"" << ObjCName;

  } else {

    llvm_unreachable(""Unexpected value decl"");

  }

  return false;

}

","static bool printObjCUSRFragment(const ValueDecl *D, StringRef ObjCName,

                                  raw_ostream &OS) {

  if (!D)

    return true;



  if (isa<ClassDecl>(D)) {

    clang::index::generateUSRForObjCClass(ObjCName, OS);

  } else if (isa<ProtocolDecl>(D)) {

    clang::index::generateUSRForObjCProtocol(ObjCName, OS);

  } else if (isa<VarDecl>(D)) {

    clang::index::generateUSRForObjCProperty(ObjCName, D->isStatic(), OS);

  } else if (isa<AbstractFunctionDecl>(D)) {

    clang::index::generateUSRForObjCMethod(ObjCName, D->isInstanceMember(), OS);

  } else if (isa<EnumDecl>(D)) {

    OS << ""@E@"" << ObjCName; // FIXME: expose clang API to handle enum names

  } else if (isa<EnumElementDecl>(D)) {

    OS << ""@"" << ObjCName;

  } else {

    llvm_unreachable(""Unexpected value decl"");

  }

  return false;

}
","
                                  raw_ostream &OS) {

  if (!D)

    return true;



  if (isa<ClassDecl>(D)) {

    clang::index::generateUSRForObjCClass(ObjCName, OS);

  } else if (isa<ProtocolDecl>(D)) {

    clang::index::generateUSRForObjCProtocol(ObjCName, OS);

  } else if (isa<VarDecl>(D)) {

    clang::index::generateUSRForObjCProperty(ObjCName, D->isStatic(), OS);

  } else if (isa<AbstractFunctionDecl>(D)) {

    clang::index::generateUSRForObjCMethod(ObjCName, D->isInstanceMember(), OS);

  } else if (isa<EnumDecl>(D)) {

    OS << ""@E@"" << ObjCName; // FIXME: expose clang API to handle enum names

  } else if (isa<EnumElementDecl>(D)) {

    OS << ""@"" << ObjCName;

  } else {

    llvm_unreachable(""Unexpected value decl"");

  }

  return false;

}

"
"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,-,"static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS, Identifier Ident,","static bool printObjCUSRForAccessor(const AbstractStorageDecl *ASD,

                                    AccessorKind Kind,

                                    raw_ostream &OS) {

  ObjCSelector Selector;

  switch (Kind) {

    case swift::AccessorKind::IsGetter:

      Selector = ASD->getObjCGetterSelector();

      break;

    case swift::AccessorKind::IsSetter:

      Selector = ASD->getObjCSetterSelector();

      break;

    default:

      llvm_unreachable(""invalid accessor kind"");

  }

  assert(Selector);

  llvm::SmallString<128> Buf;

  clang::index::generateUSRForObjCMethod(Selector.getString(Buf),

                                         ASD->isInstanceMember(), OS);

  return false;

}

","static bool printObjCUSRForAccessor(const AbstractStorageDecl *ASD,
","                                    AccessorKind Kind,

                                    raw_ostream &OS) {

  ObjCSelector Selector;

  switch (Kind) {

    case swift::AccessorKind::IsGetter:

      Selector = ASD->getObjCGetterSelector();

      break;

    case swift::AccessorKind::IsSetter:

      Selector = ASD->getObjCSetterSelector();

      break;

    default:

      llvm_unreachable(""invalid accessor kind"");

  }

  assert(Selector);

  llvm::SmallString<128> Buf;

  clang::index::generateUSRForObjCMethod(Selector.getString(Buf),

                                         ASD->isInstanceMember(), OS);

  return false;

}


"
"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,+,"static bool printObjCUSRForAccessor(const AbstractStorageDecl *ASD,","static bool printObjCUSRForAccessor(const AbstractStorageDecl *ASD,

                                    AccessorKind Kind,

                                    raw_ostream &OS) {

  ObjCSelector Selector;

  switch (Kind) {

    case swift::AccessorKind::IsGetter:

      Selector = ASD->getObjCGetterSelector();

      break;

    case swift::AccessorKind::IsSetter:

      Selector = ASD->getObjCSetterSelector();

      break;

    default:

      llvm_unreachable(""invalid accessor kind"");

  }

  assert(Selector);

  llvm::SmallString<128> Buf;

  clang::index::generateUSRForObjCMethod(Selector.getString(Buf),

                                         ASD->isInstanceMember(), OS);

  return false;

}

","static bool printObjCUSRForAccessor(const AbstractStorageDecl *ASD,

                                    AccessorKind Kind,

                                    raw_ostream &OS) {

  ObjCSelector Selector;

  switch (Kind) {

    case swift::AccessorKind::IsGetter:

      Selector = ASD->getObjCGetterSelector();

      break;

    case swift::AccessorKind::IsSetter:

      Selector = ASD->getObjCSetterSelector();

      break;

    default:

      llvm_unreachable(""invalid accessor kind"");

  }

  assert(Selector);

  llvm::SmallString<128> Buf;

  clang::index::generateUSRForObjCMethod(Selector.getString(Buf),

                                         ASD->isInstanceMember(), OS);

  return false;

}
","
                                    AccessorKind Kind,

                                    raw_ostream &OS) {

  ObjCSelector Selector;

  switch (Kind) {

    case swift::AccessorKind::IsGetter:

      Selector = ASD->getObjCGetterSelector();

      break;

    case swift::AccessorKind::IsSetter:

      Selector = ASD->getObjCSetterSelector();

      break;

    default:

      llvm_unreachable(""invalid accessor kind"");

  }

  assert(Selector);

  llvm::SmallString<128> Buf;

  clang::index::generateUSRForObjCMethod(Selector.getString(Buf),

                                         ASD->isInstanceMember(), OS);

  return false;

}

"
"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,+,assert(Selector);,"static bool printObjCUSRForAccessor(const AbstractStorageDecl *ASD,

                                    AccessorKind Kind,

                                    raw_ostream &OS) {

  ObjCSelector Selector;

  switch (Kind) {

    case swift::AccessorKind::IsGetter:

      Selector = ASD->getObjCGetterSelector();

      break;

    case swift::AccessorKind::IsSetter:

      Selector = ASD->getObjCSetterSelector();

      break;

    default:

      llvm_unreachable(""invalid accessor kind"");

  }

  assert(Selector);

  llvm::SmallString<128> Buf;

  clang::index::generateUSRForObjCMethod(Selector.getString(Buf),

                                         ASD->isInstanceMember(), OS);

  return false;

}

","static bool printObjCUSRForAccessor(const AbstractStorageDecl *ASD,

                                    AccessorKind Kind,

                                    raw_ostream &OS) {

  ObjCSelector Selector;

  switch (Kind) {

    case swift::AccessorKind::IsGetter:

      Selector = ASD->getObjCGetterSelector();

      break;

    case swift::AccessorKind::IsSetter:

      Selector = ASD->getObjCSetterSelector();

      break;

    default:

      llvm_unreachable(""invalid accessor kind"");

  }

 ","
  llvm::SmallString<128> Buf;

  clang::index::generateUSRForObjCMethod(Selector.getString(Buf),

                                         ASD->isInstanceMember(), OS);

  return false;

}

"
"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,+,"static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}

","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}
","
  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}

"
"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,-,"if (printObjCNameFragment(Parent, ObjCName.first.str(), OS))","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}

","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

","
    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}


"
"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,+,"if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}

","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

   ","
      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}

"
"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,-,"return printObjCNameFragment(D, Ident.str(), OS);","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}

","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;
","  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}


"
"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,-,"return printObjCNameFragment(D, Selector.getString(Buf), OS);","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}

","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {

  OS << clang::index::getUSRSpacePrefix();



  if (auto *Parent = D->getDeclContext()->

        getAsNominalTypeOrNominalTypeExtensionContext()) {

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }
","

  auto ObjCName = objc_translation::getObjCNameForSwiftDecl(D);



  if (!ObjCName.first.empty())

    return printObjCUSRFragment(D, ObjCName.first.str(), OS);



  assert(ObjCName.second);

  llvm::SmallString<128> Buf;

  return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);

}


"
Use clang-style USRs for swift decls that are exposed to Objective C,lib/AST/USRGeneration.cpp,+,"static bool printObjCNameFragment(const ValueDecl *D, StringRef ObjCName,","static bool printObjCNameFragment(const ValueDecl *D, StringRef ObjCName,

                                  raw_ostream &OS) {

  if (!D)

    return true;



  if (isa<ClassDecl>(D)) {

    clang::index::generateUSRForObjCClass(ObjCName, OS);

  } else if (isa<ProtocolDecl>(D)) {

    clang::index::generateUSRForObjCProtocol(ObjCName, OS);

  } else if (isa<VarDecl>(D)) {

    clang::index::generateUSRForObjCProperty(ObjCName, D->isStatic(), OS);

  } else if (isa<AbstractFunctionDecl>(D)) {

    clang::index::generateUSRForObjCMethod(ObjCName, D->isInstanceMember(), OS);

  } else if (isa<EnumDecl>(D)) {

    OS << ""@E@"" << ObjCName; // FIXME: expose clang API to handle enum names

  } else if (isa<EnumElementDecl>(D)) {

    OS << ""@"" << ObjCName;

  } else {

    llvm_unreachable(""Unexpected value decl"");

    return true;

  }

  return false;

}

","static bool printObjCNameFragment(const ValueDecl *D, StringRef ObjCName,

                                  raw_ostream &OS) {

  if (!D)

    return true;



  if (isa<ClassDecl>(D)) {

    clang::index::generateUSRForObjCClass(ObjCName, OS);

  } else if (isa<ProtocolDecl>(D)) {

    clang::index::generateUSRForObjCProtocol(ObjCName, OS);

  } else if (isa<VarDecl>(D)) {

    clang::index::generateUSRForObjCProperty(ObjCName, D->isStatic(), OS);

  } else if (isa<AbstractFunctionDecl>(D)) {

    clang::index::generateUSRForObjCMethod(ObjCName, D->isInstanceMember(), OS);

  } else if (isa<EnumDecl>(D)) {

    OS << ""@E@"" << ObjCName; // FIXME: expose clang API to handle enum names

  } else if (isa<EnumElementDecl>(D)) {

    OS << ""@"" << ObjCName;

  } else {

    llvm_unreachable(""Unexpected value decl"");

    return true;

  }

  return false;

}
","
                                  raw_ostream &OS) {

  if (!D)

    return true;



  if (isa<ClassDecl>(D)) {

    clang::index::generateUSRForObjCClass(ObjCName, OS);

  } else if (isa<ProtocolDecl>(D)) {

    clang::index::generateUSRForObjCProtocol(ObjCName, OS);

  } else if (isa<VarDecl>(D)) {

    clang::index::generateUSRForObjCProperty(ObjCName, D->isStatic(), OS);

  } else if (isa<AbstractFunctionDecl>(D)) {

    clang::index::generateUSRForObjCMethod(ObjCName, D->isInstanceMember(), OS);

  } else if (isa<EnumDecl>(D)) {

    OS << ""@E@"" << ObjCName; // FIXME: expose clang API to handle enum names

  } else if (isa<EnumElementDecl>(D)) {

    OS << ""@"" << ObjCName;

  } else {

    llvm_unreachable(""Unexpected value decl"");

    return true;

  }

  return false;

}

"
Use clang-style USRs for swift decls that are exposed to Objective C,lib/AST/USRGeneration.cpp,+,"static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS, Identifier Ident,","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS, Identifier Ident,

                         ObjCSelector Selector) {

  OS << clang::index::getUSRSpacePrefix();



  if (D->getDeclContext()->isTypeContext()) {

    auto *Parent = D->getDeclContext()->getAsNominalTypeOrNominalTypeExtensionContext();

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCNameFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  if (!Ident.empty())

    return printObjCNameFragment(D, Ident.str(), OS);

  if (Selector) {

    llvm::SmallString<128> Buf;

    return printObjCNameFragment(D, Selector.getString(Buf), OS);

  }

  return false;

}

","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS, Identifier Ident,

                         ObjCSelector Selector) {

  OS << clang::index::getUSRSpacePrefix();



  if (D->getDeclContext()->isTypeContext()) {

    auto *Parent = D->getDeclContext()->getAsNominalTypeOrNominalTypeExtensionContext();

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCNameFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  if (!Ident.empty())

    return printObjCNameFragment(D, Ident.str(), OS);

  if (Selector) {

    llvm::SmallString<128> Buf;

    return printObjCNameFragment(D, Selector.getString(Buf), OS);

  }

  return false;

}
","
                         ObjCSelector Selector) {

  OS << clang::index::getUSRSpacePrefix();



  if (D->getDeclContext()->isTypeContext()) {

    auto *Parent = D->getDeclContext()->getAsNominalTypeOrNominalTypeExtensionContext();

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCNameFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  if (!Ident.empty())

    return printObjCNameFragment(D, Ident.str(), OS);

  if (Selector) {

    llvm::SmallString<128> Buf;

    return printObjCNameFragment(D, Selector.getString(Buf), OS);

  }

  return false;

}

"
Use clang-style USRs for swift decls that are exposed to Objective C,lib/AST/USRGeneration.cpp,+,"if (printObjCNameFragment(Parent, ObjCName.first.str(), OS))","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS, Identifier Ident,

                         ObjCSelector Selector) {

  OS << clang::index::getUSRSpacePrefix();



  if (D->getDeclContext()->isTypeContext()) {

    auto *Parent = D->getDeclContext()->getAsNominalTypeOrNominalTypeExtensionContext();

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCNameFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  if (!Ident.empty())

    return printObjCNameFragment(D, Ident.str(), OS);

  if (Selector) {

    llvm::SmallString<128> Buf;

    return printObjCNameFragment(D, Selector.getString(Buf), OS);

  }

  return false;

}

","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS, Identifier Ident,

                         ObjCSelector Selector) {

  OS << clang::index::getUSRSpacePrefix();



  if (D->getDeclContext()->isTypeContext()) {

    auto *Parent = D->getDeclContext()->getAsNominalTypeOrNominalTypeExtensionContext();

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

   ","
      return true;

  }



  if (!Ident.empty())

    return printObjCNameFragment(D, Ident.str(), OS);

  if (Selector) {

    llvm::SmallString<128> Buf;

    return printObjCNameFragment(D, Selector.getString(Buf), OS);

  }

  return false;

}

"
Use clang-style USRs for swift decls that are exposed to Objective C,lib/AST/USRGeneration.cpp,+,"return printObjCNameFragment(D, Ident.str(), OS);","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS, Identifier Ident,

                         ObjCSelector Selector) {

  OS << clang::index::getUSRSpacePrefix();



  if (D->getDeclContext()->isTypeContext()) {

    auto *Parent = D->getDeclContext()->getAsNominalTypeOrNominalTypeExtensionContext();

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCNameFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  if (!Ident.empty())

    return printObjCNameFragment(D, Ident.str(), OS);

  if (Selector) {

    llvm::SmallString<128> Buf;

    return printObjCNameFragment(D, Selector.getString(Buf), OS);

  }

  return false;

}

","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS, Identifier Ident,

                         ObjCSelector Selector) {

  OS << clang::index::getUSRSpacePrefix();



  if (D->getDeclContext()->isTypeContext()) {

    auto *Parent = D->getDeclContext()->getAsNominalTypeOrNominalTypeExtensionContext();

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCNameFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  if (!Ident.empty())

   ","
  if (Selector) {

    llvm::SmallString<128> Buf;

    return printObjCNameFragment(D, Selector.getString(Buf), OS);

  }

  return false;

}

"
Use clang-style USRs for swift decls that are exposed to Objective C,lib/AST/USRGeneration.cpp,+,"return printObjCNameFragment(D, Selector.getString(Buf), OS);","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS, Identifier Ident,

                         ObjCSelector Selector) {

  OS << clang::index::getUSRSpacePrefix();



  if (D->getDeclContext()->isTypeContext()) {

    auto *Parent = D->getDeclContext()->getAsNominalTypeOrNominalTypeExtensionContext();

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCNameFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  if (!Ident.empty())

    return printObjCNameFragment(D, Ident.str(), OS);

  if (Selector) {

    llvm::SmallString<128> Buf;

    return printObjCNameFragment(D, Selector.getString(Buf), OS);

  }

  return false;

}

","static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS, Identifier Ident,

                         ObjCSelector Selector) {

  OS << clang::index::getUSRSpacePrefix();



  if (D->getDeclContext()->isTypeContext()) {

    auto *Parent = D->getDeclContext()->getAsNominalTypeOrNominalTypeExtensionContext();

    auto ObjCName = objc_translation::getObjCNameForSwiftDecl(Parent);

    if (printObjCNameFragment(Parent, ObjCName.first.str(), OS))

      return true;

  }



  if (!Ident.empty())

    return printObjCNameFragment(D, Ident.str(), OS);

  if (Selector) {

    llvm::SmallString<128> Buf;

   ","
  }

  return false;

}

"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,getForeignErrorConventionKindString(ForeignErrorConvention::Kind value) {,"static StringRef

getForeignErrorConventionKindString(ForeignErrorConvention::Kind value) {

  switch (value) {

  case ForeignErrorConvention::ZeroResult: return ""ZeroResult"";

  case ForeignErrorConvention::NonZeroResult: return ""NonZeroResult"";

  case ForeignErrorConvention::ZeroPreservedResult: return ""ZeroPreservedResult"";

  case ForeignErrorConvention::NilResult: return ""NilResult"";

  case ForeignErrorConvention::NonNilError: return ""NonNilError"";

  }

}

","static StringRef
","
  switch (value) {

  case ForeignErrorConvention::ZeroResult: return ""ZeroResult"";

  case ForeignErrorConvention::NonZeroResult: return ""NonZeroResult"";

  case ForeignErrorConvention::ZeroPreservedResult: return ""ZeroPreservedResult"";

  case ForeignErrorConvention::NilResult: return ""NilResult"";

  case ForeignErrorConvention::NonNilError: return ""NonNilError"";

  }

}

"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#column"");","    void printParameter(const ParamDecl *P) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter "";

      printDeclName(P);

      if (!P->getArgumentName().empty())

        PrintWithColorRAII(OS, IdentifierColor)

          << "" apiName="" << P->getArgumentName();



      if (P->hasType()) {

        PrintWithColorRAII(OS, TypeColor) << "" type='"";

        P->getType().print(PrintWithColorRAII(OS, TypeColor).getOS());

        PrintWithColorRAII(OS, TypeColor) << ""'"";

      }



      if (P->hasInterfaceType()) {

        PrintWithColorRAII(OS, InterfaceTypeColor) << "" interface type='"";

        P->getInterfaceType().print(

            PrintWithColorRAII(OS, InterfaceTypeColor).getOS());

        PrintWithColorRAII(OS, InterfaceTypeColor) << ""'"";

      }



      if (!P->isLet())

        OS << "" mutable"";



      if (P->isVariadic())

        OS << "" variadic"";



      if (P->getDefaultArgumentKind() != DefaultArgumentKind::None)

        printField(""default_arg"",

                   getDefaultArgumentKindString(P->getDefaultArgumentKind()));



      if (auto init = P->getDefaultValue()) {

        OS << "" expression=\n"";

        printRec(init);

      }



      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }

","    void printParameter(const ParamDecl *P) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter "";

      printDeclName(P);

      if (!P->getArgumentName().empty())

        PrintWithColorRAII(OS, IdentifierColor)

          << "" apiName="" << P->getArgumentName();



      if (P->hasType()) {

        PrintWithColorRAII(OS, TypeColor) << "" type='"";

        P->getType().print(PrintWithColorRAII(OS, TypeColor).getOS());

        PrintWithColorRAII(OS, TypeColor) << ""'"";

      }



      if (P->hasInterfaceType()) {
","        PrintWithColorRAII(OS, InterfaceTypeColor) << "" interface type='"";

        P->getInterfaceType().print(

            PrintWithColorRAII(OS, InterfaceTypeColor).getOS());

        PrintWithColorRAII(OS, InterfaceTypeColor) << ""'"";

      }



      if (!P->isLet())

        OS << "" mutable"";



      if (P->isVariadic())

        OS << "" variadic"";



      if (P->getDefaultArgumentKind() != DefaultArgumentKind::None)

        printField(""default_arg"",

                   getDefaultArgumentKindString(P->getDefaultArgumentKind()));



      if (auto init = P->getDefaultValue()) {

        OS << "" expression=\n"";

        printRec(init);

      }



      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#dsohandle"");","    void printParameter(const ParamDecl *P) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter "";

      printDeclName(P);

      if (!P->getArgumentName().empty())

        PrintWithColorRAII(OS, IdentifierColor)

          << "" apiName="" << P->getArgumentName();



      if (P->hasType()) {

        PrintWithColorRAII(OS, TypeColor) << "" type='"";

        P->getType().print(PrintWithColorRAII(OS, TypeColor).getOS());

        PrintWithColorRAII(OS, TypeColor) << ""'"";

      }



      if (P->hasInterfaceType()) {

        PrintWithColorRAII(OS, InterfaceTypeColor) << "" interface type='"";

        P->getInterfaceType().print(

            PrintWithColorRAII(OS, InterfaceTypeColor).getOS());

        PrintWithColorRAII(OS, InterfaceTypeColor) << ""'"";

      }



      if (!P->isLet())

        OS << "" mutable"";



      if (P->isVariadic())

        OS << "" variadic"";



      if (P->getDefaultArgumentKind() != DefaultArgumentKind::None)

        printField(""default_arg"",

                   getDefaultArgumentKindString(P->getDefaultArgumentKind()));



      if (auto init = P->getDefaultValue()) {

        OS << "" expression=\n"";

        printRec(init);

      }



      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }

","    void printParameter(const ParamDecl *P) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter "";

      printDeclName(P);

      if (!P->getArgumentName().empty())

        PrintWithColorRAII(OS, IdentifierColor)

          << "" apiName="" << P->getArgumentName();



      if (P->hasType()) {

        PrintWithColorRAII(OS, TypeColor) << "" type='"";

        P->getType().print(PrintWithColorRAII(OS, TypeColor).getOS());

        PrintWithColorRAII(OS, TypeColor) << ""'"";

      }



      if (P->hasInterfaceType()) {

        PrintWithColorRAII(OS, InterfaceTypeColor) << "" interface type='"";
","        P->getInterfaceType().print(

            PrintWithColorRAII(OS, InterfaceTypeColor).getOS());

        PrintWithColorRAII(OS, InterfaceTypeColor) << ""'"";

      }



      if (!P->isLet())

        OS << "" mutable"";



      if (P->isVariadic())

        OS << "" variadic"";



      if (P->getDefaultArgumentKind() != DefaultArgumentKind::None)

        printField(""default_arg"",

                   getDefaultArgumentKindString(P->getDefaultArgumentKind()));



      if (auto init = P->getDefaultValue()) {

        OS << "" expression=\n"";

        printRec(init);

      }



      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#file"");","    void printParameter(const ParamDecl *P) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter "";

      printDeclName(P);

      if (!P->getArgumentName().empty())

        PrintWithColorRAII(OS, IdentifierColor)

          << "" apiName="" << P->getArgumentName();



      if (P->hasType()) {

        PrintWithColorRAII(OS, TypeColor) << "" type='"";

        P->getType().print(PrintWithColorRAII(OS, TypeColor).getOS());

        PrintWithColorRAII(OS, TypeColor) << ""'"";

      }



      if (P->hasInterfaceType()) {

        PrintWithColorRAII(OS, InterfaceTypeColor) << "" interface type='"";

        P->getInterfaceType().print(

            PrintWithColorRAII(OS, InterfaceTypeColor).getOS());

        PrintWithColorRAII(OS, InterfaceTypeColor) << ""'"";

      }



      if (!P->isLet())

        OS << "" mutable"";



      if (P->isVariadic())

        OS << "" variadic"";



      if (P->getDefaultArgumentKind() != DefaultArgumentKind::None)

        printField(""default_arg"",

                   getDefaultArgumentKindString(P->getDefaultArgumentKind()));



      if (auto init = P->getDefaultValue()) {

        OS << "" expression=\n"";

        printRec(init);

      }



      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }

","    void printParameter(const ParamDecl *P) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter "";

      printDeclName(P);

      if (!P->getArgumentName().empty())

        PrintWithColorRAII(OS, IdentifierColor)

          << "" apiName="" << P->getArgumentName();



      if (P->hasType()) {

        PrintWithColorRAII(OS, TypeColor) << "" type='"";

        P->getType().print(PrintWithColorRAII(OS, TypeColor).getOS());

        PrintWithColorRAII(OS, TypeColor) << ""'"";

      }



      if (P->hasInterfaceType()) {

        PrintWithColorRAII(OS, InterfaceTypeColor) << "" interface type='"";

        P->getInterfaceType().print(
","            PrintWithColorRAII(OS, InterfaceTypeColor).getOS());

        PrintWithColorRAII(OS, InterfaceTypeColor) << ""'"";

      }



      if (!P->isLet())

        OS << "" mutable"";



      if (P->isVariadic())

        OS << "" variadic"";



      if (P->getDefaultArgumentKind() != DefaultArgumentKind::None)

        printField(""default_arg"",

                   getDefaultArgumentKindString(P->getDefaultArgumentKind()));



      if (auto init = P->getDefaultValue()) {

        OS << "" expression=\n"";

        printRec(init);

      }



      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#function"");","    void printParameter(const ParamDecl *P) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter "";

      printDeclName(P);

      if (!P->getArgumentName().empty())

        PrintWithColorRAII(OS, IdentifierColor)

          << "" apiName="" << P->getArgumentName();



      if (P->hasType()) {

        PrintWithColorRAII(OS, TypeColor) << "" type='"";

        P->getType().print(PrintWithColorRAII(OS, TypeColor).getOS());

        PrintWithColorRAII(OS, TypeColor) << ""'"";

      }



      if (P->hasInterfaceType()) {

        PrintWithColorRAII(OS, InterfaceTypeColor) << "" interface type='"";

        P->getInterfaceType().print(

            PrintWithColorRAII(OS, InterfaceTypeColor).getOS());

        PrintWithColorRAII(OS, InterfaceTypeColor) << ""'"";

      }



      if (!P->isLet())

        OS << "" mutable"";



      if (P->isVariadic())

        OS << "" variadic"";



      if (P->getDefaultArgumentKind() != DefaultArgumentKind::None)

        printField(""default_arg"",

                   getDefaultArgumentKindString(P->getDefaultArgumentKind()));



      if (auto init = P->getDefaultValue()) {

        OS << "" expression=\n"";

        printRec(init);

      }



      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }

","    void printParameter(const ParamDecl *P) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter "";

      printDeclName(P);

      if (!P->getArgumentName().empty())

        PrintWithColorRAII(OS, IdentifierColor)

          << "" apiName="" << P->getArgumentName();



      if (P->hasType()) {

        PrintWithColorRAII(OS, TypeColor) << "" type='"";

        P->getType().print(PrintWithColorRAII(OS, TypeColor).getOS());

        PrintWithColorRAII(OS, TypeColor) << ""'"";

      }



      if (P->hasInterfaceType()) {

        PrintWithColorRAII(OS, InterfaceTypeColor) << "" interface type='"";

        P->getInterfaceType().print(

            PrintWithColorRAII(OS, InterfaceTypeColor).getOS());
","        PrintWithColorRAII(OS, InterfaceTypeColor) << ""'"";

      }



      if (!P->isLet())

        OS << "" mutable"";



      if (P->isVariadic())

        OS << "" variadic"";



      if (P->getDefaultArgumentKind() != DefaultArgumentKind::None)

        printField(""default_arg"",

                   getDefaultArgumentKindString(P->getDefaultArgumentKind()));



      if (auto init = P->getDefaultValue()) {

        OS << "" expression=\n"";

        printRec(init);

      }



      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#line"");","    void printParameterList(const ParameterList *params) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";

      Indent += 2;

      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }

","    void printParameterList(const ParameterList *params) {
","      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";

      Indent += 2;

      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""nil"");","    void printParameterList(const ParameterList *params) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";

      Indent += 2;

      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }

","    void printParameterList(const ParameterList *params) {

      OS.indent(Indent);
","      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";

      Indent += 2;

      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""[]"");","    void printParameterList(const ParameterList *params) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";

      Indent += 2;

      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }

","    void printParameterList(const ParameterList *params) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';
","      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";

      Indent += 2;

      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""[:]"");","    void printParameterList(const ParameterList *params) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";

      Indent += 2;

      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }

","    void printParameterList(const ParameterList *params) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";
","      Indent += 2;

      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""normal"");","    void printParameterList(const ParameterList *params) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";

      Indent += 2;

      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }

","    void printParameterList(const ParameterList *params) {

      OS.indent(Indent);

      PrintWithColorRAII(OS, ParenthesisColor) << '(';

      PrintWithColorRAII(OS, ParameterColor) << ""parameter_list"";

      Indent += 2;
","      for (auto P : *params) {

        OS << '\n';

        printParameter(P);

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

      Indent -= 2;

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor) << "" designated"";","    void visitConstructorDecl(ConstructorDecl *CD) {

      printCommonAFD(CD, ""constructor_decl"");

      if (CD->isRequired())

        PrintWithColorRAII(OS, DeclModifierColor) << "" required"";

      PrintWithColorRAII(OS, DeclModifierColor) << "" ""

        << getCtorInitializerKindString(CD->getInitKind());

      if (CD->getFailability() != OTK_None)

        PrintWithColorRAII(OS, DeclModifierColor) << "" failable=""

          << getOptionalTypeKindString(CD->getFailability());

      printAbstractFunctionDecl(CD);

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }

","    void visitConstructorDecl(ConstructorDecl *CD) {

      printCommonAFD(CD, ""constructor_decl"");

      if (CD->isRequired())

","
      PrintWithColorRAII(OS, DeclModifierColor) << "" ""

        << getCtorInitializerKindString(CD->getInitKind());

      if (CD->getFailability() != OTK_None)

        PrintWithColorRAII(OS, DeclModifierColor) << "" failable=""

          << getOptionalTypeKindString(CD->getFailability());

      printAbstractFunctionDecl(CD);

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor) << "" convenience"";","    void visitConstructorDecl(ConstructorDecl *CD) {

      printCommonAFD(CD, ""constructor_decl"");

      if (CD->isRequired())

        PrintWithColorRAII(OS, DeclModifierColor) << "" required"";

      PrintWithColorRAII(OS, DeclModifierColor) << "" ""

        << getCtorInitializerKindString(CD->getInitKind());

      if (CD->getFailability() != OTK_None)

        PrintWithColorRAII(OS, DeclModifierColor) << "" failable=""

          << getOptionalTypeKindString(CD->getFailability());

      printAbstractFunctionDecl(CD);

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }

","    void visitConstructorDecl(ConstructorDecl *CD) {

      printCommonAFD(CD, ""constructor_decl"");

      if (CD->isRequired())

        PrintWithColorRAII(OS, DeclModifierColor) << "" required"";

      PrintWithColorRAII(OS, DeclModifierColor) << "" ""
","        << getCtorInitializerKindString(CD->getInitKind());

      if (CD->getFailability() != OTK_None)

        PrintWithColorRAII(OS, DeclModifierColor) << "" failable=""

          << getOptionalTypeKindString(CD->getFailability());

      printAbstractFunctionDecl(CD);

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor) << "" factory"";","    void visitDestructorDecl(DestructorDecl *DD) {

      printCommonAFD(DD, ""destructor_decl"");

      printAbstractFunctionDecl(DD);

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }

","    void visitDestructorDecl(DestructorDecl *DD) {

","
      printAbstractFunctionDecl(DD);

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor) << "" failable=Optional"";","    void visitTopLevelCodeDecl(TopLevelCodeDecl *TLCD) {

      printCommon(TLCD, ""top_level_code_decl"");

      if (TLCD->getBody()) {

        OS << ""\n"";

        printRec(TLCD->getBody());

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }

","    void visitTopLevelCodeDecl(TopLevelCodeDecl *TLCD) {

      printCommon(TLCD, ""top_level_code_decl"");

","
        OS << ""\n"";

        printRec(TLCD->getBody());

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor)","    void visitTopLevelCodeDecl(TopLevelCodeDecl *TLCD) {

      printCommon(TLCD, ""top_level_code_decl"");

      if (TLCD->getBody()) {

        OS << ""\n"";

        printRec(TLCD->getBody());

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }

","    void visitTopLevelCodeDecl(TopLevelCodeDecl *TLCD) {

      printCommon(TLCD, ""top_level_code_decl"");

      if (TLCD->getBody()) {

        OS << ""\n"";
","        printRec(TLCD->getBody());

      }

      PrintWithColorRAII(OS, ParenthesisColor) << ')';

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,void printStringEncoding(StringLiteralExpr::Encoding encoding) {,"  void visitStringLiteralExpr(StringLiteralExpr *E) {

    printCommon(E, ""string_literal_expr"");

    PrintWithColorRAII(OS, LiteralValueColor) << "" encoding=""

      << getStringLiteralExprEncodingString(E->getEncoding())

      << "" value="" << QuotedString(E->getValue())

      << "" builtin_initializer="";

    E->getBuiltinInitializer().dump(

      PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, LiteralValueColor) << "" initializer="";

    E->getInitializer().dump(PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

",,"
    printCommon(E, ""string_literal_expr"");

    PrintWithColorRAII(OS, LiteralValueColor) << "" encoding=""

      << getStringLiteralExprEncodingString(E->getEncoding())

      << "" value="" << QuotedString(E->getValue())

      << "" builtin_initializer="";

    E->getBuiltinInitializer().dump(

      PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, LiteralValueColor) << "" initializer="";

    E->getInitializer().dump(PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor) << ""utf8"";","  void visitStringLiteralExpr(StringLiteralExpr *E) {

    printCommon(E, ""string_literal_expr"");

    PrintWithColorRAII(OS, LiteralValueColor) << "" encoding=""

      << getStringLiteralExprEncodingString(E->getEncoding())

      << "" value="" << QuotedString(E->getValue())

      << "" builtin_initializer="";

    E->getBuiltinInitializer().dump(

      PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, LiteralValueColor) << "" initializer="";

    E->getInitializer().dump(PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitStringLiteralExpr(StringLiteralExpr *E) {

","
    PrintWithColorRAII(OS, LiteralValueColor) << "" encoding=""

      << getStringLiteralExprEncodingString(E->getEncoding())

      << "" value="" << QuotedString(E->getValue())

      << "" builtin_initializer="";

    E->getBuiltinInitializer().dump(

      PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, LiteralValueColor) << "" initializer="";

    E->getInitializer().dump(PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor) << ""utf16"";","  void visitStringLiteralExpr(StringLiteralExpr *E) {

    printCommon(E, ""string_literal_expr"");

    PrintWithColorRAII(OS, LiteralValueColor) << "" encoding=""

      << getStringLiteralExprEncodingString(E->getEncoding())

      << "" value="" << QuotedString(E->getValue())

      << "" builtin_initializer="";

    E->getBuiltinInitializer().dump(

      PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, LiteralValueColor) << "" initializer="";

    E->getInitializer().dump(PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitStringLiteralExpr(StringLiteralExpr *E) {

    printCommon(E, ""string_literal_expr"");

","
      << getStringLiteralExprEncodingString(E->getEncoding())

      << "" value="" << QuotedString(E->getValue())

      << "" builtin_initializer="";

    E->getBuiltinInitializer().dump(

      PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, LiteralValueColor) << "" initializer="";

    E->getInitializer().dump(PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor) << ""unicodeScalar"";","  void visitStringLiteralExpr(StringLiteralExpr *E) {

    printCommon(E, ""string_literal_expr"");

    PrintWithColorRAII(OS, LiteralValueColor) << "" encoding=""

      << getStringLiteralExprEncodingString(E->getEncoding())

      << "" value="" << QuotedString(E->getValue())

      << "" builtin_initializer="";

    E->getBuiltinInitializer().dump(

      PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, LiteralValueColor) << "" initializer="";

    E->getInitializer().dump(PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitStringLiteralExpr(StringLiteralExpr *E) {

    printCommon(E, ""string_literal_expr"");

    PrintWithColorRAII(OS, LiteralValueColor) << "" encoding=""

","
      << "" value="" << QuotedString(E->getValue())

      << "" builtin_initializer="";

    E->getBuiltinInitializer().dump(

      PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, LiteralValueColor) << "" initializer="";

    E->getInitializer().dump(PrintWithColorRAII(OS, LiteralValueColor).getOS());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor) << "" encoding="";","  void visitInterpolatedStringLiteralExpr(InterpolatedStringLiteralExpr *E) {

    printCommon(E, ""interpolated_string_literal_expr"");

    for (auto Segment : E->getSegments()) {

      OS << '\n';

      printRec(Segment);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

",,"
    printCommon(E, ""interpolated_string_literal_expr"");

    for (auto Segment : E->getSegments()) {

      OS << '\n';

      printRec(Segment);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,printStringEncoding(E->getEncoding());,"  void visitInterpolatedStringLiteralExpr(InterpolatedStringLiteralExpr *E) {

    printCommon(E, ""interpolated_string_literal_expr"");

    for (auto Segment : E->getSegments()) {

      OS << '\n';

      printRec(Segment);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

",,"
    printCommon(E, ""interpolated_string_literal_expr"");

    for (auto Segment : E->getSegments()) {

      OS << '\n';

      printRec(Segment);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor)","  void visitInterpolatedStringLiteralExpr(InterpolatedStringLiteralExpr *E) {

    printCommon(E, ""interpolated_string_literal_expr"");

    for (auto Segment : E->getSegments()) {

      OS << '\n';

      printRec(Segment);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

",,"
    printCommon(E, ""interpolated_string_literal_expr"");

    for (auto Segment : E->getSegments()) {

      OS << '\n';

      printRec(Segment);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printCommon(E, ""magic_identifier_literal_expr"") << "" kind="";","  void visitMagicIdentifierLiteralExpr(MagicIdentifierLiteralExpr *E) {

    printCommon(E, ""magic_identifier_literal_expr"")

      << "" kind="" << getMagicIdentifierLiteralExprKindString(E->getKind());



    if (E->isString()) {

      OS << "" encoding=""

         << getStringLiteralExprEncodingString(E->getStringEncoding())

         << "" builtin_initializer="";

      E->getBuiltinInitializer().dump(OS);

      OS << "" initializer="";

      E->getInitializer().dump(OS);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitMagicIdentifierLiteralExpr(MagicIdentifierLiteralExpr *E) {
","    printCommon(E, ""magic_identifier_literal_expr"")

      << "" kind="" << getMagicIdentifierLiteralExprKindString(E->getKind());



    if (E->isString()) {

      OS << "" encoding=""

         << getStringLiteralExprEncodingString(E->getStringEncoding())

         << "" builtin_initializer="";

      E->getBuiltinInitializer().dump(OS);

      OS << "" initializer="";

      E->getInitializer().dump(OS);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,printStringEncoding(E->getStringEncoding());,"  void visitMagicIdentifierLiteralExpr(MagicIdentifierLiteralExpr *E) {

    printCommon(E, ""magic_identifier_literal_expr"")

      << "" kind="" << getMagicIdentifierLiteralExprKindString(E->getKind());



    if (E->isString()) {

      OS << "" encoding=""

         << getStringLiteralExprEncodingString(E->getStringEncoding())

         << "" builtin_initializer="";

      E->getBuiltinInitializer().dump(OS);

      OS << "" initializer="";

      E->getInitializer().dump(OS);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitMagicIdentifierLiteralExpr(MagicIdentifierLiteralExpr *E) {

    printCommon(E, ""magic_identifier_literal_expr"")

","


    if (E->isString()) {

      OS << "" encoding=""

         << getStringLiteralExprEncodingString(E->getStringEncoding())

         << "" builtin_initializer="";

      E->getBuiltinInitializer().dump(OS);

      OS << "" initializer="";

      E->getInitializer().dump(OS);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,printStringEncoding(E->getStringEncoding());,"  void visitMagicIdentifierLiteralExpr(MagicIdentifierLiteralExpr *E) {

    printCommon(E, ""magic_identifier_literal_expr"")

      << "" kind="" << getMagicIdentifierLiteralExprKindString(E->getKind());



    if (E->isString()) {

      OS << "" encoding=""

         << getStringLiteralExprEncodingString(E->getStringEncoding())

         << "" builtin_initializer="";

      E->getBuiltinInitializer().dump(OS);

      OS << "" initializer="";

      E->getInitializer().dump(OS);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitMagicIdentifierLiteralExpr(MagicIdentifierLiteralExpr *E) {

    printCommon(E, ""magic_identifier_literal_expr"")

      << "" kind="" << getMagicIdentifierLiteralExprKindString(E->getKind());



","
      OS << "" encoding=""

         << getStringLiteralExprEncodingString(E->getStringEncoding())

         << "" builtin_initializer="";

      E->getBuiltinInitializer().dump(OS);

      OS << "" initializer="";

      E->getInitializer().dump(OS);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << E->getAccessSemantics();","  void visitDeclRefExpr(DeclRefExpr *E) {

    printCommon(E, ""declref_expr"");

    PrintWithColorRAII(OS, DeclColor) << "" decl="";

    E->getDeclRef().dump(PrintWithColorRAII(OS, DeclColor).getOS());

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

      PrintWithColorRAII(OS, AccessibilityColor)

        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    PrintWithColorRAII(OS, ExprModifierColor)

      << "" function_ref="" << getFunctionRefKindStr(E->getFunctionRefKind())

      << "" specialized="" << (E->isSpecialized()? ""yes"" : ""no"");



    for (auto TR : E->getGenericArgs()) {

      OS << '\n';

      printRec(TR);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitDeclRefExpr(DeclRefExpr *E) {

    printCommon(E, ""declref_expr"");

","
    E->getDeclRef().dump(PrintWithColorRAII(OS, DeclColor).getOS());

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

      PrintWithColorRAII(OS, AccessibilityColor)

        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    PrintWithColorRAII(OS, ExprModifierColor)

      << "" function_ref="" << getFunctionRefKindStr(E->getFunctionRefKind())

      << "" specialized="" << (E->isSpecialized()? ""yes"" : ""no"");



    for (auto TR : E->getGenericArgs()) {

      OS << '\n';

      printRec(TR);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, AccessibilityColor)","  void visitDeclRefExpr(DeclRefExpr *E) {

    printCommon(E, ""declref_expr"");

    PrintWithColorRAII(OS, DeclColor) << "" decl="";

    E->getDeclRef().dump(PrintWithColorRAII(OS, DeclColor).getOS());

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

      PrintWithColorRAII(OS, AccessibilityColor)

        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    PrintWithColorRAII(OS, ExprModifierColor)

      << "" function_ref="" << getFunctionRefKindStr(E->getFunctionRefKind())

      << "" specialized="" << (E->isSpecialized()? ""yes"" : ""no"");



    for (auto TR : E->getGenericArgs()) {

      OS << '\n';

      printRec(TR);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitDeclRefExpr(DeclRefExpr *E) {

    printCommon(E, ""declref_expr"");

    PrintWithColorRAII(OS, DeclColor) << "" decl="";

    E->getDeclRef().dump(PrintWithColorRAII(OS, DeclColor).getOS());

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

     ","
        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    PrintWithColorRAII(OS, ExprModifierColor)

      << "" function_ref="" << getFunctionRefKindStr(E->getFunctionRefKind())

      << "" specialized="" << (E->isSpecialized()? ""yes"" : ""no"");



    for (auto TR : E->getGenericArgs()) {

      OS << '\n';

      printRec(TR);

    }

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << E->getAccessSemantics();","  void visitMemberRefExpr(MemberRefExpr *E) {

    printCommon(E, ""member_ref_expr"")

      << "" decl="";

    E->getMember().dump(OS);

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

      PrintWithColorRAII(OS, AccessibilityColor)

        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    if (E->isSuper())

      OS << "" super"";



    OS << '\n';

    printRec(E->getBase());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitMemberRefExpr(MemberRefExpr *E) {

    printCommon(E, ""member_ref_expr"")

      << "" decl="";
","    E->getMember().dump(OS);

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

      PrintWithColorRAII(OS, AccessibilityColor)

        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    if (E->isSuper())

      OS << "" super"";



    OS << '\n';

    printRec(E->getBase());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, AccessibilityColor)","  void visitMemberRefExpr(MemberRefExpr *E) {

    printCommon(E, ""member_ref_expr"")

      << "" decl="";

    E->getMember().dump(OS);

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

      PrintWithColorRAII(OS, AccessibilityColor)

        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    if (E->isSuper())

      OS << "" super"";



    OS << '\n';

    printRec(E->getBase());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitMemberRefExpr(MemberRefExpr *E) {

    printCommon(E, ""member_ref_expr"")

      << "" decl="";

    E->getMember().dump(OS);

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

     ","
        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    if (E->isSuper())

      OS << "" super"";



    OS << '\n';

    printRec(E->getBase());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << E->getAccessSemantics();","  void visitSubscriptExpr(SubscriptExpr *E) {

    printCommon(E, ""subscript_expr"");

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

      PrintWithColorRAII(OS, AccessibilityColor)

        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    if (E->isSuper())

      OS << "" super"";

    if (E->hasDecl()) {

      OS << ""  decl="";

      E->getDecl().dump(OS);

    }

    printArgumentLabels(E->getArgumentLabels());

    OS << '\n';

    printRec(E->getBase());

    OS << '\n';

    printRec(E->getIndex());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitSubscriptExpr(SubscriptExpr *E) {

","
    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

      PrintWithColorRAII(OS, AccessibilityColor)

        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    if (E->isSuper())

      OS << "" super"";

    if (E->hasDecl()) {

      OS << ""  decl="";

      E->getDecl().dump(OS);

    }

    printArgumentLabels(E->getArgumentLabels());

    OS << '\n';

    printRec(E->getBase());

    OS << '\n';

    printRec(E->getIndex());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, AccessibilityColor)","  void visitSubscriptExpr(SubscriptExpr *E) {

    printCommon(E, ""subscript_expr"");

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

      PrintWithColorRAII(OS, AccessibilityColor)

        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    if (E->isSuper())

      OS << "" super"";

    if (E->hasDecl()) {

      OS << ""  decl="";

      E->getDecl().dump(OS);

    }

    printArgumentLabels(E->getArgumentLabels());

    OS << '\n';

    printRec(E->getBase());

    OS << '\n';

    printRec(E->getIndex());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

","  void visitSubscriptExpr(SubscriptExpr *E) {

    printCommon(E, ""subscript_expr"");

    if (E->getAccessSemantics() != AccessSemantics::Ordinary)

     ","
        << "" "" << getAccessSemanticsString(E->getAccessSemantics());

    if (E->isSuper())

      OS << "" super"";

    if (E->hasDecl()) {

      OS << ""  decl="";

      E->getDecl().dump(OS);

    }

    printArgumentLabels(E->getArgumentLabels());

    OS << '\n';

    printRec(E->getBase());

    OS << '\n';

    printRec(E->getIndex());

    PrintWithColorRAII(OS, ParenthesisColor) << ')';

  }

"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printFlag(""vararg"");","    void dumpParameterFlags(ParameterTypeFlags paramFlags) {

      printFlag(paramFlags.isVariadic(), ""vararg"");

      printFlag(paramFlags.isAutoClosure(), ""autoclosure"");

      printFlag(paramFlags.isEscaping(), ""escaping"");

    }

","    void dumpParameterFlags(ParameterTypeFlags paramFlags) {

","
      printFlag(paramFlags.isAutoClosure(), ""autoclosure"");

      printFlag(paramFlags.isEscaping(), ""escaping"");

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printFlag(""autoclosure"");","    void dumpParameterFlags(ParameterTypeFlags paramFlags) {

      printFlag(paramFlags.isVariadic(), ""vararg"");

      printFlag(paramFlags.isAutoClosure(), ""autoclosure"");

      printFlag(paramFlags.isEscaping(), ""escaping"");

    }

","    void dumpParameterFlags(ParameterTypeFlags paramFlags) {

      printFlag(paramFlags.isVariadic(), ""vararg"");
","      printFlag(paramFlags.isAutoClosure(), ""autoclosure"");

      printFlag(paramFlags.isEscaping(), ""escaping"");

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printFlag(""escaping"");","    void dumpParameterFlags(ParameterTypeFlags paramFlags) {

      printFlag(paramFlags.isVariadic(), ""vararg"");

      printFlag(paramFlags.isAutoClosure(), ""autoclosure"");

      printFlag(paramFlags.isEscaping(), ""escaping"");

    }

","    void dumpParameterFlags(ParameterTypeFlags paramFlags) {

      printFlag(paramFlags.isVariadic(), ""vararg"");

","
      printFlag(paramFlags.isEscaping(), ""escaping"");

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,"printFlag(paramFlags.isVariadic(), ""vararg"");","    void dumpParameterFlags(ParameterTypeFlags paramFlags) {

      printFlag(paramFlags.isVariadic(), ""vararg"");

      printFlag(paramFlags.isAutoClosure(), ""autoclosure"");

      printFlag(paramFlags.isEscaping(), ""escaping"");

    }

","    void dumpParameterFlags(ParameterTypeFlags paramFlags) {

     ","
      printFlag(paramFlags.isAutoClosure(), ""autoclosure"");

      printFlag(paramFlags.isEscaping(), ""escaping"");

    }

"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,void printMetatypeRepresentation(MetatypeRepresentation representation) {,"    void visitMetatypeType(MetatypeType *T, StringRef label) {

      printCommon(T, label, ""metatype_type"");

      if (T->hasRepresentation())

        OS << "" "" << getMetatypeRepresentationString(T->getRepresentation());

      printRec(T->getInstanceType());

      OS << "")"";

    }

",,"
      printCommon(T, label, ""metatype_type"");

      if (T->hasRepresentation())

        OS << "" "" << getMetatypeRepresentationString(T->getRepresentation());

      printRec(T->getInstanceType());

      OS << "")"";

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,printMetatypeRepresentation(T->getRepresentation());,"    void visitModuleType(ModuleType *T, StringRef label) {

      printCommon(T, label, ""module_type"");

      printField(""module"", T->getModule()->getName());

      OS << "")"";

    }

",,"
      printCommon(T, label, ""module_type"");

      printField(""module"", T->getModule()->getName());

      OS << "")"";

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,printMetatypeRepresentation(T->getRepresentation());,"    void visitExistentialMetatypeType(ExistentialMetatypeType *T,

                                      StringRef label) {

      printCommon(T, label, ""existential_metatype_type"");

      if (T->hasRepresentation())

        OS << "" "" << getMetatypeRepresentationString(T->getRepresentation());

      printRec(T->getInstanceType());

      OS << "")"";

    }

","    void visitExistentialMetatypeType(ExistentialMetatypeType *T,

                                      StringRef label) {

","
      if (T->hasRepresentation())

        OS << "" "" << getMetatypeRepresentationString(T->getRepresentation());

      printRec(T->getInstanceType());

      OS << "")"";

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""block"");","    void printAnyFunctionTypeCommon(AnyFunctionType *T, StringRef label,

                                    StringRef name) {

      printCommon(T, label, name);

      SILFunctionType::Representation representation =

        T->getExtInfo().getSILRepresentation();



      if (representation != SILFunctionType::Representation::Thick)

        printField(""representation"",

                   getSILFunctionTypeRepresentationString(representation));



      printFlag(T->isAutoClosure(), ""autoclosure"");

      printFlag(!T->isNoEscape(), ""escaping"");

      printFlag(T->throws(), ""throws"");



      printRec(""input"", T->getInput());

      printRec(""output"", T->getResult());

    }

","    void printAnyFunctionTypeCommon(AnyFunctionType *T, StringRef label,

                                    StringRef name) {

      printCommon(T, label, name);

      SILFunctionType::Representation representation =

        T->getExtInfo().getSILRepresentation();


","      if (representation != SILFunctionType::Representation::Thick)

        printField(""representation"",

                   getSILFunctionTypeRepresentationString(representation));



      printFlag(T->isAutoClosure(), ""autoclosure"");

      printFlag(!T->isNoEscape(), ""escaping"");

      printFlag(T->throws(), ""throws"");



      printRec(""input"", T->getInput());

      printRec(""output"", T->getResult());

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""c"");","    void printAnyFunctionTypeCommon(AnyFunctionType *T, StringRef label,

                                    StringRef name) {

      printCommon(T, label, name);

      SILFunctionType::Representation representation =

        T->getExtInfo().getSILRepresentation();



      if (representation != SILFunctionType::Representation::Thick)

        printField(""representation"",

                   getSILFunctionTypeRepresentationString(representation));



      printFlag(T->isAutoClosure(), ""autoclosure"");

      printFlag(!T->isNoEscape(), ""escaping"");

      printFlag(T->throws(), ""throws"");



      printRec(""input"", T->getInput());

      printRec(""output"", T->getResult());

    }

","    void printAnyFunctionTypeCommon(AnyFunctionType *T, StringRef label,

                                    StringRef name) {

      printCommon(T, label, name);

      SILFunctionType::Representation representation =

        T->getExtInfo().getSILRepresentation();



      if (representation != SILFunctionType::Representation::Thick)

","
                   getSILFunctionTypeRepresentationString(representation));



      printFlag(T->isAutoClosure(), ""autoclosure"");

      printFlag(!T->isNoEscape(), ""escaping"");

      printFlag(T->throws(), ""throws"");



      printRec(""input"", T->getInput());

      printRec(""output"", T->getResult());

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""method"");","    void visitFunctionType(FunctionType *T, StringRef label) {

      printAnyFunctionTypeCommon(T, label, ""function_type"");

      OS << "")"";

    }

","    void visitFunctionType(FunctionType *T, StringRef label) {

","
      OS << "")"";

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""objc_method"");","    void visitGenericFunctionType(GenericFunctionType *T, StringRef label) {

      printAnyFunctionTypeCommon(T, label, ""generic_function_type"");

      // FIXME: generic signature dumping needs improvement

      OS << ""\n"";

      OS.indent(Indent + 2) << ""("";

      printField(""generic_sig"", T->getGenericSignature()->getAsString());

      OS << "")"";

      OS << "")"";

    }

",,"
      printAnyFunctionTypeCommon(T, label, ""generic_function_type"");

      // FIXME: generic signature dumping needs improvement

      OS << ""\n"";

      OS.indent(Indent + 2) << ""("";

      printField(""generic_sig"", T->getGenericSignature()->getAsString());

      OS << "")"";

      OS << "")"";

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""witness_method"");","    void visitGenericFunctionType(GenericFunctionType *T, StringRef label) {

      printAnyFunctionTypeCommon(T, label, ""generic_function_type"");

      // FIXME: generic signature dumping needs improvement

      OS << ""\n"";

      OS.indent(Indent + 2) << ""("";

      printField(""generic_sig"", T->getGenericSignature()->getAsString());

      OS << "")"";

      OS << "")"";

    }

","    void visitGenericFunctionType(GenericFunctionType *T, StringRef label) {

      printAnyFunctionTypeCommon(T, label, ""generic_function_type"");
","      // FIXME: generic signature dumping needs improvement

      OS << ""\n"";

      OS.indent(Indent + 2) << ""("";

      printField(""generic_sig"", T->getGenericSignature()->getAsString());

      OS << "")"";

      OS << "")"";

    }


"
Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""closure"");","    void visitGenericFunctionType(GenericFunctionType *T, StringRef label) {

      printAnyFunctionTypeCommon(T, label, ""generic_function_type"");

      // FIXME: generic signature dumping needs improvement

      OS << ""\n"";

      OS.indent(Indent + 2) << ""("";

      printField(""generic_sig"", T->getGenericSignature()->getAsString());

      OS << "")"";

      OS << "")"";

    }

","    void visitGenericFunctionType(GenericFunctionType *T, StringRef label) {

      printAnyFunctionTypeCommon(T, label, ""generic_function_type"");

      // FIXME: generic signature dumping needs improvement

","
      OS.indent(Indent + 2) << ""("";

      printField(""generic_sig"", T->getGenericSignature()->getAsString());

      OS << "")"";

      OS << "")"";

    }


"
Merge pull request #7592 from gottesmm/lvalue_temporaries,lib/SILGen/SILGenDecl.cpp,+,assert(evaluation.getKind() == FormalAccess::Owned);,"  OwnedFormalAccess &getEvaluation(SILGenFunction &gen) const {

    auto &evaluation = *gen.FormalEvalContext.find(Depth);

    assert(evaluation.getKind() == FormalAccess::Owned);

    return static_cast<OwnedFormalAccess &>(evaluation);

  }

","  OwnedFormalAccess &getEvaluation(SILGenFunction &gen) const {

    auto &evaluation = *gen.FormalEvalContext.find(Depth);

   ","
    return static_cast<OwnedFormalAccess &>(evaluation);

  }

"
"[silgen] When emitting lvalue gets into temporaries, cleanup the temporaries as early as possible.

Previously, we were emitting these cleanups at the end of the lexical scope
instead of at the end of the formal evaluation scope. This change ensures that
we always emit the cleanup immediately at the end of the formal evaluation
scope.

Previously in most cases we got away with this due to the +0 self
hack. Basically we would emit a get for a self parameter and then immediately
use that self parameter as a guaranteed parameter. Then the hack would insert
the destroy value forwarding the lexical scope level cleanup at the same time.

rdar://29791263",lib/SILGen/SILGenDecl.cpp,+,assert(evaluation.getKind() == FormalAccess::Owned);,"  OwnedFormalAccess &getEvaluation(SILGenFunction &gen) const {

    auto &evaluation = *gen.FormalEvalContext.find(Depth);

    assert(evaluation.getKind() == FormalAccess::Owned);

    return static_cast<OwnedFormalAccess &>(evaluation);

  }

","  OwnedFormalAccess &getEvaluation(SILGenFunction &gen) const {

    auto &evaluation = *gen.FormalEvalContext.find(Depth);

   ","
    return static_cast<OwnedFormalAccess &>(evaluation);

  }

"
Cleanup: Move Swift to ObjC name translation API to libAST to allow larger audience body. NFC (#7586),lib/PrintAsObjC/PrintAsObjC.cpp,-,assert(isa<ClassDecl>(VD) || isa<ProtocolDecl>(VD) || isa<StructDecl>(VD) ||,"static bool looksLikeInitMethod(ObjCSelector selector) {

  ArrayRef<Identifier> selectorPieces = selector.getSelectorPieces();

  assert(!selectorPieces.empty());

  auto firstPiece = selectorPieces.front().str();

  if (!firstPiece.startswith(""init"")) return false;

  return !(firstPiece.size() > 4 && clang::isLowercase(firstPiece[4]));

}

","static bool looksLikeInitMethod(ObjCSelector selector) {

  ArrayRef<Identifier> selectorPieces = selector.getSelectorPieces();

  assert(!selectorPieces.empty());
","  auto firstPiece = selectorPieces.front().str();

  if (!firstPiece.startswith(""init"")) return false;

  return !(firstPiece.size() > 4 && clang::isLowercase(firstPiece[4]));

}


"
"Merge pull request #7582 from bitjammer/sr-3989-syntax-fallthrough-stmt

[Syntax] Implement fallthrough-statement",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(FallthroughKW, Fallthrough.getFallthroughKeyword());","TEST(StmtSyntaxTests, FallthroughStmtGetAPIs) {

  llvm::SmallString<48> Scratch;

  llvm::raw_svector_ostream OS(Scratch);



  auto FallthroughKW = SyntaxFactory::makeFallthroughKeyword({}, {});



  auto Fallthrough = SyntaxFactory::makeBlankFallthroughStmt()

    .withFallthroughKeyword(FallthroughKW);



  /// This should be directly shared through reference-counting.

  ASSERT_EQ(FallthroughKW, Fallthrough.getFallthroughKeyword());

}

","TEST(StmtSyntaxTests, FallthroughStmtGetAPIs) {

  llvm::SmallString<48> Scratch;

  llvm::raw_svector_ostream OS(Scratch);



  auto FallthroughKW = SyntaxFactory::makeFallthroughKeyword({}, {});



  auto Fallthrough = SyntaxFactory::makeBlankFallthroughStmt()

    .withFallthroughKeyword(FallthroughKW);



  /// This should be directly shared through reference-counting.

 ","
}

"
Merge pull request #7583 from gottesmm/formal_access_rename,lib/SILGen/SILGenLValue.cpp,-,assert(evaluation.getKind() == FormalEvaluation::Exclusive);,"  void emit(SILGenFunction &gen, CleanupLocation loc) override {

    auto &evaluation = *gen.FormalEvalContext.find(Depth);

    assert(evaluation.getKind() == FormalAccess::Exclusive);

    auto &lvalue = static_cast<ExclusiveBorrowFormalAccess &>(evaluation);

    lvalue.performWriteback(gen, /*isFinal*/ false);

  }

","  void emit(SILGenFunction &gen, CleanupLocation loc) override {

","
    assert(evaluation.getKind() == FormalAccess::Exclusive);

    auto &lvalue = static_cast<ExclusiveBorrowFormalAccess &>(evaluation);

    lvalue.performWriteback(gen, /*isFinal*/ false);

  }


"
Merge pull request #7583 from gottesmm/formal_access_rename,lib/SILGen/SILGenLValue.cpp,+,assert(evaluation.getKind() == FormalAccess::Exclusive);,"  void emit(SILGenFunction &gen, CleanupLocation loc) override {

    auto &evaluation = *gen.FormalEvalContext.find(Depth);

    assert(evaluation.getKind() == FormalAccess::Exclusive);

    auto &lvalue = static_cast<ExclusiveBorrowFormalAccess &>(evaluation);

    lvalue.performWriteback(gen, /*isFinal*/ false);

  }

","  void emit(SILGenFunction &gen, CleanupLocation loc) override {

    auto &evaluation = *gen.FormalEvalContext.find(Depth);

   ","
    auto &lvalue = static_cast<ExclusiveBorrowFormalAccess &>(evaluation);

    lvalue.performWriteback(gen, /*isFinal*/ false);

  }

"
[silgen] Use the name FormalAccess to refer to state related to accesses in a single formal evaluation context.,lib/SILGen/SILGenLValue.cpp,-,assert(evaluation.getKind() == FormalEvaluation::Exclusive);,"  void emit(SILGenFunction &gen, CleanupLocation loc) override {

    auto &evaluation = *gen.FormalEvalContext.find(Depth);

    assert(evaluation.getKind() == FormalAccess::Exclusive);

    auto &lvalue = static_cast<ExclusiveBorrowFormalAccess &>(evaluation);

    lvalue.performWriteback(gen, /*isFinal*/ false);

  }

","  void emit(SILGenFunction &gen, CleanupLocation loc) override {

","
    assert(evaluation.getKind() == FormalAccess::Exclusive);

    auto &lvalue = static_cast<ExclusiveBorrowFormalAccess &>(evaluation);

    lvalue.performWriteback(gen, /*isFinal*/ false);

  }


"
[silgen] Use the name FormalAccess to refer to state related to accesses in a single formal evaluation context.,lib/SILGen/SILGenLValue.cpp,+,assert(evaluation.getKind() == FormalAccess::Exclusive);,"  void emit(SILGenFunction &gen, CleanupLocation loc) override {

    auto &evaluation = *gen.FormalEvalContext.find(Depth);

    assert(evaluation.getKind() == FormalAccess::Exclusive);

    auto &lvalue = static_cast<ExclusiveBorrowFormalAccess &>(evaluation);

    lvalue.performWriteback(gen, /*isFinal*/ false);

  }

","  void emit(SILGenFunction &gen, CleanupLocation loc) override {

    auto &evaluation = *gen.FormalEvalContext.find(Depth);

   ","
    auto &lvalue = static_cast<ExclusiveBorrowFormalAccess &>(evaluation);

    lvalue.performWriteback(gen, /*isFinal*/ false);

  }

"
"[Syntax] Implement fallthrough-statement

https://bugs.swift.org/browse/SR-3989",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(FallthroughKW, Fallthrough.getFallthroughKeyword());","TEST(StmtSyntaxTests, FallthroughStmtGetAPIs) {

  llvm::SmallString<48> Scratch;

  llvm::raw_svector_ostream OS(Scratch);



  auto FallthroughKW = SyntaxFactory::makeFallthroughKeyword({}, {});



  auto Fallthrough = SyntaxFactory::makeBlankFallthroughStmt()

    .withFallthroughKeyword(FallthroughKW);



  /// This should be directly shared through reference-counting.

  ASSERT_EQ(FallthroughKW, Fallthrough.getFallthroughKeyword());

}

","TEST(StmtSyntaxTests, FallthroughStmtGetAPIs) {

  llvm::SmallString<48> Scratch;

  llvm::raw_svector_ostream OS(Scratch);



  auto FallthroughKW = SyntaxFactory::makeFallthroughKeyword({}, {});



  auto Fallthrough = SyntaxFactory::makeBlankFallthroughStmt()

    .withFallthroughKeyword(FallthroughKW);



  /// This should be directly shared through reference-counting.

 ","
}

"
"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/Trivia.cpp,+,"void printRepeated(llvm::raw_ostream &OS, char c, size_t Count) {","void printRepeated(llvm::raw_ostream &OS, char c, size_t Count) {

  for (decltype(Count) i = 0; i < Count; ++i)

    OS << c;

}

","void printRepeated(llvm::raw_ostream &OS, char c, size_t Count) {

  for (decltype(Count) i = 0; i < Count; ++i)

    OS << c;

}
","
  for (decltype(Count) i = 0; i < Count; ++i)

    OS << c;

}

"
"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",tools/swift-format/swift-format.cpp,+,"InputFilename, Buffer.getError().message());","int doFormat(ArrayRef<StringRef> InputFiles) {



  for (auto InputFilename : InputFiles) {

    CompilerInvocation Invocation;

    Invocation.addInputFilename(InputFilename);

    Invocation.setModuleName(""Format"");

    CompilerInstance Instance;



    auto &SourceMgr = Instance.getSourceMgr();

    auto &Diags = Instance.getDiags();



    PrintingDiagnosticConsumer DiagPrinter;

    Instance.addDiagnosticConsumer(&DiagPrinter);

    if (Instance.setup(Invocation)) {

      return EXIT_FAILURE;

    }



    // First, parse the file normally and get the regular old AST.

    Instance.performParseOnly();



    auto BufferID = Instance.getInputBufferIDs().back();

    auto &SF = Instance.getMainModule()

      ->getMainSourceFile(SourceFileKind::Main);



    auto Buffer = llvm::MemoryBuffer::getFile(InputFilename);

    if (!Buffer) {

      Diags.diagnose(SourceLoc(), diag::cannot_open_file,

                     InputFilename, Buffer.getError().message());

      return EXIT_FAILURE;

    }



    auto Tokens = tokenizeWithTrivia(Invocation.getLangOptions(),

                                     SourceMgr, BufferID);



    SmallVector<Decl *, 256> FileDecls;

    SF.getTopLevelDecls(FileDecls);

    sema::Semantics Sema;

    for (auto *Decl : FileDecls) {

      if (Decl->escapedFromIfConfig()) {

        continue;

      }

      auto NewNode = transformAST(ASTNode(Decl), Sema, SourceMgr,

                                  BufferID, Tokens);

      if (NewNode.hasValue()) {

        auto Reformatted = format(NewNode.getValue());

        Reformatted.print(llvm::outs());

      }

    }

  }

  return EXIT_SUCCESS;

}

","int doFormat(ArrayRef<StringRef> InputFiles) {



  for (auto InputFilename : InputFiles) {

    CompilerInvocation Invocation;

    Invocation.addInputFilename(InputFilename);

    Invocation.setModuleName(""Format"");

    CompilerInstance Instance;



    auto &SourceMgr = Instance.getSourceMgr();

    auto &Diags = Instance.getDiags();



    PrintingDiagnosticConsumer DiagPrinter;

    Instance.addDiagnosticConsumer(&DiagPrinter);

    if (Instance.setup(Invocation)) {

      return EXIT_FAILURE;

    }



    // First, parse the file normally and get the regular old AST.

    Instance.performParseOnly();



    auto BufferID = Instance.getInputBufferIDs().back();

    auto &SF = Instance.getMainModule()

      ->getMainSourceFile(SourceFileKind::Main);



    auto Buffer = llvm::MemoryBuffer::getFile(InputFilename);

    if (!Buffer) {

      Diags.diagnose(SourceLoc(), diag::cannot_open_file,

                    ","
      return EXIT_FAILURE;

    }



    auto Tokens = tokenizeWithTrivia(Invocation.getLangOptions(),

                                     SourceMgr, BufferID);



    SmallVector<Decl *, 256> FileDecls;

    SF.getTopLevelDecls(FileDecls);

    sema::Semantics Sema;

    for (auto *Decl : FileDecls) {

      if (Decl->escapedFromIfConfig()) {

        continue;

      }

      auto NewNode = transformAST(ASTNode(Decl), Sema, SourceMgr,

                                  BufferID, Tokens);

      if (NewNode.hasValue()) {

        auto Reformatted = format(NewNode.getValue());

        Reformatted.print(llvm::outs());

      }

    }

  }

  return EXIT_SUCCESS;

}

"
"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",tools/swift-format/swift-format.cpp,+,Reformatted.print(llvm::outs());,"int doFormat(ArrayRef<StringRef> InputFiles) {



  for (auto InputFilename : InputFiles) {

    CompilerInvocation Invocation;

    Invocation.addInputFilename(InputFilename);

    Invocation.setModuleName(""Format"");

    CompilerInstance Instance;



    auto &SourceMgr = Instance.getSourceMgr();

    auto &Diags = Instance.getDiags();



    PrintingDiagnosticConsumer DiagPrinter;

    Instance.addDiagnosticConsumer(&DiagPrinter);

    if (Instance.setup(Invocation)) {

      return EXIT_FAILURE;

    }



    // First, parse the file normally and get the regular old AST.

    Instance.performParseOnly();



    auto BufferID = Instance.getInputBufferIDs().back();

    auto &SF = Instance.getMainModule()

      ->getMainSourceFile(SourceFileKind::Main);



    auto Buffer = llvm::MemoryBuffer::getFile(InputFilename);

    if (!Buffer) {

      Diags.diagnose(SourceLoc(), diag::cannot_open_file,

                     InputFilename, Buffer.getError().message());

      return EXIT_FAILURE;

    }



    auto Tokens = tokenizeWithTrivia(Invocation.getLangOptions(),

                                     SourceMgr, BufferID);



    SmallVector<Decl *, 256> FileDecls;

    SF.getTopLevelDecls(FileDecls);

    sema::Semantics Sema;

    for (auto *Decl : FileDecls) {

      if (Decl->escapedFromIfConfig()) {

        continue;

      }

      auto NewNode = transformAST(ASTNode(Decl), Sema, SourceMgr,

                                  BufferID, Tokens);

      if (NewNode.hasValue()) {

        auto Reformatted = format(NewNode.getValue());

        Reformatted.print(llvm::outs());

      }

    }

  }

  return EXIT_SUCCESS;

}

","int doFormat(ArrayRef<StringRef> InputFiles) {



  for (auto InputFilename : InputFiles) {

    CompilerInvocation Invocation;

    Invocation.addInputFilename(InputFilename);

    Invocation.setModuleName(""Format"");

    CompilerInstance Instance;



    auto &SourceMgr = Instance.getSourceMgr();

    auto &Diags = Instance.getDiags();



    PrintingDiagnosticConsumer DiagPrinter;

    Instance.addDiagnosticConsumer(&DiagPrinter);

    if (Instance.setup(Invocation)) {

      return EXIT_FAILURE;

    }



    // First, parse the file normally and get the regular old AST.

    Instance.performParseOnly();



    auto BufferID = Instance.getInputBufferIDs().back();

    auto &SF = Instance.getMainModule()

      ->getMainSourceFile(SourceFileKind::Main);



    auto Buffer = llvm::MemoryBuffer::getFile(InputFilename);

    if (!Buffer) {

      Diags.diagnose(SourceLoc(), diag::cannot_open_file,

                     InputFilename, Buffer.getError().message());

      return EXIT_FAILURE;

    }



    auto Tokens = tokenizeWithTrivia(Invocation.getLangOptions(),

                                     SourceMgr, BufferID);



    SmallVector<Decl *, 256> FileDecls;

    SF.getTopLevelDecls(FileDecls);

    sema::Semantics Sema;

    for (auto *Decl : FileDecls) {

      if (Decl->escapedFromIfConfig()) {

        continue;

      }

      auto NewNode = transformAST(ASTNode(Decl), Sema, SourceMgr,

                                  BufferID, Tokens);

      if (NewNode.hasValue()) {

        auto Reformatted = format(NewNode.getValue());

       ","
      }

    }

  }

  return EXIT_SUCCESS;

}

"
"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeBlankTypealiasDecl().print(OS);,"TEST(DeclSyntaxTests, TypealiasMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankTypealiasDecl().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<64> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Typealias =

      SyntaxFactory::makeTypealiasKeyword({}, { Trivia::spaces(1) });

    auto Subsequence = SyntaxFactory::makeIdentifier(""MyCollection"", {}, {});

    auto ElementParam =

      SyntaxFactory::makeGenericParameter(""Element"", {}, {});

    auto LeftAngle = SyntaxFactory::makeLeftAngleToken({}, {});

    auto RightAngle =

      SyntaxFactory::makeRightAngleToken({}, { Trivia::spaces(1) });

    auto GenericParams = GenericParameterClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(RightAngle)

      .addParameter(None, ElementParam)

      .build();

    auto Assignment = SyntaxFactory::makeEqualToken({}, { Trivia::spaces(1) });



    auto ElementArg = SyntaxFactory::makeTypeIdentifier(""Element"", {}, {});



    auto GenericArgs = GenericArgumentClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(None, ElementArg)

      .build();



    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto Array_Int = SyntaxFactory::makeTypeIdentifier(Array, GenericArgs);



    SyntaxFactory::makeTypealiasDecl(Typealias, Subsequence, GenericParams,

                                       Assignment, Array_Int)

      .print(OS);

    ASSERT_EQ(OS.str().str(),

              ""typealias MyCollection<Element> = Array<Element>"");

  }

}

","TEST(DeclSyntaxTests, TypealiasMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<64> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Typealias =

      SyntaxFactory::makeTypealiasKeyword({}, { Trivia::spaces(1) });

    auto Subsequence = SyntaxFactory::makeIdentifier(""MyCollection"", {}, {});

    auto ElementParam =

      SyntaxFactory::makeGenericParameter(""Element"", {}, {});

    auto LeftAngle = SyntaxFactory::makeLeftAngleToken({}, {});

    auto RightAngle =

      SyntaxFactory::makeRightAngleToken({}, { Trivia::spaces(1) });

    auto GenericParams = GenericParameterClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(RightAngle)

      .addParameter(None, ElementParam)

      .build();

    auto Assignment = SyntaxFactory::makeEqualToken({}, { Trivia::spaces(1) });



    auto ElementArg = SyntaxFactory::makeTypeIdentifier(""Element"", {}, {});



    auto GenericArgs = GenericArgumentClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(None, ElementArg)

      .build();



    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto Array_Int = SyntaxFactory::makeTypeIdentifier(Array, GenericArgs);



    SyntaxFactory::makeTypealiasDecl(Typealias, Subsequence, GenericParams,

                                       Assignment, Array_Int)

      .print(OS);

    ASSERT_EQ(OS.str().str(),

              ""typealias MyCollection<Element> = Array<Element>"");

  }

}

"
"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(DeclSyntaxTests, TypealiasMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankTypealiasDecl().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<64> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Typealias =

      SyntaxFactory::makeTypealiasKeyword({}, { Trivia::spaces(1) });

    auto Subsequence = SyntaxFactory::makeIdentifier(""MyCollection"", {}, {});

    auto ElementParam =

      SyntaxFactory::makeGenericParameter(""Element"", {}, {});

    auto LeftAngle = SyntaxFactory::makeLeftAngleToken({}, {});

    auto RightAngle =

      SyntaxFactory::makeRightAngleToken({}, { Trivia::spaces(1) });

    auto GenericParams = GenericParameterClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(RightAngle)

      .addParameter(None, ElementParam)

      .build();

    auto Assignment = SyntaxFactory::makeEqualToken({}, { Trivia::spaces(1) });



    auto ElementArg = SyntaxFactory::makeTypeIdentifier(""Element"", {}, {});



    auto GenericArgs = GenericArgumentClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(None, ElementArg)

      .build();



    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto Array_Int = SyntaxFactory::makeTypeIdentifier(Array, GenericArgs);



    SyntaxFactory::makeTypealiasDecl(Typealias, Subsequence, GenericParams,

                                       Assignment, Array_Int)

      .print(OS);

    ASSERT_EQ(OS.str().str(),

              ""typealias MyCollection<Element> = Array<Element>"");

  }

}

","TEST(DeclSyntaxTests, TypealiasMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankTypealiasDecl().print(OS);

   ","
  }

  {

    SmallString<64> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Typealias =

      SyntaxFactory::makeTypealiasKeyword({}, { Trivia::spaces(1) });

    auto Subsequence = SyntaxFactory::makeIdentifier(""MyCollection"", {}, {});

    auto ElementParam =

      SyntaxFactory::makeGenericParameter(""Element"", {}, {});

    auto LeftAngle = SyntaxFactory::makeLeftAngleToken({}, {});

    auto RightAngle =

      SyntaxFactory::makeRightAngleToken({}, { Trivia::spaces(1) });

    auto GenericParams = GenericParameterClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(RightAngle)

      .addParameter(None, ElementParam)

      .build();

    auto Assignment = SyntaxFactory::makeEqualToken({}, { Trivia::spaces(1) });



    auto ElementArg = SyntaxFactory::makeTypeIdentifier(""Element"", {}, {});



    auto GenericArgs = GenericArgumentClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(None, ElementArg)

      .build();



    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto Array_Int = SyntaxFactory::makeTypeIdentifier(Array, GenericArgs);



    SyntaxFactory::makeTypealiasDecl(Typealias, Subsequence, GenericParams,

                                       Assignment, Array_Int)

      .print(OS);

    ASSERT_EQ(OS.str().str(),

              ""typealias MyCollection<Element> = Array<Element>"");

  }

}

"
"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/DeclSyntaxTests.cpp,+,.print(OS);,"TEST(DeclSyntaxTests, TypealiasMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankTypealiasDecl().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<64> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Typealias =

      SyntaxFactory::makeTypealiasKeyword({}, { Trivia::spaces(1) });

    auto Subsequence = SyntaxFactory::makeIdentifier(""MyCollection"", {}, {});

    auto ElementParam =

      SyntaxFactory::makeGenericParameter(""Element"", {}, {});

    auto LeftAngle = SyntaxFactory::makeLeftAngleToken({}, {});

    auto RightAngle =

      SyntaxFactory::makeRightAngleToken({}, { Trivia::spaces(1) });

    auto GenericParams = GenericParameterClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(RightAngle)

      .addParameter(None, ElementParam)

      .build();

    auto Assignment = SyntaxFactory::makeEqualToken({}, { Trivia::spaces(1) });



    auto ElementArg = SyntaxFactory::makeTypeIdentifier(""Element"", {}, {});



    auto GenericArgs = GenericArgumentClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(None, ElementArg)

      .build();



    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto Array_Int = SyntaxFactory::makeTypeIdentifier(Array, GenericArgs);



    SyntaxFactory::makeTypealiasDecl(Typealias, Subsequence, GenericParams,

                                       Assignment, Array_Int)

      .print(OS);

    ASSERT_EQ(OS.str().str(),

              ""typealias MyCollection<Element> = Array<Element>"");

  }

}

","TEST(DeclSyntaxTests, TypealiasMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankTypealiasDecl(","
    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<64> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Typealias =

      SyntaxFactory::makeTypealiasKeyword({}, { Trivia::spaces(1) });

    auto Subsequence = SyntaxFactory::makeIdentifier(""MyCollection"", {}, {});

    auto ElementParam =

      SyntaxFactory::makeGenericParameter(""Element"", {}, {});

    auto LeftAngle = SyntaxFactory::makeLeftAngleToken({}, {});

    auto RightAngle =

      SyntaxFactory::makeRightAngleToken({}, { Trivia::spaces(1) });

    auto GenericParams = GenericParameterClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(RightAngle)

      .addParameter(None, ElementParam)

      .build();

    auto Assignment = SyntaxFactory::makeEqualToken({}, { Trivia::spaces(1) });



    auto ElementArg = SyntaxFactory::makeTypeIdentifier(""Element"", {}, {});



    auto GenericArgs = GenericArgumentClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(None, ElementArg)

      .build();



    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto Array_Int = SyntaxFactory::makeTypeIdentifier(Array, GenericArgs);



    SyntaxFactory::makeTypealiasDecl(Typealias, Subsequence, GenericParams,

                                       Assignment, Array_Int)

      .print(OS);

    ASSERT_EQ(OS.str().str(),

              ""typealias MyCollection<Element> = Array<Element>"");

  }

}

"
"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(),","TEST(DeclSyntaxTests, TypealiasMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankTypealiasDecl().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<64> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Typealias =

      SyntaxFactory::makeTypealiasKeyword({}, { Trivia::spaces(1) });

    auto Subsequence = SyntaxFactory::makeIdentifier(""MyCollection"", {}, {});

    auto ElementParam =

      SyntaxFactory::makeGenericParameter(""Element"", {}, {});

    auto LeftAngle = SyntaxFactory::makeLeftAngleToken({}, {});

    auto RightAngle =

      SyntaxFactory::makeRightAngleToken({}, { Trivia::spaces(1) });

    auto GenericParams = GenericParameterClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(RightAngle)

      .addParameter(None, ElementParam)

      .build();

    auto Assignment = SyntaxFactory::makeEqualToken({}, { Trivia::spaces(1) });



    auto ElementArg = SyntaxFactory::makeTypeIdentifier(""Element"", {}, {});



    auto GenericArgs = GenericArgumentClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(None, ElementArg)

      .build();



    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto Array_Int = SyntaxFactory::makeTypeIdentifier(Array, GenericArgs);



    SyntaxFactory::makeTypealiasDecl(Typealias, Subsequence, GenericParams,

                                       Assignment, Array_Int)

      .print(OS);

    ASSERT_EQ(OS.str().str(),

              ""typealias MyCollection<Element> = Array<Element>"");

  }

}

","TEST(DeclSyntaxTests, TypealiasMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankTypealiasDecl().print(OS);

   ","
  }

  {

    SmallString<64> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Typealias =

      SyntaxFactory::makeTypealiasKeyword({}, { Trivia::spaces(1) });

    auto Subsequence = SyntaxFactory::makeIdentifier(""MyCollection"", {}, {});

    auto ElementParam =

      SyntaxFactory::makeGenericParameter(""Element"", {}, {});

    auto LeftAngle = SyntaxFactory::makeLeftAngleToken({}, {});

    auto RightAngle =

      SyntaxFactory::makeRightAngleToken({}, { Trivia::spaces(1) });

    auto GenericParams = GenericParameterClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(RightAngle)

      .addParameter(None, ElementParam)

      .build();

    auto Assignment = SyntaxFactory::makeEqualToken({}, { Trivia::spaces(1) });



    auto ElementArg = SyntaxFactory::makeTypeIdentifier(""Element"", {}, {});



    auto GenericArgs = GenericArgumentClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(None, ElementArg)

      .build();



    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto Array_Int = SyntaxFactory::makeTypeIdentifier(Array, GenericArgs);



    SyntaxFactory::makeTypealiasDecl(Typealias, Subsequence, GenericParams,

                                       Assignment, Array_Int)

      .print(OS);

    ASSERT_EQ(OS.str().str(),

              ""typealias MyCollection<Element> = Array<Element>"");

  }

}

"
"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Autoclosure.print(OS);,"TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

   ","
    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

"
"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@autoclosure"");","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

   ","
  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

"
"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Convention.withBalancedTokens(cArgs).print(OS);,"TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

     ","
      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

"
"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@convention(c)"");","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

     ","
    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

"
"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Convention.withBalancedTokens(swiftArgs).print(OS);,"TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

     ","
      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

"
"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@convention(swift)"");","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

     ","
    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

"
"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Convention.withBalancedTokens(blockArgs).print(OS);,"TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

     ","
      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

"
"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@convention(block)"");","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

     ","
    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

"
"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Escaping.print(OS);,"TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

   ","
    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

"
"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@escaping"");","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

   ","
  }

}

"
"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/Trivia.cpp,+,"void printRepeated(llvm::raw_ostream &OS, char c, size_t Count) {","void printRepeated(llvm::raw_ostream &OS, char c, size_t Count) {

  for (decltype(Count) i = 0; i < Count; ++i)

    OS << c;

}

","void printRepeated(llvm::raw_ostream &OS, char c, size_t Count) {

  for (decltype(Count) i = 0; i < Count; ++i)

    OS << c;

}
","
  for (decltype(Count) i = 0; i < Count; ++i)

    OS << c;

}

"
"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",tools/swift-format/swift-format.cpp,+,"InputFilename, Buffer.getError().message());","int doFormat(ArrayRef<StringRef> InputFiles) {



  for (auto InputFilename : InputFiles) {

    CompilerInvocation Invocation;

    Invocation.addInputFilename(InputFilename);

    Invocation.setModuleName(""Format"");

    CompilerInstance Instance;



    auto &SourceMgr = Instance.getSourceMgr();

    auto &Diags = Instance.getDiags();



    PrintingDiagnosticConsumer DiagPrinter;

    Instance.addDiagnosticConsumer(&DiagPrinter);

    if (Instance.setup(Invocation)) {

      return EXIT_FAILURE;

    }



    // First, parse the file normally and get the regular old AST.

    Instance.performParseOnly();



    auto BufferID = Instance.getInputBufferIDs().back();

    auto &SF = Instance.getMainModule()

      ->getMainSourceFile(SourceFileKind::Main);



    auto Buffer = llvm::MemoryBuffer::getFile(InputFilename);

    if (!Buffer) {

      Diags.diagnose(SourceLoc(), diag::cannot_open_file,

                     InputFilename, Buffer.getError().message());

      return EXIT_FAILURE;

    }



    auto Tokens = tokenizeWithTrivia(Invocation.getLangOptions(),

                                     SourceMgr, BufferID);



    SmallVector<Decl *, 256> FileDecls;

    SF.getTopLevelDecls(FileDecls);

    sema::Semantics Sema;

    for (auto *Decl : FileDecls) {

      if (Decl->escapedFromIfConfig()) {

        continue;

      }

      auto NewNode = transformAST(ASTNode(Decl), Sema, SourceMgr,

                                  BufferID, Tokens);

      if (NewNode.hasValue()) {

        auto Reformatted = format(NewNode.getValue());

        Reformatted.print(llvm::outs());

      }

    }

  }

  return EXIT_SUCCESS;

}

","int doFormat(ArrayRef<StringRef> InputFiles) {



  for (auto InputFilename : InputFiles) {

    CompilerInvocation Invocation;

    Invocation.addInputFilename(InputFilename);

    Invocation.setModuleName(""Format"");

    CompilerInstance Instance;



    auto &SourceMgr = Instance.getSourceMgr();

    auto &Diags = Instance.getDiags();



    PrintingDiagnosticConsumer DiagPrinter;

    Instance.addDiagnosticConsumer(&DiagPrinter);

    if (Instance.setup(Invocation)) {

      return EXIT_FAILURE;

    }



    // First, parse the file normally and get the regular old AST.

    Instance.performParseOnly();



    auto BufferID = Instance.getInputBufferIDs().back();

    auto &SF = Instance.getMainModule()

      ->getMainSourceFile(SourceFileKind::Main);



    auto Buffer = llvm::MemoryBuffer::getFile(InputFilename);

    if (!Buffer) {

      Diags.diagnose(SourceLoc(), diag::cannot_open_file,

                    ","
      return EXIT_FAILURE;

    }



    auto Tokens = tokenizeWithTrivia(Invocation.getLangOptions(),

                                     SourceMgr, BufferID);



    SmallVector<Decl *, 256> FileDecls;

    SF.getTopLevelDecls(FileDecls);

    sema::Semantics Sema;

    for (auto *Decl : FileDecls) {

      if (Decl->escapedFromIfConfig()) {

        continue;

      }

      auto NewNode = transformAST(ASTNode(Decl), Sema, SourceMgr,

                                  BufferID, Tokens);

      if (NewNode.hasValue()) {

        auto Reformatted = format(NewNode.getValue());

        Reformatted.print(llvm::outs());

      }

    }

  }

  return EXIT_SUCCESS;

}

"
"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",tools/swift-format/swift-format.cpp,+,Reformatted.print(llvm::outs());,"int doFormat(ArrayRef<StringRef> InputFiles) {



  for (auto InputFilename : InputFiles) {

    CompilerInvocation Invocation;

    Invocation.addInputFilename(InputFilename);

    Invocation.setModuleName(""Format"");

    CompilerInstance Instance;



    auto &SourceMgr = Instance.getSourceMgr();

    auto &Diags = Instance.getDiags();



    PrintingDiagnosticConsumer DiagPrinter;

    Instance.addDiagnosticConsumer(&DiagPrinter);

    if (Instance.setup(Invocation)) {

      return EXIT_FAILURE;

    }



    // First, parse the file normally and get the regular old AST.

    Instance.performParseOnly();



    auto BufferID = Instance.getInputBufferIDs().back();

    auto &SF = Instance.getMainModule()

      ->getMainSourceFile(SourceFileKind::Main);



    auto Buffer = llvm::MemoryBuffer::getFile(InputFilename);

    if (!Buffer) {

      Diags.diagnose(SourceLoc(), diag::cannot_open_file,

                     InputFilename, Buffer.getError().message());

      return EXIT_FAILURE;

    }



    auto Tokens = tokenizeWithTrivia(Invocation.getLangOptions(),

                                     SourceMgr, BufferID);



    SmallVector<Decl *, 256> FileDecls;

    SF.getTopLevelDecls(FileDecls);

    sema::Semantics Sema;

    for (auto *Decl : FileDecls) {

      if (Decl->escapedFromIfConfig()) {

        continue;

      }

      auto NewNode = transformAST(ASTNode(Decl), Sema, SourceMgr,

                                  BufferID, Tokens);

      if (NewNode.hasValue()) {

        auto Reformatted = format(NewNode.getValue());

        Reformatted.print(llvm::outs());

      }

    }

  }

  return EXIT_SUCCESS;

}

","int doFormat(ArrayRef<StringRef> InputFiles) {



  for (auto InputFilename : InputFiles) {

    CompilerInvocation Invocation;

    Invocation.addInputFilename(InputFilename);

    Invocation.setModuleName(""Format"");

    CompilerInstance Instance;



    auto &SourceMgr = Instance.getSourceMgr();

    auto &Diags = Instance.getDiags();



    PrintingDiagnosticConsumer DiagPrinter;

    Instance.addDiagnosticConsumer(&DiagPrinter);

    if (Instance.setup(Invocation)) {

      return EXIT_FAILURE;

    }



    // First, parse the file normally and get the regular old AST.

    Instance.performParseOnly();



    auto BufferID = Instance.getInputBufferIDs().back();

    auto &SF = Instance.getMainModule()

      ->getMainSourceFile(SourceFileKind::Main);



    auto Buffer = llvm::MemoryBuffer::getFile(InputFilename);

    if (!Buffer) {

      Diags.diagnose(SourceLoc(), diag::cannot_open_file,

                     InputFilename, Buffer.getError().message());

      return EXIT_FAILURE;

    }



    auto Tokens = tokenizeWithTrivia(Invocation.getLangOptions(),

                                     SourceMgr, BufferID);



    SmallVector<Decl *, 256> FileDecls;

    SF.getTopLevelDecls(FileDecls);

    sema::Semantics Sema;

    for (auto *Decl : FileDecls) {

      if (Decl->escapedFromIfConfig()) {

        continue;

      }

      auto NewNode = transformAST(ASTNode(Decl), Sema, SourceMgr,

                                  BufferID, Tokens);

      if (NewNode.hasValue()) {

        auto Reformatted = format(NewNode.getValue());

       ","
      }

    }

  }

  return EXIT_SUCCESS;

}

"
"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeBlankTypealiasDecl().print(OS);,"TEST(DeclSyntaxTests, TypealiasMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankTypealiasDecl().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<64> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Typealias =

      SyntaxFactory::makeTypealiasKeyword({}, { Trivia::spaces(1) });

    auto Subsequence = SyntaxFactory::makeIdentifier(""MyCollection"", {}, {});

    auto ElementParam =

      SyntaxFactory::makeGenericParameter(""Element"", {}, {});

    auto LeftAngle = SyntaxFactory::makeLeftAngleToken({}, {});

    auto RightAngle =

      SyntaxFactory::makeRightAngleToken({}, { Trivia::spaces(1) });

    auto GenericParams = GenericParameterClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(RightAngle)

      .addParameter(None, ElementParam)

      .build();

    auto Assignment = SyntaxFactory::makeEqualToken({}, { Trivia::spaces(1) });



    auto ElementArg = SyntaxFactory::makeTypeIdentifier(""Element"", {}, {});



    auto GenericArgs = GenericArgumentClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(None, ElementArg)

      .build();



    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto Array_Int = SyntaxFactory::makeTypeIdentifier(Array, GenericArgs);



    SyntaxFactory::makeTypealiasDecl(Typealias, Subsequence, GenericParams,

                                       Assignment, Array_Int)

      .print(OS);

    ASSERT_EQ(OS.str().str(),

              ""typealias MyCollection<Element> = Array<Element>"");

  }

}

","TEST(DeclSyntaxTests, TypealiasMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

   ","
    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<64> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Typealias =

      SyntaxFactory::makeTypealiasKeyword({}, { Trivia::spaces(1) });

    auto Subsequence = SyntaxFactory::makeIdentifier(""MyCollection"", {}, {});

    auto ElementParam =

      SyntaxFactory::makeGenericParameter(""Element"", {}, {});

    auto LeftAngle = SyntaxFactory::makeLeftAngleToken({}, {});

    auto RightAngle =

      SyntaxFactory::makeRightAngleToken({}, { Trivia::spaces(1) });

    auto GenericParams = GenericParameterClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(RightAngle)

      .addParameter(None, ElementParam)

      .build();

    auto Assignment = SyntaxFactory::makeEqualToken({}, { Trivia::spaces(1) });



    auto ElementArg = SyntaxFactory::makeTypeIdentifier(""Element"", {}, {});



    auto GenericArgs = GenericArgumentClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(None, ElementArg)

      .build();



    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto Array_Int = SyntaxFactory::makeTypeIdentifier(Array, GenericArgs);



    SyntaxFactory::makeTypealiasDecl(Typealias, Subsequence, GenericParams,

                                       Assignment, Array_Int)

      .print(OS);

    ASSERT_EQ(OS.str().str(),

              ""typealias MyCollection<Element> = Array<Element>"");

  }

}

"
"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");","TEST(DeclSyntaxTests, TypealiasMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankTypealiasDecl().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<64> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Typealias =

      SyntaxFactory::makeTypealiasKeyword({}, { Trivia::spaces(1) });

    auto Subsequence = SyntaxFactory::makeIdentifier(""MyCollection"", {}, {});

    auto ElementParam =

      SyntaxFactory::makeGenericParameter(""Element"", {}, {});

    auto LeftAngle = SyntaxFactory::makeLeftAngleToken({}, {});

    auto RightAngle =

      SyntaxFactory::makeRightAngleToken({}, { Trivia::spaces(1) });

    auto GenericParams = GenericParameterClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(RightAngle)

      .addParameter(None, ElementParam)

      .build();

    auto Assignment = SyntaxFactory::makeEqualToken({}, { Trivia::spaces(1) });



    auto ElementArg = SyntaxFactory::makeTypeIdentifier(""Element"", {}, {});



    auto GenericArgs = GenericArgumentClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(None, ElementArg)

      .build();



    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto Array_Int = SyntaxFactory::makeTypeIdentifier(Array, GenericArgs);



    SyntaxFactory::makeTypealiasDecl(Typealias, Subsequence, GenericParams,

                                       Assignment, Array_Int)

      .print(OS);

    ASSERT_EQ(OS.str().str(),

              ""typealias MyCollection<Element> = Array<Element>"");

  }

}

","TEST(DeclSyntaxTests, TypealiasMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankTypealiasDecl().print(OS);

   ","
  }

  {

    SmallString<64> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Typealias =

      SyntaxFactory::makeTypealiasKeyword({}, { Trivia::spaces(1) });

    auto Subsequence = SyntaxFactory::makeIdentifier(""MyCollection"", {}, {});

    auto ElementParam =

      SyntaxFactory::makeGenericParameter(""Element"", {}, {});

    auto LeftAngle = SyntaxFactory::makeLeftAngleToken({}, {});

    auto RightAngle =

      SyntaxFactory::makeRightAngleToken({}, { Trivia::spaces(1) });

    auto GenericParams = GenericParameterClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(RightAngle)

      .addParameter(None, ElementParam)

      .build();

    auto Assignment = SyntaxFactory::makeEqualToken({}, { Trivia::spaces(1) });



    auto ElementArg = SyntaxFactory::makeTypeIdentifier(""Element"", {}, {});



    auto GenericArgs = GenericArgumentClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(None, ElementArg)

      .build();



    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto Array_Int = SyntaxFactory::makeTypeIdentifier(Array, GenericArgs);



    SyntaxFactory::makeTypealiasDecl(Typealias, Subsequence, GenericParams,

                                       Assignment, Array_Int)

      .print(OS);

    ASSERT_EQ(OS.str().str(),

              ""typealias MyCollection<Element> = Array<Element>"");

  }

}

"
"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/DeclSyntaxTests.cpp,+,.print(OS);,"TEST(DeclSyntaxTests, TypealiasMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankTypealiasDecl().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<64> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Typealias =

      SyntaxFactory::makeTypealiasKeyword({}, { Trivia::spaces(1) });

    auto Subsequence = SyntaxFactory::makeIdentifier(""MyCollection"", {}, {});

    auto ElementParam =

      SyntaxFactory::makeGenericParameter(""Element"", {}, {});

    auto LeftAngle = SyntaxFactory::makeLeftAngleToken({}, {});

    auto RightAngle =

      SyntaxFactory::makeRightAngleToken({}, { Trivia::spaces(1) });

    auto GenericParams = GenericParameterClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(RightAngle)

      .addParameter(None, ElementParam)

      .build();

    auto Assignment = SyntaxFactory::makeEqualToken({}, { Trivia::spaces(1) });



    auto ElementArg = SyntaxFactory::makeTypeIdentifier(""Element"", {}, {});



    auto GenericArgs = GenericArgumentClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(None, ElementArg)

      .build();



    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto Array_Int = SyntaxFactory::makeTypeIdentifier(Array, GenericArgs);



    SyntaxFactory::makeTypealiasDecl(Typealias, Subsequence, GenericParams,

                                       Assignment, Array_Int)

      .print(OS);

    ASSERT_EQ(OS.str().str(),

              ""typealias MyCollection<Element> = Array<Element>"");

  }

}

","TEST(DeclSyntaxTests, TypealiasMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankTypealiasDecl(","
    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<64> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Typealias =

      SyntaxFactory::makeTypealiasKeyword({}, { Trivia::spaces(1) });

    auto Subsequence = SyntaxFactory::makeIdentifier(""MyCollection"", {}, {});

    auto ElementParam =

      SyntaxFactory::makeGenericParameter(""Element"", {}, {});

    auto LeftAngle = SyntaxFactory::makeLeftAngleToken({}, {});

    auto RightAngle =

      SyntaxFactory::makeRightAngleToken({}, { Trivia::spaces(1) });

    auto GenericParams = GenericParameterClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(RightAngle)

      .addParameter(None, ElementParam)

      .build();

    auto Assignment = SyntaxFactory::makeEqualToken({}, { Trivia::spaces(1) });



    auto ElementArg = SyntaxFactory::makeTypeIdentifier(""Element"", {}, {});



    auto GenericArgs = GenericArgumentClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(None, ElementArg)

      .build();



    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto Array_Int = SyntaxFactory::makeTypeIdentifier(Array, GenericArgs);



    SyntaxFactory::makeTypealiasDecl(Typealias, Subsequence, GenericParams,

                                       Assignment, Array_Int)

      .print(OS);

    ASSERT_EQ(OS.str().str(),

              ""typealias MyCollection<Element> = Array<Element>"");

  }

}

"
"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(),","TEST(DeclSyntaxTests, TypealiasMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankTypealiasDecl().print(OS);

    ASSERT_EQ(OS.str().str(), """");

  }

  {

    SmallString<64> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Typealias =

      SyntaxFactory::makeTypealiasKeyword({}, { Trivia::spaces(1) });

    auto Subsequence = SyntaxFactory::makeIdentifier(""MyCollection"", {}, {});

    auto ElementParam =

      SyntaxFactory::makeGenericParameter(""Element"", {}, {});

    auto LeftAngle = SyntaxFactory::makeLeftAngleToken({}, {});

    auto RightAngle =

      SyntaxFactory::makeRightAngleToken({}, { Trivia::spaces(1) });

    auto GenericParams = GenericParameterClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(RightAngle)

      .addParameter(None, ElementParam)

      .build();

    auto Assignment = SyntaxFactory::makeEqualToken({}, { Trivia::spaces(1) });



    auto ElementArg = SyntaxFactory::makeTypeIdentifier(""Element"", {}, {});



    auto GenericArgs = GenericArgumentClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(None, ElementArg)

      .build();



    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto Array_Int = SyntaxFactory::makeTypeIdentifier(Array, GenericArgs);



    SyntaxFactory::makeTypealiasDecl(Typealias, Subsequence, GenericParams,

                                       Assignment, Array_Int)

      .print(OS);

    ASSERT_EQ(OS.str().str(),

              ""typealias MyCollection<Element> = Array<Element>"");

  }

}

","TEST(DeclSyntaxTests, TypealiasMakeAPIs) {

  {

    SmallString<1> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    SyntaxFactory::makeBlankTypealiasDecl().print(OS);

   ","
  }

  {

    SmallString<64> Scratch;

    llvm::raw_svector_ostream OS(Scratch);

    auto Typealias =

      SyntaxFactory::makeTypealiasKeyword({}, { Trivia::spaces(1) });

    auto Subsequence = SyntaxFactory::makeIdentifier(""MyCollection"", {}, {});

    auto ElementParam =

      SyntaxFactory::makeGenericParameter(""Element"", {}, {});

    auto LeftAngle = SyntaxFactory::makeLeftAngleToken({}, {});

    auto RightAngle =

      SyntaxFactory::makeRightAngleToken({}, { Trivia::spaces(1) });

    auto GenericParams = GenericParameterClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(RightAngle)

      .addParameter(None, ElementParam)

      .build();

    auto Assignment = SyntaxFactory::makeEqualToken({}, { Trivia::spaces(1) });



    auto ElementArg = SyntaxFactory::makeTypeIdentifier(""Element"", {}, {});



    auto GenericArgs = GenericArgumentClauseBuilder()

      .useLeftAngleBracket(LeftAngle)

      .useRightAngleBracket(SyntaxFactory::makeRightAngleToken({}, {}))

      .addGenericArgument(None, ElementArg)

      .build();



    auto Array = SyntaxFactory::makeIdentifier(""Array"", {}, {});

    auto Array_Int = SyntaxFactory::makeTypeIdentifier(Array, GenericArgs);



    SyntaxFactory::makeTypealiasDecl(Typealias, Subsequence, GenericParams,

                                       Assignment, Array_Int)

      .print(OS);

    ASSERT_EQ(OS.str().str(),

              ""typealias MyCollection<Element> = Array<Element>"");

  }

}

"
"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Autoclosure.print(OS);,"TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

   ","
    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

"
"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@autoclosure"");","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

   ","
  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

"
"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Convention.withBalancedTokens(cArgs).print(OS);,"TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

     ","
      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

"
"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@convention(c)"");","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

     ","
    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

"
"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Convention.withBalancedTokens(swiftArgs).print(OS);,"TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

     ","
      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

"
"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@convention(swift)"");","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

     ","
    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

"
"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Convention.withBalancedTokens(blockArgs).print(OS);,"TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

     ","
      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

"
"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@convention(block)"");","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

     ","
    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

"
"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Escaping.print(OS);,"TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

   ","
    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

"
"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@escaping"");","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

    ASSERT_EQ(OS.str().str(), ""@escaping"");

  }

}

","TEST(TypeSyntaxTests, TypeAttributeWithAPIs) {

  auto At = SyntaxFactory::makeAtSignToken({}, {});

  {

    auto AutoclosureID = SyntaxFactory::makeIdentifier(""autoclosure"", {}, {});

    SmallString<24> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto Autoclosure = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(AutoclosureID);

    Autoclosure.print(OS);

    ASSERT_EQ(OS.str().str(), ""@autoclosure"");

  }



  {

    auto conventionID = SyntaxFactory::makeIdentifier(""convention"", {}, {});

    auto LeftParen = SyntaxFactory::makeLeftParenToken({}, {});

    auto RightParen = SyntaxFactory::makeRightParenToken({}, {});



    auto Convention = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(conventionID)

      .withLeftParenToken(LeftParen)

      .withRightParenToken(RightParen);



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto cID = SyntaxFactory::makeIdentifier(""c"", {}, {});

      auto cArgs = SyntaxFactory::makeBalancedTokens({cID});

      Convention.withBalancedTokens(cArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(c)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto swiftID = SyntaxFactory::makeIdentifier(""swift"", {}, {});

      auto swiftArgs = SyntaxFactory::makeBalancedTokens({swiftID});

      Convention.withBalancedTokens(swiftArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(swift)"");

    }



    {

      SmallString<48> Scratch;

      llvm::raw_svector_ostream OS { Scratch };

      auto blockID = SyntaxFactory::makeIdentifier(""block"", {}, {});

      auto blockArgs = SyntaxFactory::makeBalancedTokens({blockID});

      Convention.withBalancedTokens(blockArgs).print(OS);

      ASSERT_EQ(OS.str().str(), ""@convention(block)"");

    }

  }



  {

    SmallString<48> Scratch;

    llvm::raw_svector_ostream OS { Scratch };

    auto EscapingID = SyntaxFactory::makeIdentifier(""escaping"", {}, {});

    auto Escaping = SyntaxFactory::makeBlankTypeAttribute()

      .withAtSignToken(At)

      .withIdentifier(EscapingID);

    Escaping.print(OS);

   ","
  }

}

"
"[IDE][Utils] Add an IDE stream utility. (#7546)

This provides a stream utility for writing to a underlying string buffer multiple string pieces and retrieve them later as StringRef when the underlying buffer is stable.",tools/SourceKit/lib/SwiftLang/SwiftSourceDocInfo.cpp,-,"if (SwiftLangSupport::printUSR(VD, OS))","static bool passCursorInfoForDecl(const ValueDecl *VD,

                                  const ModuleDecl *MainModule,

                                  const Type Ty,

                                  const Type ContainerTy,

                                  bool IsRef,

                                  Optional<unsigned> OrigBufferID,

                                  SwiftLangSupport &Lang,

                                  const CompilerInvocation &Invok,

                            ArrayRef<ImmutableTextSnapshotRef> PreviousASTSnaps,

                             std::function<void(const CursorInfo &)> Receiver) {

  if (AvailableAttr::isUnavailable(VD))

    return true;



  SmallString<64> SS;

  auto BaseType = findBaseTypeForReplacingArchetype(VD, Ty);

  bool InSynthesizedExtension = false;

  if (BaseType) {

    if (auto Target = BaseType->getAnyNominal()) {

      SynthesizedExtensionAnalyzer Analyzer(Target,

                                            PrintOptions::printInterface());

      InSynthesizedExtension = Analyzer.isInSynthesizedExtension(VD);

    }

  }



  unsigned NameBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDisplayName(VD, OS);

  }

  unsigned NameEnd = SS.size();



  unsigned USRBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printUSR(VD, OS);

    if (InSynthesizedExtension) {

        OS << LangSupport::SynthesizedUSRSeparator;

        SwiftLangSupport::printUSR(BaseType->getAnyNominal(), OS);

    }

  }

  unsigned USREnd = SS.size();



  unsigned TypenameBegin = SS.size();

  if (VD->hasInterfaceType()) {

    llvm::raw_svector_ostream OS(SS);

    PrintOptions Options;

    Options.PrintNameAliasUnderlyingType = true;

    VD->getInterfaceType().print(OS, Options);

  }

  unsigned TypenameEnd = SS.size();



  unsigned MangledTypeStart = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDeclTypeUSR(VD, OS);

  }

  unsigned MangledTypeEnd = SS.size();



  unsigned MangledContainerTypeStart = SS.size();

  if (ContainerTy && !ContainerTy->hasArchetype()) {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printTypeUSR(ContainerTy, OS);

  }

  unsigned MangledContainerTypeEnd = SS.size();



  unsigned DocCommentBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    ide::getDocumentationCommentAsXML(VD, OS);

  }

  unsigned DocCommentEnd = SS.size();



  if (DocCommentEnd == DocCommentBegin) {

    if (auto *Req = ASTPrinter::findConformancesWithDocComment(

        const_cast<ValueDecl*>(VD))) {

      llvm::raw_svector_ostream OS(SS);

      ide::getDocumentationCommentAsXML(Req, OS);

    }

    DocCommentEnd = SS.size();

  }



  unsigned DeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    printAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned DeclEnd = SS.size();



  unsigned FullDeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printFullyAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned FullDeclEnd = SS.size();



  unsigned GroupBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    auto *GroupVD = InSynthesizedExtension ? BaseType->getAnyNominal() : VD;

    if (auto OP = GroupVD->getGroupName())

      OS << OP.getValue();

  }

  unsigned GroupEnd = SS.size();



  DelayedStringRetriever OverUSRsStream(SS);

  ide::walkOverriddenDecls(VD,

    [&](llvm::PointerUnion<const ValueDecl*, const clang::NamedDecl*> D) {

      OverUSRsStream.startPiece();

      if (auto VD = D.dyn_cast<const ValueDecl*>()) {

        if (SwiftLangSupport::printUSR(VD, OverUSRsStream))

          return;

      } else {

        llvm::SmallString<128> Buf;

        if (clang::index::generateUSRForDecl(

            D.get<const clang::NamedDecl*>(), Buf))

          return;

        OverUSRsStream << Buf.str();

      }

      OverUSRsStream.endPiece();

  });



  DelayedStringRetriever RelDeclsStream(SS);

  walkRelatedDecls(VD, [&](const ValueDecl *RelatedDecl, bool DuplicateName) {

    RelDeclsStream.startPiece();

    {

      RelDeclsStream<<""<RelatedName usr=\"""";

      SwiftLangSupport::printUSR(RelatedDecl, RelDeclsStream);

      RelDeclsStream<<""\"">"";

      if (isa<AbstractFunctionDecl>(RelatedDecl) && DuplicateName) {

        // Related decls are generally overloads, so print parameter types to

        // differentiate them.

        PrintOptions PO;

        PO.SkipAttributes = true;

        PO.SkipIntroducerKeywords = true;

        PO.ArgAndParamPrinting = PrintOptions::ArgAndParamPrintingMode::ArgumentOnly;

        XMLEscapingPrinter Printer(RelDeclsStream);

        if (BaseType) {

          PO.setBaseType(BaseType);

          PO.PrintAsMember = true;

        }

        RelatedDecl->print(Printer, PO);

      } else {

        llvm::SmallString<128> Buf;

        {

          llvm::raw_svector_ostream OSBuf(Buf);

          SwiftLangSupport::printDisplayName(RelatedDecl, OSBuf);

        }

        swift::markup::appendWithXMLEscaping(RelDeclsStream, Buf);

      }

      RelDeclsStream<<""</RelatedName>"";

    }

    RelDeclsStream.endPiece();

  });



  ASTContext &Ctx = VD->getASTContext();



  ClangImporter *Importer = static_cast<ClangImporter*>(

      Ctx.getClangModuleLoader());

  std::string ModuleName;

  auto ClangNode = VD->getClangNode();

  if (ClangNode) {

    auto ClangMod = Importer->getClangOwningModule(ClangNode);

    ModuleName = ClangMod->getFullModuleName();

  } else if (VD->getLoc().isInvalid() && VD->getModuleContext() != MainModule) {

    ModuleName = VD->getModuleContext()->getName().str();

  }

  StringRef ModuleInterfaceName;

  if (auto IFaceGenRef = Lang.getIFaceGenContexts().find(ModuleName, Invok))

    ModuleInterfaceName = IFaceGenRef->getDocumentName();



  UIdent Kind = SwiftLangSupport::getUIDForDecl(VD, IsRef);

  StringRef Name = StringRef(SS.begin()+NameBegin, NameEnd-NameBegin);

  StringRef USR = StringRef(SS.begin()+USRBegin, USREnd-USRBegin);

  StringRef TypeName = StringRef(SS.begin()+TypenameBegin,

                                 TypenameEnd-TypenameBegin);

  StringRef TypeUsr = StringRef(SS.begin()+MangledTypeStart,

                                MangledTypeEnd - MangledTypeStart);



  StringRef ContainerTypeUsr = StringRef(SS.begin()+MangledContainerTypeStart,

                            MangledContainerTypeEnd - MangledContainerTypeStart);

  StringRef DocComment = StringRef(SS.begin()+DocCommentBegin,

                                   DocCommentEnd-DocCommentBegin);

  StringRef AnnotatedDecl = StringRef(SS.begin()+DeclBegin,

                                      DeclEnd-DeclBegin);

  StringRef FullyAnnotatedDecl =

      StringRef(SS.begin() + FullDeclBegin, FullDeclEnd - FullDeclBegin);

  StringRef GroupName = StringRef(SS.begin() + GroupBegin, GroupEnd - GroupBegin);



  llvm::Optional<std::pair<unsigned, unsigned>> DeclarationLoc;

  StringRef Filename;

  getLocationInfo(VD, DeclarationLoc, Filename);

  if (DeclarationLoc.hasValue()) {

    DeclarationLoc = tryRemappingLocToLatestSnapshot(Lang,

                                                     *DeclarationLoc,

                                                     Filename,

                                                     PreviousASTSnaps);

    if (!DeclarationLoc.hasValue())

      return true; // failed to remap.

  }



  SmallVector<StringRef, 4> OverUSRs;

  OverUSRsStream.retrieve([&](StringRef S) { OverUSRs.push_back(S); });



  SmallVector<StringRef, 4> AnnotatedRelatedDecls;

  RelDeclsStream.retrieve([&](StringRef S) { AnnotatedRelatedDecls.push_back(S); });



  bool IsSystem = VD->getModuleContext()->isSystemModule();

  std::string TypeInterface;



  CursorInfo Info;

  Info.Kind = Kind;

  Info.Name = Name;

  Info.USR = USR;

  Info.TypeName = TypeName;

  Info.TypeUSR = TypeUsr;

  Info.ContainerTypeUSR = ContainerTypeUsr;

  Info.DocComment = DocComment;

  Info.AnnotatedDeclaration = AnnotatedDecl;

  Info.FullyAnnotatedDeclaration = FullyAnnotatedDecl;

  Info.ModuleName = ModuleName;

  Info.ModuleInterfaceName = ModuleInterfaceName;

  Info.DeclarationLoc = DeclarationLoc;

  Info.Filename = Filename;

  Info.OverrideUSRs = OverUSRs;

  Info.AnnotatedRelatedDeclarations = AnnotatedRelatedDecls;

  Info.GroupName = GroupName;

  Info.IsSystem = IsSystem;

  Info.TypeInterface = StringRef();

  Receiver(Info);

  return false;

}

","static bool passCursorInfoForDecl(const ValueDecl *VD,

                                  const ModuleDecl *MainModule,

                                  const Type Ty,

                                  const Type ContainerTy,

                                  bool IsRef,

                                  Optional<unsigned> OrigBufferID,

                                  SwiftLangSupport &Lang,

                                  const CompilerInvocation &Invok,

                            ArrayRef<ImmutableTextSnapshotRef> PreviousASTSnaps,

                             std::function<void(const CursorInfo &)> Receiver) {

  if (AvailableAttr::isUnavailable(VD))

    return true;



  SmallString<64> SS;

  auto BaseType = findBaseTypeForReplacingArchetype(VD, Ty);

  bool InSynthesizedExtension = false;

  if (BaseType) {

    if (auto Target = BaseType->getAnyNominal()) {

      SynthesizedExtensionAnalyzer Analyzer(Target,

                                            PrintOptions::printInterface());

      InSynthesizedExtension = Analyzer.isInSynthesizedExtension(VD);

    }

  }



  unsigned NameBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDisplayName(VD, OS);

  }

  unsigned NameEnd = SS.size();



  unsigned USRBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printUSR(VD, OS);

    if (InSynthesizedExtension) {

        OS << LangSupport::SynthesizedUSRSeparator;

        SwiftLangSupport::printUSR(BaseType->getAnyNominal(), OS);

    }

  }

  unsigned USREnd = SS.size();



  unsigned TypenameBegin = SS.size();

  if (VD->hasInterfaceType()) {

    llvm::raw_svector_ostream OS(SS);

    PrintOptions Options;

    Options.PrintNameAliasUnderlyingType = true;

    VD->getInterfaceType().print(OS, Options);

  }

  unsigned TypenameEnd = SS.size();



  unsigned MangledTypeStart = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDeclTypeUSR(VD, OS);

  }

  unsigned MangledTypeEnd = SS.size();
","

  unsigned MangledContainerTypeStart = SS.size();

  if (ContainerTy && !ContainerTy->hasArchetype()) {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printTypeUSR(ContainerTy, OS);

  }

  unsigned MangledContainerTypeEnd = SS.size();



  unsigned DocCommentBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    ide::getDocumentationCommentAsXML(VD, OS);

  }

  unsigned DocCommentEnd = SS.size();



  if (DocCommentEnd == DocCommentBegin) {

    if (auto *Req = ASTPrinter::findConformancesWithDocComment(

        const_cast<ValueDecl*>(VD))) {

      llvm::raw_svector_ostream OS(SS);

      ide::getDocumentationCommentAsXML(Req, OS);

    }

    DocCommentEnd = SS.size();

  }



  unsigned DeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    printAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned DeclEnd = SS.size();



  unsigned FullDeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printFullyAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned FullDeclEnd = SS.size();



  unsigned GroupBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    auto *GroupVD = InSynthesizedExtension ? BaseType->getAnyNominal() : VD;

    if (auto OP = GroupVD->getGroupName())

      OS << OP.getValue();

  }

  unsigned GroupEnd = SS.size();



  DelayedStringRetriever OverUSRsStream(SS);

  ide::walkOverriddenDecls(VD,

    [&](llvm::PointerUnion<const ValueDecl*, const clang::NamedDecl*> D) {

      OverUSRsStream.startPiece();

      if (auto VD = D.dyn_cast<const ValueDecl*>()) {

        if (SwiftLangSupport::printUSR(VD, OverUSRsStream))

          return;

      } else {

        llvm::SmallString<128> Buf;

        if (clang::index::generateUSRForDecl(

            D.get<const clang::NamedDecl*>(), Buf))

          return;

        OverUSRsStream << Buf.str();

      }

      OverUSRsStream.endPiece();

  });



  DelayedStringRetriever RelDeclsStream(SS);

  walkRelatedDecls(VD, [&](const ValueDecl *RelatedDecl, bool DuplicateName) {

    RelDeclsStream.startPiece();

    {

      RelDeclsStream<<""<RelatedName usr=\"""";

      SwiftLangSupport::printUSR(RelatedDecl, RelDeclsStream);

      RelDeclsStream<<""\"">"";

      if (isa<AbstractFunctionDecl>(RelatedDecl) && DuplicateName) {

        // Related decls are generally overloads, so print parameter types to

        // differentiate them.

        PrintOptions PO;

        PO.SkipAttributes = true;

        PO.SkipIntroducerKeywords = true;

        PO.ArgAndParamPrinting = PrintOptions::ArgAndParamPrintingMode::ArgumentOnly;

        XMLEscapingPrinter Printer(RelDeclsStream);

        if (BaseType) {

          PO.setBaseType(BaseType);

          PO.PrintAsMember = true;

        }

        RelatedDecl->print(Printer, PO);

      } else {

        llvm::SmallString<128> Buf;

        {

          llvm::raw_svector_ostream OSBuf(Buf);

          SwiftLangSupport::printDisplayName(RelatedDecl, OSBuf);

        }

        swift::markup::appendWithXMLEscaping(RelDeclsStream, Buf);

      }

      RelDeclsStream<<""</RelatedName>"";

    }

    RelDeclsStream.endPiece();

  });



  ASTContext &Ctx = VD->getASTContext();



  ClangImporter *Importer = static_cast<ClangImporter*>(

      Ctx.getClangModuleLoader());

  std::string ModuleName;

  auto ClangNode = VD->getClangNode();

  if (ClangNode) {

    auto ClangMod = Importer->getClangOwningModule(ClangNode);

    ModuleName = ClangMod->getFullModuleName();

  } else if (VD->getLoc().isInvalid() && VD->getModuleContext() != MainModule) {

    ModuleName = VD->getModuleContext()->getName().str();

  }

  StringRef ModuleInterfaceName;

  if (auto IFaceGenRef = Lang.getIFaceGenContexts().find(ModuleName, Invok))

    ModuleInterfaceName = IFaceGenRef->getDocumentName();



  UIdent Kind = SwiftLangSupport::getUIDForDecl(VD, IsRef);

  StringRef Name = StringRef(SS.begin()+NameBegin, NameEnd-NameBegin);

  StringRef USR = StringRef(SS.begin()+USRBegin, USREnd-USRBegin);

  StringRef TypeName = StringRef(SS.begin()+TypenameBegin,

                                 TypenameEnd-TypenameBegin);

  StringRef TypeUsr = StringRef(SS.begin()+MangledTypeStart,

                                MangledTypeEnd - MangledTypeStart);



  StringRef ContainerTypeUsr = StringRef(SS.begin()+MangledContainerTypeStart,

                            MangledContainerTypeEnd - MangledContainerTypeStart);

  StringRef DocComment = StringRef(SS.begin()+DocCommentBegin,

                                   DocCommentEnd-DocCommentBegin);

  StringRef AnnotatedDecl = StringRef(SS.begin()+DeclBegin,

                                      DeclEnd-DeclBegin);

  StringRef FullyAnnotatedDecl =

      StringRef(SS.begin() + FullDeclBegin, FullDeclEnd - FullDeclBegin);

  StringRef GroupName = StringRef(SS.begin() + GroupBegin, GroupEnd - GroupBegin);



  llvm::Optional<std::pair<unsigned, unsigned>> DeclarationLoc;

  StringRef Filename;

  getLocationInfo(VD, DeclarationLoc, Filename);

  if (DeclarationLoc.hasValue()) {

    DeclarationLoc = tryRemappingLocToLatestSnapshot(Lang,

                                                     *DeclarationLoc,

                                                     Filename,

                                                     PreviousASTSnaps);

    if (!DeclarationLoc.hasValue())

      return true; // failed to remap.

  }



  SmallVector<StringRef, 4> OverUSRs;

  OverUSRsStream.retrieve([&](StringRef S) { OverUSRs.push_back(S); });



  SmallVector<StringRef, 4> AnnotatedRelatedDecls;

  RelDeclsStream.retrieve([&](StringRef S) { AnnotatedRelatedDecls.push_back(S); });



  bool IsSystem = VD->getModuleContext()->isSystemModule();

  std::string TypeInterface;



  CursorInfo Info;

  Info.Kind = Kind;

  Info.Name = Name;

  Info.USR = USR;

  Info.TypeName = TypeName;

  Info.TypeUSR = TypeUsr;

  Info.ContainerTypeUSR = ContainerTypeUsr;

  Info.DocComment = DocComment;

  Info.AnnotatedDeclaration = AnnotatedDecl;

  Info.FullyAnnotatedDeclaration = FullyAnnotatedDecl;

  Info.ModuleName = ModuleName;

  Info.ModuleInterfaceName = ModuleInterfaceName;

  Info.DeclarationLoc = DeclarationLoc;

  Info.Filename = Filename;

  Info.OverrideUSRs = OverUSRs;

  Info.AnnotatedRelatedDeclarations = AnnotatedRelatedDecls;

  Info.GroupName = GroupName;

  Info.IsSystem = IsSystem;

  Info.TypeInterface = StringRef();

  Receiver(Info);

  return false;

}


"
"[IDE][Utils] Add an IDE stream utility. (#7546)

This provides a stream utility for writing to a underlying string buffer multiple string pieces and retrieve them later as StringRef when the underlying buffer is stable.",tools/SourceKit/lib/SwiftLang/SwiftSourceDocInfo.cpp,+,"if (SwiftLangSupport::printUSR(VD, OverUSRsStream))","static bool passCursorInfoForDecl(const ValueDecl *VD,

                                  const ModuleDecl *MainModule,

                                  const Type Ty,

                                  const Type ContainerTy,

                                  bool IsRef,

                                  Optional<unsigned> OrigBufferID,

                                  SwiftLangSupport &Lang,

                                  const CompilerInvocation &Invok,

                            ArrayRef<ImmutableTextSnapshotRef> PreviousASTSnaps,

                             std::function<void(const CursorInfo &)> Receiver) {

  if (AvailableAttr::isUnavailable(VD))

    return true;



  SmallString<64> SS;

  auto BaseType = findBaseTypeForReplacingArchetype(VD, Ty);

  bool InSynthesizedExtension = false;

  if (BaseType) {

    if (auto Target = BaseType->getAnyNominal()) {

      SynthesizedExtensionAnalyzer Analyzer(Target,

                                            PrintOptions::printInterface());

      InSynthesizedExtension = Analyzer.isInSynthesizedExtension(VD);

    }

  }



  unsigned NameBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDisplayName(VD, OS);

  }

  unsigned NameEnd = SS.size();



  unsigned USRBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printUSR(VD, OS);

    if (InSynthesizedExtension) {

        OS << LangSupport::SynthesizedUSRSeparator;

        SwiftLangSupport::printUSR(BaseType->getAnyNominal(), OS);

    }

  }

  unsigned USREnd = SS.size();



  unsigned TypenameBegin = SS.size();

  if (VD->hasInterfaceType()) {

    llvm::raw_svector_ostream OS(SS);

    PrintOptions Options;

    Options.PrintNameAliasUnderlyingType = true;

    VD->getInterfaceType().print(OS, Options);

  }

  unsigned TypenameEnd = SS.size();



  unsigned MangledTypeStart = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDeclTypeUSR(VD, OS);

  }

  unsigned MangledTypeEnd = SS.size();



  unsigned MangledContainerTypeStart = SS.size();

  if (ContainerTy && !ContainerTy->hasArchetype()) {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printTypeUSR(ContainerTy, OS);

  }

  unsigned MangledContainerTypeEnd = SS.size();



  unsigned DocCommentBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    ide::getDocumentationCommentAsXML(VD, OS);

  }

  unsigned DocCommentEnd = SS.size();



  if (DocCommentEnd == DocCommentBegin) {

    if (auto *Req = ASTPrinter::findConformancesWithDocComment(

        const_cast<ValueDecl*>(VD))) {

      llvm::raw_svector_ostream OS(SS);

      ide::getDocumentationCommentAsXML(Req, OS);

    }

    DocCommentEnd = SS.size();

  }



  unsigned DeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    printAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned DeclEnd = SS.size();



  unsigned FullDeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printFullyAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned FullDeclEnd = SS.size();



  unsigned GroupBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    auto *GroupVD = InSynthesizedExtension ? BaseType->getAnyNominal() : VD;

    if (auto OP = GroupVD->getGroupName())

      OS << OP.getValue();

  }

  unsigned GroupEnd = SS.size();



  DelayedStringRetriever OverUSRsStream(SS);

  ide::walkOverriddenDecls(VD,

    [&](llvm::PointerUnion<const ValueDecl*, const clang::NamedDecl*> D) {

      OverUSRsStream.startPiece();

      if (auto VD = D.dyn_cast<const ValueDecl*>()) {

        if (SwiftLangSupport::printUSR(VD, OverUSRsStream))

          return;

      } else {

        llvm::SmallString<128> Buf;

        if (clang::index::generateUSRForDecl(

            D.get<const clang::NamedDecl*>(), Buf))

          return;

        OverUSRsStream << Buf.str();

      }

      OverUSRsStream.endPiece();

  });



  DelayedStringRetriever RelDeclsStream(SS);

  walkRelatedDecls(VD, [&](const ValueDecl *RelatedDecl, bool DuplicateName) {

    RelDeclsStream.startPiece();

    {

      RelDeclsStream<<""<RelatedName usr=\"""";

      SwiftLangSupport::printUSR(RelatedDecl, RelDeclsStream);

      RelDeclsStream<<""\"">"";

      if (isa<AbstractFunctionDecl>(RelatedDecl) && DuplicateName) {

        // Related decls are generally overloads, so print parameter types to

        // differentiate them.

        PrintOptions PO;

        PO.SkipAttributes = true;

        PO.SkipIntroducerKeywords = true;

        PO.ArgAndParamPrinting = PrintOptions::ArgAndParamPrintingMode::ArgumentOnly;

        XMLEscapingPrinter Printer(RelDeclsStream);

        if (BaseType) {

          PO.setBaseType(BaseType);

          PO.PrintAsMember = true;

        }

        RelatedDecl->print(Printer, PO);

      } else {

        llvm::SmallString<128> Buf;

        {

          llvm::raw_svector_ostream OSBuf(Buf);

          SwiftLangSupport::printDisplayName(RelatedDecl, OSBuf);

        }

        swift::markup::appendWithXMLEscaping(RelDeclsStream, Buf);

      }

      RelDeclsStream<<""</RelatedName>"";

    }

    RelDeclsStream.endPiece();

  });



  ASTContext &Ctx = VD->getASTContext();



  ClangImporter *Importer = static_cast<ClangImporter*>(

      Ctx.getClangModuleLoader());

  std::string ModuleName;

  auto ClangNode = VD->getClangNode();

  if (ClangNode) {

    auto ClangMod = Importer->getClangOwningModule(ClangNode);

    ModuleName = ClangMod->getFullModuleName();

  } else if (VD->getLoc().isInvalid() && VD->getModuleContext() != MainModule) {

    ModuleName = VD->getModuleContext()->getName().str();

  }

  StringRef ModuleInterfaceName;

  if (auto IFaceGenRef = Lang.getIFaceGenContexts().find(ModuleName, Invok))

    ModuleInterfaceName = IFaceGenRef->getDocumentName();



  UIdent Kind = SwiftLangSupport::getUIDForDecl(VD, IsRef);

  StringRef Name = StringRef(SS.begin()+NameBegin, NameEnd-NameBegin);

  StringRef USR = StringRef(SS.begin()+USRBegin, USREnd-USRBegin);

  StringRef TypeName = StringRef(SS.begin()+TypenameBegin,

                                 TypenameEnd-TypenameBegin);

  StringRef TypeUsr = StringRef(SS.begin()+MangledTypeStart,

                                MangledTypeEnd - MangledTypeStart);



  StringRef ContainerTypeUsr = StringRef(SS.begin()+MangledContainerTypeStart,

                            MangledContainerTypeEnd - MangledContainerTypeStart);

  StringRef DocComment = StringRef(SS.begin()+DocCommentBegin,

                                   DocCommentEnd-DocCommentBegin);

  StringRef AnnotatedDecl = StringRef(SS.begin()+DeclBegin,

                                      DeclEnd-DeclBegin);

  StringRef FullyAnnotatedDecl =

      StringRef(SS.begin() + FullDeclBegin, FullDeclEnd - FullDeclBegin);

  StringRef GroupName = StringRef(SS.begin() + GroupBegin, GroupEnd - GroupBegin);



  llvm::Optional<std::pair<unsigned, unsigned>> DeclarationLoc;

  StringRef Filename;

  getLocationInfo(VD, DeclarationLoc, Filename);

  if (DeclarationLoc.hasValue()) {

    DeclarationLoc = tryRemappingLocToLatestSnapshot(Lang,

                                                     *DeclarationLoc,

                                                     Filename,

                                                     PreviousASTSnaps);

    if (!DeclarationLoc.hasValue())

      return true; // failed to remap.

  }



  SmallVector<StringRef, 4> OverUSRs;

  OverUSRsStream.retrieve([&](StringRef S) { OverUSRs.push_back(S); });



  SmallVector<StringRef, 4> AnnotatedRelatedDecls;

  RelDeclsStream.retrieve([&](StringRef S) { AnnotatedRelatedDecls.push_back(S); });



  bool IsSystem = VD->getModuleContext()->isSystemModule();

  std::string TypeInterface;



  CursorInfo Info;

  Info.Kind = Kind;

  Info.Name = Name;

  Info.USR = USR;

  Info.TypeName = TypeName;

  Info.TypeUSR = TypeUsr;

  Info.ContainerTypeUSR = ContainerTypeUsr;

  Info.DocComment = DocComment;

  Info.AnnotatedDeclaration = AnnotatedDecl;

  Info.FullyAnnotatedDeclaration = FullyAnnotatedDecl;

  Info.ModuleName = ModuleName;

  Info.ModuleInterfaceName = ModuleInterfaceName;

  Info.DeclarationLoc = DeclarationLoc;

  Info.Filename = Filename;

  Info.OverrideUSRs = OverUSRs;

  Info.AnnotatedRelatedDeclarations = AnnotatedRelatedDecls;

  Info.GroupName = GroupName;

  Info.IsSystem = IsSystem;

  Info.TypeInterface = StringRef();

  Receiver(Info);

  return false;

}

","static bool passCursorInfoForDecl(const ValueDecl *VD,

                                  const ModuleDecl *MainModule,

                                  const Type Ty,

                                  const Type ContainerTy,

                                  bool IsRef,

                                  Optional<unsigned> OrigBufferID,

                                  SwiftLangSupport &Lang,

                                  const CompilerInvocation &Invok,

                            ArrayRef<ImmutableTextSnapshotRef> PreviousASTSnaps,

                             std::function<void(const CursorInfo &)> Receiver) {

  if (AvailableAttr::isUnavailable(VD))

    return true;



  SmallString<64> SS;

  auto BaseType = findBaseTypeForReplacingArchetype(VD, Ty);

  bool InSynthesizedExtension = false;

  if (BaseType) {

    if (auto Target = BaseType->getAnyNominal()) {

      SynthesizedExtensionAnalyzer Analyzer(Target,

                                            PrintOptions::printInterface());

      InSynthesizedExtension = Analyzer.isInSynthesizedExtension(VD);

    }

  }



  unsigned NameBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDisplayName(VD, OS);

  }

  unsigned NameEnd = SS.size();



  unsigned USRBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printUSR(VD, OS);

    if (InSynthesizedExtension) {

        OS << LangSupport::SynthesizedUSRSeparator;

        SwiftLangSupport::printUSR(BaseType->getAnyNominal(), OS);

    }

  }

  unsigned USREnd = SS.size();



  unsigned TypenameBegin = SS.size();

  if (VD->hasInterfaceType()) {

    llvm::raw_svector_ostream OS(SS);

    PrintOptions Options;

    Options.PrintNameAliasUnderlyingType = true;

    VD->getInterfaceType().print(OS, Options);

  }

  unsigned TypenameEnd = SS.size();



  unsigned MangledTypeStart = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDeclTypeUSR(VD, OS);

  }

  unsigned MangledTypeEnd = SS.size();



  unsigned MangledContainerTypeStart = SS.size();

  if (ContainerTy && !ContainerTy->hasArchetype()) {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printTypeUSR(ContainerTy, OS);

  }

  unsigned MangledContainerTypeEnd = SS.size();



  unsigned DocCommentBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    ide::getDocumentationCommentAsXML(VD, OS);

  }

  unsigned DocCommentEnd = SS.size();



  if (DocCommentEnd == DocCommentBegin) {

    if (auto *Req = ASTPrinter::findConformancesWithDocComment(

        const_cast<ValueDecl*>(VD))) {

      llvm::raw_svector_ostream OS(SS);

      ide::getDocumentationCommentAsXML(Req, OS);

    }

    DocCommentEnd = SS.size();

  }



  unsigned DeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    printAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned DeclEnd = SS.size();



  unsigned FullDeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printFullyAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned FullDeclEnd = SS.size();



  unsigned GroupBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    auto *GroupVD = InSynthesizedExtension ? BaseType->getAnyNominal() : VD;

    if (auto OP = GroupVD->getGroupName())

      OS << OP.getValue();

  }

  unsigned GroupEnd = SS.size();



  DelayedStringRetriever OverUSRsStream(SS);

  ide::walkOverriddenDecls(VD,

    [&](llvm::PointerUnion<const ValueDecl*, const clang::NamedDecl*> D) {

      OverUSRsStream.startPiece();

      if (auto VD = D.dyn_cast<const ValueDecl*>()) {

       ","
          return;

      } else {

        llvm::SmallString<128> Buf;

        if (clang::index::generateUSRForDecl(

            D.get<const clang::NamedDecl*>(), Buf))

          return;

        OverUSRsStream << Buf.str();

      }

      OverUSRsStream.endPiece();

  });



  DelayedStringRetriever RelDeclsStream(SS);

  walkRelatedDecls(VD, [&](const ValueDecl *RelatedDecl, bool DuplicateName) {

    RelDeclsStream.startPiece();

    {

      RelDeclsStream<<""<RelatedName usr=\"""";

      SwiftLangSupport::printUSR(RelatedDecl, RelDeclsStream);

      RelDeclsStream<<""\"">"";

      if (isa<AbstractFunctionDecl>(RelatedDecl) && DuplicateName) {

        // Related decls are generally overloads, so print parameter types to

        // differentiate them.

        PrintOptions PO;

        PO.SkipAttributes = true;

        PO.SkipIntroducerKeywords = true;

        PO.ArgAndParamPrinting = PrintOptions::ArgAndParamPrintingMode::ArgumentOnly;

        XMLEscapingPrinter Printer(RelDeclsStream);

        if (BaseType) {

          PO.setBaseType(BaseType);

          PO.PrintAsMember = true;

        }

        RelatedDecl->print(Printer, PO);

      } else {

        llvm::SmallString<128> Buf;

        {

          llvm::raw_svector_ostream OSBuf(Buf);

          SwiftLangSupport::printDisplayName(RelatedDecl, OSBuf);

        }

        swift::markup::appendWithXMLEscaping(RelDeclsStream, Buf);

      }

      RelDeclsStream<<""</RelatedName>"";

    }

    RelDeclsStream.endPiece();

  });



  ASTContext &Ctx = VD->getASTContext();



  ClangImporter *Importer = static_cast<ClangImporter*>(

      Ctx.getClangModuleLoader());

  std::string ModuleName;

  auto ClangNode = VD->getClangNode();

  if (ClangNode) {

    auto ClangMod = Importer->getClangOwningModule(ClangNode);

    ModuleName = ClangMod->getFullModuleName();

  } else if (VD->getLoc().isInvalid() && VD->getModuleContext() != MainModule) {

    ModuleName = VD->getModuleContext()->getName().str();

  }

  StringRef ModuleInterfaceName;

  if (auto IFaceGenRef = Lang.getIFaceGenContexts().find(ModuleName, Invok))

    ModuleInterfaceName = IFaceGenRef->getDocumentName();



  UIdent Kind = SwiftLangSupport::getUIDForDecl(VD, IsRef);

  StringRef Name = StringRef(SS.begin()+NameBegin, NameEnd-NameBegin);

  StringRef USR = StringRef(SS.begin()+USRBegin, USREnd-USRBegin);

  StringRef TypeName = StringRef(SS.begin()+TypenameBegin,

                                 TypenameEnd-TypenameBegin);

  StringRef TypeUsr = StringRef(SS.begin()+MangledTypeStart,

                                MangledTypeEnd - MangledTypeStart);



  StringRef ContainerTypeUsr = StringRef(SS.begin()+MangledContainerTypeStart,

                            MangledContainerTypeEnd - MangledContainerTypeStart);

  StringRef DocComment = StringRef(SS.begin()+DocCommentBegin,

                                   DocCommentEnd-DocCommentBegin);

  StringRef AnnotatedDecl = StringRef(SS.begin()+DeclBegin,

                                      DeclEnd-DeclBegin);

  StringRef FullyAnnotatedDecl =

      StringRef(SS.begin() + FullDeclBegin, FullDeclEnd - FullDeclBegin);

  StringRef GroupName = StringRef(SS.begin() + GroupBegin, GroupEnd - GroupBegin);



  llvm::Optional<std::pair<unsigned, unsigned>> DeclarationLoc;

  StringRef Filename;

  getLocationInfo(VD, DeclarationLoc, Filename);

  if (DeclarationLoc.hasValue()) {

    DeclarationLoc = tryRemappingLocToLatestSnapshot(Lang,

                                                     *DeclarationLoc,

                                                     Filename,

                                                     PreviousASTSnaps);

    if (!DeclarationLoc.hasValue())

      return true; // failed to remap.

  }



  SmallVector<StringRef, 4> OverUSRs;

  OverUSRsStream.retrieve([&](StringRef S) { OverUSRs.push_back(S); });



  SmallVector<StringRef, 4> AnnotatedRelatedDecls;

  RelDeclsStream.retrieve([&](StringRef S) { AnnotatedRelatedDecls.push_back(S); });



  bool IsSystem = VD->getModuleContext()->isSystemModule();

  std::string TypeInterface;



  CursorInfo Info;

  Info.Kind = Kind;

  Info.Name = Name;

  Info.USR = USR;

  Info.TypeName = TypeName;

  Info.TypeUSR = TypeUsr;

  Info.ContainerTypeUSR = ContainerTypeUsr;

  Info.DocComment = DocComment;

  Info.AnnotatedDeclaration = AnnotatedDecl;

  Info.FullyAnnotatedDeclaration = FullyAnnotatedDecl;

  Info.ModuleName = ModuleName;

  Info.ModuleInterfaceName = ModuleInterfaceName;

  Info.DeclarationLoc = DeclarationLoc;

  Info.Filename = Filename;

  Info.OverrideUSRs = OverUSRs;

  Info.AnnotatedRelatedDeclarations = AnnotatedRelatedDecls;

  Info.GroupName = GroupName;

  Info.IsSystem = IsSystem;

  Info.TypeInterface = StringRef();

  Receiver(Info);

  return false;

}

"
"[IDE][Utils] Add an IDE stream utility. (#7546)

This provides a stream utility for writing to a underlying string buffer multiple string pieces and retrieve them later as StringRef when the underlying buffer is stable.",tools/SourceKit/lib/SwiftLang/SwiftSourceDocInfo.cpp,-,"SwiftLangSupport::printUSR(RelatedDecl, OS);","static bool passCursorInfoForDecl(const ValueDecl *VD,

                                  const ModuleDecl *MainModule,

                                  const Type Ty,

                                  const Type ContainerTy,

                                  bool IsRef,

                                  Optional<unsigned> OrigBufferID,

                                  SwiftLangSupport &Lang,

                                  const CompilerInvocation &Invok,

                            ArrayRef<ImmutableTextSnapshotRef> PreviousASTSnaps,

                             std::function<void(const CursorInfo &)> Receiver) {

  if (AvailableAttr::isUnavailable(VD))

    return true;



  SmallString<64> SS;

  auto BaseType = findBaseTypeForReplacingArchetype(VD, Ty);

  bool InSynthesizedExtension = false;

  if (BaseType) {

    if (auto Target = BaseType->getAnyNominal()) {

      SynthesizedExtensionAnalyzer Analyzer(Target,

                                            PrintOptions::printInterface());

      InSynthesizedExtension = Analyzer.isInSynthesizedExtension(VD);

    }

  }



  unsigned NameBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDisplayName(VD, OS);

  }

  unsigned NameEnd = SS.size();



  unsigned USRBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printUSR(VD, OS);

    if (InSynthesizedExtension) {

        OS << LangSupport::SynthesizedUSRSeparator;

        SwiftLangSupport::printUSR(BaseType->getAnyNominal(), OS);

    }

  }

  unsigned USREnd = SS.size();



  unsigned TypenameBegin = SS.size();

  if (VD->hasInterfaceType()) {

    llvm::raw_svector_ostream OS(SS);

    PrintOptions Options;

    Options.PrintNameAliasUnderlyingType = true;

    VD->getInterfaceType().print(OS, Options);

  }

  unsigned TypenameEnd = SS.size();



  unsigned MangledTypeStart = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDeclTypeUSR(VD, OS);

  }

  unsigned MangledTypeEnd = SS.size();



  unsigned MangledContainerTypeStart = SS.size();

  if (ContainerTy && !ContainerTy->hasArchetype()) {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printTypeUSR(ContainerTy, OS);

  }

  unsigned MangledContainerTypeEnd = SS.size();



  unsigned DocCommentBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    ide::getDocumentationCommentAsXML(VD, OS);

  }

  unsigned DocCommentEnd = SS.size();



  if (DocCommentEnd == DocCommentBegin) {

    if (auto *Req = ASTPrinter::findConformancesWithDocComment(

        const_cast<ValueDecl*>(VD))) {

      llvm::raw_svector_ostream OS(SS);

      ide::getDocumentationCommentAsXML(Req, OS);

    }

    DocCommentEnd = SS.size();

  }



  unsigned DeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    printAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned DeclEnd = SS.size();



  unsigned FullDeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printFullyAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned FullDeclEnd = SS.size();



  unsigned GroupBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    auto *GroupVD = InSynthesizedExtension ? BaseType->getAnyNominal() : VD;

    if (auto OP = GroupVD->getGroupName())

      OS << OP.getValue();

  }

  unsigned GroupEnd = SS.size();



  DelayedStringRetriever OverUSRsStream(SS);

  ide::walkOverriddenDecls(VD,

    [&](llvm::PointerUnion<const ValueDecl*, const clang::NamedDecl*> D) {

      OverUSRsStream.startPiece();

      if (auto VD = D.dyn_cast<const ValueDecl*>()) {

        if (SwiftLangSupport::printUSR(VD, OverUSRsStream))

          return;

      } else {

        llvm::SmallString<128> Buf;

        if (clang::index::generateUSRForDecl(

            D.get<const clang::NamedDecl*>(), Buf))

          return;

        OverUSRsStream << Buf.str();

      }

      OverUSRsStream.endPiece();

  });



  DelayedStringRetriever RelDeclsStream(SS);

  walkRelatedDecls(VD, [&](const ValueDecl *RelatedDecl, bool DuplicateName) {

    RelDeclsStream.startPiece();

    {

      RelDeclsStream<<""<RelatedName usr=\"""";

      SwiftLangSupport::printUSR(RelatedDecl, RelDeclsStream);

      RelDeclsStream<<""\"">"";

      if (isa<AbstractFunctionDecl>(RelatedDecl) && DuplicateName) {

        // Related decls are generally overloads, so print parameter types to

        // differentiate them.

        PrintOptions PO;

        PO.SkipAttributes = true;

        PO.SkipIntroducerKeywords = true;

        PO.ArgAndParamPrinting = PrintOptions::ArgAndParamPrintingMode::ArgumentOnly;

        XMLEscapingPrinter Printer(RelDeclsStream);

        if (BaseType) {

          PO.setBaseType(BaseType);

          PO.PrintAsMember = true;

        }

        RelatedDecl->print(Printer, PO);

      } else {

        llvm::SmallString<128> Buf;

        {

          llvm::raw_svector_ostream OSBuf(Buf);

          SwiftLangSupport::printDisplayName(RelatedDecl, OSBuf);

        }

        swift::markup::appendWithXMLEscaping(RelDeclsStream, Buf);

      }

      RelDeclsStream<<""</RelatedName>"";

    }

    RelDeclsStream.endPiece();

  });



  ASTContext &Ctx = VD->getASTContext();



  ClangImporter *Importer = static_cast<ClangImporter*>(

      Ctx.getClangModuleLoader());

  std::string ModuleName;

  auto ClangNode = VD->getClangNode();

  if (ClangNode) {

    auto ClangMod = Importer->getClangOwningModule(ClangNode);

    ModuleName = ClangMod->getFullModuleName();

  } else if (VD->getLoc().isInvalid() && VD->getModuleContext() != MainModule) {

    ModuleName = VD->getModuleContext()->getName().str();

  }

  StringRef ModuleInterfaceName;

  if (auto IFaceGenRef = Lang.getIFaceGenContexts().find(ModuleName, Invok))

    ModuleInterfaceName = IFaceGenRef->getDocumentName();



  UIdent Kind = SwiftLangSupport::getUIDForDecl(VD, IsRef);

  StringRef Name = StringRef(SS.begin()+NameBegin, NameEnd-NameBegin);

  StringRef USR = StringRef(SS.begin()+USRBegin, USREnd-USRBegin);

  StringRef TypeName = StringRef(SS.begin()+TypenameBegin,

                                 TypenameEnd-TypenameBegin);

  StringRef TypeUsr = StringRef(SS.begin()+MangledTypeStart,

                                MangledTypeEnd - MangledTypeStart);



  StringRef ContainerTypeUsr = StringRef(SS.begin()+MangledContainerTypeStart,

                            MangledContainerTypeEnd - MangledContainerTypeStart);

  StringRef DocComment = StringRef(SS.begin()+DocCommentBegin,

                                   DocCommentEnd-DocCommentBegin);

  StringRef AnnotatedDecl = StringRef(SS.begin()+DeclBegin,

                                      DeclEnd-DeclBegin);

  StringRef FullyAnnotatedDecl =

      StringRef(SS.begin() + FullDeclBegin, FullDeclEnd - FullDeclBegin);

  StringRef GroupName = StringRef(SS.begin() + GroupBegin, GroupEnd - GroupBegin);



  llvm::Optional<std::pair<unsigned, unsigned>> DeclarationLoc;

  StringRef Filename;

  getLocationInfo(VD, DeclarationLoc, Filename);

  if (DeclarationLoc.hasValue()) {

    DeclarationLoc = tryRemappingLocToLatestSnapshot(Lang,

                                                     *DeclarationLoc,

                                                     Filename,

                                                     PreviousASTSnaps);

    if (!DeclarationLoc.hasValue())

      return true; // failed to remap.

  }



  SmallVector<StringRef, 4> OverUSRs;

  OverUSRsStream.retrieve([&](StringRef S) { OverUSRs.push_back(S); });



  SmallVector<StringRef, 4> AnnotatedRelatedDecls;

  RelDeclsStream.retrieve([&](StringRef S) { AnnotatedRelatedDecls.push_back(S); });



  bool IsSystem = VD->getModuleContext()->isSystemModule();

  std::string TypeInterface;



  CursorInfo Info;

  Info.Kind = Kind;

  Info.Name = Name;

  Info.USR = USR;

  Info.TypeName = TypeName;

  Info.TypeUSR = TypeUsr;

  Info.ContainerTypeUSR = ContainerTypeUsr;

  Info.DocComment = DocComment;

  Info.AnnotatedDeclaration = AnnotatedDecl;

  Info.FullyAnnotatedDeclaration = FullyAnnotatedDecl;

  Info.ModuleName = ModuleName;

  Info.ModuleInterfaceName = ModuleInterfaceName;

  Info.DeclarationLoc = DeclarationLoc;

  Info.Filename = Filename;

  Info.OverrideUSRs = OverUSRs;

  Info.AnnotatedRelatedDeclarations = AnnotatedRelatedDecls;

  Info.GroupName = GroupName;

  Info.IsSystem = IsSystem;

  Info.TypeInterface = StringRef();

  Receiver(Info);

  return false;

}

","static bool passCursorInfoForDecl(const ValueDecl *VD,

                                  const ModuleDecl *MainModule,

                                  const Type Ty,

                                  const Type ContainerTy,

                                  bool IsRef,

                                  Optional<unsigned> OrigBufferID,

                                  SwiftLangSupport &Lang,

                                  const CompilerInvocation &Invok,

                            ArrayRef<ImmutableTextSnapshotRef> PreviousASTSnaps,

                             std::function<void(const CursorInfo &)> Receiver) {

  if (AvailableAttr::isUnavailable(VD))

    return true;



  SmallString<64> SS;

  auto BaseType = findBaseTypeForReplacingArchetype(VD, Ty);

  bool InSynthesizedExtension = false;

  if (BaseType) {

    if (auto Target = BaseType->getAnyNominal()) {

      SynthesizedExtensionAnalyzer Analyzer(Target,

                                            PrintOptions::printInterface());

      InSynthesizedExtension = Analyzer.isInSynthesizedExtension(VD);

    }

  }



  unsigned NameBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDisplayName(VD, OS);

  }

  unsigned NameEnd = SS.size();



  unsigned USRBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printUSR(VD, OS);

    if (InSynthesizedExtension) {

        OS << LangSupport::SynthesizedUSRSeparator;

        SwiftLangSupport::printUSR(BaseType->getAnyNominal(), OS);

    }

  }

  unsigned USREnd = SS.size();



  unsigned TypenameBegin = SS.size();

  if (VD->hasInterfaceType()) {

    llvm::raw_svector_ostream OS(SS);

    PrintOptions Options;

    Options.PrintNameAliasUnderlyingType = true;

    VD->getInterfaceType().print(OS, Options);

  }

  unsigned TypenameEnd = SS.size();



  unsigned MangledTypeStart = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDeclTypeUSR(VD, OS);

  }

  unsigned MangledTypeEnd = SS.size();



  unsigned MangledContainerTypeStart = SS.size();

  if (ContainerTy && !ContainerTy->hasArchetype()) {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printTypeUSR(ContainerTy, OS);

  }

  unsigned MangledContainerTypeEnd = SS.size();



  unsigned DocCommentBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    ide::getDocumentationCommentAsXML(VD, OS);

  }

  unsigned DocCommentEnd = SS.size();



  if (DocCommentEnd == DocCommentBegin) {
","    if (auto *Req = ASTPrinter::findConformancesWithDocComment(

        const_cast<ValueDecl*>(VD))) {

      llvm::raw_svector_ostream OS(SS);

      ide::getDocumentationCommentAsXML(Req, OS);

    }

    DocCommentEnd = SS.size();

  }



  unsigned DeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    printAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned DeclEnd = SS.size();



  unsigned FullDeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printFullyAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned FullDeclEnd = SS.size();



  unsigned GroupBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    auto *GroupVD = InSynthesizedExtension ? BaseType->getAnyNominal() : VD;

    if (auto OP = GroupVD->getGroupName())

      OS << OP.getValue();

  }

  unsigned GroupEnd = SS.size();



  DelayedStringRetriever OverUSRsStream(SS);

  ide::walkOverriddenDecls(VD,

    [&](llvm::PointerUnion<const ValueDecl*, const clang::NamedDecl*> D) {

      OverUSRsStream.startPiece();

      if (auto VD = D.dyn_cast<const ValueDecl*>()) {

        if (SwiftLangSupport::printUSR(VD, OverUSRsStream))

          return;

      } else {

        llvm::SmallString<128> Buf;

        if (clang::index::generateUSRForDecl(

            D.get<const clang::NamedDecl*>(), Buf))

          return;

        OverUSRsStream << Buf.str();

      }

      OverUSRsStream.endPiece();

  });



  DelayedStringRetriever RelDeclsStream(SS);

  walkRelatedDecls(VD, [&](const ValueDecl *RelatedDecl, bool DuplicateName) {

    RelDeclsStream.startPiece();

    {

      RelDeclsStream<<""<RelatedName usr=\"""";

      SwiftLangSupport::printUSR(RelatedDecl, RelDeclsStream);

      RelDeclsStream<<""\"">"";

      if (isa<AbstractFunctionDecl>(RelatedDecl) && DuplicateName) {

        // Related decls are generally overloads, so print parameter types to

        // differentiate them.

        PrintOptions PO;

        PO.SkipAttributes = true;

        PO.SkipIntroducerKeywords = true;

        PO.ArgAndParamPrinting = PrintOptions::ArgAndParamPrintingMode::ArgumentOnly;

        XMLEscapingPrinter Printer(RelDeclsStream);

        if (BaseType) {

          PO.setBaseType(BaseType);

          PO.PrintAsMember = true;

        }

        RelatedDecl->print(Printer, PO);

      } else {

        llvm::SmallString<128> Buf;

        {

          llvm::raw_svector_ostream OSBuf(Buf);

          SwiftLangSupport::printDisplayName(RelatedDecl, OSBuf);

        }

        swift::markup::appendWithXMLEscaping(RelDeclsStream, Buf);

      }

      RelDeclsStream<<""</RelatedName>"";

    }

    RelDeclsStream.endPiece();

  });



  ASTContext &Ctx = VD->getASTContext();



  ClangImporter *Importer = static_cast<ClangImporter*>(

      Ctx.getClangModuleLoader());

  std::string ModuleName;

  auto ClangNode = VD->getClangNode();

  if (ClangNode) {

    auto ClangMod = Importer->getClangOwningModule(ClangNode);

    ModuleName = ClangMod->getFullModuleName();

  } else if (VD->getLoc().isInvalid() && VD->getModuleContext() != MainModule) {

    ModuleName = VD->getModuleContext()->getName().str();

  }

  StringRef ModuleInterfaceName;

  if (auto IFaceGenRef = Lang.getIFaceGenContexts().find(ModuleName, Invok))

    ModuleInterfaceName = IFaceGenRef->getDocumentName();



  UIdent Kind = SwiftLangSupport::getUIDForDecl(VD, IsRef);

  StringRef Name = StringRef(SS.begin()+NameBegin, NameEnd-NameBegin);

  StringRef USR = StringRef(SS.begin()+USRBegin, USREnd-USRBegin);

  StringRef TypeName = StringRef(SS.begin()+TypenameBegin,

                                 TypenameEnd-TypenameBegin);

  StringRef TypeUsr = StringRef(SS.begin()+MangledTypeStart,

                                MangledTypeEnd - MangledTypeStart);



  StringRef ContainerTypeUsr = StringRef(SS.begin()+MangledContainerTypeStart,

                            MangledContainerTypeEnd - MangledContainerTypeStart);

  StringRef DocComment = StringRef(SS.begin()+DocCommentBegin,

                                   DocCommentEnd-DocCommentBegin);

  StringRef AnnotatedDecl = StringRef(SS.begin()+DeclBegin,

                                      DeclEnd-DeclBegin);

  StringRef FullyAnnotatedDecl =

      StringRef(SS.begin() + FullDeclBegin, FullDeclEnd - FullDeclBegin);

  StringRef GroupName = StringRef(SS.begin() + GroupBegin, GroupEnd - GroupBegin);



  llvm::Optional<std::pair<unsigned, unsigned>> DeclarationLoc;

  StringRef Filename;

  getLocationInfo(VD, DeclarationLoc, Filename);

  if (DeclarationLoc.hasValue()) {

    DeclarationLoc = tryRemappingLocToLatestSnapshot(Lang,

                                                     *DeclarationLoc,

                                                     Filename,

                                                     PreviousASTSnaps);

    if (!DeclarationLoc.hasValue())

      return true; // failed to remap.

  }



  SmallVector<StringRef, 4> OverUSRs;

  OverUSRsStream.retrieve([&](StringRef S) { OverUSRs.push_back(S); });



  SmallVector<StringRef, 4> AnnotatedRelatedDecls;

  RelDeclsStream.retrieve([&](StringRef S) { AnnotatedRelatedDecls.push_back(S); });



  bool IsSystem = VD->getModuleContext()->isSystemModule();

  std::string TypeInterface;



  CursorInfo Info;

  Info.Kind = Kind;

  Info.Name = Name;

  Info.USR = USR;

  Info.TypeName = TypeName;

  Info.TypeUSR = TypeUsr;

  Info.ContainerTypeUSR = ContainerTypeUsr;

  Info.DocComment = DocComment;

  Info.AnnotatedDeclaration = AnnotatedDecl;

  Info.FullyAnnotatedDeclaration = FullyAnnotatedDecl;

  Info.ModuleName = ModuleName;

  Info.ModuleInterfaceName = ModuleInterfaceName;

  Info.DeclarationLoc = DeclarationLoc;

  Info.Filename = Filename;

  Info.OverrideUSRs = OverUSRs;

  Info.AnnotatedRelatedDeclarations = AnnotatedRelatedDecls;

  Info.GroupName = GroupName;

  Info.IsSystem = IsSystem;

  Info.TypeInterface = StringRef();

  Receiver(Info);

  return false;

}


"
"[IDE][Utils] Add an IDE stream utility. (#7546)

This provides a stream utility for writing to a underlying string buffer multiple string pieces and retrieve them later as StringRef when the underlying buffer is stable.",tools/SourceKit/lib/SwiftLang/SwiftSourceDocInfo.cpp,+,"SwiftLangSupport::printUSR(RelatedDecl, RelDeclsStream);","static bool passCursorInfoForDecl(const ValueDecl *VD,

                                  const ModuleDecl *MainModule,

                                  const Type Ty,

                                  const Type ContainerTy,

                                  bool IsRef,

                                  Optional<unsigned> OrigBufferID,

                                  SwiftLangSupport &Lang,

                                  const CompilerInvocation &Invok,

                            ArrayRef<ImmutableTextSnapshotRef> PreviousASTSnaps,

                             std::function<void(const CursorInfo &)> Receiver) {

  if (AvailableAttr::isUnavailable(VD))

    return true;



  SmallString<64> SS;

  auto BaseType = findBaseTypeForReplacingArchetype(VD, Ty);

  bool InSynthesizedExtension = false;

  if (BaseType) {

    if (auto Target = BaseType->getAnyNominal()) {

      SynthesizedExtensionAnalyzer Analyzer(Target,

                                            PrintOptions::printInterface());

      InSynthesizedExtension = Analyzer.isInSynthesizedExtension(VD);

    }

  }



  unsigned NameBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDisplayName(VD, OS);

  }

  unsigned NameEnd = SS.size();



  unsigned USRBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printUSR(VD, OS);

    if (InSynthesizedExtension) {

        OS << LangSupport::SynthesizedUSRSeparator;

        SwiftLangSupport::printUSR(BaseType->getAnyNominal(), OS);

    }

  }

  unsigned USREnd = SS.size();



  unsigned TypenameBegin = SS.size();

  if (VD->hasInterfaceType()) {

    llvm::raw_svector_ostream OS(SS);

    PrintOptions Options;

    Options.PrintNameAliasUnderlyingType = true;

    VD->getInterfaceType().print(OS, Options);

  }

  unsigned TypenameEnd = SS.size();



  unsigned MangledTypeStart = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDeclTypeUSR(VD, OS);

  }

  unsigned MangledTypeEnd = SS.size();



  unsigned MangledContainerTypeStart = SS.size();

  if (ContainerTy && !ContainerTy->hasArchetype()) {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printTypeUSR(ContainerTy, OS);

  }

  unsigned MangledContainerTypeEnd = SS.size();



  unsigned DocCommentBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    ide::getDocumentationCommentAsXML(VD, OS);

  }

  unsigned DocCommentEnd = SS.size();



  if (DocCommentEnd == DocCommentBegin) {

    if (auto *Req = ASTPrinter::findConformancesWithDocComment(

        const_cast<ValueDecl*>(VD))) {

      llvm::raw_svector_ostream OS(SS);

      ide::getDocumentationCommentAsXML(Req, OS);

    }

    DocCommentEnd = SS.size();

  }



  unsigned DeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    printAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned DeclEnd = SS.size();



  unsigned FullDeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printFullyAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned FullDeclEnd = SS.size();



  unsigned GroupBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    auto *GroupVD = InSynthesizedExtension ? BaseType->getAnyNominal() : VD;

    if (auto OP = GroupVD->getGroupName())

      OS << OP.getValue();

  }

  unsigned GroupEnd = SS.size();



  DelayedStringRetriever OverUSRsStream(SS);

  ide::walkOverriddenDecls(VD,

    [&](llvm::PointerUnion<const ValueDecl*, const clang::NamedDecl*> D) {

      OverUSRsStream.startPiece();

      if (auto VD = D.dyn_cast<const ValueDecl*>()) {

        if (SwiftLangSupport::printUSR(VD, OverUSRsStream))

          return;

      } else {

        llvm::SmallString<128> Buf;

        if (clang::index::generateUSRForDecl(

            D.get<const clang::NamedDecl*>(), Buf))

          return;

        OverUSRsStream << Buf.str();

      }

      OverUSRsStream.endPiece();

  });



  DelayedStringRetriever RelDeclsStream(SS);

  walkRelatedDecls(VD, [&](const ValueDecl *RelatedDecl, bool DuplicateName) {

    RelDeclsStream.startPiece();

    {

      RelDeclsStream<<""<RelatedName usr=\"""";

      SwiftLangSupport::printUSR(RelatedDecl, RelDeclsStream);

      RelDeclsStream<<""\"">"";

      if (isa<AbstractFunctionDecl>(RelatedDecl) && DuplicateName) {

        // Related decls are generally overloads, so print parameter types to

        // differentiate them.

        PrintOptions PO;

        PO.SkipAttributes = true;

        PO.SkipIntroducerKeywords = true;

        PO.ArgAndParamPrinting = PrintOptions::ArgAndParamPrintingMode::ArgumentOnly;

        XMLEscapingPrinter Printer(RelDeclsStream);

        if (BaseType) {

          PO.setBaseType(BaseType);

          PO.PrintAsMember = true;

        }

        RelatedDecl->print(Printer, PO);

      } else {

        llvm::SmallString<128> Buf;

        {

          llvm::raw_svector_ostream OSBuf(Buf);

          SwiftLangSupport::printDisplayName(RelatedDecl, OSBuf);

        }

        swift::markup::appendWithXMLEscaping(RelDeclsStream, Buf);

      }

      RelDeclsStream<<""</RelatedName>"";

    }

    RelDeclsStream.endPiece();

  });



  ASTContext &Ctx = VD->getASTContext();



  ClangImporter *Importer = static_cast<ClangImporter*>(

      Ctx.getClangModuleLoader());

  std::string ModuleName;

  auto ClangNode = VD->getClangNode();

  if (ClangNode) {

    auto ClangMod = Importer->getClangOwningModule(ClangNode);

    ModuleName = ClangMod->getFullModuleName();

  } else if (VD->getLoc().isInvalid() && VD->getModuleContext() != MainModule) {

    ModuleName = VD->getModuleContext()->getName().str();

  }

  StringRef ModuleInterfaceName;

  if (auto IFaceGenRef = Lang.getIFaceGenContexts().find(ModuleName, Invok))

    ModuleInterfaceName = IFaceGenRef->getDocumentName();



  UIdent Kind = SwiftLangSupport::getUIDForDecl(VD, IsRef);

  StringRef Name = StringRef(SS.begin()+NameBegin, NameEnd-NameBegin);

  StringRef USR = StringRef(SS.begin()+USRBegin, USREnd-USRBegin);

  StringRef TypeName = StringRef(SS.begin()+TypenameBegin,

                                 TypenameEnd-TypenameBegin);

  StringRef TypeUsr = StringRef(SS.begin()+MangledTypeStart,

                                MangledTypeEnd - MangledTypeStart);



  StringRef ContainerTypeUsr = StringRef(SS.begin()+MangledContainerTypeStart,

                            MangledContainerTypeEnd - MangledContainerTypeStart);

  StringRef DocComment = StringRef(SS.begin()+DocCommentBegin,

                                   DocCommentEnd-DocCommentBegin);

  StringRef AnnotatedDecl = StringRef(SS.begin()+DeclBegin,

                                      DeclEnd-DeclBegin);

  StringRef FullyAnnotatedDecl =

      StringRef(SS.begin() + FullDeclBegin, FullDeclEnd - FullDeclBegin);

  StringRef GroupName = StringRef(SS.begin() + GroupBegin, GroupEnd - GroupBegin);



  llvm::Optional<std::pair<unsigned, unsigned>> DeclarationLoc;

  StringRef Filename;

  getLocationInfo(VD, DeclarationLoc, Filename);

  if (DeclarationLoc.hasValue()) {

    DeclarationLoc = tryRemappingLocToLatestSnapshot(Lang,

                                                     *DeclarationLoc,

                                                     Filename,

                                                     PreviousASTSnaps);

    if (!DeclarationLoc.hasValue())

      return true; // failed to remap.

  }



  SmallVector<StringRef, 4> OverUSRs;

  OverUSRsStream.retrieve([&](StringRef S) { OverUSRs.push_back(S); });



  SmallVector<StringRef, 4> AnnotatedRelatedDecls;

  RelDeclsStream.retrieve([&](StringRef S) { AnnotatedRelatedDecls.push_back(S); });



  bool IsSystem = VD->getModuleContext()->isSystemModule();

  std::string TypeInterface;



  CursorInfo Info;

  Info.Kind = Kind;

  Info.Name = Name;

  Info.USR = USR;

  Info.TypeName = TypeName;

  Info.TypeUSR = TypeUsr;

  Info.ContainerTypeUSR = ContainerTypeUsr;

  Info.DocComment = DocComment;

  Info.AnnotatedDeclaration = AnnotatedDecl;

  Info.FullyAnnotatedDeclaration = FullyAnnotatedDecl;

  Info.ModuleName = ModuleName;

  Info.ModuleInterfaceName = ModuleInterfaceName;

  Info.DeclarationLoc = DeclarationLoc;

  Info.Filename = Filename;

  Info.OverrideUSRs = OverUSRs;

  Info.AnnotatedRelatedDeclarations = AnnotatedRelatedDecls;

  Info.GroupName = GroupName;

  Info.IsSystem = IsSystem;

  Info.TypeInterface = StringRef();

  Receiver(Info);

  return false;

}

","static bool passCursorInfoForDecl(const ValueDecl *VD,

                                  const ModuleDecl *MainModule,

                                  const Type Ty,

                                  const Type ContainerTy,

                                  bool IsRef,

                                  Optional<unsigned> OrigBufferID,

                                  SwiftLangSupport &Lang,

                                  const CompilerInvocation &Invok,

                            ArrayRef<ImmutableTextSnapshotRef> PreviousASTSnaps,

                             std::function<void(const CursorInfo &)> Receiver) {

  if (AvailableAttr::isUnavailable(VD))

    return true;



  SmallString<64> SS;

  auto BaseType = findBaseTypeForReplacingArchetype(VD, Ty);

  bool InSynthesizedExtension = false;

  if (BaseType) {

    if (auto Target = BaseType->getAnyNominal()) {

      SynthesizedExtensionAnalyzer Analyzer(Target,

                                            PrintOptions::printInterface());

      InSynthesizedExtension = Analyzer.isInSynthesizedExtension(VD);

    }

  }



  unsigned NameBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDisplayName(VD, OS);

  }

  unsigned NameEnd = SS.size();



  unsigned USRBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printUSR(VD, OS);

    if (InSynthesizedExtension) {

        OS << LangSupport::SynthesizedUSRSeparator;

        SwiftLangSupport::printUSR(BaseType->getAnyNominal(), OS);

    }

  }

  unsigned USREnd = SS.size();



  unsigned TypenameBegin = SS.size();

  if (VD->hasInterfaceType()) {

    llvm::raw_svector_ostream OS(SS);

    PrintOptions Options;

    Options.PrintNameAliasUnderlyingType = true;

    VD->getInterfaceType().print(OS, Options);

  }

  unsigned TypenameEnd = SS.size();



  unsigned MangledTypeStart = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDeclTypeUSR(VD, OS);

  }

  unsigned MangledTypeEnd = SS.size();



  unsigned MangledContainerTypeStart = SS.size();

  if (ContainerTy && !ContainerTy->hasArchetype()) {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printTypeUSR(ContainerTy, OS);

  }

  unsigned MangledContainerTypeEnd = SS.size();



  unsigned DocCommentBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    ide::getDocumentationCommentAsXML(VD, OS);

  }

  unsigned DocCommentEnd = SS.size();



  if (DocCommentEnd == DocCommentBegin) {

    if (auto *Req = ASTPrinter::findConformancesWithDocComment(

        const_cast<ValueDecl*>(VD))) {

      llvm::raw_svector_ostream OS(SS);

      ide::getDocumentationCommentAsXML(Req, OS);

    }

    DocCommentEnd = SS.size();

  }



  unsigned DeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    printAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned DeclEnd = SS.size();



  unsigned FullDeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printFullyAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned FullDeclEnd = SS.size();



  unsigned GroupBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    auto *GroupVD = InSynthesizedExtension ? BaseType->getAnyNominal() : VD;

    if (auto OP = GroupVD->getGroupName())

      OS << OP.getValue();

  }

  unsigned GroupEnd = SS.size();



  DelayedStringRetriever OverUSRsStream(SS);

  ide::walkOverriddenDecls(VD,

    [&](llvm::PointerUnion<const ValueDecl*, const clang::NamedDecl*> D) {

      OverUSRsStream.startPiece();

      if (auto VD = D.dyn_cast<const ValueDecl*>()) {

        if (SwiftLangSupport::printUSR(VD, OverUSRsStream))

          return;

      } else {

        llvm::SmallString<128> Buf;

        if (clang::index::generateUSRForDecl(

            D.get<const clang::NamedDecl*>(), Buf))

          return;

        OverUSRsStream << Buf.str();

      }

      OverUSRsStream.endPiece();

  });



  DelayedStringRetriever RelDeclsStream(SS);

  walkRelatedDecls(VD, [&](const ValueDecl *RelatedDecl, bool DuplicateName) {

    RelDeclsStream.startPiece();

    {

      RelDeclsStream<<""<RelatedName usr=\"""";

     ","
      RelDeclsStream<<""\"">"";

      if (isa<AbstractFunctionDecl>(RelatedDecl) && DuplicateName) {

        // Related decls are generally overloads, so print parameter types to

        // differentiate them.

        PrintOptions PO;

        PO.SkipAttributes = true;

        PO.SkipIntroducerKeywords = true;

        PO.ArgAndParamPrinting = PrintOptions::ArgAndParamPrintingMode::ArgumentOnly;

        XMLEscapingPrinter Printer(RelDeclsStream);

        if (BaseType) {

          PO.setBaseType(BaseType);

          PO.PrintAsMember = true;

        }

        RelatedDecl->print(Printer, PO);

      } else {

        llvm::SmallString<128> Buf;

        {

          llvm::raw_svector_ostream OSBuf(Buf);

          SwiftLangSupport::printDisplayName(RelatedDecl, OSBuf);

        }

        swift::markup::appendWithXMLEscaping(RelDeclsStream, Buf);

      }

      RelDeclsStream<<""</RelatedName>"";

    }

    RelDeclsStream.endPiece();

  });



  ASTContext &Ctx = VD->getASTContext();



  ClangImporter *Importer = static_cast<ClangImporter*>(

      Ctx.getClangModuleLoader());

  std::string ModuleName;

  auto ClangNode = VD->getClangNode();

  if (ClangNode) {

    auto ClangMod = Importer->getClangOwningModule(ClangNode);

    ModuleName = ClangMod->getFullModuleName();

  } else if (VD->getLoc().isInvalid() && VD->getModuleContext() != MainModule) {

    ModuleName = VD->getModuleContext()->getName().str();

  }

  StringRef ModuleInterfaceName;

  if (auto IFaceGenRef = Lang.getIFaceGenContexts().find(ModuleName, Invok))

    ModuleInterfaceName = IFaceGenRef->getDocumentName();



  UIdent Kind = SwiftLangSupport::getUIDForDecl(VD, IsRef);

  StringRef Name = StringRef(SS.begin()+NameBegin, NameEnd-NameBegin);

  StringRef USR = StringRef(SS.begin()+USRBegin, USREnd-USRBegin);

  StringRef TypeName = StringRef(SS.begin()+TypenameBegin,

                                 TypenameEnd-TypenameBegin);

  StringRef TypeUsr = StringRef(SS.begin()+MangledTypeStart,

                                MangledTypeEnd - MangledTypeStart);



  StringRef ContainerTypeUsr = StringRef(SS.begin()+MangledContainerTypeStart,

                            MangledContainerTypeEnd - MangledContainerTypeStart);

  StringRef DocComment = StringRef(SS.begin()+DocCommentBegin,

                                   DocCommentEnd-DocCommentBegin);

  StringRef AnnotatedDecl = StringRef(SS.begin()+DeclBegin,

                                      DeclEnd-DeclBegin);

  StringRef FullyAnnotatedDecl =

      StringRef(SS.begin() + FullDeclBegin, FullDeclEnd - FullDeclBegin);

  StringRef GroupName = StringRef(SS.begin() + GroupBegin, GroupEnd - GroupBegin);



  llvm::Optional<std::pair<unsigned, unsigned>> DeclarationLoc;

  StringRef Filename;

  getLocationInfo(VD, DeclarationLoc, Filename);

  if (DeclarationLoc.hasValue()) {

    DeclarationLoc = tryRemappingLocToLatestSnapshot(Lang,

                                                     *DeclarationLoc,

                                                     Filename,

                                                     PreviousASTSnaps);

    if (!DeclarationLoc.hasValue())

      return true; // failed to remap.

  }



  SmallVector<StringRef, 4> OverUSRs;

  OverUSRsStream.retrieve([&](StringRef S) { OverUSRs.push_back(S); });



  SmallVector<StringRef, 4> AnnotatedRelatedDecls;

  RelDeclsStream.retrieve([&](StringRef S) { AnnotatedRelatedDecls.push_back(S); });



  bool IsSystem = VD->getModuleContext()->isSystemModule();

  std::string TypeInterface;



  CursorInfo Info;

  Info.Kind = Kind;

  Info.Name = Name;

  Info.USR = USR;

  Info.TypeName = TypeName;

  Info.TypeUSR = TypeUsr;

  Info.ContainerTypeUSR = ContainerTypeUsr;

  Info.DocComment = DocComment;

  Info.AnnotatedDeclaration = AnnotatedDecl;

  Info.FullyAnnotatedDeclaration = FullyAnnotatedDecl;

  Info.ModuleName = ModuleName;

  Info.ModuleInterfaceName = ModuleInterfaceName;

  Info.DeclarationLoc = DeclarationLoc;

  Info.Filename = Filename;

  Info.OverrideUSRs = OverUSRs;

  Info.AnnotatedRelatedDeclarations = AnnotatedRelatedDecls;

  Info.GroupName = GroupName;

  Info.IsSystem = IsSystem;

  Info.TypeInterface = StringRef();

  Receiver(Info);

  return false;

}

"
"[IDE][Utils] Add an IDE stream utility. (#7546)

This provides a stream utility for writing to a underlying string buffer multiple string pieces and retrieve them later as StringRef when the underlying buffer is stable.",tools/SourceKit/lib/SwiftLang/SwiftSourceDocInfo.cpp,-,XMLEscapingPrinter Printer(OS);,"static bool passCursorInfoForDecl(const ValueDecl *VD,

                                  const ModuleDecl *MainModule,

                                  const Type Ty,

                                  const Type ContainerTy,

                                  bool IsRef,

                                  Optional<unsigned> OrigBufferID,

                                  SwiftLangSupport &Lang,

                                  const CompilerInvocation &Invok,

                            ArrayRef<ImmutableTextSnapshotRef> PreviousASTSnaps,

                             std::function<void(const CursorInfo &)> Receiver) {

  if (AvailableAttr::isUnavailable(VD))

    return true;



  SmallString<64> SS;

  auto BaseType = findBaseTypeForReplacingArchetype(VD, Ty);

  bool InSynthesizedExtension = false;

  if (BaseType) {

    if (auto Target = BaseType->getAnyNominal()) {

      SynthesizedExtensionAnalyzer Analyzer(Target,

                                            PrintOptions::printInterface());

      InSynthesizedExtension = Analyzer.isInSynthesizedExtension(VD);

    }

  }



  unsigned NameBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDisplayName(VD, OS);

  }

  unsigned NameEnd = SS.size();



  unsigned USRBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printUSR(VD, OS);

    if (InSynthesizedExtension) {

        OS << LangSupport::SynthesizedUSRSeparator;

        SwiftLangSupport::printUSR(BaseType->getAnyNominal(), OS);

    }

  }

  unsigned USREnd = SS.size();



  unsigned TypenameBegin = SS.size();

  if (VD->hasInterfaceType()) {

    llvm::raw_svector_ostream OS(SS);

    PrintOptions Options;

    Options.PrintNameAliasUnderlyingType = true;

    VD->getInterfaceType().print(OS, Options);

  }

  unsigned TypenameEnd = SS.size();



  unsigned MangledTypeStart = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDeclTypeUSR(VD, OS);

  }

  unsigned MangledTypeEnd = SS.size();



  unsigned MangledContainerTypeStart = SS.size();

  if (ContainerTy && !ContainerTy->hasArchetype()) {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printTypeUSR(ContainerTy, OS);

  }

  unsigned MangledContainerTypeEnd = SS.size();



  unsigned DocCommentBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    ide::getDocumentationCommentAsXML(VD, OS);

  }

  unsigned DocCommentEnd = SS.size();



  if (DocCommentEnd == DocCommentBegin) {

    if (auto *Req = ASTPrinter::findConformancesWithDocComment(

        const_cast<ValueDecl*>(VD))) {

      llvm::raw_svector_ostream OS(SS);

      ide::getDocumentationCommentAsXML(Req, OS);

    }

    DocCommentEnd = SS.size();

  }



  unsigned DeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    printAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned DeclEnd = SS.size();



  unsigned FullDeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printFullyAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned FullDeclEnd = SS.size();



  unsigned GroupBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    auto *GroupVD = InSynthesizedExtension ? BaseType->getAnyNominal() : VD;

    if (auto OP = GroupVD->getGroupName())

      OS << OP.getValue();

  }

  unsigned GroupEnd = SS.size();



  DelayedStringRetriever OverUSRsStream(SS);

  ide::walkOverriddenDecls(VD,

    [&](llvm::PointerUnion<const ValueDecl*, const clang::NamedDecl*> D) {

      OverUSRsStream.startPiece();

      if (auto VD = D.dyn_cast<const ValueDecl*>()) {

        if (SwiftLangSupport::printUSR(VD, OverUSRsStream))

          return;

      } else {

        llvm::SmallString<128> Buf;

        if (clang::index::generateUSRForDecl(

            D.get<const clang::NamedDecl*>(), Buf))

          return;

        OverUSRsStream << Buf.str();

      }

      OverUSRsStream.endPiece();

  });



  DelayedStringRetriever RelDeclsStream(SS);

  walkRelatedDecls(VD, [&](const ValueDecl *RelatedDecl, bool DuplicateName) {

    RelDeclsStream.startPiece();

    {

      RelDeclsStream<<""<RelatedName usr=\"""";

      SwiftLangSupport::printUSR(RelatedDecl, RelDeclsStream);

      RelDeclsStream<<""\"">"";

      if (isa<AbstractFunctionDecl>(RelatedDecl) && DuplicateName) {

        // Related decls are generally overloads, so print parameter types to

        // differentiate them.

        PrintOptions PO;

        PO.SkipAttributes = true;

        PO.SkipIntroducerKeywords = true;

        PO.ArgAndParamPrinting = PrintOptions::ArgAndParamPrintingMode::ArgumentOnly;

        XMLEscapingPrinter Printer(RelDeclsStream);

        if (BaseType) {

          PO.setBaseType(BaseType);

          PO.PrintAsMember = true;

        }

        RelatedDecl->print(Printer, PO);

      } else {

        llvm::SmallString<128> Buf;

        {

          llvm::raw_svector_ostream OSBuf(Buf);

          SwiftLangSupport::printDisplayName(RelatedDecl, OSBuf);

        }

        swift::markup::appendWithXMLEscaping(RelDeclsStream, Buf);

      }

      RelDeclsStream<<""</RelatedName>"";

    }

    RelDeclsStream.endPiece();

  });



  ASTContext &Ctx = VD->getASTContext();



  ClangImporter *Importer = static_cast<ClangImporter*>(

      Ctx.getClangModuleLoader());

  std::string ModuleName;

  auto ClangNode = VD->getClangNode();

  if (ClangNode) {

    auto ClangMod = Importer->getClangOwningModule(ClangNode);

    ModuleName = ClangMod->getFullModuleName();

  } else if (VD->getLoc().isInvalid() && VD->getModuleContext() != MainModule) {

    ModuleName = VD->getModuleContext()->getName().str();

  }

  StringRef ModuleInterfaceName;

  if (auto IFaceGenRef = Lang.getIFaceGenContexts().find(ModuleName, Invok))

    ModuleInterfaceName = IFaceGenRef->getDocumentName();



  UIdent Kind = SwiftLangSupport::getUIDForDecl(VD, IsRef);

  StringRef Name = StringRef(SS.begin()+NameBegin, NameEnd-NameBegin);

  StringRef USR = StringRef(SS.begin()+USRBegin, USREnd-USRBegin);

  StringRef TypeName = StringRef(SS.begin()+TypenameBegin,

                                 TypenameEnd-TypenameBegin);

  StringRef TypeUsr = StringRef(SS.begin()+MangledTypeStart,

                                MangledTypeEnd - MangledTypeStart);



  StringRef ContainerTypeUsr = StringRef(SS.begin()+MangledContainerTypeStart,

                            MangledContainerTypeEnd - MangledContainerTypeStart);

  StringRef DocComment = StringRef(SS.begin()+DocCommentBegin,

                                   DocCommentEnd-DocCommentBegin);

  StringRef AnnotatedDecl = StringRef(SS.begin()+DeclBegin,

                                      DeclEnd-DeclBegin);

  StringRef FullyAnnotatedDecl =

      StringRef(SS.begin() + FullDeclBegin, FullDeclEnd - FullDeclBegin);

  StringRef GroupName = StringRef(SS.begin() + GroupBegin, GroupEnd - GroupBegin);



  llvm::Optional<std::pair<unsigned, unsigned>> DeclarationLoc;

  StringRef Filename;

  getLocationInfo(VD, DeclarationLoc, Filename);

  if (DeclarationLoc.hasValue()) {

    DeclarationLoc = tryRemappingLocToLatestSnapshot(Lang,

                                                     *DeclarationLoc,

                                                     Filename,

                                                     PreviousASTSnaps);

    if (!DeclarationLoc.hasValue())

      return true; // failed to remap.

  }



  SmallVector<StringRef, 4> OverUSRs;

  OverUSRsStream.retrieve([&](StringRef S) { OverUSRs.push_back(S); });



  SmallVector<StringRef, 4> AnnotatedRelatedDecls;

  RelDeclsStream.retrieve([&](StringRef S) { AnnotatedRelatedDecls.push_back(S); });



  bool IsSystem = VD->getModuleContext()->isSystemModule();

  std::string TypeInterface;



  CursorInfo Info;

  Info.Kind = Kind;

  Info.Name = Name;

  Info.USR = USR;

  Info.TypeName = TypeName;

  Info.TypeUSR = TypeUsr;

  Info.ContainerTypeUSR = ContainerTypeUsr;

  Info.DocComment = DocComment;

  Info.AnnotatedDeclaration = AnnotatedDecl;

  Info.FullyAnnotatedDeclaration = FullyAnnotatedDecl;

  Info.ModuleName = ModuleName;

  Info.ModuleInterfaceName = ModuleInterfaceName;

  Info.DeclarationLoc = DeclarationLoc;

  Info.Filename = Filename;

  Info.OverrideUSRs = OverUSRs;

  Info.AnnotatedRelatedDeclarations = AnnotatedRelatedDecls;

  Info.GroupName = GroupName;

  Info.IsSystem = IsSystem;

  Info.TypeInterface = StringRef();

  Receiver(Info);

  return false;

}

","static bool passCursorInfoForDecl(const ValueDecl *VD,

                                  const ModuleDecl *MainModule,

                                  const Type Ty,

                                  const Type ContainerTy,

                                  bool IsRef,

                                  Optional<unsigned> OrigBufferID,

                                  SwiftLangSupport &Lang,

                                  const CompilerInvocation &Invok,

                            ArrayRef<ImmutableTextSnapshotRef> PreviousASTSnaps,

                             std::function<void(const CursorInfo &)> Receiver) {

  if (AvailableAttr::isUnavailable(VD))

    return true;



  SmallString<64> SS;

  auto BaseType = findBaseTypeForReplacingArchetype(VD, Ty);

  bool InSynthesizedExtension = false;

  if (BaseType) {

    if (auto Target = BaseType->getAnyNominal()) {

      SynthesizedExtensionAnalyzer Analyzer(Target,

                                            PrintOptions::printInterface());

      InSynthesizedExtension = Analyzer.isInSynthesizedExtension(VD);

    }

  }



  unsigned NameBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDisplayName(VD, OS);

  }

  unsigned NameEnd = SS.size();



  unsigned USRBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printUSR(VD, OS);

    if (InSynthesizedExtension) {

        OS << LangSupport::SynthesizedUSRSeparator;

        SwiftLangSupport::printUSR(BaseType->getAnyNominal(), OS);

    }

  }

  unsigned USREnd = SS.size();



  unsigned TypenameBegin = SS.size();

  if (VD->hasInterfaceType()) {

    llvm::raw_svector_ostream OS(SS);

    PrintOptions Options;

    Options.PrintNameAliasUnderlyingType = true;

    VD->getInterfaceType().print(OS, Options);

  }

  unsigned TypenameEnd = SS.size();



  unsigned MangledTypeStart = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDeclTypeUSR(VD, OS);

  }

  unsigned MangledTypeEnd = SS.size();



  unsigned MangledContainerTypeStart = SS.size();

  if (ContainerTy && !ContainerTy->hasArchetype()) {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printTypeUSR(ContainerTy, OS);

  }

  unsigned MangledContainerTypeEnd = SS.size();



  unsigned DocCommentBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    ide::getDocumentationCommentAsXML(VD, OS);

  }

  unsigned DocCommentEnd = SS.size();



  if (DocCommentEnd == DocCommentBegin) {

    if (auto *Req = ASTPrinter::findConformancesWithDocComment(

        const_cast<ValueDecl*>(VD))) {

      llvm::raw_svector_ostream OS(SS);

      ide::getDocumentationCommentAsXML(Req, OS);

    }

","
  }



  unsigned DeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    printAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned DeclEnd = SS.size();



  unsigned FullDeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printFullyAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned FullDeclEnd = SS.size();



  unsigned GroupBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    auto *GroupVD = InSynthesizedExtension ? BaseType->getAnyNominal() : VD;

    if (auto OP = GroupVD->getGroupName())

      OS << OP.getValue();

  }

  unsigned GroupEnd = SS.size();



  DelayedStringRetriever OverUSRsStream(SS);

  ide::walkOverriddenDecls(VD,

    [&](llvm::PointerUnion<const ValueDecl*, const clang::NamedDecl*> D) {

      OverUSRsStream.startPiece();

      if (auto VD = D.dyn_cast<const ValueDecl*>()) {

        if (SwiftLangSupport::printUSR(VD, OverUSRsStream))

          return;

      } else {

        llvm::SmallString<128> Buf;

        if (clang::index::generateUSRForDecl(

            D.get<const clang::NamedDecl*>(), Buf))

          return;

        OverUSRsStream << Buf.str();

      }

      OverUSRsStream.endPiece();

  });



  DelayedStringRetriever RelDeclsStream(SS);

  walkRelatedDecls(VD, [&](const ValueDecl *RelatedDecl, bool DuplicateName) {

    RelDeclsStream.startPiece();

    {

      RelDeclsStream<<""<RelatedName usr=\"""";

      SwiftLangSupport::printUSR(RelatedDecl, RelDeclsStream);

      RelDeclsStream<<""\"">"";

      if (isa<AbstractFunctionDecl>(RelatedDecl) && DuplicateName) {

        // Related decls are generally overloads, so print parameter types to

        // differentiate them.

        PrintOptions PO;

        PO.SkipAttributes = true;

        PO.SkipIntroducerKeywords = true;

        PO.ArgAndParamPrinting = PrintOptions::ArgAndParamPrintingMode::ArgumentOnly;

        XMLEscapingPrinter Printer(RelDeclsStream);

        if (BaseType) {

          PO.setBaseType(BaseType);

          PO.PrintAsMember = true;

        }

        RelatedDecl->print(Printer, PO);

      } else {

        llvm::SmallString<128> Buf;

        {

          llvm::raw_svector_ostream OSBuf(Buf);

          SwiftLangSupport::printDisplayName(RelatedDecl, OSBuf);

        }

        swift::markup::appendWithXMLEscaping(RelDeclsStream, Buf);

      }

      RelDeclsStream<<""</RelatedName>"";

    }

    RelDeclsStream.endPiece();

  });



  ASTContext &Ctx = VD->getASTContext();



  ClangImporter *Importer = static_cast<ClangImporter*>(

      Ctx.getClangModuleLoader());

  std::string ModuleName;

  auto ClangNode = VD->getClangNode();

  if (ClangNode) {

    auto ClangMod = Importer->getClangOwningModule(ClangNode);

    ModuleName = ClangMod->getFullModuleName();

  } else if (VD->getLoc().isInvalid() && VD->getModuleContext() != MainModule) {

    ModuleName = VD->getModuleContext()->getName().str();

  }

  StringRef ModuleInterfaceName;

  if (auto IFaceGenRef = Lang.getIFaceGenContexts().find(ModuleName, Invok))

    ModuleInterfaceName = IFaceGenRef->getDocumentName();



  UIdent Kind = SwiftLangSupport::getUIDForDecl(VD, IsRef);

  StringRef Name = StringRef(SS.begin()+NameBegin, NameEnd-NameBegin);

  StringRef USR = StringRef(SS.begin()+USRBegin, USREnd-USRBegin);

  StringRef TypeName = StringRef(SS.begin()+TypenameBegin,

                                 TypenameEnd-TypenameBegin);

  StringRef TypeUsr = StringRef(SS.begin()+MangledTypeStart,

                                MangledTypeEnd - MangledTypeStart);



  StringRef ContainerTypeUsr = StringRef(SS.begin()+MangledContainerTypeStart,

                            MangledContainerTypeEnd - MangledContainerTypeStart);

  StringRef DocComment = StringRef(SS.begin()+DocCommentBegin,

                                   DocCommentEnd-DocCommentBegin);

  StringRef AnnotatedDecl = StringRef(SS.begin()+DeclBegin,

                                      DeclEnd-DeclBegin);

  StringRef FullyAnnotatedDecl =

      StringRef(SS.begin() + FullDeclBegin, FullDeclEnd - FullDeclBegin);

  StringRef GroupName = StringRef(SS.begin() + GroupBegin, GroupEnd - GroupBegin);



  llvm::Optional<std::pair<unsigned, unsigned>> DeclarationLoc;

  StringRef Filename;

  getLocationInfo(VD, DeclarationLoc, Filename);

  if (DeclarationLoc.hasValue()) {

    DeclarationLoc = tryRemappingLocToLatestSnapshot(Lang,

                                                     *DeclarationLoc,

                                                     Filename,

                                                     PreviousASTSnaps);

    if (!DeclarationLoc.hasValue())

      return true; // failed to remap.

  }



  SmallVector<StringRef, 4> OverUSRs;

  OverUSRsStream.retrieve([&](StringRef S) { OverUSRs.push_back(S); });



  SmallVector<StringRef, 4> AnnotatedRelatedDecls;

  RelDeclsStream.retrieve([&](StringRef S) { AnnotatedRelatedDecls.push_back(S); });



  bool IsSystem = VD->getModuleContext()->isSystemModule();

  std::string TypeInterface;



  CursorInfo Info;

  Info.Kind = Kind;

  Info.Name = Name;

  Info.USR = USR;

  Info.TypeName = TypeName;

  Info.TypeUSR = TypeUsr;

  Info.ContainerTypeUSR = ContainerTypeUsr;

  Info.DocComment = DocComment;

  Info.AnnotatedDeclaration = AnnotatedDecl;

  Info.FullyAnnotatedDeclaration = FullyAnnotatedDecl;

  Info.ModuleName = ModuleName;

  Info.ModuleInterfaceName = ModuleInterfaceName;

  Info.DeclarationLoc = DeclarationLoc;

  Info.Filename = Filename;

  Info.OverrideUSRs = OverUSRs;

  Info.AnnotatedRelatedDeclarations = AnnotatedRelatedDecls;

  Info.GroupName = GroupName;

  Info.IsSystem = IsSystem;

  Info.TypeInterface = StringRef();

  Receiver(Info);

  return false;

}


"
"[IDE][Utils] Add an IDE stream utility. (#7546)

This provides a stream utility for writing to a underlying string buffer multiple string pieces and retrieve them later as StringRef when the underlying buffer is stable.",tools/SourceKit/lib/SwiftLang/SwiftSourceDocInfo.cpp,+,XMLEscapingPrinter Printer(RelDeclsStream);,"static bool passCursorInfoForDecl(const ValueDecl *VD,

                                  const ModuleDecl *MainModule,

                                  const Type Ty,

                                  const Type ContainerTy,

                                  bool IsRef,

                                  Optional<unsigned> OrigBufferID,

                                  SwiftLangSupport &Lang,

                                  const CompilerInvocation &Invok,

                            ArrayRef<ImmutableTextSnapshotRef> PreviousASTSnaps,

                             std::function<void(const CursorInfo &)> Receiver) {

  if (AvailableAttr::isUnavailable(VD))

    return true;



  SmallString<64> SS;

  auto BaseType = findBaseTypeForReplacingArchetype(VD, Ty);

  bool InSynthesizedExtension = false;

  if (BaseType) {

    if (auto Target = BaseType->getAnyNominal()) {

      SynthesizedExtensionAnalyzer Analyzer(Target,

                                            PrintOptions::printInterface());

      InSynthesizedExtension = Analyzer.isInSynthesizedExtension(VD);

    }

  }



  unsigned NameBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDisplayName(VD, OS);

  }

  unsigned NameEnd = SS.size();



  unsigned USRBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printUSR(VD, OS);

    if (InSynthesizedExtension) {

        OS << LangSupport::SynthesizedUSRSeparator;

        SwiftLangSupport::printUSR(BaseType->getAnyNominal(), OS);

    }

  }

  unsigned USREnd = SS.size();



  unsigned TypenameBegin = SS.size();

  if (VD->hasInterfaceType()) {

    llvm::raw_svector_ostream OS(SS);

    PrintOptions Options;

    Options.PrintNameAliasUnderlyingType = true;

    VD->getInterfaceType().print(OS, Options);

  }

  unsigned TypenameEnd = SS.size();



  unsigned MangledTypeStart = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDeclTypeUSR(VD, OS);

  }

  unsigned MangledTypeEnd = SS.size();



  unsigned MangledContainerTypeStart = SS.size();

  if (ContainerTy && !ContainerTy->hasArchetype()) {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printTypeUSR(ContainerTy, OS);

  }

  unsigned MangledContainerTypeEnd = SS.size();



  unsigned DocCommentBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    ide::getDocumentationCommentAsXML(VD, OS);

  }

  unsigned DocCommentEnd = SS.size();



  if (DocCommentEnd == DocCommentBegin) {

    if (auto *Req = ASTPrinter::findConformancesWithDocComment(

        const_cast<ValueDecl*>(VD))) {

      llvm::raw_svector_ostream OS(SS);

      ide::getDocumentationCommentAsXML(Req, OS);

    }

    DocCommentEnd = SS.size();

  }



  unsigned DeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    printAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned DeclEnd = SS.size();



  unsigned FullDeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printFullyAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned FullDeclEnd = SS.size();



  unsigned GroupBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    auto *GroupVD = InSynthesizedExtension ? BaseType->getAnyNominal() : VD;

    if (auto OP = GroupVD->getGroupName())

      OS << OP.getValue();

  }

  unsigned GroupEnd = SS.size();



  DelayedStringRetriever OverUSRsStream(SS);

  ide::walkOverriddenDecls(VD,

    [&](llvm::PointerUnion<const ValueDecl*, const clang::NamedDecl*> D) {

      OverUSRsStream.startPiece();

      if (auto VD = D.dyn_cast<const ValueDecl*>()) {

        if (SwiftLangSupport::printUSR(VD, OverUSRsStream))

          return;

      } else {

        llvm::SmallString<128> Buf;

        if (clang::index::generateUSRForDecl(

            D.get<const clang::NamedDecl*>(), Buf))

          return;

        OverUSRsStream << Buf.str();

      }

      OverUSRsStream.endPiece();

  });



  DelayedStringRetriever RelDeclsStream(SS);

  walkRelatedDecls(VD, [&](const ValueDecl *RelatedDecl, bool DuplicateName) {

    RelDeclsStream.startPiece();

    {

      RelDeclsStream<<""<RelatedName usr=\"""";

      SwiftLangSupport::printUSR(RelatedDecl, RelDeclsStream);

      RelDeclsStream<<""\"">"";

      if (isa<AbstractFunctionDecl>(RelatedDecl) && DuplicateName) {

        // Related decls are generally overloads, so print parameter types to

        // differentiate them.

        PrintOptions PO;

        PO.SkipAttributes = true;

        PO.SkipIntroducerKeywords = true;

        PO.ArgAndParamPrinting = PrintOptions::ArgAndParamPrintingMode::ArgumentOnly;

        XMLEscapingPrinter Printer(RelDeclsStream);

        if (BaseType) {

          PO.setBaseType(BaseType);

          PO.PrintAsMember = true;

        }

        RelatedDecl->print(Printer, PO);

      } else {

        llvm::SmallString<128> Buf;

        {

          llvm::raw_svector_ostream OSBuf(Buf);

          SwiftLangSupport::printDisplayName(RelatedDecl, OSBuf);

        }

        swift::markup::appendWithXMLEscaping(RelDeclsStream, Buf);

      }

      RelDeclsStream<<""</RelatedName>"";

    }

    RelDeclsStream.endPiece();

  });



  ASTContext &Ctx = VD->getASTContext();



  ClangImporter *Importer = static_cast<ClangImporter*>(

      Ctx.getClangModuleLoader());

  std::string ModuleName;

  auto ClangNode = VD->getClangNode();

  if (ClangNode) {

    auto ClangMod = Importer->getClangOwningModule(ClangNode);

    ModuleName = ClangMod->getFullModuleName();

  } else if (VD->getLoc().isInvalid() && VD->getModuleContext() != MainModule) {

    ModuleName = VD->getModuleContext()->getName().str();

  }

  StringRef ModuleInterfaceName;

  if (auto IFaceGenRef = Lang.getIFaceGenContexts().find(ModuleName, Invok))

    ModuleInterfaceName = IFaceGenRef->getDocumentName();



  UIdent Kind = SwiftLangSupport::getUIDForDecl(VD, IsRef);

  StringRef Name = StringRef(SS.begin()+NameBegin, NameEnd-NameBegin);

  StringRef USR = StringRef(SS.begin()+USRBegin, USREnd-USRBegin);

  StringRef TypeName = StringRef(SS.begin()+TypenameBegin,

                                 TypenameEnd-TypenameBegin);

  StringRef TypeUsr = StringRef(SS.begin()+MangledTypeStart,

                                MangledTypeEnd - MangledTypeStart);



  StringRef ContainerTypeUsr = StringRef(SS.begin()+MangledContainerTypeStart,

                            MangledContainerTypeEnd - MangledContainerTypeStart);

  StringRef DocComment = StringRef(SS.begin()+DocCommentBegin,

                                   DocCommentEnd-DocCommentBegin);

  StringRef AnnotatedDecl = StringRef(SS.begin()+DeclBegin,

                                      DeclEnd-DeclBegin);

  StringRef FullyAnnotatedDecl =

      StringRef(SS.begin() + FullDeclBegin, FullDeclEnd - FullDeclBegin);

  StringRef GroupName = StringRef(SS.begin() + GroupBegin, GroupEnd - GroupBegin);



  llvm::Optional<std::pair<unsigned, unsigned>> DeclarationLoc;

  StringRef Filename;

  getLocationInfo(VD, DeclarationLoc, Filename);

  if (DeclarationLoc.hasValue()) {

    DeclarationLoc = tryRemappingLocToLatestSnapshot(Lang,

                                                     *DeclarationLoc,

                                                     Filename,

                                                     PreviousASTSnaps);

    if (!DeclarationLoc.hasValue())

      return true; // failed to remap.

  }



  SmallVector<StringRef, 4> OverUSRs;

  OverUSRsStream.retrieve([&](StringRef S) { OverUSRs.push_back(S); });



  SmallVector<StringRef, 4> AnnotatedRelatedDecls;

  RelDeclsStream.retrieve([&](StringRef S) { AnnotatedRelatedDecls.push_back(S); });



  bool IsSystem = VD->getModuleContext()->isSystemModule();

  std::string TypeInterface;



  CursorInfo Info;

  Info.Kind = Kind;

  Info.Name = Name;

  Info.USR = USR;

  Info.TypeName = TypeName;

  Info.TypeUSR = TypeUsr;

  Info.ContainerTypeUSR = ContainerTypeUsr;

  Info.DocComment = DocComment;

  Info.AnnotatedDeclaration = AnnotatedDecl;

  Info.FullyAnnotatedDeclaration = FullyAnnotatedDecl;

  Info.ModuleName = ModuleName;

  Info.ModuleInterfaceName = ModuleInterfaceName;

  Info.DeclarationLoc = DeclarationLoc;

  Info.Filename = Filename;

  Info.OverrideUSRs = OverUSRs;

  Info.AnnotatedRelatedDeclarations = AnnotatedRelatedDecls;

  Info.GroupName = GroupName;

  Info.IsSystem = IsSystem;

  Info.TypeInterface = StringRef();

  Receiver(Info);

  return false;

}

","static bool passCursorInfoForDecl(const ValueDecl *VD,

                                  const ModuleDecl *MainModule,

                                  const Type Ty,

                                  const Type ContainerTy,

                                  bool IsRef,

                                  Optional<unsigned> OrigBufferID,

                                  SwiftLangSupport &Lang,

                                  const CompilerInvocation &Invok,

                            ArrayRef<ImmutableTextSnapshotRef> PreviousASTSnaps,

                             std::function<void(const CursorInfo &)> Receiver) {

  if (AvailableAttr::isUnavailable(VD))

    return true;



  SmallString<64> SS;

  auto BaseType = findBaseTypeForReplacingArchetype(VD, Ty);

  bool InSynthesizedExtension = false;

  if (BaseType) {

    if (auto Target = BaseType->getAnyNominal()) {

      SynthesizedExtensionAnalyzer Analyzer(Target,

                                            PrintOptions::printInterface());

      InSynthesizedExtension = Analyzer.isInSynthesizedExtension(VD);

    }

  }



  unsigned NameBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDisplayName(VD, OS);

  }

  unsigned NameEnd = SS.size();



  unsigned USRBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printUSR(VD, OS);

    if (InSynthesizedExtension) {

        OS << LangSupport::SynthesizedUSRSeparator;

        SwiftLangSupport::printUSR(BaseType->getAnyNominal(), OS);

    }

  }

  unsigned USREnd = SS.size();



  unsigned TypenameBegin = SS.size();

  if (VD->hasInterfaceType()) {

    llvm::raw_svector_ostream OS(SS);

    PrintOptions Options;

    Options.PrintNameAliasUnderlyingType = true;

    VD->getInterfaceType().print(OS, Options);

  }

  unsigned TypenameEnd = SS.size();



  unsigned MangledTypeStart = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printDeclTypeUSR(VD, OS);

  }

  unsigned MangledTypeEnd = SS.size();



  unsigned MangledContainerTypeStart = SS.size();

  if (ContainerTy && !ContainerTy->hasArchetype()) {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printTypeUSR(ContainerTy, OS);

  }

  unsigned MangledContainerTypeEnd = SS.size();



  unsigned DocCommentBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    ide::getDocumentationCommentAsXML(VD, OS);

  }

  unsigned DocCommentEnd = SS.size();



  if (DocCommentEnd == DocCommentBegin) {

    if (auto *Req = ASTPrinter::findConformancesWithDocComment(

        const_cast<ValueDecl*>(VD))) {

      llvm::raw_svector_ostream OS(SS);

      ide::getDocumentationCommentAsXML(Req, OS);

    }

    DocCommentEnd = SS.size();

  }



  unsigned DeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    printAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned DeclEnd = SS.size();



  unsigned FullDeclBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    SwiftLangSupport::printFullyAnnotatedDeclaration(VD, BaseType, OS);

  }

  unsigned FullDeclEnd = SS.size();



  unsigned GroupBegin = SS.size();

  {

    llvm::raw_svector_ostream OS(SS);

    auto *GroupVD = InSynthesizedExtension ? BaseType->getAnyNominal() : VD;

    if (auto OP = GroupVD->getGroupName())

      OS << OP.getValue();

  }

  unsigned GroupEnd = SS.size();



  DelayedStringRetriever OverUSRsStream(SS);

  ide::walkOverriddenDecls(VD,

    [&](llvm::PointerUnion<const ValueDecl*, const clang::NamedDecl*> D) {

      OverUSRsStream.startPiece();

      if (auto VD = D.dyn_cast<const ValueDecl*>()) {

        if (SwiftLangSupport::printUSR(VD, OverUSRsStream))

          return;

      } else {

        llvm::SmallString<128> Buf;

        if (clang::index::generateUSRForDecl(

            D.get<const clang::NamedDecl*>(), Buf))

          return;

        OverUSRsStream << Buf.str();

      }

      OverUSRsStream.endPiece();

  });



  DelayedStringRetriever RelDeclsStream(SS);

  walkRelatedDecls(VD, [&](const ValueDecl *RelatedDecl, bool DuplicateName) {

    RelDeclsStream.startPiece();

    {

      RelDeclsStream<<""<RelatedName usr=\"""";

      SwiftLangSupport::printUSR(RelatedDecl, RelDeclsStream);

      RelDeclsStream<<""\"">"";

      if (isa<AbstractFunctionDecl>(RelatedDecl) && DuplicateName) {

        // Related decls are generally overloads, so print parameter types to

        // differentiate them.

        PrintOptions PO;

        PO.SkipAttributes = true;

        PO.SkipIntroducerKeywords = true;

        PO.ArgAndParamPrinting = PrintOptions::ArgAndParamPrintingMode::ArgumentOnly;

       ","
        if (BaseType) {

          PO.setBaseType(BaseType);

          PO.PrintAsMember = true;

        }

        RelatedDecl->print(Printer, PO);

      } else {

        llvm::SmallString<128> Buf;

        {

          llvm::raw_svector_ostream OSBuf(Buf);

          SwiftLangSupport::printDisplayName(RelatedDecl, OSBuf);

        }

        swift::markup::appendWithXMLEscaping(RelDeclsStream, Buf);

      }

      RelDeclsStream<<""</RelatedName>"";

    }

    RelDeclsStream.endPiece();

  });



  ASTContext &Ctx = VD->getASTContext();



  ClangImporter *Importer = static_cast<ClangImporter*>(

      Ctx.getClangModuleLoader());

  std::string ModuleName;

  auto ClangNode = VD->getClangNode();

  if (ClangNode) {

    auto ClangMod = Importer->getClangOwningModule(ClangNode);

    ModuleName = ClangMod->getFullModuleName();

  } else if (VD->getLoc().isInvalid() && VD->getModuleContext() != MainModule) {

    ModuleName = VD->getModuleContext()->getName().str();

  }

  StringRef ModuleInterfaceName;

  if (auto IFaceGenRef = Lang.getIFaceGenContexts().find(ModuleName, Invok))

    ModuleInterfaceName = IFaceGenRef->getDocumentName();



  UIdent Kind = SwiftLangSupport::getUIDForDecl(VD, IsRef);

  StringRef Name = StringRef(SS.begin()+NameBegin, NameEnd-NameBegin);

  StringRef USR = StringRef(SS.begin()+USRBegin, USREnd-USRBegin);

  StringRef TypeName = StringRef(SS.begin()+TypenameBegin,

                                 TypenameEnd-TypenameBegin);

  StringRef TypeUsr = StringRef(SS.begin()+MangledTypeStart,

                                MangledTypeEnd - MangledTypeStart);



  StringRef ContainerTypeUsr = StringRef(SS.begin()+MangledContainerTypeStart,

                            MangledContainerTypeEnd - MangledContainerTypeStart);

  StringRef DocComment = StringRef(SS.begin()+DocCommentBegin,

                                   DocCommentEnd-DocCommentBegin);

  StringRef AnnotatedDecl = StringRef(SS.begin()+DeclBegin,

                                      DeclEnd-DeclBegin);

  StringRef FullyAnnotatedDecl =

      StringRef(SS.begin() + FullDeclBegin, FullDeclEnd - FullDeclBegin);

  StringRef GroupName = StringRef(SS.begin() + GroupBegin, GroupEnd - GroupBegin);



  llvm::Optional<std::pair<unsigned, unsigned>> DeclarationLoc;

  StringRef Filename;

  getLocationInfo(VD, DeclarationLoc, Filename);

  if (DeclarationLoc.hasValue()) {

    DeclarationLoc = tryRemappingLocToLatestSnapshot(Lang,

                                                     *DeclarationLoc,

                                                     Filename,

                                                     PreviousASTSnaps);

    if (!DeclarationLoc.hasValue())

      return true; // failed to remap.

  }



  SmallVector<StringRef, 4> OverUSRs;

  OverUSRsStream.retrieve([&](StringRef S) { OverUSRs.push_back(S); });



  SmallVector<StringRef, 4> AnnotatedRelatedDecls;

  RelDeclsStream.retrieve([&](StringRef S) { AnnotatedRelatedDecls.push_back(S); });



  bool IsSystem = VD->getModuleContext()->isSystemModule();

  std::string TypeInterface;



  CursorInfo Info;

  Info.Kind = Kind;

  Info.Name = Name;

  Info.USR = USR;

  Info.TypeName = TypeName;

  Info.TypeUSR = TypeUsr;

  Info.ContainerTypeUSR = ContainerTypeUsr;

  Info.DocComment = DocComment;

  Info.AnnotatedDeclaration = AnnotatedDecl;

  Info.FullyAnnotatedDeclaration = FullyAnnotatedDecl;

  Info.ModuleName = ModuleName;

  Info.ModuleInterfaceName = ModuleInterfaceName;

  Info.DeclarationLoc = DeclarationLoc;

  Info.Filename = Filename;

  Info.OverrideUSRs = OverUSRs;

  Info.AnnotatedRelatedDeclarations = AnnotatedRelatedDecls;

  Info.GroupName = GroupName;

  Info.IsSystem = IsSystem;

  Info.TypeInterface = StringRef();

  Receiver(Info);

  return false;

}

"
Merge pull request #7532 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(onlyHaveDebugUses(inst));,"  void markDeadInst(SILInstruction *inst) {

    assert(onlyHaveDebugUses(inst));

    instsToDelete.insert(inst);

  }

","  void markDeadInst(SILInstruction *inst) {

   ","
    instsToDelete.insert(inst);

  }

"
Merge pull request #7532 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(!pass.valueStorageMap.getStorage(tupleInst).storageAddress);,"  void visitDestroyValueInst(DestroyValueInst *destroyInst) {

    SILValue src = destroyInst->getOperand();

    SILValue addr = pass.valueStorageMap.getStorage(src).storageAddress;

    B.createDestroyAddr(destroyInst->getLoc(), addr);

    pass.markDeadInst(destroyInst);

  }

","  void visitDestroyValueInst(DestroyValueInst *destroyInst) {

","
    SILValue addr = pass.valueStorageMap.getStorage(src).storageAddress;

    B.createDestroyAddr(destroyInst->getLoc(), addr);

    pass.markDeadInst(destroyInst);

  }


"
Merge pull request #7532 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(!pass.valueStorageMap.getStorage(tupleInst).storageAddress);,"  void visitTupleInst(TupleInst *tupleInst) {

    // Tuple elements have their own storage. Tuple instructions are dead.

    assert(!pass.valueStorageMap.getStorage(tupleInst).storageAddress);

  }

","  void visitTupleInst(TupleInst *tupleInst) {

    // Tuple elements have their own storage. Tuple instructions are dead.

   ","
  }

"
AddressLowering: fix handling of result tuples.,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(onlyHaveDebugUses(inst));,"  void markDeadInst(SILInstruction *inst) {

    assert(onlyHaveDebugUses(inst));

    instsToDelete.insert(inst);

  }

","  void markDeadInst(SILInstruction *inst) {

   ","
    instsToDelete.insert(inst);

  }

"
AddressLowering: fix handling of result tuples.,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(!pass.valueStorageMap.getStorage(tupleInst).storageAddress);,"  void visitDestroyValueInst(DestroyValueInst *destroyInst) {

    SILValue src = destroyInst->getOperand();

    SILValue addr = pass.valueStorageMap.getStorage(src).storageAddress;

    B.createDestroyAddr(destroyInst->getLoc(), addr);

    pass.markDeadInst(destroyInst);

  }

","  void visitDestroyValueInst(DestroyValueInst *destroyInst) {

","
    SILValue addr = pass.valueStorageMap.getStorage(src).storageAddress;

    B.createDestroyAddr(destroyInst->getLoc(), addr);

    pass.markDeadInst(destroyInst);

  }


"
AddressLowering: fix handling of result tuples.,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(!pass.valueStorageMap.getStorage(tupleInst).storageAddress);,"  void visitTupleInst(TupleInst *tupleInst) {

    // Tuple elements have their own storage. Tuple instructions are dead.

    assert(!pass.valueStorageMap.getStorage(tupleInst).storageAddress);

  }

","  void visitTupleInst(TupleInst *tupleInst) {

    // Tuple elements have their own storage. Tuple instructions are dead.

   ","
  }

"
"Merge pull request #7514 from shajrawi/store_opaque_values

support stores of non-loadable types under opaque mode",lib/SILGen/RValue.cpp,-,assert(eltTI.isLoadable());,"  void visitTupleType(CanTupleType tupleFormalType, ManagedValue tupleMV) {

    bool isPlusZero = tupleMV.isPlusZeroRValueOrTrivial();

    SILValue tuple = tupleMV.forward(gen);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple->getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple->getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      SILValue elt;

      if (tuple->getType().isObject()) {

        assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

        elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      } else {

        elt = gen.B.createTupleElementAddr(loc, tuple, i, eltTy);



        // RValue has an invariant that loadable values have been

        // loaded.  Except it's not really an invariant, because

        // argument emission likes to lie sometimes.

        if (eltTI.isLoadable()) {

          elt = eltTI.emitLoad(gen.B, loc, elt, LoadOwnershipQualifier::Take);

        }

      }



      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      auto eltMV = isPlusZero ? ManagedValue::forUnmanaged(elt)

                              : gen.emitManagedRValueWithCleanup(elt, eltTI);



      visit(eltFormalType, eltMV);

    }

  }

","  void visitTupleType(CanTupleType tupleFormalType, ManagedValue tupleMV) {

    bool isPlusZero = tupleMV.isPlusZeroRValueOrTrivial();

    SILValue tuple = tupleMV.forward(gen);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());


","      auto eltTy = tuple->getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple->getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      SILValue elt;

      if (tuple->getType().isObject()) {

        assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

        elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      } else {

        elt = gen.B.createTupleElementAddr(loc, tuple, i, eltTy);



        // RValue has an invariant that loadable values have been

        // loaded.  Except it's not really an invariant, because

        // argument emission likes to lie sometimes.

        if (eltTI.isLoadable()) {

          elt = eltTI.emitLoad(gen.B, loc, elt, LoadOwnershipQualifier::Take);

        }

      }



      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      auto eltMV = isPlusZero ? ManagedValue::forUnmanaged(elt)

                              : gen.emitManagedRValueWithCleanup(elt, eltTI);



      visit(eltFormalType, eltMV);

    }

  }


"
"Merge pull request #7514 from shajrawi/store_opaque_values

support stores of non-loadable types under opaque mode",lib/SILGen/RValue.cpp,+,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,"  void visitTupleType(CanTupleType tupleFormalType, ManagedValue tupleMV) {

    bool isPlusZero = tupleMV.isPlusZeroRValueOrTrivial();

    SILValue tuple = tupleMV.forward(gen);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple->getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple->getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      SILValue elt;

      if (tuple->getType().isObject()) {

        assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

        elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      } else {

        elt = gen.B.createTupleElementAddr(loc, tuple, i, eltTy);



        // RValue has an invariant that loadable values have been

        // loaded.  Except it's not really an invariant, because

        // argument emission likes to lie sometimes.

        if (eltTI.isLoadable()) {

          elt = eltTI.emitLoad(gen.B, loc, elt, LoadOwnershipQualifier::Take);

        }

      }



      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      auto eltMV = isPlusZero ? ManagedValue::forUnmanaged(elt)

                              : gen.emitManagedRValueWithCleanup(elt, eltTI);



      visit(eltFormalType, eltMV);

    }

  }

","  void visitTupleType(CanTupleType tupleFormalType, ManagedValue tupleMV) {

    bool isPlusZero = tupleMV.isPlusZeroRValueOrTrivial();

    SILValue tuple = tupleMV.forward(gen);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple->getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple->getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      SILValue elt;

      if (tuple->getType().isObject()) {

       ","
        elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      } else {

        elt = gen.B.createTupleElementAddr(loc, tuple, i, eltTy);



        // RValue has an invariant that loadable values have been

        // loaded.  Except it's not really an invariant, because

        // argument emission likes to lie sometimes.

        if (eltTI.isLoadable()) {

          elt = eltTI.emitLoad(gen.B, loc, elt, LoadOwnershipQualifier::Take);

        }

      }



      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      auto eltMV = isPlusZero ? ManagedValue::forUnmanaged(elt)

                              : gen.emitManagedRValueWithCleanup(elt, eltTI);



      visit(eltFormalType, eltMV);

    }

  }

"
"Merge pull request #7186 from aschwaighofer/cow_exist_silgen_support

SIL/SILGen support for copy-on-write existentials",lib/SILGen/SILGenLValue.cpp,+,"assert(false && ""I believe that we should never end up here. One, we ""","    ManagedValue offset(SILGenFunction &gen, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(base.getType().isExistentialType() &&

             ""base for open existential component must be an existential"");

      auto addr = gen.B.createOpenExistentialAddr(

          loc, base.getLValueAddress(), getTypeOfRValue().getAddressType(),

          getOpenedExistentialAccessFor(accessKind));



      if (base.hasCleanup()) {

        assert(false && ""I believe that we should never end up here. One, we ""

                        ""assert above that base is an l-value address and we ""

                        ""state l-values don't have associated cleanup. Two, we ""

                        ""enter deinit of the buffer but don't have ""

                        ""book-keeping for the value. Three, I believe that ""

                        ""would mean to have a l-value passed at +1 which I ""

                        ""don't believe we do."");

        // Leave a cleanup to deinit the existential container.

        gen.enterDeinitExistentialCleanup(base.getValue(), CanType(),

                                          ExistentialRepresentation::Opaque);

      }



      gen.setArchetypeOpeningSite(cast<ArchetypeType>(getSubstFormalType()),

                                  addr);

      return ManagedValue::forLValue(addr);

    }

","    ManagedValue offset(SILGenFunction &gen, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(base.getType().isExistentialType() &&

             ""base for open existential component must be an existential"");

      auto addr = gen.B.createOpenExistentialAddr(

          loc, base.getLValueAddress(), getTypeOfRValue().getAddressType(),

          getOpenedExistentialAccessFor(accessKind));



      if (base.hasCleanup()) {

       ","
                        ""assert above that base is an l-value address and we ""

                        ""state l-values don't have associated cleanup. Two, we ""

                        ""enter deinit of the buffer but don't have ""

                        ""book-keeping for the value. Three, I believe that ""

                        ""would mean to have a l-value passed at +1 which I ""

                        ""don't believe we do."");

        // Leave a cleanup to deinit the existential container.

        gen.enterDeinitExistentialCleanup(base.getValue(), CanType(),

                                          ExistentialRepresentation::Opaque);

      }



      gen.setArchetypeOpeningSite(cast<ArchetypeType>(getSubstFormalType()),

                                  addr);

      return ManagedValue::forLValue(addr);

    }

"
support stores of non-loadable types under opaque mode,lib/SILGen/RValue.cpp,-,assert(eltTI.isLoadable());,"  void visitTupleType(CanTupleType tupleFormalType, ManagedValue tupleMV) {

    bool isPlusZero = tupleMV.isPlusZeroRValueOrTrivial();

    SILValue tuple = tupleMV.forward(gen);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple->getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple->getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      SILValue elt;

      if (tuple->getType().isObject()) {

        assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

        elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      } else {

        elt = gen.B.createTupleElementAddr(loc, tuple, i, eltTy);



        // RValue has an invariant that loadable values have been

        // loaded.  Except it's not really an invariant, because

        // argument emission likes to lie sometimes.

        if (eltTI.isLoadable()) {

          elt = eltTI.emitLoad(gen.B, loc, elt, LoadOwnershipQualifier::Take);

        }

      }



      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      auto eltMV = isPlusZero ? ManagedValue::forUnmanaged(elt)

                              : gen.emitManagedRValueWithCleanup(elt, eltTI);



      visit(eltFormalType, eltMV);

    }

  }

","  void visitTupleType(CanTupleType tupleFormalType, ManagedValue tupleMV) {

    bool isPlusZero = tupleMV.isPlusZeroRValueOrTrivial();

    SILValue tuple = tupleMV.forward(gen);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());


","      auto eltTy = tuple->getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple->getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      SILValue elt;

      if (tuple->getType().isObject()) {

        assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

        elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      } else {

        elt = gen.B.createTupleElementAddr(loc, tuple, i, eltTy);



        // RValue has an invariant that loadable values have been

        // loaded.  Except it's not really an invariant, because

        // argument emission likes to lie sometimes.

        if (eltTI.isLoadable()) {

          elt = eltTI.emitLoad(gen.B, loc, elt, LoadOwnershipQualifier::Take);

        }

      }



      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      auto eltMV = isPlusZero ? ManagedValue::forUnmanaged(elt)

                              : gen.emitManagedRValueWithCleanup(elt, eltTI);



      visit(eltFormalType, eltMV);

    }

  }


"
support stores of non-loadable types under opaque mode,lib/SILGen/RValue.cpp,+,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,"  void visitTupleType(CanTupleType tupleFormalType, ManagedValue tupleMV) {

    bool isPlusZero = tupleMV.isPlusZeroRValueOrTrivial();

    SILValue tuple = tupleMV.forward(gen);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple->getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple->getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      SILValue elt;

      if (tuple->getType().isObject()) {

        assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());

        elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      } else {

        elt = gen.B.createTupleElementAddr(loc, tuple, i, eltTy);



        // RValue has an invariant that loadable values have been

        // loaded.  Except it's not really an invariant, because

        // argument emission likes to lie sometimes.

        if (eltTI.isLoadable()) {

          elt = eltTI.emitLoad(gen.B, loc, elt, LoadOwnershipQualifier::Take);

        }

      }



      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      auto eltMV = isPlusZero ? ManagedValue::forUnmanaged(elt)

                              : gen.emitManagedRValueWithCleanup(elt, eltTI);



      visit(eltFormalType, eltMV);

    }

  }

","  void visitTupleType(CanTupleType tupleFormalType, ManagedValue tupleMV) {

    bool isPlusZero = tupleMV.isPlusZeroRValueOrTrivial();

    SILValue tuple = tupleMV.forward(gen);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple->getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple->getType().isAddress());

      auto &eltTI = gen.getTypeLowering(eltTy);



      // Project the element.

      SILValue elt;

      if (tuple->getType().isObject()) {

       ","
        elt = gen.B.createTupleExtract(loc, tuple, i, eltTy);

      } else {

        elt = gen.B.createTupleElementAddr(loc, tuple, i, eltTy);



        // RValue has an invariant that loadable values have been

        // loaded.  Except it's not really an invariant, because

        // argument emission likes to lie sometimes.

        if (eltTI.isLoadable()) {

          elt = eltTI.emitLoad(gen.B, loc, elt, LoadOwnershipQualifier::Take);

        }

      }



      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      auto eltMV = isPlusZero ? ManagedValue::forUnmanaged(elt)

                              : gen.emitManagedRValueWithCleanup(elt, eltTI);



      visit(eltFormalType, eltMV);

    }

  }

"
